<html>
<head>
<title>_k_means_elkan.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_k_means_elkan.pyx</font>
</center></td></tr></table>
<pre><span class="s0"># Author: Andreas Mueller</span>
<span class="s0">#</span>
<span class="s0"># Licence: BSD 3 clause</span>

<span class="s2">from </span><span class="s1">cython </span><span class="s2">cimport </span><span class="s1">floating</span>
<span class="s2">from </span><span class="s1">cython</span><span class="s3">.</span><span class="s1">parallel </span><span class="s2">import </span><span class="s1">prange</span><span class="s3">, </span><span class="s1">parallel</span>
<span class="s2">from </span><span class="s1">libc</span><span class="s3">.</span><span class="s1">stdlib </span><span class="s2">cimport </span><span class="s1">calloc</span><span class="s3">, </span><span class="s1">free</span>
<span class="s2">from </span><span class="s1">libc</span><span class="s3">.</span><span class="s1">string </span><span class="s2">cimport </span><span class="s1">memset</span>

<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_openmp_helpers </span><span class="s2">cimport </span><span class="s1">omp_lock_t</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_openmp_helpers </span><span class="s2">cimport </span><span class="s1">omp_init_lock</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_openmp_helpers </span><span class="s2">cimport </span><span class="s1">omp_destroy_lock</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_openmp_helpers </span><span class="s2">cimport </span><span class="s1">omp_set_lock</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_openmp_helpers </span><span class="s2">cimport </span><span class="s1">omp_unset_lock</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">extmath </span><span class="s2">import </span><span class="s1">row_norms</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_k_means_common </span><span class="s2">import </span><span class="s1">CHUNK_SIZE</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_k_means_common </span><span class="s2">cimport </span><span class="s1">_relocate_empty_clusters_dense</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_k_means_common </span><span class="s2">cimport </span><span class="s1">_relocate_empty_clusters_sparse</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_k_means_common </span><span class="s2">cimport </span><span class="s1">_euclidean_dense_dense</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_k_means_common </span><span class="s2">cimport </span><span class="s1">_euclidean_sparse_dense</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_k_means_common </span><span class="s2">cimport </span><span class="s1">_average_centers</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_k_means_common </span><span class="s2">cimport </span><span class="s1">_center_shift</span>


<span class="s2">def </span><span class="s1">init_bounds_dense</span><span class="s3">(</span>
        <span class="s1">const floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X</span><span class="s3">,                      </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">centers</span><span class="s3">,                </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">center_half_distances</span><span class="s3">,  </span><span class="s0"># IN</span>
        <span class="s1">int</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">labels</span><span class="s3">,                               </span><span class="s0"># OUT</span>
        <span class="s1">floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">upper_bounds</span><span class="s3">,                    </span><span class="s0"># OUT</span>
        <span class="s1">floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">lower_bounds</span><span class="s3">,                 </span><span class="s0"># OUT</span>
        <span class="s1">int n_threads</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Initialize upper and lower bounds for each sample for dense input data. 
 
    Given X, centers and the pairwise distances divided by 2.0 between the 
    centers this calculates the upper bounds and lower bounds for each sample. 
    The upper bound for each sample is set to the distance between the sample 
    and the closest center. 
 
    The lower bound for each sample is a one-dimensional array of n_clusters. 
    For each sample i assume that the previously assigned cluster is c1 and the 
    previous closest distance is dist, for a new cluster c2, the 
    lower_bound[i][c2] is set to distance between the sample and this new 
    cluster, if and only if dist &gt; center_half_distances[c1][c2]. This prevents 
    computation of unnecessary distances for each sample to the clusters that 
    it is unlikely to be assigned to. 
 
    Parameters 
    ---------- 
    X : ndarray of shape (n_samples, n_features), dtype=floating 
        The input data. 
 
    centers : ndarray of shape (n_clusters, n_features), dtype=floating 
        The cluster centers. 
 
    center_half_distances : ndarray of shape (n_clusters, n_clusters), \ 
            dtype=floating 
        The half of the distance between any 2 clusters centers. 
 
    labels : ndarray of shape(n_samples), dtype=int 
        The label for each sample. This array is modified in place. 
 
    upper_bounds : ndarray of shape(n_samples,), dtype=floating 
        The upper bound on the distance between each sample and its closest 
        cluster center. This array is modified in place. 
 
    lower_bounds : ndarray, of shape(n_samples, n_clusters), dtype=floating 
        The lower bound on the distance between each sample and each cluster 
        center. This array is modified in place. 
 
    n_threads : int 
        The number of threads to be used by openmp. 
    &quot;&quot;&quot;</span>
    <span class="s2">cdef</span><span class="s3">:</span>
        <span class="s1">int n_samples </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">int n_clusters </span><span class="s3">= </span><span class="s1">centers</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">int n_features </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]</span>

        <span class="s1">floating min_dist</span><span class="s3">, </span><span class="s1">dist</span>
        <span class="s1">int best_cluster</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">num_threads</span><span class="s3">=</span><span class="s1">n_threads</span><span class="s3">, </span><span class="s1">schedule</span><span class="s3">=</span><span class="s6">'static'</span><span class="s3">, </span><span class="s1">nogil</span><span class="s3">=</span><span class="s2">True</span>
    <span class="s3">):</span>
        <span class="s1">best_cluster </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">min_dist </span><span class="s3">= </span><span class="s1">_euclidean_dense_dense</span><span class="s3">(&amp;</span><span class="s1">X</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], &amp;</span><span class="s1">centers</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">],</span>
                                          <span class="s1">n_features</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
        <span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s4">0</span><span class="s3">] = </span><span class="s1">min_dist</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">n_clusters</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">min_dist </span><span class="s3">&gt; </span><span class="s1">center_half_distances</span><span class="s3">[</span><span class="s1">best_cluster</span><span class="s3">, </span><span class="s1">j</span><span class="s3">]:</span>
                <span class="s1">dist </span><span class="s3">= </span><span class="s1">_euclidean_dense_dense</span><span class="s3">(&amp;</span><span class="s1">X</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], &amp;</span><span class="s1">centers</span><span class="s3">[</span><span class="s1">j</span><span class="s3">, </span><span class="s4">0</span><span class="s3">],</span>
                                              <span class="s1">n_features</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
                <span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] = </span><span class="s1">dist</span>
                <span class="s2">if </span><span class="s1">dist </span><span class="s3">&lt; </span><span class="s1">min_dist</span><span class="s3">:</span>
                    <span class="s1">min_dist </span><span class="s3">= </span><span class="s1">dist</span>
                    <span class="s1">best_cluster </span><span class="s3">= </span><span class="s1">j</span>
        <span class="s1">labels</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">best_cluster</span>
        <span class="s1">upper_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">min_dist</span>


<span class="s2">def </span><span class="s1">init_bounds_sparse</span><span class="s3">(</span>
        <span class="s1">X</span><span class="s3">,                                             </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">centers</span><span class="s3">,                </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">center_half_distances</span><span class="s3">,  </span><span class="s0"># IN</span>
        <span class="s1">int</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">labels</span><span class="s3">,                               </span><span class="s0"># OUT</span>
        <span class="s1">floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">upper_bounds</span><span class="s3">,                    </span><span class="s0"># OUT</span>
        <span class="s1">floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">lower_bounds</span><span class="s3">,                 </span><span class="s0"># OUT</span>
        <span class="s1">int n_threads</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Initialize upper and lower bounds for each sample for sparse input data. 
 
    Given X, centers and the pairwise distances divided by 2.0 between the 
    centers this calculates the upper bounds and lower bounds for each sample. 
    The upper bound for each sample is set to the distance between the sample 
    and the closest center. 
 
    The lower bound for each sample is a one-dimensional array of n_clusters. 
    For each sample i assume that the previously assigned cluster is c1 and the 
    previous closest distance is dist, for a new cluster c2, the 
    lower_bound[i][c2] is set to distance between the sample and this new 
    cluster, if and only if dist &gt; center_half_distances[c1][c2]. This prevents 
    computation of unnecessary distances for each sample to the clusters that 
    it is unlikely to be assigned to. 
 
    Parameters 
    ---------- 
    X : sparse matrix of shape (n_samples, n_features), dtype=floating 
        The input data. Must be in CSR format. 
 
    centers : ndarray of shape (n_clusters, n_features), dtype=floating 
        The cluster centers. 
 
    center_half_distances : ndarray of shape (n_clusters, n_clusters), \ 
            dtype=floating 
        The half of the distance between any 2 clusters centers. 
 
    labels : ndarray of shape(n_samples), dtype=int 
        The label for each sample. This array is modified in place. 
 
    upper_bounds : ndarray of shape(n_samples,), dtype=floating 
        The upper bound on the distance between each sample and its closest 
        cluster center. This array is modified in place. 
 
    lower_bounds : ndarray of shape(n_samples, n_clusters), dtype=floating 
        The lower bound on the distance between each sample and each cluster 
        center. This array is modified in place. 
 
    n_threads : int 
        The number of threads to be used by openmp. 
    &quot;&quot;&quot;</span>
    <span class="s2">cdef</span><span class="s3">:</span>
        <span class="s1">int n_samples </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">int n_clusters </span><span class="s3">= </span><span class="s1">centers</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

        <span class="s1">floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_data </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">data</span>
        <span class="s1">int</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_indices </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">indices</span>
        <span class="s1">int</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_indptr </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">indptr</span>

        <span class="s1">floating min_dist</span><span class="s3">, </span><span class="s1">dist</span>
        <span class="s1">int best_cluster</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span>

        <span class="s1">floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">centers_squared_norms </span><span class="s3">= </span><span class="s1">row_norms</span><span class="s3">(</span><span class="s1">centers</span><span class="s3">, </span><span class="s1">squared</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">num_threads</span><span class="s3">=</span><span class="s1">n_threads</span><span class="s3">, </span><span class="s1">schedule</span><span class="s3">=</span><span class="s6">'static'</span><span class="s3">, </span><span class="s1">nogil</span><span class="s3">=</span><span class="s2">True</span>
    <span class="s3">):</span>
        <span class="s1">best_cluster </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">min_dist </span><span class="s3">= </span><span class="s1">_euclidean_sparse_dense</span><span class="s3">(</span>
            <span class="s1">X_data</span><span class="s3">[</span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]: </span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">]],</span>
            <span class="s1">X_indices</span><span class="s3">[</span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]: </span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">]],</span>
            <span class="s1">centers</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">centers_squared_norms</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s2">False</span><span class="s3">)</span>

        <span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s4">0</span><span class="s3">] = </span><span class="s1">min_dist</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">n_clusters</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">min_dist </span><span class="s3">&gt; </span><span class="s1">center_half_distances</span><span class="s3">[</span><span class="s1">best_cluster</span><span class="s3">, </span><span class="s1">j</span><span class="s3">]:</span>
                <span class="s1">dist </span><span class="s3">= </span><span class="s1">_euclidean_sparse_dense</span><span class="s3">(</span>
                    <span class="s1">X_data</span><span class="s3">[</span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]: </span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">]],</span>
                    <span class="s1">X_indices</span><span class="s3">[</span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]: </span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">]],</span>
                    <span class="s1">centers</span><span class="s3">[</span><span class="s1">j</span><span class="s3">], </span><span class="s1">centers_squared_norms</span><span class="s3">[</span><span class="s1">j</span><span class="s3">], </span><span class="s2">False</span><span class="s3">)</span>
                <span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] = </span><span class="s1">dist</span>
                <span class="s2">if </span><span class="s1">dist </span><span class="s3">&lt; </span><span class="s1">min_dist</span><span class="s3">:</span>
                    <span class="s1">min_dist </span><span class="s3">= </span><span class="s1">dist</span>
                    <span class="s1">best_cluster </span><span class="s3">= </span><span class="s1">j</span>
        <span class="s1">labels</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">best_cluster</span>
        <span class="s1">upper_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">min_dist</span>


<span class="s2">def </span><span class="s1">elkan_iter_chunked_dense</span><span class="s3">(</span>
        <span class="s1">const floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X</span><span class="s3">,                      </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">sample_weight</span><span class="s3">,             </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">centers_old</span><span class="s3">,            </span><span class="s0"># IN</span>
        <span class="s1">floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">centers_new</span><span class="s3">,                  </span><span class="s0"># OUT</span>
        <span class="s1">floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">weight_in_clusters</span><span class="s3">,              </span><span class="s0"># OUT</span>
        <span class="s1">const floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">center_half_distances</span><span class="s3">,  </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">distance_next_center</span><span class="s3">,      </span><span class="s0"># IN</span>
        <span class="s1">floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">upper_bounds</span><span class="s3">,                    </span><span class="s0"># INOUT</span>
        <span class="s1">floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">lower_bounds</span><span class="s3">,                 </span><span class="s0"># INOUT</span>
        <span class="s1">int</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">labels</span><span class="s3">,                               </span><span class="s0"># INOUT</span>
        <span class="s1">floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">center_shift</span><span class="s3">,                    </span><span class="s0"># OUT</span>
        <span class="s1">int n_threads</span><span class="s3">,</span>
        <span class="s1">bint update_centers</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Single iteration of K-means Elkan algorithm with dense input. 
 
    Update labels and centers (inplace), for one iteration, distributed 
    over data chunks. 
 
    Parameters 
    ---------- 
    X : ndarray of shape (n_samples, n_features), dtype=floating 
        The observations to cluster. 
 
    sample_weight : ndarray of shape (n_samples,), dtype=floating 
        The weights for each observation in X. 
 
    centers_old : ndarray of shape (n_clusters, n_features), dtype=floating 
        Centers before previous iteration, placeholder for the centers after 
        previous iteration. 
 
    centers_new : ndarray of shape (n_clusters, n_features), dtype=floating 
        Centers after previous iteration, placeholder for the new centers 
        computed during this iteration. 
 
    weight_in_clusters : ndarray of shape (n_clusters,), dtype=floating 
        Placeholder for the sums of the weights of every observation assigned 
        to each center. 
 
    center_half_distances : ndarray of shape (n_clusters, n_clusters), \ 
            dtype=floating 
        Half pairwise distances between centers. 
 
    distance_next_center : ndarray of shape (n_clusters,), dtype=floating 
        Distance between each center its closest center. 
 
    upper_bounds : ndarray of shape (n_samples,), dtype=floating 
        Upper bound for the distance between each sample and its center, 
        updated inplace. 
 
    lower_bounds : ndarray of shape (n_samples, n_clusters), dtype=floating 
        Lower bound for the distance between each sample and each center, 
        updated inplace. 
 
    labels : ndarray of shape (n_samples,), dtype=int 
        labels assignment. 
 
    center_shift : ndarray of shape (n_clusters,), dtype=floating 
        Distance between old and new centers. 
 
    n_threads : int 
        The number of threads to be used by openmp. 
 
    update_centers : bool 
        - If True, the labels and the new centers will be computed, i.e. runs 
          the E-step and the M-step of the algorithm. 
        - If False, only the labels will be computed, i.e runs the E-step of 
          the algorithm. This is useful especially when calling predict on a 
          fitted model. 
    &quot;&quot;&quot;</span>
    <span class="s2">cdef</span><span class="s3">:</span>
        <span class="s1">int n_samples </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">int n_features </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s1">int n_clusters </span><span class="s3">= </span><span class="s1">centers_new</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

    <span class="s2">if </span><span class="s1">n_samples </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s0"># An empty array was passed, do nothing and return early (before</span>
        <span class="s0"># attempting to compute n_chunks). This can typically happen when</span>
        <span class="s0"># calling the prediction function of a bisecting k-means model with a</span>
        <span class="s0"># large fraction of outiers.</span>
        <span class="s2">return</span>

    <span class="s2">cdef</span><span class="s3">:</span>
        <span class="s0"># hard-coded number of samples per chunk. Splitting in chunks is</span>
        <span class="s0"># necessary to get parallelism. Chunk size chosen to be same as lloyd's</span>
        <span class="s1">int n_samples_chunk </span><span class="s3">= </span><span class="s1">CHUNK_SIZE </span><span class="s2">if </span><span class="s1">n_samples </span><span class="s3">&gt; </span><span class="s1">CHUNK_SIZE </span><span class="s2">else </span><span class="s1">n_samples</span>
        <span class="s1">int n_chunks </span><span class="s3">= </span><span class="s1">n_samples </span><span class="s3">// </span><span class="s1">n_samples_chunk</span>
        <span class="s1">int n_samples_rem </span><span class="s3">= </span><span class="s1">n_samples </span><span class="s3">% </span><span class="s1">n_samples_chunk</span>
        <span class="s1">int chunk_idx</span>
        <span class="s1">int start</span><span class="s3">, </span><span class="s1">end</span>

        <span class="s1">int i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">k</span>

        <span class="s1">floating </span><span class="s3">*</span><span class="s1">centers_new_chunk</span>
        <span class="s1">floating </span><span class="s3">*</span><span class="s1">weight_in_clusters_chunk</span>

        <span class="s1">omp_lock_t lock</span>

    <span class="s0"># count remainder chunk in total number of chunks</span>
    <span class="s1">n_chunks </span><span class="s3">+= </span><span class="s1">n_samples </span><span class="s3">!= </span><span class="s1">n_chunks </span><span class="s3">* </span><span class="s1">n_samples_chunk</span>

    <span class="s0"># number of threads should not be bigger than number of chunks</span>
    <span class="s1">n_threads </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">n_threads</span><span class="s3">, </span><span class="s1">n_chunks</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">update_centers</span><span class="s3">:</span>
        <span class="s1">memset</span><span class="s3">(&amp;</span><span class="s1">centers_new</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], </span><span class="s4">0</span><span class="s3">, </span><span class="s1">n_clusters </span><span class="s3">* </span><span class="s1">n_features </span><span class="s3">* </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">floating</span><span class="s3">))</span>
        <span class="s1">memset</span><span class="s3">(&amp;</span><span class="s1">weight_in_clusters</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s4">0</span><span class="s3">, </span><span class="s1">n_clusters </span><span class="s3">* </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">floating</span><span class="s3">))</span>
        <span class="s1">omp_init_lock</span><span class="s3">(&amp;</span><span class="s1">lock</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">nogil</span><span class="s3">, </span><span class="s1">parallel</span><span class="s3">(</span><span class="s1">num_threads</span><span class="s3">=</span><span class="s1">n_threads</span><span class="s3">):</span>
        <span class="s0"># thread local buffers</span>
        <span class="s1">centers_new_chunk </span><span class="s3">= &lt;</span><span class="s1">floating</span><span class="s3">*&gt; </span><span class="s1">calloc</span><span class="s3">(</span><span class="s1">n_clusters </span><span class="s3">* </span><span class="s1">n_features</span><span class="s3">, </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">floating</span><span class="s3">))</span>
        <span class="s1">weight_in_clusters_chunk </span><span class="s3">= &lt;</span><span class="s1">floating</span><span class="s3">*&gt; </span><span class="s1">calloc</span><span class="s3">(</span><span class="s1">n_clusters</span><span class="s3">, </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">floating</span><span class="s3">))</span>

        <span class="s2">for </span><span class="s1">chunk_idx </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n_chunks</span><span class="s3">, </span><span class="s1">schedule</span><span class="s3">=</span><span class="s6">'static'</span><span class="s3">):</span>
            <span class="s1">start </span><span class="s3">= </span><span class="s1">chunk_idx </span><span class="s3">* </span><span class="s1">n_samples_chunk</span>
            <span class="s2">if </span><span class="s1">chunk_idx </span><span class="s3">== </span><span class="s1">n_chunks </span><span class="s3">- </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">n_samples_rem </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">:</span>
                <span class="s1">end </span><span class="s3">= </span><span class="s1">start </span><span class="s3">+ </span><span class="s1">n_samples_rem</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">end </span><span class="s3">= </span><span class="s1">start </span><span class="s3">+ </span><span class="s1">n_samples_chunk</span>

            <span class="s1">_update_chunk_dense</span><span class="s3">(</span>
                <span class="s1">X</span><span class="s3">[</span><span class="s1">start</span><span class="s3">: </span><span class="s1">end</span><span class="s3">],</span>
                <span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">start</span><span class="s3">: </span><span class="s1">end</span><span class="s3">],</span>
                <span class="s1">centers_old</span><span class="s3">,</span>
                <span class="s1">center_half_distances</span><span class="s3">,</span>
                <span class="s1">distance_next_center</span><span class="s3">,</span>
                <span class="s1">labels</span><span class="s3">[</span><span class="s1">start</span><span class="s3">: </span><span class="s1">end</span><span class="s3">],</span>
                <span class="s1">upper_bounds</span><span class="s3">[</span><span class="s1">start</span><span class="s3">: </span><span class="s1">end</span><span class="s3">],</span>
                <span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">start</span><span class="s3">: </span><span class="s1">end</span><span class="s3">],</span>
                <span class="s1">centers_new_chunk</span><span class="s3">,</span>
                <span class="s1">weight_in_clusters_chunk</span><span class="s3">,</span>
                <span class="s1">update_centers</span><span class="s3">)</span>

        <span class="s0"># reduction from local buffers.</span>
        <span class="s2">if </span><span class="s1">update_centers</span><span class="s3">:</span>
            <span class="s0"># The lock is necessary to avoid race conditions when aggregating</span>
            <span class="s0"># info from different thread-local buffers.</span>
            <span class="s1">omp_set_lock</span><span class="s3">(&amp;</span><span class="s1">lock</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_clusters</span><span class="s3">):</span>
                <span class="s1">weight_in_clusters</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] += </span><span class="s1">weight_in_clusters_chunk</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>
                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_features</span><span class="s3">):</span>
                    <span class="s1">centers_new</span><span class="s3">[</span><span class="s1">j</span><span class="s3">, </span><span class="s1">k</span><span class="s3">] += </span><span class="s1">centers_new_chunk</span><span class="s3">[</span><span class="s1">j </span><span class="s3">* </span><span class="s1">n_features </span><span class="s3">+ </span><span class="s1">k</span><span class="s3">]</span>
            <span class="s1">omp_unset_lock</span><span class="s3">(&amp;</span><span class="s1">lock</span><span class="s3">)</span>

        <span class="s1">free</span><span class="s3">(</span><span class="s1">centers_new_chunk</span><span class="s3">)</span>
        <span class="s1">free</span><span class="s3">(</span><span class="s1">weight_in_clusters_chunk</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">update_centers</span><span class="s3">:</span>
        <span class="s1">omp_destroy_lock</span><span class="s3">(&amp;</span><span class="s1">lock</span><span class="s3">)</span>
        <span class="s1">_relocate_empty_clusters_dense</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">, </span><span class="s1">centers_old</span><span class="s3">,</span>
                                       <span class="s1">centers_new</span><span class="s3">, </span><span class="s1">weight_in_clusters</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">)</span>

        <span class="s1">_average_centers</span><span class="s3">(</span><span class="s1">centers_new</span><span class="s3">, </span><span class="s1">weight_in_clusters</span><span class="s3">)</span>
        <span class="s1">_center_shift</span><span class="s3">(</span><span class="s1">centers_old</span><span class="s3">, </span><span class="s1">centers_new</span><span class="s3">, </span><span class="s1">center_shift</span><span class="s3">)</span>

        <span class="s0"># update lower and upper bounds</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">):</span>
            <span class="s1">upper_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] += </span><span class="s1">center_shift</span><span class="s3">[</span><span class="s1">labels</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]]</span>

            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_clusters</span><span class="s3">):</span>
                <span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] -= </span><span class="s1">center_shift</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] &lt; </span><span class="s4">0</span><span class="s3">:</span>
                    <span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] = </span><span class="s4">0</span>


<span class="s2">cdef </span><span class="s1">void _update_chunk_dense</span><span class="s3">(</span>
        <span class="s1">const floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X</span><span class="s3">,                      </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">sample_weight</span><span class="s3">,             </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">centers_old</span><span class="s3">,            </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">center_half_distances</span><span class="s3">,  </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">distance_next_center</span><span class="s3">,      </span><span class="s0"># IN</span>
        <span class="s1">int</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">labels</span><span class="s3">,                               </span><span class="s0"># INOUT</span>
        <span class="s1">floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">upper_bounds</span><span class="s3">,                    </span><span class="s0"># INOUT</span>
        <span class="s1">floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">lower_bounds</span><span class="s3">,                 </span><span class="s0"># INOUT</span>
        <span class="s1">floating </span><span class="s3">*</span><span class="s1">centers_new</span><span class="s3">,                         </span><span class="s0"># OUT</span>
        <span class="s1">floating </span><span class="s3">*</span><span class="s1">weight_in_clusters</span><span class="s3">,                  </span><span class="s0"># OUT</span>
        <span class="s1">bint update_centers</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
    <span class="s6">&quot;&quot;&quot;K-means combined EM step for one dense data chunk. 
 
    Compute the partial contribution of a single data chunk to the labels and 
    centers. 
    &quot;&quot;&quot;</span>
    <span class="s2">cdef</span><span class="s3">:</span>
        <span class="s1">int n_samples </span><span class="s3">= </span><span class="s1">labels</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">int n_clusters </span><span class="s3">= </span><span class="s1">centers_old</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">int n_features </span><span class="s3">= </span><span class="s1">centers_old</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]</span>

        <span class="s1">floating upper_bound</span><span class="s3">, </span><span class="s1">distance</span>
        <span class="s1">int i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">label</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">):</span>
        <span class="s1">upper_bound </span><span class="s3">= </span><span class="s1">upper_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s1">bounds_tight </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">label </span><span class="s3">= </span><span class="s1">labels</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

        <span class="s0"># Next center is not far away from the currently assigned center.</span>
        <span class="s0"># Sample might need to be assigned to another center.</span>
        <span class="s2">if not </span><span class="s1">distance_next_center</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] &gt;= </span><span class="s1">upper_bound</span><span class="s3">:</span>

            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_clusters</span><span class="s3">):</span>

                <span class="s0"># If this holds, then center_index is a good candidate for the</span>
                <span class="s0"># sample to be relabelled, and we need to confirm this by</span>
                <span class="s0"># recomputing the upper and lower bounds.</span>
                <span class="s2">if </span><span class="s3">(</span>
                    <span class="s1">j </span><span class="s3">!= </span><span class="s1">label</span>
                    <span class="s2">and </span><span class="s3">(</span><span class="s1">upper_bound </span><span class="s3">&gt; </span><span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">])</span>
                    <span class="s2">and </span><span class="s3">(</span><span class="s1">upper_bound </span><span class="s3">&gt; </span><span class="s1">center_half_distances</span><span class="s3">[</span><span class="s1">label</span><span class="s3">, </span><span class="s1">j</span><span class="s3">])</span>
                <span class="s3">):</span>

                    <span class="s0"># Recompute upper bound by calculating the actual distance</span>
                    <span class="s0"># between the sample and its current assigned center.</span>
                    <span class="s2">if not </span><span class="s1">bounds_tight</span><span class="s3">:</span>
                        <span class="s1">upper_bound </span><span class="s3">= </span><span class="s1">_euclidean_dense_dense</span><span class="s3">(</span>
                            <span class="s3">&amp;</span><span class="s1">X</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], &amp;</span><span class="s1">centers_old</span><span class="s3">[</span><span class="s1">label</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], </span><span class="s1">n_features</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
                        <span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">label</span><span class="s3">] = </span><span class="s1">upper_bound</span>
                        <span class="s1">bounds_tight </span><span class="s3">= </span><span class="s4">1</span>

                    <span class="s0"># If the condition still holds, then compute the actual</span>
                    <span class="s0"># distance between the sample and center. If this is less</span>
                    <span class="s0"># than the previous distance, reassign label.</span>
                    <span class="s2">if </span><span class="s3">(</span>
                        <span class="s1">upper_bound </span><span class="s3">&gt; </span><span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">]</span>
                        <span class="s2">or </span><span class="s3">(</span><span class="s1">upper_bound </span><span class="s3">&gt; </span><span class="s1">center_half_distances</span><span class="s3">[</span><span class="s1">label</span><span class="s3">, </span><span class="s1">j</span><span class="s3">])</span>
                    <span class="s3">):</span>

                        <span class="s1">distance </span><span class="s3">= </span><span class="s1">_euclidean_dense_dense</span><span class="s3">(</span>
                            <span class="s3">&amp;</span><span class="s1">X</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], &amp;</span><span class="s1">centers_old</span><span class="s3">[</span><span class="s1">j</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], </span><span class="s1">n_features</span><span class="s3">, </span><span class="s2">False</span><span class="s3">)</span>
                        <span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] = </span><span class="s1">distance</span>
                        <span class="s2">if </span><span class="s1">distance </span><span class="s3">&lt; </span><span class="s1">upper_bound</span><span class="s3">:</span>
                            <span class="s1">label </span><span class="s3">= </span><span class="s1">j</span>
                            <span class="s1">upper_bound </span><span class="s3">= </span><span class="s1">distance</span>

            <span class="s1">labels</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">label</span>
            <span class="s1">upper_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">upper_bound</span>

        <span class="s2">if </span><span class="s1">update_centers</span><span class="s3">:</span>
            <span class="s1">weight_in_clusters</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] += </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_features</span><span class="s3">):</span>
                <span class="s1">centers_new</span><span class="s3">[</span><span class="s1">label </span><span class="s3">* </span><span class="s1">n_features </span><span class="s3">+ </span><span class="s1">k</span><span class="s3">] += </span><span class="s1">X</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">k</span><span class="s3">] * </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">elkan_iter_chunked_sparse</span><span class="s3">(</span>
        <span class="s1">X</span><span class="s3">,                                             </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">sample_weight</span><span class="s3">,             </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">centers_old</span><span class="s3">,            </span><span class="s0"># IN</span>
        <span class="s1">floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">centers_new</span><span class="s3">,                  </span><span class="s0"># OUT</span>
        <span class="s1">floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">weight_in_clusters</span><span class="s3">,              </span><span class="s0"># OUT</span>
        <span class="s1">const floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">center_half_distances</span><span class="s3">,  </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">distance_next_center</span><span class="s3">,      </span><span class="s0"># IN</span>
        <span class="s1">floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">upper_bounds</span><span class="s3">,                    </span><span class="s0"># INOUT</span>
        <span class="s1">floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">lower_bounds</span><span class="s3">,                 </span><span class="s0"># INOUT</span>
        <span class="s1">int</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">labels</span><span class="s3">,                               </span><span class="s0"># INOUT</span>
        <span class="s1">floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">center_shift</span><span class="s3">,                    </span><span class="s0"># OUT</span>
        <span class="s1">int n_threads</span><span class="s3">,</span>
        <span class="s1">bint update_centers</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Single iteration of K-means Elkan algorithm with sparse input. 
 
    Update labels and centers (inplace), for one iteration, distributed 
    over data chunks. 
 
    Parameters 
    ---------- 
    X : sparse matrix of shape (n_samples, n_features) 
        The observations to cluster. Must be in CSR format. 
 
    sample_weight : ndarray of shape (n_samples,), dtype=floating 
        The weights for each observation in X. 
 
    centers_old : ndarray of shape (n_clusters, n_features), dtype=floating 
        Centers before previous iteration, placeholder for the centers after 
        previous iteration. 
 
    centers_new : ndarray of shape (n_clusters, n_features), dtype=floating 
        Centers after previous iteration, placeholder for the new centers 
        computed during this iteration. 
 
    weight_in_clusters : ndarray of shape (n_clusters,), dtype=floating 
        Placeholder for the sums of the weights of every observation assigned 
        to each center. 
 
    center_half_distances : ndarray of shape (n_clusters, n_clusters), \ 
            dtype=floating 
        Half pairwise distances between centers. 
 
    distance_next_center : ndarray of shape (n_clusters,), dtype=floating 
        Distance between each center its closest center. 
 
    upper_bounds : ndarray of shape (n_samples,), dtype=floating 
        Upper bound for the distance between each sample and its center, 
        updated inplace. 
 
    lower_bounds : ndarray of shape (n_samples, n_clusters), dtype=floating 
        Lower bound for the distance between each sample and each center, 
        updated inplace. 
 
    labels : ndarray of shape (n_samples,), dtype=int 
        labels assignment. 
 
    center_shift : ndarray of shape (n_clusters,), dtype=floating 
        Distance between old and new centers. 
 
    n_threads : int 
        The number of threads to be used by openmp. 
 
    update_centers : bool 
        - If True, the labels and the new centers will be computed, i.e. runs 
          the E-step and the M-step of the algorithm. 
        - If False, only the labels will be computed, i.e runs the E-step of 
          the algorithm. This is useful especially when calling predict on a 
          fitted model. 
    &quot;&quot;&quot;</span>
    <span class="s2">cdef</span><span class="s3">:</span>
        <span class="s1">int n_samples </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">int n_features </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s1">int n_clusters </span><span class="s3">= </span><span class="s1">centers_new</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

    <span class="s2">if </span><span class="s1">n_samples </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s0"># An empty array was passed, do nothing and return early (before</span>
        <span class="s0"># attempting to compute n_chunks). This can typically happen when</span>
        <span class="s0"># calling the prediction function of a bisecting k-means model with a</span>
        <span class="s0"># large fraction of outiers.</span>
        <span class="s2">return</span>

    <span class="s2">cdef</span><span class="s3">:</span>
        <span class="s1">floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_data </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">data</span>
        <span class="s1">int</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_indices </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">indices</span>
        <span class="s1">int</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_indptr </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">indptr</span>

        <span class="s0"># hard-coded number of samples per chunk. Splitting in chunks is</span>
        <span class="s0"># necessary to get parallelism. Chunk size chosen to be same as lloyd's</span>
        <span class="s1">int n_samples_chunk </span><span class="s3">= </span><span class="s1">CHUNK_SIZE </span><span class="s2">if </span><span class="s1">n_samples </span><span class="s3">&gt; </span><span class="s1">CHUNK_SIZE </span><span class="s2">else </span><span class="s1">n_samples</span>
        <span class="s1">int n_chunks </span><span class="s3">= </span><span class="s1">n_samples </span><span class="s3">// </span><span class="s1">n_samples_chunk</span>
        <span class="s1">int n_samples_rem </span><span class="s3">= </span><span class="s1">n_samples </span><span class="s3">% </span><span class="s1">n_samples_chunk</span>
        <span class="s1">int chunk_idx</span>
        <span class="s1">int start</span><span class="s3">, </span><span class="s1">end</span>

        <span class="s1">int i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">k</span>

        <span class="s1">floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">centers_squared_norms </span><span class="s3">= </span><span class="s1">row_norms</span><span class="s3">(</span><span class="s1">centers_old</span><span class="s3">, </span><span class="s1">squared</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

        <span class="s1">floating </span><span class="s3">*</span><span class="s1">centers_new_chunk</span>
        <span class="s1">floating </span><span class="s3">*</span><span class="s1">weight_in_clusters_chunk</span>

        <span class="s1">omp_lock_t lock</span>

    <span class="s0"># count remainder chunk in total number of chunks</span>
    <span class="s1">n_chunks </span><span class="s3">+= </span><span class="s1">n_samples </span><span class="s3">!= </span><span class="s1">n_chunks </span><span class="s3">* </span><span class="s1">n_samples_chunk</span>

    <span class="s0"># number of threads should not be bigger than number of chunks</span>
    <span class="s1">n_threads </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">n_threads</span><span class="s3">, </span><span class="s1">n_chunks</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">update_centers</span><span class="s3">:</span>
        <span class="s1">memset</span><span class="s3">(&amp;</span><span class="s1">centers_new</span><span class="s3">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], </span><span class="s4">0</span><span class="s3">, </span><span class="s1">n_clusters </span><span class="s3">* </span><span class="s1">n_features </span><span class="s3">* </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">floating</span><span class="s3">))</span>
        <span class="s1">memset</span><span class="s3">(&amp;</span><span class="s1">weight_in_clusters</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s4">0</span><span class="s3">, </span><span class="s1">n_clusters </span><span class="s3">* </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">floating</span><span class="s3">))</span>
        <span class="s1">omp_init_lock</span><span class="s3">(&amp;</span><span class="s1">lock</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">nogil</span><span class="s3">, </span><span class="s1">parallel</span><span class="s3">(</span><span class="s1">num_threads</span><span class="s3">=</span><span class="s1">n_threads</span><span class="s3">):</span>
        <span class="s0"># thread local buffers</span>
        <span class="s1">centers_new_chunk </span><span class="s3">= &lt;</span><span class="s1">floating</span><span class="s3">*&gt; </span><span class="s1">calloc</span><span class="s3">(</span><span class="s1">n_clusters </span><span class="s3">* </span><span class="s1">n_features</span><span class="s3">, </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">floating</span><span class="s3">))</span>
        <span class="s1">weight_in_clusters_chunk </span><span class="s3">= &lt;</span><span class="s1">floating</span><span class="s3">*&gt; </span><span class="s1">calloc</span><span class="s3">(</span><span class="s1">n_clusters</span><span class="s3">, </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">floating</span><span class="s3">))</span>

        <span class="s2">for </span><span class="s1">chunk_idx </span><span class="s2">in </span><span class="s1">prange</span><span class="s3">(</span><span class="s1">n_chunks</span><span class="s3">, </span><span class="s1">schedule</span><span class="s3">=</span><span class="s6">'static'</span><span class="s3">):</span>
            <span class="s1">start </span><span class="s3">= </span><span class="s1">chunk_idx </span><span class="s3">* </span><span class="s1">n_samples_chunk</span>
            <span class="s2">if </span><span class="s1">chunk_idx </span><span class="s3">== </span><span class="s1">n_chunks </span><span class="s3">- </span><span class="s4">1 </span><span class="s2">and </span><span class="s1">n_samples_rem </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">:</span>
                <span class="s1">end </span><span class="s3">= </span><span class="s1">start </span><span class="s3">+ </span><span class="s1">n_samples_rem</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">end </span><span class="s3">= </span><span class="s1">start </span><span class="s3">+ </span><span class="s1">n_samples_chunk</span>

            <span class="s1">_update_chunk_sparse</span><span class="s3">(</span>
                <span class="s1">X_data</span><span class="s3">[</span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">start</span><span class="s3">]: </span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">end</span><span class="s3">]],</span>
                <span class="s1">X_indices</span><span class="s3">[</span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">start</span><span class="s3">]: </span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">end</span><span class="s3">]],</span>
                <span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">start</span><span class="s3">: </span><span class="s1">end</span><span class="s3">+</span><span class="s4">1</span><span class="s3">],</span>
                <span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">start</span><span class="s3">: </span><span class="s1">end</span><span class="s3">],</span>
                <span class="s1">centers_old</span><span class="s3">,</span>
                <span class="s1">centers_squared_norms</span><span class="s3">,</span>
                <span class="s1">center_half_distances</span><span class="s3">,</span>
                <span class="s1">distance_next_center</span><span class="s3">,</span>
                <span class="s1">labels</span><span class="s3">[</span><span class="s1">start</span><span class="s3">: </span><span class="s1">end</span><span class="s3">],</span>
                <span class="s1">upper_bounds</span><span class="s3">[</span><span class="s1">start</span><span class="s3">: </span><span class="s1">end</span><span class="s3">],</span>
                <span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">start</span><span class="s3">: </span><span class="s1">end</span><span class="s3">],</span>
                <span class="s1">centers_new_chunk</span><span class="s3">,</span>
                <span class="s1">weight_in_clusters_chunk</span><span class="s3">,</span>
                <span class="s1">update_centers</span><span class="s3">)</span>

        <span class="s0"># reduction from local buffers.</span>
        <span class="s2">if </span><span class="s1">update_centers</span><span class="s3">:</span>
            <span class="s0"># The lock is necessary to avoid race conditions when aggregating</span>
            <span class="s0"># info from different thread-local buffers.</span>
            <span class="s1">omp_set_lock</span><span class="s3">(&amp;</span><span class="s1">lock</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_clusters</span><span class="s3">):</span>
                <span class="s1">weight_in_clusters</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] += </span><span class="s1">weight_in_clusters_chunk</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>
                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_features</span><span class="s3">):</span>
                    <span class="s1">centers_new</span><span class="s3">[</span><span class="s1">j</span><span class="s3">, </span><span class="s1">k</span><span class="s3">] += </span><span class="s1">centers_new_chunk</span><span class="s3">[</span><span class="s1">j </span><span class="s3">* </span><span class="s1">n_features </span><span class="s3">+ </span><span class="s1">k</span><span class="s3">]</span>
            <span class="s1">omp_unset_lock</span><span class="s3">(&amp;</span><span class="s1">lock</span><span class="s3">)</span>

        <span class="s1">free</span><span class="s3">(</span><span class="s1">centers_new_chunk</span><span class="s3">)</span>
        <span class="s1">free</span><span class="s3">(</span><span class="s1">weight_in_clusters_chunk</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">update_centers</span><span class="s3">:</span>
        <span class="s1">omp_destroy_lock</span><span class="s3">(&amp;</span><span class="s1">lock</span><span class="s3">)</span>
        <span class="s1">_relocate_empty_clusters_sparse</span><span class="s3">(</span>
            <span class="s1">X_data</span><span class="s3">, </span><span class="s1">X_indices</span><span class="s3">, </span><span class="s1">X_indptr</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">,</span>
            <span class="s1">centers_old</span><span class="s3">, </span><span class="s1">centers_new</span><span class="s3">, </span><span class="s1">weight_in_clusters</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">)</span>

        <span class="s1">_average_centers</span><span class="s3">(</span><span class="s1">centers_new</span><span class="s3">, </span><span class="s1">weight_in_clusters</span><span class="s3">)</span>
        <span class="s1">_center_shift</span><span class="s3">(</span><span class="s1">centers_old</span><span class="s3">, </span><span class="s1">centers_new</span><span class="s3">, </span><span class="s1">center_shift</span><span class="s3">)</span>

        <span class="s0"># update lower and upper bounds</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">):</span>
            <span class="s1">upper_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] += </span><span class="s1">center_shift</span><span class="s3">[</span><span class="s1">labels</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]]</span>

            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_clusters</span><span class="s3">):</span>
                <span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] -= </span><span class="s1">center_shift</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] &lt; </span><span class="s4">0</span><span class="s3">:</span>
                    <span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] = </span><span class="s4">0</span>


<span class="s2">cdef </span><span class="s1">void _update_chunk_sparse</span><span class="s3">(</span>
        <span class="s1">const floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_data</span><span class="s3">,                    </span><span class="s0"># IN</span>
        <span class="s1">const int</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_indices</span><span class="s3">,                      </span><span class="s0"># IN</span>
        <span class="s1">const int</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_indptr</span><span class="s3">,                       </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">sample_weight</span><span class="s3">,             </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">centers_old</span><span class="s3">,            </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">centers_squared_norms</span><span class="s3">,     </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">center_half_distances</span><span class="s3">,  </span><span class="s0"># IN</span>
        <span class="s1">const floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">distance_next_center</span><span class="s3">,      </span><span class="s0"># IN</span>
        <span class="s1">int</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">labels</span><span class="s3">,                               </span><span class="s0"># INOUT</span>
        <span class="s1">floating</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">upper_bounds</span><span class="s3">,                    </span><span class="s0"># INOUT</span>
        <span class="s1">floating</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">lower_bounds</span><span class="s3">,                 </span><span class="s0"># INOUT</span>
        <span class="s1">floating </span><span class="s3">*</span><span class="s1">centers_new</span><span class="s3">,                         </span><span class="s0"># OUT</span>
        <span class="s1">floating </span><span class="s3">*</span><span class="s1">weight_in_clusters</span><span class="s3">,                  </span><span class="s0"># OUT</span>
        <span class="s1">bint update_centers</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
    <span class="s6">&quot;&quot;&quot;K-means combined EM step for one sparse data chunk. 
 
    Compute the partial contribution of a single data chunk to the labels and 
    centers. 
    &quot;&quot;&quot;</span>
    <span class="s2">cdef</span><span class="s3">:</span>
        <span class="s1">int n_samples </span><span class="s3">= </span><span class="s1">labels</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">int n_clusters </span><span class="s3">= </span><span class="s1">centers_old</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">int n_features </span><span class="s3">= </span><span class="s1">centers_old</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]</span>

        <span class="s1">floating upper_bound</span><span class="s3">, </span><span class="s1">distance</span>
        <span class="s1">int i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">label</span>
        <span class="s1">int s </span><span class="s3">= </span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">):</span>
        <span class="s1">upper_bound </span><span class="s3">= </span><span class="s1">upper_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s1">bounds_tight </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">label </span><span class="s3">= </span><span class="s1">labels</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

        <span class="s0"># Next center is not far away from the currently assigned center.</span>
        <span class="s0"># Sample might need to be assigned to another center.</span>
        <span class="s2">if not </span><span class="s1">distance_next_center</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] &gt;= </span><span class="s1">upper_bound</span><span class="s3">:</span>

            <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_clusters</span><span class="s3">):</span>

                <span class="s0"># If this holds, then center_index is a good candidate for the</span>
                <span class="s0"># sample to be relabelled, and we need to confirm this by</span>
                <span class="s0"># recomputing the upper and lower bounds.</span>
                <span class="s2">if </span><span class="s3">(</span>
                    <span class="s1">j </span><span class="s3">!= </span><span class="s1">label</span>
                    <span class="s2">and </span><span class="s3">(</span><span class="s1">upper_bound </span><span class="s3">&gt; </span><span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">])</span>
                    <span class="s2">and </span><span class="s3">(</span><span class="s1">upper_bound </span><span class="s3">&gt; </span><span class="s1">center_half_distances</span><span class="s3">[</span><span class="s1">label</span><span class="s3">, </span><span class="s1">j</span><span class="s3">])</span>
                <span class="s3">):</span>

                    <span class="s0"># Recompute upper bound by calculating the actual distance</span>
                    <span class="s0"># between the sample and its current assigned center.</span>
                    <span class="s2">if not </span><span class="s1">bounds_tight</span><span class="s3">:</span>
                        <span class="s1">upper_bound </span><span class="s3">= </span><span class="s1">_euclidean_sparse_dense</span><span class="s3">(</span>
                            <span class="s1">X_data</span><span class="s3">[</span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">s</span><span class="s3">: </span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">] - </span><span class="s1">s</span><span class="s3">],</span>
                            <span class="s1">X_indices</span><span class="s3">[</span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">s</span><span class="s3">: </span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">] - </span><span class="s1">s</span><span class="s3">],</span>
                            <span class="s1">centers_old</span><span class="s3">[</span><span class="s1">label</span><span class="s3">], </span><span class="s1">centers_squared_norms</span><span class="s3">[</span><span class="s1">label</span><span class="s3">], </span><span class="s2">False</span><span class="s3">)</span>
                        <span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">label</span><span class="s3">] = </span><span class="s1">upper_bound</span>
                        <span class="s1">bounds_tight </span><span class="s3">= </span><span class="s4">1</span>

                    <span class="s0"># If the condition still holds, then compute the actual</span>
                    <span class="s0"># distance between the sample and center. If this is less</span>
                    <span class="s0"># than the previous distance, reassign label.</span>
                    <span class="s2">if </span><span class="s3">(</span>
                        <span class="s1">upper_bound </span><span class="s3">&gt; </span><span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">]</span>
                        <span class="s2">or </span><span class="s3">(</span><span class="s1">upper_bound </span><span class="s3">&gt; </span><span class="s1">center_half_distances</span><span class="s3">[</span><span class="s1">label</span><span class="s3">, </span><span class="s1">j</span><span class="s3">])</span>
                    <span class="s3">):</span>
                        <span class="s1">distance </span><span class="s3">= </span><span class="s1">_euclidean_sparse_dense</span><span class="s3">(</span>
                            <span class="s1">X_data</span><span class="s3">[</span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">s</span><span class="s3">: </span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">] - </span><span class="s1">s</span><span class="s3">],</span>
                            <span class="s1">X_indices</span><span class="s3">[</span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">s</span><span class="s3">: </span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">] - </span><span class="s1">s</span><span class="s3">],</span>
                            <span class="s1">centers_old</span><span class="s3">[</span><span class="s1">j</span><span class="s3">], </span><span class="s1">centers_squared_norms</span><span class="s3">[</span><span class="s1">j</span><span class="s3">], </span><span class="s2">False</span><span class="s3">)</span>
                        <span class="s1">lower_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] = </span><span class="s1">distance</span>
                        <span class="s2">if </span><span class="s1">distance </span><span class="s3">&lt; </span><span class="s1">upper_bound</span><span class="s3">:</span>
                            <span class="s1">label </span><span class="s3">= </span><span class="s1">j</span>
                            <span class="s1">upper_bound </span><span class="s3">= </span><span class="s1">distance</span>

            <span class="s1">labels</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">label</span>
            <span class="s1">upper_bounds</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">upper_bound</span>

        <span class="s2">if </span><span class="s1">update_centers</span><span class="s3">:</span>
            <span class="s1">weight_in_clusters</span><span class="s3">[</span><span class="s1">label</span><span class="s3">] += </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">s</span><span class="s3">, </span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">] - </span><span class="s1">s</span><span class="s3">):</span>
                <span class="s1">centers_new</span><span class="s3">[</span><span class="s1">label </span><span class="s3">* </span><span class="s1">n_features </span><span class="s3">+ </span><span class="s1">X_indices</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]] += </span><span class="s1">X_data</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] * </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
</pre>
</body>
</html>