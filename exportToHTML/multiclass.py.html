<html>
<head>
<title>multiclass.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
multiclass.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Utilities to handle multiclass/multioutput target in classifiers.&quot;&quot;&quot;</span>

<span class="s2"># Author: Arnaud Joly, Joel Nothman, Hamzeh Alsalhi</span>
<span class="s2">#</span>
<span class="s2"># License: BSD 3 clause</span>

<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">from </span><span class="s1">collections</span><span class="s4">.</span><span class="s1">abc </span><span class="s3">import </span><span class="s1">Sequence</span>
<span class="s3">from </span><span class="s1">itertools </span><span class="s3">import </span><span class="s1">chain</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse </span><span class="s3">import </span><span class="s1">issparse</span>

<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_array_api </span><span class="s3">import </span><span class="s1">get_namespace</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">fixes </span><span class="s3">import </span><span class="s1">VisibleDeprecationWarning</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">validation </span><span class="s3">import </span><span class="s1">_assert_all_finite</span><span class="s4">, </span><span class="s1">check_array</span>


<span class="s3">def </span><span class="s1">_unique_multiclass</span><span class="s4">(</span><span class="s1">y</span><span class="s4">):</span>
    <span class="s1">xp</span><span class="s4">, </span><span class="s1">is_array_api_compliant </span><span class="s4">= </span><span class="s1">get_namespace</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s5">&quot;__array__&quot;</span><span class="s4">) </span><span class="s3">or </span><span class="s1">is_array_api_compliant</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">unique_values</span><span class="s4">(</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">y</span><span class="s4">))</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">set</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_unique_indicator</span><span class="s4">(</span><span class="s1">y</span><span class="s4">):</span>
    <span class="s1">xp</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">get_namespace</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span>
        <span class="s1">check_array</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">input_name</span><span class="s4">=</span><span class="s5">&quot;y&quot;</span><span class="s4">, </span><span class="s1">accept_sparse</span><span class="s4">=[</span><span class="s5">&quot;csr&quot;</span><span class="s4">, </span><span class="s5">&quot;csc&quot;</span><span class="s4">, </span><span class="s5">&quot;coo&quot;</span><span class="s4">]).</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>
    <span class="s4">)</span>


<span class="s1">_FN_UNIQUE_LABELS </span><span class="s4">= {</span>
    <span class="s5">&quot;binary&quot;</span><span class="s4">: </span><span class="s1">_unique_multiclass</span><span class="s4">,</span>
    <span class="s5">&quot;multiclass&quot;</span><span class="s4">: </span><span class="s1">_unique_multiclass</span><span class="s4">,</span>
    <span class="s5">&quot;multilabel-indicator&quot;</span><span class="s4">: </span><span class="s1">_unique_indicator</span><span class="s4">,</span>
<span class="s4">}</span>


<span class="s3">def </span><span class="s1">unique_labels</span><span class="s4">(*</span><span class="s1">ys</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Extract an ordered array of unique labels. 
 
    We don't allow: 
        - mix of multilabel and multiclass (single label) targets 
        - mix of label indicator matrix and anything else, 
          because there are no explicit labels) 
        - mix of label indicator matrices of different sizes 
        - mix of string and integer labels 
 
    At the moment, we also don't allow &quot;multiclass-multioutput&quot; input type. 
 
    Parameters 
    ---------- 
    *ys : array-likes 
        Label values. 
 
    Returns 
    ------- 
    out : ndarray of shape (n_unique_labels,) 
        An ordered array of unique labels. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.utils.multiclass import unique_labels 
    &gt;&gt;&gt; unique_labels([3, 5, 5, 5, 7, 7]) 
    array([3, 5, 7]) 
    &gt;&gt;&gt; unique_labels([1, 2, 3, 4], [2, 2, 3, 4]) 
    array([1, 2, 3, 4]) 
    &gt;&gt;&gt; unique_labels([1, 2, 10], [5, 11]) 
    array([ 1,  2,  5, 10, 11]) 
    &quot;&quot;&quot;</span>
    <span class="s1">xp</span><span class="s4">, </span><span class="s1">is_array_api_compliant </span><span class="s4">= </span><span class="s1">get_namespace</span><span class="s4">(*</span><span class="s1">ys</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">ys</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;No argument has been passed.&quot;</span><span class="s4">)</span>
    <span class="s2"># Check that we don't mix label format</span>

    <span class="s1">ys_types </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">type_of_target</span><span class="s4">(</span><span class="s1">x</span><span class="s4">) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">ys</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ys_types </span><span class="s4">== {</span><span class="s5">&quot;binary&quot;</span><span class="s4">, </span><span class="s5">&quot;multiclass&quot;</span><span class="s4">}:</span>
        <span class="s1">ys_types </span><span class="s4">= {</span><span class="s5">&quot;multiclass&quot;</span><span class="s4">}</span>

    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">ys_types</span><span class="s4">) &gt; </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Mix type of y not allowed, got types %s&quot; </span><span class="s4">% </span><span class="s1">ys_types</span><span class="s4">)</span>

    <span class="s1">label_type </span><span class="s4">= </span><span class="s1">ys_types</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">()</span>

    <span class="s2"># Check consistency for the indicator format</span>
    <span class="s3">if </span><span class="s4">(</span>
        <span class="s1">label_type </span><span class="s4">== </span><span class="s5">&quot;multilabel-indicator&quot;</span>
        <span class="s3">and </span><span class="s1">len</span><span class="s4">(</span>
            <span class="s1">set</span><span class="s4">(</span>
                <span class="s1">check_array</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">accept_sparse</span><span class="s4">=[</span><span class="s5">&quot;csr&quot;</span><span class="s4">, </span><span class="s5">&quot;csc&quot;</span><span class="s4">, </span><span class="s5">&quot;coo&quot;</span><span class="s4">]).</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] </span><span class="s3">for </span><span class="s1">y </span><span class="s3">in </span><span class="s1">ys</span>
            <span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s4">&gt; </span><span class="s6">1</span>
    <span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
            <span class="s5">&quot;Multi-label binary indicator input with different numbers of labels&quot;</span>
        <span class="s4">)</span>

    <span class="s2"># Get the unique set of labels</span>
    <span class="s1">_unique_labels </span><span class="s4">= </span><span class="s1">_FN_UNIQUE_LABELS</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">label_type</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">_unique_labels</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Unknown label type: %s&quot; </span><span class="s4">% </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">ys</span><span class="s4">))</span>

    <span class="s3">if </span><span class="s1">is_array_api_compliant</span><span class="s4">:</span>
        <span class="s2"># array_api does not allow for mixed dtypes</span>
        <span class="s1">unique_ys </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">concat</span><span class="s4">([</span><span class="s1">_unique_labels</span><span class="s4">(</span><span class="s1">y</span><span class="s4">) </span><span class="s3">for </span><span class="s1">y </span><span class="s3">in </span><span class="s1">ys</span><span class="s4">])</span>
        <span class="s3">return </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">unique_values</span><span class="s4">(</span><span class="s1">unique_ys</span><span class="s4">)</span>

    <span class="s1">ys_labels </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">chain</span><span class="s4">.</span><span class="s1">from_iterable</span><span class="s4">((</span><span class="s1">i </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">_unique_labels</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)) </span><span class="s3">for </span><span class="s1">y </span><span class="s3">in </span><span class="s1">ys</span><span class="s4">))</span>
    <span class="s2"># Check that we don't mix string type with number type</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">label</span><span class="s4">, </span><span class="s1">str</span><span class="s4">) </span><span class="s3">for </span><span class="s1">label </span><span class="s3">in </span><span class="s1">ys_labels</span><span class="s4">)) &gt; </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Mix of label input types (string and number)&quot;</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">sorted</span><span class="s4">(</span><span class="s1">ys_labels</span><span class="s4">))</span>


<span class="s3">def </span><span class="s1">_is_integral_float</span><span class="s4">(</span><span class="s1">y</span><span class="s4">):</span>
    <span class="s1">xp</span><span class="s4">, </span><span class="s1">is_array_api_compliant </span><span class="s4">= </span><span class="s1">get_namespace</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">isdtype</span><span class="s4">(</span><span class="s1">y</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s5">&quot;real floating&quot;</span><span class="s4">) </span><span class="s3">and </span><span class="s1">bool</span><span class="s4">(</span>
        <span class="s1">xp</span><span class="s4">.</span><span class="s1">all</span><span class="s4">(</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">astype</span><span class="s4">((</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">int64</span><span class="s4">)), </span><span class="s1">y</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">) == </span><span class="s1">y</span><span class="s4">)</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">is_multilabel</span><span class="s4">(</span><span class="s1">y</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Check if ``y`` is in a multilabel format. 
 
    Parameters 
    ---------- 
    y : ndarray of shape (n_samples,) 
        Target values. 
 
    Returns 
    ------- 
    out : bool 
        Return ``True``, if ``y`` is in a multilabel format, else ```False``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.utils.multiclass import is_multilabel 
    &gt;&gt;&gt; is_multilabel([0, 1, 0, 1]) 
    False 
    &gt;&gt;&gt; is_multilabel([[1], [0, 2], []]) 
    False 
    &gt;&gt;&gt; is_multilabel(np.array([[1, 0], [0, 0]])) 
    True 
    &gt;&gt;&gt; is_multilabel(np.array([[1], [0], [0]])) 
    False 
    &gt;&gt;&gt; is_multilabel(np.array([[1, 0, 0]])) 
    True 
    &quot;&quot;&quot;</span>
    <span class="s1">xp</span><span class="s4">, </span><span class="s1">is_array_api_compliant </span><span class="s4">= </span><span class="s1">get_namespace</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s5">&quot;__array__&quot;</span><span class="s4">) </span><span class="s3">or </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">Sequence</span><span class="s4">) </span><span class="s3">or </span><span class="s1">is_array_api_compliant</span><span class="s4">:</span>
        <span class="s2"># DeprecationWarning will be replaced by ValueError, see NEP 34</span>
        <span class="s2"># https://numpy.org/neps/nep-0034-infer-dtype-is-object.html</span>
        <span class="s1">check_y_kwargs </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span>
            <span class="s1">accept_sparse</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s1">allow_nd</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s1">force_all_finite</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">ensure_2d</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">ensure_min_samples</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
            <span class="s1">ensure_min_features</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">with </span><span class="s1">warnings</span><span class="s4">.</span><span class="s1">catch_warnings</span><span class="s4">():</span>
            <span class="s1">warnings</span><span class="s4">.</span><span class="s1">simplefilter</span><span class="s4">(</span><span class="s5">&quot;error&quot;</span><span class="s4">, </span><span class="s1">VisibleDeprecationWarning</span><span class="s4">)</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">y </span><span class="s4">= </span><span class="s1">check_array</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">check_y_kwargs</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s4">(</span><span class="s1">VisibleDeprecationWarning</span><span class="s4">, </span><span class="s1">ValueError</span><span class="s4">) </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">str</span><span class="s4">(</span><span class="s1">e</span><span class="s4">).</span><span class="s1">startswith</span><span class="s4">(</span><span class="s5">&quot;Complex data not supported&quot;</span><span class="s4">):</span>
                    <span class="s3">raise</span>

                <span class="s2"># dtype=object should be provided explicitly for ragged arrays,</span>
                <span class="s2"># see NEP 34</span>
                <span class="s1">y </span><span class="s4">= </span><span class="s1">check_array</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">object</span><span class="s4">, **</span><span class="s1">check_y_kwargs</span><span class="s4">)</span>

    <span class="s3">if not </span><span class="s4">(</span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s5">&quot;shape&quot;</span><span class="s4">) </span><span class="s3">and </span><span class="s1">y</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">== </span><span class="s6">2 </span><span class="s3">and </span><span class="s1">y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] &gt; </span><span class="s6">1</span><span class="s4">):</span>
        <span class="s3">return False</span>

    <span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">y</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">y</span><span class="s4">.</span><span class="s1">format </span><span class="s3">in </span><span class="s4">(</span><span class="s5">&quot;dok&quot;</span><span class="s4">, </span><span class="s5">&quot;lil&quot;</span><span class="s4">):</span>
            <span class="s1">y </span><span class="s4">= </span><span class="s1">y</span><span class="s4">.</span><span class="s1">tocsr</span><span class="s4">()</span>
        <span class="s1">labels </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">unique_values</span><span class="s4">(</span><span class="s1">y</span><span class="s4">.</span><span class="s1">data</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">len</span><span class="s4">(</span><span class="s1">y</span><span class="s4">.</span><span class="s1">data</span><span class="s4">) == </span><span class="s6">0</span>
            <span class="s3">or </span><span class="s4">(</span><span class="s1">labels</span><span class="s4">.</span><span class="s1">size </span><span class="s4">== </span><span class="s6">1 </span><span class="s3">or </span><span class="s4">(</span><span class="s1">labels</span><span class="s4">.</span><span class="s1">size </span><span class="s4">== </span><span class="s6">2</span><span class="s4">) </span><span class="s3">and </span><span class="s4">(</span><span class="s6">0 </span><span class="s3">in </span><span class="s1">labels</span><span class="s4">))</span>
            <span class="s3">and </span><span class="s4">(</span><span class="s1">y</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">.</span><span class="s1">kind </span><span class="s3">in </span><span class="s5">&quot;biu&quot; </span><span class="s3">or </span><span class="s1">_is_integral_float</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">))  </span><span class="s2"># bool, int, uint</span>
        <span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">labels </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">unique_values</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">labels</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] &lt; </span><span class="s6">3 </span><span class="s3">and </span><span class="s4">(</span>
            <span class="s1">xp</span><span class="s4">.</span><span class="s1">isdtype</span><span class="s4">(</span><span class="s1">y</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, (</span><span class="s5">&quot;bool&quot;</span><span class="s4">, </span><span class="s5">&quot;signed integer&quot;</span><span class="s4">, </span><span class="s5">&quot;unsigned integer&quot;</span><span class="s4">))</span>
            <span class="s3">or </span><span class="s1">_is_integral_float</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">)</span>
        <span class="s4">)</span>


<span class="s3">def </span><span class="s1">check_classification_targets</span><span class="s4">(</span><span class="s1">y</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Ensure that target y is of a non-regression type. 
 
    Only the following target types (as defined in type_of_target) are allowed: 
        'binary', 'multiclass', 'multiclass-multioutput', 
        'multilabel-indicator', 'multilabel-sequences' 
 
    Parameters 
    ---------- 
    y : array-like 
        Target values. 
    &quot;&quot;&quot;</span>
    <span class="s1">y_type </span><span class="s4">= </span><span class="s1">type_of_target</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">input_name</span><span class="s4">=</span><span class="s5">&quot;y&quot;</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">y_type </span><span class="s3">not in </span><span class="s4">[</span>
        <span class="s5">&quot;binary&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;multiclass&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;multiclass-multioutput&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;multilabel-indicator&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;multilabel-sequences&quot;</span><span class="s4">,</span>
    <span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
            <span class="s5">f&quot;Unknown label type: </span><span class="s3">{</span><span class="s1">y_type</span><span class="s3">}</span><span class="s5">. Maybe you are trying to fit a &quot;</span>
            <span class="s5">&quot;classifier, which expects discrete classes on a &quot;</span>
            <span class="s5">&quot;regression target with continuous values.&quot;</span>
        <span class="s4">)</span>


<span class="s3">def </span><span class="s1">type_of_target</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">input_name</span><span class="s4">=</span><span class="s5">&quot;&quot;</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Determine the type of data indicated by the target. 
 
    Note that this type is the most specific type that can be inferred. 
    For example: 
 
        * ``binary`` is more specific but compatible with ``multiclass``. 
        * ``multiclass`` of integers is more specific but compatible with 
          ``continuous``. 
        * ``multilabel-indicator`` is more specific but compatible with 
          ``multiclass-multioutput``. 
 
    Parameters 
    ---------- 
    y : {array-like, sparse matrix} 
        Target values. If a sparse matrix, `y` is expected to be a 
        CSR/CSC matrix. 
 
    input_name : str, default=&quot;&quot; 
        The data name used to construct the error message. 
 
        .. versionadded:: 1.1.0 
 
    Returns 
    ------- 
    target_type : str 
        One of: 
 
        * 'continuous': `y` is an array-like of floats that are not all 
          integers, and is 1d or a column vector. 
        * 'continuous-multioutput': `y` is a 2d array of floats that are 
          not all integers, and both dimensions are of size &gt; 1. 
        * 'binary': `y` contains &lt;= 2 discrete values and is 1d or a column 
          vector. 
        * 'multiclass': `y` contains more than two discrete values, is not a 
          sequence of sequences, and is 1d or a column vector. 
        * 'multiclass-multioutput': `y` is a 2d array that contains more 
          than two discrete values, is not a sequence of sequences, and both 
          dimensions are of size &gt; 1. 
        * 'multilabel-indicator': `y` is a label indicator matrix, an array 
          of two dimensions with at least two columns, and at most 2 unique 
          values. 
        * 'unknown': `y` is array-like but none of the above, such as a 3d 
          array, sequence of sequences, or an array of non-sequence objects. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.utils.multiclass import type_of_target 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; type_of_target([0.1, 0.6]) 
    'continuous' 
    &gt;&gt;&gt; type_of_target([1, -1, -1, 1]) 
    'binary' 
    &gt;&gt;&gt; type_of_target(['a', 'b', 'a']) 
    'binary' 
    &gt;&gt;&gt; type_of_target([1.0, 2.0]) 
    'binary' 
    &gt;&gt;&gt; type_of_target([1, 0, 2]) 
    'multiclass' 
    &gt;&gt;&gt; type_of_target([1.0, 0.0, 3.0]) 
    'multiclass' 
    &gt;&gt;&gt; type_of_target(['a', 'b', 'c']) 
    'multiclass' 
    &gt;&gt;&gt; type_of_target(np.array([[1, 2], [3, 1]])) 
    'multiclass-multioutput' 
    &gt;&gt;&gt; type_of_target([[1, 2]]) 
    'multilabel-indicator' 
    &gt;&gt;&gt; type_of_target(np.array([[1.5, 2.0], [3.0, 1.6]])) 
    'continuous-multioutput' 
    &gt;&gt;&gt; type_of_target(np.array([[0, 1], [1, 1]])) 
    'multilabel-indicator' 
    &quot;&quot;&quot;</span>
    <span class="s1">xp</span><span class="s4">, </span><span class="s1">is_array_api_compliant </span><span class="s4">= </span><span class="s1">get_namespace</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
    <span class="s1">valid </span><span class="s4">= (</span>
        <span class="s4">(</span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">Sequence</span><span class="s4">) </span><span class="s3">or </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">y</span><span class="s4">) </span><span class="s3">or </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s5">&quot;__array__&quot;</span><span class="s4">))</span>
        <span class="s3">and not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">str</span><span class="s4">)</span>
        <span class="s3">or </span><span class="s1">is_array_api_compliant</span>
    <span class="s4">)</span>

    <span class="s3">if not </span><span class="s1">valid</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
            <span class="s5">&quot;Expected array-like (array or non-string sequence), got %r&quot; </span><span class="s4">% </span><span class="s1">y</span>
        <span class="s4">)</span>

    <span class="s1">sparse_pandas </span><span class="s4">= </span><span class="s1">y</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__ </span><span class="s3">in </span><span class="s4">[</span><span class="s5">&quot;SparseSeries&quot;</span><span class="s4">, </span><span class="s5">&quot;SparseArray&quot;</span><span class="s4">]</span>
    <span class="s3">if </span><span class="s1">sparse_pandas</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;y cannot be class 'SparseSeries' or 'SparseArray'&quot;</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">is_multilabel</span><span class="s4">(</span><span class="s1">y</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s5">&quot;multilabel-indicator&quot;</span>

    <span class="s2"># DeprecationWarning will be replaced by ValueError, see NEP 34</span>
    <span class="s2"># https://numpy.org/neps/nep-0034-infer-dtype-is-object.html</span>
    <span class="s2"># We therefore catch both deprecation (NumPy &lt; 1.24) warning and</span>
    <span class="s2"># value error (NumPy &gt;= 1.24).</span>
    <span class="s1">check_y_kwargs </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span>
        <span class="s1">accept_sparse</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">allow_nd</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">force_all_finite</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">ensure_2d</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">ensure_min_samples</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
        <span class="s1">ensure_min_features</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
    <span class="s4">)</span>

    <span class="s3">with </span><span class="s1">warnings</span><span class="s4">.</span><span class="s1">catch_warnings</span><span class="s4">():</span>
        <span class="s1">warnings</span><span class="s4">.</span><span class="s1">simplefilter</span><span class="s4">(</span><span class="s5">&quot;error&quot;</span><span class="s4">, </span><span class="s1">VisibleDeprecationWarning</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">y</span><span class="s4">):</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">y </span><span class="s4">= </span><span class="s1">check_array</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">check_y_kwargs</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s4">(</span><span class="s1">VisibleDeprecationWarning</span><span class="s4">, </span><span class="s1">ValueError</span><span class="s4">) </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">str</span><span class="s4">(</span><span class="s1">e</span><span class="s4">).</span><span class="s1">startswith</span><span class="s4">(</span><span class="s5">&quot;Complex data not supported&quot;</span><span class="s4">):</span>
                    <span class="s3">raise</span>

                <span class="s2"># dtype=object should be provided explicitly for ragged arrays,</span>
                <span class="s2"># see NEP 34</span>
                <span class="s1">y </span><span class="s4">= </span><span class="s1">check_array</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">object</span><span class="s4">, **</span><span class="s1">check_y_kwargs</span><span class="s4">)</span>

    <span class="s3">try</span><span class="s4">:</span>
        <span class="s2"># TODO(1.7): Change to ValueError when byte labels is deprecated.</span>
        <span class="s2"># labels in bytes format</span>
        <span class="s1">first_row_or_val </span><span class="s4">= </span><span class="s1">y</span><span class="s4">[[</span><span class="s6">0</span><span class="s4">], :] </span><span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">y</span><span class="s4">) </span><span class="s3">else </span><span class="s1">y</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">first_row_or_val</span><span class="s4">, </span><span class="s1">bytes</span><span class="s4">):</span>
            <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                <span class="s4">(</span>
                    <span class="s5">&quot;Support for labels represented as bytes is deprecated in v1.5 and&quot;</span>
                    <span class="s5">&quot; will error in v1.7. Convert the labels to a string or integer&quot;</span>
                    <span class="s5">&quot; format.&quot;</span>
                <span class="s4">),</span>
                <span class="s1">FutureWarning</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s2"># The old sequence of sequences format</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s3">not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">first_row_or_val</span><span class="s4">, </span><span class="s5">&quot;__array__&quot;</span><span class="s4">)</span>
            <span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">first_row_or_val</span><span class="s4">, </span><span class="s1">Sequence</span><span class="s4">)</span>
            <span class="s3">and not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">first_row_or_val</span><span class="s4">, </span><span class="s1">str</span><span class="s4">)</span>
        <span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;You appear to be using a legacy multi-label data&quot;</span>
                <span class="s5">&quot; representation. Sequence of sequences are no&quot;</span>
                <span class="s5">&quot; longer supported; use a binary array or sparse&quot;</span>
                <span class="s5">&quot; matrix instead - the MultiLabelBinarizer&quot;</span>
                <span class="s5">&quot; transformer can convert to this format.&quot;</span>
            <span class="s4">)</span>
    <span class="s3">except </span><span class="s1">IndexError</span><span class="s4">:</span>
        <span class="s3">pass</span>

    <span class="s2"># Invalid inputs</span>
    <span class="s3">if </span><span class="s1">y</span><span class="s4">.</span><span class="s1">ndim </span><span class="s3">not in </span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s6">2</span><span class="s4">):</span>
        <span class="s2"># Number of dimension greater than 2: [[[1, 2]]]</span>
        <span class="s3">return </span><span class="s5">&quot;unknown&quot;</span>
    <span class="s3">if not </span><span class="s1">min</span><span class="s4">(</span><span class="s1">y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">):</span>
        <span class="s2"># Empty ndarray: []/[[]]</span>
        <span class="s3">if </span><span class="s1">y</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">== </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s2"># 1-D empty array: []</span>
            <span class="s3">return </span><span class="s5">&quot;binary&quot;  </span><span class="s2"># []</span>
        <span class="s2"># 2-D empty array: [[]]</span>
        <span class="s3">return </span><span class="s5">&quot;unknown&quot;</span>
    <span class="s3">if not </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">y</span><span class="s4">) </span><span class="s3">and </span><span class="s1">y</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">== </span><span class="s1">object </span><span class="s3">and not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">y</span><span class="s4">.</span><span class="s1">flat</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s2"># [obj_1] and not [&quot;label_1&quot;]</span>
        <span class="s3">return </span><span class="s5">&quot;unknown&quot;</span>

    <span class="s2"># Check if multioutput</span>
    <span class="s3">if </span><span class="s1">y</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">== </span><span class="s6">2 </span><span class="s3">and </span><span class="s1">y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] &gt; </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s1">suffix </span><span class="s4">= </span><span class="s5">&quot;-multioutput&quot;  </span><span class="s2"># [[1, 2], [1, 2]]</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">suffix </span><span class="s4">= </span><span class="s5">&quot;&quot;  </span><span class="s2"># [1, 2, 3] or [[1], [2], [3]]</span>

    <span class="s2"># Check float and contains non-integer float values</span>
    <span class="s3">if </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">isdtype</span><span class="s4">(</span><span class="s1">y</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s5">&quot;real floating&quot;</span><span class="s4">):</span>
        <span class="s2"># [.1, .2, 3] or [[.1, .2, 3]] or [[1., .2]] and not [1., 2., 3.]</span>
        <span class="s1">data </span><span class="s4">= </span><span class="s1">y</span><span class="s4">.</span><span class="s1">data </span><span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">y</span><span class="s4">) </span><span class="s3">else </span><span class="s1">y</span>
        <span class="s3">if </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">any</span><span class="s4">(</span><span class="s1">data </span><span class="s4">!= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">int</span><span class="s4">)):</span>
            <span class="s1">_assert_all_finite</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">input_name</span><span class="s4">=</span><span class="s1">input_name</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s5">&quot;continuous&quot; </span><span class="s4">+ </span><span class="s1">suffix</span>

    <span class="s2"># Check multiclass</span>
    <span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">first_row_or_val</span><span class="s4">):</span>
        <span class="s1">first_row_or_val </span><span class="s4">= </span><span class="s1">first_row_or_val</span><span class="s4">.</span><span class="s1">data</span>
    <span class="s3">if </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">unique_values</span><span class="s4">(</span><span class="s1">y</span><span class="s4">).</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] &gt; </span><span class="s6">2 </span><span class="s3">or </span><span class="s4">(</span><span class="s1">y</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">== </span><span class="s6">2 </span><span class="s3">and </span><span class="s1">len</span><span class="s4">(</span><span class="s1">first_row_or_val</span><span class="s4">) &gt; </span><span class="s6">1</span><span class="s4">):</span>
        <span class="s2"># [1, 2, 3] or [[1., 2., 3]] or [[1, 2]]</span>
        <span class="s3">return </span><span class="s5">&quot;multiclass&quot; </span><span class="s4">+ </span><span class="s1">suffix</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s5">&quot;binary&quot;  </span><span class="s2"># [1, 2] or [[&quot;a&quot;], [&quot;b&quot;]]</span>


<span class="s3">def </span><span class="s1">_check_partial_fit_first_call</span><span class="s4">(</span><span class="s1">clf</span><span class="s4">, </span><span class="s1">classes</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Private helper function for factorizing common classes param logic. 
 
    Estimators that implement the ``partial_fit`` API need to be provided with 
    the list of possible classes at the first call to partial_fit. 
 
    Subsequent calls to partial_fit should check that ``classes`` is still 
    consistent with a previous value of ``clf.classes_`` when provided. 
 
    This function returns True if it detects that this was the first call to 
    ``partial_fit`` on ``clf``. In that case the ``classes_`` attribute is also 
    set on ``clf``. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">clf</span><span class="s4">, </span><span class="s5">&quot;classes_&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">is None and </span><span class="s1">classes </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;classes must be passed on the first call to partial_fit.&quot;</span><span class="s4">)</span>

    <span class="s3">elif </span><span class="s1">classes </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">clf</span><span class="s4">, </span><span class="s5">&quot;classes_&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array_equal</span><span class="s4">(</span><span class="s1">clf</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">, </span><span class="s1">unique_labels</span><span class="s4">(</span><span class="s1">classes</span><span class="s4">)):</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                    <span class="s5">&quot;`classes=%r` is not the same as on last call &quot;</span>
                    <span class="s5">&quot;to partial_fit, was: %r&quot; </span><span class="s4">% (</span><span class="s1">classes</span><span class="s4">, </span><span class="s1">clf</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">)</span>
                <span class="s4">)</span>

        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># This is the first call to partial_fit</span>
            <span class="s1">clf</span><span class="s4">.</span><span class="s1">classes_ </span><span class="s4">= </span><span class="s1">unique_labels</span><span class="s4">(</span><span class="s1">classes</span><span class="s4">)</span>
            <span class="s3">return True</span>

    <span class="s2"># classes is None and clf.classes_ has already previously been set:</span>
    <span class="s2"># nothing to do</span>
    <span class="s3">return False</span>


<span class="s3">def </span><span class="s1">class_distribution</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute class priors from multioutput-multiclass target data. 
 
    Parameters 
    ---------- 
    y : {array-like, sparse matrix} of size (n_samples, n_outputs) 
        The labels for each example. 
 
    sample_weight : array-like of shape (n_samples,), default=None 
        Sample weights. 
 
    Returns 
    ------- 
    classes : list of size n_outputs of ndarray of size (n_classes,) 
        List of classes for each column. 
 
    n_classes : list of int of size n_outputs 
        Number of classes in each column. 
 
    class_prior : list of size n_outputs of ndarray of size (n_classes,) 
        Class distribution of each column. 
    &quot;&quot;&quot;</span>
    <span class="s1">classes </span><span class="s4">= []</span>
    <span class="s1">n_classes </span><span class="s4">= []</span>
    <span class="s1">class_prior </span><span class="s4">= []</span>

    <span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_outputs </span><span class="s4">= </span><span class="s1">y</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s3">if </span><span class="s1">sample_weight </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">sample_weight </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">sample_weight</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">y</span><span class="s4">):</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">y</span><span class="s4">.</span><span class="s1">tocsc</span><span class="s4">()</span>
        <span class="s1">y_nnz </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">diff</span><span class="s4">(</span><span class="s1">y</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">)</span>

        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">n_outputs</span><span class="s4">):</span>
            <span class="s1">col_nonzero </span><span class="s4">= </span><span class="s1">y</span><span class="s4">.</span><span class="s1">indices</span><span class="s4">[</span><span class="s1">y</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] : </span><span class="s1">y</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">[</span><span class="s1">k </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">]]</span>
            <span class="s2"># separate sample weights for zero and non-zero elements</span>
            <span class="s3">if </span><span class="s1">sample_weight </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">nz_samp_weight </span><span class="s4">= </span><span class="s1">sample_weight</span><span class="s4">[</span><span class="s1">col_nonzero</span><span class="s4">]</span>
                <span class="s1">zeros_samp_weight_sum </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">sample_weight</span><span class="s4">) - </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">nz_samp_weight</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">nz_samp_weight </span><span class="s4">= </span><span class="s3">None</span>
                <span class="s1">zeros_samp_weight_sum </span><span class="s4">= </span><span class="s1">y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] - </span><span class="s1">y_nnz</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>

            <span class="s1">classes_k</span><span class="s4">, </span><span class="s1">y_k </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">unique</span><span class="s4">(</span>
                <span class="s1">y</span><span class="s4">.</span><span class="s1">data</span><span class="s4">[</span><span class="s1">y</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] : </span><span class="s1">y</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">[</span><span class="s1">k </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">]], </span><span class="s1">return_inverse</span><span class="s4">=</span><span class="s3">True</span>
            <span class="s4">)</span>
            <span class="s1">class_prior_k </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">bincount</span><span class="s4">(</span><span class="s1">y_k</span><span class="s4">, </span><span class="s1">weights</span><span class="s4">=</span><span class="s1">nz_samp_weight</span><span class="s4">)</span>

            <span class="s2"># An explicit zero was found, combine its weight with the weight</span>
            <span class="s2"># of the implicit zeros</span>
            <span class="s3">if </span><span class="s6">0 </span><span class="s3">in </span><span class="s1">classes_k</span><span class="s4">:</span>
                <span class="s1">class_prior_k</span><span class="s4">[</span><span class="s1">classes_k </span><span class="s4">== </span><span class="s6">0</span><span class="s4">] += </span><span class="s1">zeros_samp_weight_sum</span>

            <span class="s2"># If an there is an implicit zero and it is not in classes and</span>
            <span class="s2"># class_prior, make an entry for it</span>
            <span class="s3">if </span><span class="s6">0 </span><span class="s3">not in </span><span class="s1">classes_k </span><span class="s3">and </span><span class="s1">y_nnz</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] &lt; </span><span class="s1">y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
                <span class="s1">classes_k </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">insert</span><span class="s4">(</span><span class="s1">classes_k</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s6">0</span><span class="s4">)</span>
                <span class="s1">class_prior_k </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">insert</span><span class="s4">(</span><span class="s1">class_prior_k</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s1">zeros_samp_weight_sum</span><span class="s4">)</span>

            <span class="s1">classes</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">classes_k</span><span class="s4">)</span>
            <span class="s1">n_classes</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">classes_k</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])</span>
            <span class="s1">class_prior</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">class_prior_k </span><span class="s4">/ </span><span class="s1">class_prior_k</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">())</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">n_outputs</span><span class="s4">):</span>
            <span class="s1">classes_k</span><span class="s4">, </span><span class="s1">y_k </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">unique</span><span class="s4">(</span><span class="s1">y</span><span class="s4">[:, </span><span class="s1">k</span><span class="s4">], </span><span class="s1">return_inverse</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
            <span class="s1">classes</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">classes_k</span><span class="s4">)</span>
            <span class="s1">n_classes</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">classes_k</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])</span>
            <span class="s1">class_prior_k </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">bincount</span><span class="s4">(</span><span class="s1">y_k</span><span class="s4">, </span><span class="s1">weights</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">)</span>
            <span class="s1">class_prior</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">class_prior_k </span><span class="s4">/ </span><span class="s1">class_prior_k</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">())</span>

    <span class="s3">return </span><span class="s4">(</span><span class="s1">classes</span><span class="s4">, </span><span class="s1">n_classes</span><span class="s4">, </span><span class="s1">class_prior</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_ovr_decision_function</span><span class="s4">(</span><span class="s1">predictions</span><span class="s4">, </span><span class="s1">confidences</span><span class="s4">, </span><span class="s1">n_classes</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute a continuous, tie-breaking OvR decision function from OvO. 
 
    It is important to include a continuous value, not only votes, 
    to make computing AUC or calibration meaningful. 
 
    Parameters 
    ---------- 
    predictions : array-like of shape (n_samples, n_classifiers) 
        Predicted classes for each binary classifier. 
 
    confidences : array-like of shape (n_samples, n_classifiers) 
        Decision functions or predicted probabilities for positive class 
        for each binary classifier. 
 
    n_classes : int 
        Number of classes. n_classifiers must be 
        ``n_classes * (n_classes - 1 ) / 2``. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_samples </span><span class="s4">= </span><span class="s1">predictions</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
    <span class="s1">votes </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_classes</span><span class="s4">))</span>
    <span class="s1">sum_of_confidences </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_classes</span><span class="s4">))</span>

    <span class="s1">k </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">n_classes</span><span class="s4">):</span>
        <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">i </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">, </span><span class="s1">n_classes</span><span class="s4">):</span>
            <span class="s1">sum_of_confidences</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">] -= </span><span class="s1">confidences</span><span class="s4">[:, </span><span class="s1">k</span><span class="s4">]</span>
            <span class="s1">sum_of_confidences</span><span class="s4">[:, </span><span class="s1">j</span><span class="s4">] += </span><span class="s1">confidences</span><span class="s4">[:, </span><span class="s1">k</span><span class="s4">]</span>
            <span class="s1">votes</span><span class="s4">[</span><span class="s1">predictions</span><span class="s4">[:, </span><span class="s1">k</span><span class="s4">] == </span><span class="s6">0</span><span class="s4">, </span><span class="s1">i</span><span class="s4">] += </span><span class="s6">1</span>
            <span class="s1">votes</span><span class="s4">[</span><span class="s1">predictions</span><span class="s4">[:, </span><span class="s1">k</span><span class="s4">] == </span><span class="s6">1</span><span class="s4">, </span><span class="s1">j</span><span class="s4">] += </span><span class="s6">1</span>
            <span class="s1">k </span><span class="s4">+= </span><span class="s6">1</span>

    <span class="s2"># Monotonically transform the sum_of_confidences to (-1/3, 1/3)</span>
    <span class="s2"># and add it with votes. The monotonic transformation  is</span>
    <span class="s2"># f: x -&gt; x / (3 * (|x| + 1)), it uses 1/3 instead of 1/2</span>
    <span class="s2"># to ensure that we won't reach the limits and change vote order.</span>
    <span class="s2"># The motivation is to use confidence levels as a way to break ties in</span>
    <span class="s2"># the votes without switching any decision made based on a difference</span>
    <span class="s2"># of 1 vote.</span>
    <span class="s1">transformed_confidences </span><span class="s4">= </span><span class="s1">sum_of_confidences </span><span class="s4">/ (</span>
        <span class="s6">3 </span><span class="s4">* (</span><span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">sum_of_confidences</span><span class="s4">) + </span><span class="s6">1</span><span class="s4">)</span>
    <span class="s4">)</span>
    <span class="s3">return </span><span class="s1">votes </span><span class="s4">+ </span><span class="s1">transformed_confidences</span>
</pre>
</body>
</html>