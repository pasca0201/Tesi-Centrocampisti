<html>
<head>
<title>_gb.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_gb.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Gradient Boosted Regression Trees. 
 
This module contains methods for fitting gradient boosted regression trees for 
both classification and regression. 
 
The module structure is the following: 
 
- The ``BaseGradientBoosting`` base class implements a common ``fit`` method 
  for all the estimators in the module. Regression and classification 
  only differ in the concrete ``LossFunction`` used. 
 
- ``GradientBoostingClassifier`` implements gradient boosting for 
  classification problems. 
 
- ``GradientBoostingRegressor`` implements gradient boosting for 
  regression problems. 
&quot;&quot;&quot;</span>

<span class="s2"># Authors: Peter Prettenhofer, Scott White, Gilles Louppe, Emanuele Olivetti,</span>
<span class="s2">#          Arnaud Joly, Jacob Schreiber</span>
<span class="s2"># License: BSD 3 clause</span>

<span class="s3">import </span><span class="s1">math</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">from </span><span class="s1">abc </span><span class="s3">import </span><span class="s1">ABCMeta</span><span class="s4">, </span><span class="s1">abstractmethod</span>
<span class="s3">from </span><span class="s1">numbers </span><span class="s3">import </span><span class="s1">Integral</span><span class="s4">, </span><span class="s1">Real</span>
<span class="s3">from </span><span class="s1">time </span><span class="s3">import </span><span class="s1">time</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse </span><span class="s3">import </span><span class="s1">csc_matrix</span><span class="s4">, </span><span class="s1">csr_matrix</span><span class="s4">, </span><span class="s1">issparse</span>

<span class="s3">from </span><span class="s4">..</span><span class="s1">_loss</span><span class="s4">.</span><span class="s1">loss </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">_LOSSES</span><span class="s4">,</span>
    <span class="s1">AbsoluteError</span><span class="s4">,</span>
    <span class="s1">ExponentialLoss</span><span class="s4">,</span>
    <span class="s1">HalfBinomialLoss</span><span class="s4">,</span>
    <span class="s1">HalfMultinomialLoss</span><span class="s4">,</span>
    <span class="s1">HalfSquaredError</span><span class="s4">,</span>
    <span class="s1">HuberLoss</span><span class="s4">,</span>
    <span class="s1">PinballLoss</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">base </span><span class="s3">import </span><span class="s1">ClassifierMixin</span><span class="s4">, </span><span class="s1">RegressorMixin</span><span class="s4">, </span><span class="s1">_fit_context</span><span class="s4">, </span><span class="s1">is_classifier</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">dummy </span><span class="s3">import </span><span class="s1">DummyClassifier</span><span class="s4">, </span><span class="s1">DummyRegressor</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">exceptions </span><span class="s3">import </span><span class="s1">NotFittedError</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">model_selection </span><span class="s3">import </span><span class="s1">train_test_split</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">preprocessing </span><span class="s3">import </span><span class="s1">LabelEncoder</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">tree </span><span class="s3">import </span><span class="s1">DecisionTreeRegressor</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">tree</span><span class="s4">.</span><span class="s1">_tree </span><span class="s3">import </span><span class="s1">DOUBLE</span><span class="s4">, </span><span class="s1">DTYPE</span><span class="s4">, </span><span class="s1">TREE_LEAF</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils </span><span class="s3">import </span><span class="s1">check_array</span><span class="s4">, </span><span class="s1">check_random_state</span><span class="s4">, </span><span class="s1">column_or_1d</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_param_validation </span><span class="s3">import </span><span class="s1">HasMethods</span><span class="s4">, </span><span class="s1">Interval</span><span class="s4">, </span><span class="s1">StrOptions</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">multiclass </span><span class="s3">import </span><span class="s1">check_classification_targets</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">stats </span><span class="s3">import </span><span class="s1">_weighted_percentile</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">validation </span><span class="s3">import </span><span class="s1">_check_sample_weight</span><span class="s4">, </span><span class="s1">check_is_fitted</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_base </span><span class="s3">import </span><span class="s1">BaseEnsemble</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_gradient_boosting </span><span class="s3">import </span><span class="s1">_random_sample_mask</span><span class="s4">, </span><span class="s1">predict_stage</span><span class="s4">, </span><span class="s1">predict_stages</span>

<span class="s1">_LOSSES </span><span class="s4">= </span><span class="s1">_LOSSES</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">()</span>
<span class="s1">_LOSSES</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;quantile&quot;</span><span class="s4">: </span><span class="s1">PinballLoss</span><span class="s4">,</span>
        <span class="s5">&quot;huber&quot;</span><span class="s4">: </span><span class="s1">HuberLoss</span><span class="s4">,</span>
    <span class="s4">}</span>
<span class="s4">)</span>


<span class="s3">def </span><span class="s1">_safe_divide</span><span class="s4">(</span><span class="s1">numerator</span><span class="s4">, </span><span class="s1">denominator</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Prevents overflow and division by zero.&quot;&quot;&quot;</span>
    <span class="s2"># This is used for classifiers where the denominator might become zero exatly.</span>
    <span class="s2"># For instance for log loss, HalfBinomialLoss, if proba=0 or proba=1 exactly, then</span>
    <span class="s2"># denominator = hessian = 0, and we should set the node value in the line search to</span>
    <span class="s2"># zero as there is no improvement of the loss possible.</span>
    <span class="s2"># For numerical safety, we do this already for extremely tiny values.</span>
    <span class="s3">if </span><span class="s1">abs</span><span class="s4">(</span><span class="s1">denominator</span><span class="s4">) &lt; </span><span class="s6">1e-150</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s6">0.0</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s2"># Cast to Python float to trigger Python errors, e.g. ZeroDivisionError,</span>
        <span class="s2"># without relying on `np.errstate` that is not supported by Pyodide.</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">float</span><span class="s4">(</span><span class="s1">numerator</span><span class="s4">) / </span><span class="s1">float</span><span class="s4">(</span><span class="s1">denominator</span><span class="s4">)</span>
        <span class="s2"># Cast to Python float to trigger a ZeroDivisionError without relying</span>
        <span class="s2"># on `np.errstate` that is not supported by Pyodide.</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">float</span><span class="s4">(</span><span class="s1">numerator</span><span class="s4">) / </span><span class="s1">float</span><span class="s4">(</span><span class="s1">denominator</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">math</span><span class="s4">.</span><span class="s1">isinf</span><span class="s4">(</span><span class="s1">result</span><span class="s4">):</span>
            <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span><span class="s5">&quot;overflow encountered in _safe_divide&quot;</span><span class="s4">, </span><span class="s1">RuntimeWarning</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">result</span>


<span class="s3">def </span><span class="s1">_init_raw_predictions</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">loss</span><span class="s4">, </span><span class="s1">use_predict_proba</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Return the initial raw predictions. 
 
    Parameters 
    ---------- 
    X : ndarray of shape (n_samples, n_features) 
        The data array. 
    estimator : object 
        The estimator to use to compute the predictions. 
    loss : BaseLoss 
        An instance of a loss function class. 
    use_predict_proba : bool 
        Whether estimator.predict_proba is used instead of estimator.predict. 
 
    Returns 
    ------- 
    raw_predictions : ndarray of shape (n_samples, K) 
        The initial raw predictions. K is equal to 1 for binary 
        classification and regression, and equal to the number of classes 
        for multiclass classification. ``raw_predictions`` is casted 
        into float64. 
    &quot;&quot;&quot;</span>
    <span class="s2"># TODO: Use loss.fit_intercept_only where appropriate instead of</span>
    <span class="s2"># DummyRegressor which is the default given by the `init` parameter,</span>
    <span class="s2"># see also _init_state.</span>
    <span class="s3">if </span><span class="s1">use_predict_proba</span><span class="s4">:</span>
        <span class="s2"># Our parameter validation, set via _fit_context and _parameter_constraints</span>
        <span class="s2"># already guarantees that estimator has a predict_proba method.</span>
        <span class="s1">predictions </span><span class="s4">= </span><span class="s1">estimator</span><span class="s4">.</span><span class="s1">predict_proba</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">loss</span><span class="s4">.</span><span class="s1">is_multiclass</span><span class="s4">:</span>
            <span class="s1">predictions </span><span class="s4">= </span><span class="s1">predictions</span><span class="s4">[:, </span><span class="s6">1</span><span class="s4">]  </span><span class="s2"># probability of positive class</span>
        <span class="s1">eps </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">finfo</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">).</span><span class="s1">eps  </span><span class="s2"># FIXME: This is quite large!</span>
        <span class="s1">predictions </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">clip</span><span class="s4">(</span><span class="s1">predictions</span><span class="s4">, </span><span class="s1">eps</span><span class="s4">, </span><span class="s6">1 </span><span class="s4">- </span><span class="s1">eps</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">predictions </span><span class="s4">= </span><span class="s1">estimator</span><span class="s4">.</span><span class="s1">predict</span><span class="s4">(</span><span class="s1">X</span><span class="s4">).</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">predictions</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">== </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">loss</span><span class="s4">.</span><span class="s1">link</span><span class="s4">.</span><span class="s1">link</span><span class="s4">(</span><span class="s1">predictions</span><span class="s4">).</span><span class="s1">reshape</span><span class="s4">(-</span><span class="s6">1</span><span class="s4">, </span><span class="s6">1</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">loss</span><span class="s4">.</span><span class="s1">link</span><span class="s4">.</span><span class="s1">link</span><span class="s4">(</span><span class="s1">predictions</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_update_terminal_regions</span><span class="s4">(</span>
    <span class="s1">loss</span><span class="s4">,</span>
    <span class="s1">tree</span><span class="s4">,</span>
    <span class="s1">X</span><span class="s4">,</span>
    <span class="s1">y</span><span class="s4">,</span>
    <span class="s1">neg_gradient</span><span class="s4">,</span>
    <span class="s1">raw_prediction</span><span class="s4">,</span>
    <span class="s1">sample_weight</span><span class="s4">,</span>
    <span class="s1">sample_mask</span><span class="s4">,</span>
    <span class="s1">learning_rate</span><span class="s4">=</span><span class="s6">0.1</span><span class="s4">,</span>
    <span class="s1">k</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Update the leaf values to be predicted by the tree and raw_prediction. 
 
    The current raw predictions of the model (of this stage) are updated. 
 
    Additionally, the terminal regions (=leaves) of the given tree are updated as well. 
    This corresponds to the line search step in &quot;Greedy Function Approximation&quot; by 
    Friedman, Algorithm 1 step 5. 
 
    Update equals: 
        argmin_{x} loss(y_true, raw_prediction_old + x * tree.value) 
 
    For non-trivial cases like the Binomial loss, the update has no closed formula and 
    is an approximation, again, see the Friedman paper. 
 
    Also note that the update formula for the SquaredError is the identity. Therefore, 
    in this case, the leaf values don't need an update and only the raw_predictions are 
    updated (with the learning rate included). 
 
    Parameters 
    ---------- 
    loss : BaseLoss 
    tree : tree.Tree 
        The tree object. 
    X : ndarray of shape (n_samples, n_features) 
        The data array. 
    y : ndarray of shape (n_samples,) 
        The target labels. 
    neg_gradient : ndarray of shape (n_samples,) 
        The negative gradient. 
    raw_prediction : ndarray of shape (n_samples, n_trees_per_iteration) 
        The raw predictions (i.e. values from the tree leaves) of the 
        tree ensemble at iteration ``i - 1``. 
    sample_weight : ndarray of shape (n_samples,) 
        The weight of each sample. 
    sample_mask : ndarray of shape (n_samples,) 
        The sample mask to be used. 
    learning_rate : float, default=0.1 
        Learning rate shrinks the contribution of each tree by 
         ``learning_rate``. 
    k : int, default=0 
        The index of the estimator being updated. 
    &quot;&quot;&quot;</span>
    <span class="s2"># compute leaf for each sample in ``X``.</span>
    <span class="s1">terminal_regions </span><span class="s4">= </span><span class="s1">tree</span><span class="s4">.</span><span class="s1">apply</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">loss</span><span class="s4">, </span><span class="s1">HalfSquaredError</span><span class="s4">):</span>
        <span class="s2"># mask all which are not in sample mask.</span>
        <span class="s1">masked_terminal_regions </span><span class="s4">= </span><span class="s1">terminal_regions</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">()</span>
        <span class="s1">masked_terminal_regions</span><span class="s4">[~</span><span class="s1">sample_mask</span><span class="s4">] = -</span><span class="s6">1</span>

        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">loss</span><span class="s4">, </span><span class="s1">HalfBinomialLoss</span><span class="s4">):</span>

            <span class="s3">def </span><span class="s1">compute_update</span><span class="s4">(</span><span class="s1">y_</span><span class="s4">, </span><span class="s1">indices</span><span class="s4">, </span><span class="s1">neg_gradient</span><span class="s4">, </span><span class="s1">raw_prediction</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
                <span class="s2"># Make a single Newton-Raphson step, see &quot;Additive Logistic Regression:</span>
                <span class="s2"># A Statistical View of Boosting&quot; FHT00 and note that we use a slightly</span>
                <span class="s2"># different version (factor 2) of &quot;F&quot; with proba=expit(raw_prediction).</span>
                <span class="s2"># Our node estimate is given by:</span>
                <span class="s2">#    sum(w * (y - prob)) / sum(w * prob * (1 - prob))</span>
                <span class="s2"># we take advantage that: y - prob = neg_gradient</span>
                <span class="s1">neg_g </span><span class="s4">= </span><span class="s1">neg_gradient</span><span class="s4">.</span><span class="s1">take</span><span class="s4">(</span><span class="s1">indices</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">0</span><span class="s4">)</span>
                <span class="s1">prob </span><span class="s4">= </span><span class="s1">y_ </span><span class="s4">- </span><span class="s1">neg_g</span>
                <span class="s2"># numerator = negative gradient = y - prob</span>
                <span class="s1">numerator </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">average</span><span class="s4">(</span><span class="s1">neg_g</span><span class="s4">, </span><span class="s1">weights</span><span class="s4">=</span><span class="s1">sw</span><span class="s4">)</span>
                <span class="s2"># denominator = hessian = prob * (1 - prob)</span>
                <span class="s1">denominator </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">average</span><span class="s4">(</span><span class="s1">prob </span><span class="s4">* (</span><span class="s6">1 </span><span class="s4">- </span><span class="s1">prob</span><span class="s4">), </span><span class="s1">weights</span><span class="s4">=</span><span class="s1">sw</span><span class="s4">)</span>
                <span class="s3">return </span><span class="s1">_safe_divide</span><span class="s4">(</span><span class="s1">numerator</span><span class="s4">, </span><span class="s1">denominator</span><span class="s4">)</span>

        <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">loss</span><span class="s4">, </span><span class="s1">HalfMultinomialLoss</span><span class="s4">):</span>

            <span class="s3">def </span><span class="s1">compute_update</span><span class="s4">(</span><span class="s1">y_</span><span class="s4">, </span><span class="s1">indices</span><span class="s4">, </span><span class="s1">neg_gradient</span><span class="s4">, </span><span class="s1">raw_prediction</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
                <span class="s2"># we take advantage that: y - prob = neg_gradient</span>
                <span class="s1">neg_g </span><span class="s4">= </span><span class="s1">neg_gradient</span><span class="s4">.</span><span class="s1">take</span><span class="s4">(</span><span class="s1">indices</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">0</span><span class="s4">)</span>
                <span class="s1">prob </span><span class="s4">= </span><span class="s1">y_ </span><span class="s4">- </span><span class="s1">neg_g</span>
                <span class="s1">K </span><span class="s4">= </span><span class="s1">loss</span><span class="s4">.</span><span class="s1">n_classes</span>
                <span class="s2"># numerator = negative gradient * (k - 1) / k</span>
                <span class="s2"># Note: The factor (k - 1)/k appears in the original papers &quot;Greedy</span>
                <span class="s2"># Function Approximation&quot; by Friedman and &quot;Additive Logistic</span>
                <span class="s2"># Regression&quot; by Friedman, Hastie, Tibshirani. This factor is, however,</span>
                <span class="s2"># wrong or at least arbitrary as it directly multiplies the</span>
                <span class="s2"># learning_rate. We keep it for backward compatibility.</span>
                <span class="s1">numerator </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">average</span><span class="s4">(</span><span class="s1">neg_g</span><span class="s4">, </span><span class="s1">weights</span><span class="s4">=</span><span class="s1">sw</span><span class="s4">)</span>
                <span class="s1">numerator </span><span class="s4">*= (</span><span class="s1">K </span><span class="s4">- </span><span class="s6">1</span><span class="s4">) / </span><span class="s1">K</span>
                <span class="s2"># denominator = (diagonal) hessian = prob * (1 - prob)</span>
                <span class="s1">denominator </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">average</span><span class="s4">(</span><span class="s1">prob </span><span class="s4">* (</span><span class="s6">1 </span><span class="s4">- </span><span class="s1">prob</span><span class="s4">), </span><span class="s1">weights</span><span class="s4">=</span><span class="s1">sw</span><span class="s4">)</span>
                <span class="s3">return </span><span class="s1">_safe_divide</span><span class="s4">(</span><span class="s1">numerator</span><span class="s4">, </span><span class="s1">denominator</span><span class="s4">)</span>

        <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">loss</span><span class="s4">, </span><span class="s1">ExponentialLoss</span><span class="s4">):</span>

            <span class="s3">def </span><span class="s1">compute_update</span><span class="s4">(</span><span class="s1">y_</span><span class="s4">, </span><span class="s1">indices</span><span class="s4">, </span><span class="s1">neg_gradient</span><span class="s4">, </span><span class="s1">raw_prediction</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
                <span class="s1">neg_g </span><span class="s4">= </span><span class="s1">neg_gradient</span><span class="s4">.</span><span class="s1">take</span><span class="s4">(</span><span class="s1">indices</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">0</span><span class="s4">)</span>
                <span class="s2"># numerator = negative gradient = y * exp(-raw) - (1-y) * exp(raw)</span>
                <span class="s1">numerator </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">average</span><span class="s4">(</span><span class="s1">neg_g</span><span class="s4">, </span><span class="s1">weights</span><span class="s4">=</span><span class="s1">sw</span><span class="s4">)</span>
                <span class="s2"># denominator = hessian = y * exp(-raw) + (1-y) * exp(raw)</span>
                <span class="s2"># if y=0: hessian = exp(raw) = -neg_g</span>
                <span class="s2">#    y=1: hessian = exp(-raw) = neg_g</span>
                <span class="s1">hessian </span><span class="s4">= </span><span class="s1">neg_g</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">()</span>
                <span class="s1">hessian</span><span class="s4">[</span><span class="s1">y_ </span><span class="s4">== </span><span class="s6">0</span><span class="s4">] *= -</span><span class="s6">1</span>
                <span class="s1">denominator </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">average</span><span class="s4">(</span><span class="s1">hessian</span><span class="s4">, </span><span class="s1">weights</span><span class="s4">=</span><span class="s1">sw</span><span class="s4">)</span>
                <span class="s3">return </span><span class="s1">_safe_divide</span><span class="s4">(</span><span class="s1">numerator</span><span class="s4">, </span><span class="s1">denominator</span><span class="s4">)</span>

        <span class="s3">else</span><span class="s4">:</span>

            <span class="s3">def </span><span class="s1">compute_update</span><span class="s4">(</span><span class="s1">y_</span><span class="s4">, </span><span class="s1">indices</span><span class="s4">, </span><span class="s1">neg_gradient</span><span class="s4">, </span><span class="s1">raw_prediction</span><span class="s4">, </span><span class="s1">k</span><span class="s4">):</span>
                <span class="s3">return </span><span class="s1">loss</span><span class="s4">.</span><span class="s1">fit_intercept_only</span><span class="s4">(</span>
                    <span class="s1">y_true</span><span class="s4">=</span><span class="s1">y_ </span><span class="s4">- </span><span class="s1">raw_prediction</span><span class="s4">[</span><span class="s1">indices</span><span class="s4">, </span><span class="s1">k</span><span class="s4">],</span>
                    <span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sw</span><span class="s4">,</span>
                <span class="s4">)</span>

        <span class="s2"># update each leaf (= perform line search)</span>
        <span class="s3">for </span><span class="s1">leaf </span><span class="s3">in </span><span class="s1">np</span><span class="s4">.</span><span class="s1">nonzero</span><span class="s4">(</span><span class="s1">tree</span><span class="s4">.</span><span class="s1">children_left </span><span class="s4">== </span><span class="s1">TREE_LEAF</span><span class="s4">)[</span><span class="s6">0</span><span class="s4">]:</span>
            <span class="s1">indices </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">nonzero</span><span class="s4">(</span><span class="s1">masked_terminal_regions </span><span class="s4">== </span><span class="s1">leaf</span><span class="s4">)[</span>
                <span class="s6">0</span>
            <span class="s4">]  </span><span class="s2"># of terminal regions</span>
            <span class="s1">y_ </span><span class="s4">= </span><span class="s1">y</span><span class="s4">.</span><span class="s1">take</span><span class="s4">(</span><span class="s1">indices</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">0</span><span class="s4">)</span>
            <span class="s1">sw </span><span class="s4">= </span><span class="s3">None if </span><span class="s1">sample_weight </span><span class="s3">is None else </span><span class="s1">sample_weight</span><span class="s4">[</span><span class="s1">indices</span><span class="s4">]</span>
            <span class="s1">update </span><span class="s4">= </span><span class="s1">compute_update</span><span class="s4">(</span><span class="s1">y_</span><span class="s4">, </span><span class="s1">indices</span><span class="s4">, </span><span class="s1">neg_gradient</span><span class="s4">, </span><span class="s1">raw_prediction</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>

            <span class="s2"># TODO: Multiply here by learning rate instead of everywhere else.</span>
            <span class="s1">tree</span><span class="s4">.</span><span class="s1">value</span><span class="s4">[</span><span class="s1">leaf</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s6">0</span><span class="s4">] = </span><span class="s1">update</span>

    <span class="s2"># update predictions (both in-bag and out-of-bag)</span>
    <span class="s1">raw_prediction</span><span class="s4">[:, </span><span class="s1">k</span><span class="s4">] += </span><span class="s1">learning_rate </span><span class="s4">* </span><span class="s1">tree</span><span class="s4">.</span><span class="s1">value</span><span class="s4">[:, </span><span class="s6">0</span><span class="s4">, </span><span class="s6">0</span><span class="s4">].</span><span class="s1">take</span><span class="s4">(</span>
        <span class="s1">terminal_regions</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">0</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">set_huber_delta</span><span class="s4">(</span><span class="s1">loss</span><span class="s4">, </span><span class="s1">y_true</span><span class="s4">, </span><span class="s1">raw_prediction</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Calculate and set self.closs.delta based on self.quantile.&quot;&quot;&quot;</span>
    <span class="s1">abserr </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">y_true </span><span class="s4">- </span><span class="s1">raw_prediction</span><span class="s4">.</span><span class="s1">squeeze</span><span class="s4">())</span>
    <span class="s2"># sample_weight is always a ndarray, never None.</span>
    <span class="s1">delta </span><span class="s4">= </span><span class="s1">_weighted_percentile</span><span class="s4">(</span><span class="s1">abserr</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s6">100 </span><span class="s4">* </span><span class="s1">loss</span><span class="s4">.</span><span class="s1">quantile</span><span class="s4">)</span>
    <span class="s1">loss</span><span class="s4">.</span><span class="s1">closs</span><span class="s4">.</span><span class="s1">delta </span><span class="s4">= </span><span class="s1">float</span><span class="s4">(</span><span class="s1">delta</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">VerboseReporter</span><span class="s4">:</span>
    <span class="s0">&quot;&quot;&quot;Reports verbose output to stdout. 
 
    Parameters 
    ---------- 
    verbose : int 
        Verbosity level. If ``verbose==1`` output is printed once in a while 
        (when iteration mod verbose_mod is zero).; if larger than 1 then output 
        is printed for each update. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">verbose </span><span class="s4">= </span><span class="s1">verbose</span>

    <span class="s3">def </span><span class="s1">init</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">est</span><span class="s4">, </span><span class="s1">begin_at_stage</span><span class="s4">=</span><span class="s6">0</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Initialize reporter 
 
        Parameters 
        ---------- 
        est : Estimator 
            The estimator 
 
        begin_at_stage : int, default=0 
            stage at which to begin reporting 
        &quot;&quot;&quot;</span>
        <span class="s2"># header fields and line format str</span>
        <span class="s1">header_fields </span><span class="s4">= [</span><span class="s5">&quot;Iter&quot;</span><span class="s4">, </span><span class="s5">&quot;Train Loss&quot;</span><span class="s4">]</span>
        <span class="s1">verbose_fmt </span><span class="s4">= [</span><span class="s5">&quot;{iter:&gt;10d}&quot;</span><span class="s4">, </span><span class="s5">&quot;{train_score:&gt;16.4f}&quot;</span><span class="s4">]</span>
        <span class="s2"># do oob?</span>
        <span class="s3">if </span><span class="s1">est</span><span class="s4">.</span><span class="s1">subsample </span><span class="s4">&lt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s1">header_fields</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">&quot;OOB Improve&quot;</span><span class="s4">)</span>
            <span class="s1">verbose_fmt</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">&quot;{oob_impr:&gt;16.4f}&quot;</span><span class="s4">)</span>
        <span class="s1">header_fields</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">&quot;Remaining Time&quot;</span><span class="s4">)</span>
        <span class="s1">verbose_fmt</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s5">&quot;{remaining_time:&gt;16s}&quot;</span><span class="s4">)</span>

        <span class="s2"># print the header line</span>
        <span class="s1">print</span><span class="s4">((</span><span class="s5">&quot;%10s &quot; </span><span class="s4">+ </span><span class="s5">&quot;%16s &quot; </span><span class="s4">* (</span><span class="s1">len</span><span class="s4">(</span><span class="s1">header_fields</span><span class="s4">) - </span><span class="s6">1</span><span class="s4">)) % </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">header_fields</span><span class="s4">))</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">verbose_fmt </span><span class="s4">= </span><span class="s5">&quot; &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">verbose_fmt</span><span class="s4">)</span>
        <span class="s2"># plot verbose info each time i % verbose_mod == 0</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">verbose_mod </span><span class="s4">= </span><span class="s6">1</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">start_time </span><span class="s4">= </span><span class="s1">time</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">begin_at_stage </span><span class="s4">= </span><span class="s1">begin_at_stage</span>

    <span class="s3">def </span><span class="s1">update</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">j</span><span class="s4">, </span><span class="s1">est</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Update reporter with new iteration. 
 
        Parameters 
        ---------- 
        j : int 
            The new iteration. 
        est : Estimator 
            The estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">do_oob </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">subsample </span><span class="s4">&lt; </span><span class="s6">1</span>
        <span class="s2"># we need to take into account if we fit additional estimators.</span>
        <span class="s1">i </span><span class="s4">= </span><span class="s1">j </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">begin_at_stage  </span><span class="s2"># iteration relative to the start iter</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s1">i </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">) % </span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose_mod </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">oob_impr </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">oob_improvement_</span><span class="s4">[</span><span class="s1">j</span><span class="s4">] </span><span class="s3">if </span><span class="s1">do_oob </span><span class="s3">else </span><span class="s6">0</span>
            <span class="s1">remaining_time </span><span class="s4">= (</span>
                <span class="s4">(</span><span class="s1">est</span><span class="s4">.</span><span class="s1">n_estimators </span><span class="s4">- (</span><span class="s1">j </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">)) * (</span><span class="s1">time</span><span class="s4">() - </span><span class="s1">self</span><span class="s4">.</span><span class="s1">start_time</span><span class="s4">) / </span><span class="s1">float</span><span class="s4">(</span><span class="s1">i </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s3">if </span><span class="s1">remaining_time </span><span class="s4">&gt; </span><span class="s6">60</span><span class="s4">:</span>
                <span class="s1">remaining_time </span><span class="s4">= </span><span class="s5">&quot;{0:.2f}m&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">remaining_time </span><span class="s4">/ </span><span class="s6">60.0</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">remaining_time </span><span class="s4">= </span><span class="s5">&quot;{0:.2f}s&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">remaining_time</span><span class="s4">)</span>
            <span class="s1">print</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">verbose_fmt</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span>
                    <span class="s1">iter</span><span class="s4">=</span><span class="s1">j </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">,</span>
                    <span class="s1">train_score</span><span class="s4">=</span><span class="s1">est</span><span class="s4">.</span><span class="s1">train_score_</span><span class="s4">[</span><span class="s1">j</span><span class="s4">],</span>
                    <span class="s1">oob_impr</span><span class="s4">=</span><span class="s1">oob_impr</span><span class="s4">,</span>
                    <span class="s1">remaining_time</span><span class="s4">=</span><span class="s1">remaining_time</span><span class="s4">,</span>
                <span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose </span><span class="s4">== </span><span class="s6">1 </span><span class="s3">and </span><span class="s4">((</span><span class="s1">i </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">) // (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose_mod </span><span class="s4">* </span><span class="s6">10</span><span class="s4">) &gt; </span><span class="s6">0</span><span class="s4">):</span>
                <span class="s2"># adjust verbose frequency (powers of 10)</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">verbose_mod </span><span class="s4">*= </span><span class="s6">10</span>


<span class="s3">class </span><span class="s1">BaseGradientBoosting</span><span class="s4">(</span><span class="s1">BaseEnsemble</span><span class="s4">, </span><span class="s1">metaclass</span><span class="s4">=</span><span class="s1">ABCMeta</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Abstract base class for Gradient Boosting.&quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
        <span class="s4">**</span><span class="s1">DecisionTreeRegressor</span><span class="s4">.</span><span class="s1">_parameter_constraints</span><span class="s4">,</span>
        <span class="s5">&quot;learning_rate&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;n_estimators&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;criterion&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;friedman_mse&quot;</span><span class="s4">, </span><span class="s5">&quot;squared_error&quot;</span><span class="s4">})],</span>
        <span class="s5">&quot;subsample&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">, </span><span class="s6">1.0</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;right&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;verbose&quot;</span><span class="s4">: [</span><span class="s5">&quot;verbose&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;warm_start&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;validation_fraction&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">, </span><span class="s6">1.0</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;neither&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;n_iter_no_change&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">), </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;tol&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
    <span class="s4">}</span>
    <span class="s1">_parameter_constraints</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;splitter&quot;</span><span class="s4">)</span>
    <span class="s1">_parameter_constraints</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;monotonic_cst&quot;</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">abstractmethod</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">loss</span><span class="s4">,</span>
        <span class="s1">learning_rate</span><span class="s4">,</span>
        <span class="s1">n_estimators</span><span class="s4">,</span>
        <span class="s1">criterion</span><span class="s4">,</span>
        <span class="s1">min_samples_split</span><span class="s4">,</span>
        <span class="s1">min_samples_leaf</span><span class="s4">,</span>
        <span class="s1">min_weight_fraction_leaf</span><span class="s4">,</span>
        <span class="s1">max_depth</span><span class="s4">,</span>
        <span class="s1">min_impurity_decrease</span><span class="s4">,</span>
        <span class="s1">init</span><span class="s4">,</span>
        <span class="s1">subsample</span><span class="s4">,</span>
        <span class="s1">max_features</span><span class="s4">,</span>
        <span class="s1">ccp_alpha</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">,</span>
        <span class="s1">alpha</span><span class="s4">=</span><span class="s6">0.9</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
        <span class="s1">max_leaf_nodes</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">warm_start</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">validation_fraction</span><span class="s4">=</span><span class="s6">0.1</span><span class="s4">,</span>
        <span class="s1">n_iter_no_change</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">tol</span><span class="s4">=</span><span class="s6">1e-4</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_estimators </span><span class="s4">= </span><span class="s1">n_estimators</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">learning_rate </span><span class="s4">= </span><span class="s1">learning_rate</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">loss </span><span class="s4">= </span><span class="s1">loss</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">criterion </span><span class="s4">= </span><span class="s1">criterion</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">min_samples_split </span><span class="s4">= </span><span class="s1">min_samples_split</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">min_samples_leaf </span><span class="s4">= </span><span class="s1">min_samples_leaf</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">min_weight_fraction_leaf </span><span class="s4">= </span><span class="s1">min_weight_fraction_leaf</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">subsample </span><span class="s4">= </span><span class="s1">subsample</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">max_features </span><span class="s4">= </span><span class="s1">max_features</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">max_depth </span><span class="s4">= </span><span class="s1">max_depth</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">min_impurity_decrease </span><span class="s4">= </span><span class="s1">min_impurity_decrease</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">ccp_alpha </span><span class="s4">= </span><span class="s1">ccp_alpha</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">init </span><span class="s4">= </span><span class="s1">init</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">random_state </span><span class="s4">= </span><span class="s1">random_state</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">alpha </span><span class="s4">= </span><span class="s1">alpha</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">verbose </span><span class="s4">= </span><span class="s1">verbose</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">max_leaf_nodes </span><span class="s4">= </span><span class="s1">max_leaf_nodes</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">warm_start </span><span class="s4">= </span><span class="s1">warm_start</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">validation_fraction </span><span class="s4">= </span><span class="s1">validation_fraction</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_iter_no_change </span><span class="s4">= </span><span class="s1">n_iter_no_change</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">tol </span><span class="s4">= </span><span class="s1">tol</span>

    <span class="s4">@</span><span class="s1">abstractmethod</span>
    <span class="s3">def </span><span class="s1">_encode_y</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Called by fit to validate and encode y.&quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">abstractmethod</span>
    <span class="s3">def </span><span class="s1">_get_loss</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Get loss object from sklearn._loss.loss.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">_fit_stage</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">i</span><span class="s4">,</span>
        <span class="s1">X</span><span class="s4">,</span>
        <span class="s1">y</span><span class="s4">,</span>
        <span class="s1">raw_predictions</span><span class="s4">,</span>
        <span class="s1">sample_weight</span><span class="s4">,</span>
        <span class="s1">sample_mask</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">,</span>
        <span class="s1">X_csc</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">X_csr</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Fit another stage of ``n_trees_per_iteration_`` trees.&quot;&quot;&quot;</span>
        <span class="s1">original_y </span><span class="s4">= </span><span class="s1">y</span>

        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loss</span><span class="s4">, </span><span class="s1">HuberLoss</span><span class="s4">):</span>
            <span class="s1">set_huber_delta</span><span class="s4">(</span>
                <span class="s1">loss</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loss</span><span class="s4">,</span>
                <span class="s1">y_true</span><span class="s4">=</span><span class="s1">y</span><span class="s4">,</span>
                <span class="s1">raw_prediction</span><span class="s4">=</span><span class="s1">raw_predictions</span><span class="s4">,</span>
                <span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s2"># TODO: Without oob, i.e. with self.subsample = 1.0, we could call</span>
        <span class="s2"># self._loss.loss_gradient and use it to set train_score_.</span>
        <span class="s2"># But note that train_score_[i] is the score AFTER fitting the i-th tree.</span>
        <span class="s2"># Note: We need the negative gradient!</span>
        <span class="s1">neg_gradient </span><span class="s4">= -</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loss</span><span class="s4">.</span><span class="s1">gradient</span><span class="s4">(</span>
            <span class="s1">y_true</span><span class="s4">=</span><span class="s1">y</span><span class="s4">,</span>
            <span class="s1">raw_prediction</span><span class="s4">=</span><span class="s1">raw_predictions</span><span class="s4">,</span>
            <span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,  </span><span class="s2"># We pass sample_weights to the tree directly.</span>
        <span class="s4">)</span>
        <span class="s2"># 2-d views of shape (n_samples, n_trees_per_iteration_) or (n_samples, 1)</span>
        <span class="s2"># on neg_gradient to simplify the loop over n_trees_per_iteration_.</span>
        <span class="s3">if </span><span class="s1">neg_gradient</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">== </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s1">neg_g_view </span><span class="s4">= </span><span class="s1">neg_gradient</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">((-</span><span class="s6">1</span><span class="s4">, </span><span class="s6">1</span><span class="s4">))</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">neg_g_view </span><span class="s4">= </span><span class="s1">neg_gradient</span>

        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_trees_per_iteration_</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loss</span><span class="s4">.</span><span class="s1">is_multiclass</span><span class="s4">:</span>
                <span class="s1">y </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span><span class="s1">original_y </span><span class="s4">== </span><span class="s1">k</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>

            <span class="s2"># induce regression tree on the negative gradient</span>
            <span class="s1">tree </span><span class="s4">= </span><span class="s1">DecisionTreeRegressor</span><span class="s4">(</span>
                <span class="s1">criterion</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">criterion</span><span class="s4">,</span>
                <span class="s1">splitter</span><span class="s4">=</span><span class="s5">&quot;best&quot;</span><span class="s4">,</span>
                <span class="s1">max_depth</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">max_depth</span><span class="s4">,</span>
                <span class="s1">min_samples_split</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">min_samples_split</span><span class="s4">,</span>
                <span class="s1">min_samples_leaf</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">min_samples_leaf</span><span class="s4">,</span>
                <span class="s1">min_weight_fraction_leaf</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">min_weight_fraction_leaf</span><span class="s4">,</span>
                <span class="s1">min_impurity_decrease</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">min_impurity_decrease</span><span class="s4">,</span>
                <span class="s1">max_features</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">max_features</span><span class="s4">,</span>
                <span class="s1">max_leaf_nodes</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">max_leaf_nodes</span><span class="s4">,</span>
                <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
                <span class="s1">ccp_alpha</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">ccp_alpha</span><span class="s4">,</span>
            <span class="s4">)</span>

            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">subsample </span><span class="s4">&lt; </span><span class="s6">1.0</span><span class="s4">:</span>
                <span class="s2"># no inplace multiplication!</span>
                <span class="s1">sample_weight </span><span class="s4">= </span><span class="s1">sample_weight </span><span class="s4">* </span><span class="s1">sample_mask</span><span class="s4">.</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>

            <span class="s1">X </span><span class="s4">= </span><span class="s1">X_csc </span><span class="s3">if </span><span class="s1">X_csc </span><span class="s3">is not None else </span><span class="s1">X</span>
            <span class="s1">tree</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">, </span><span class="s1">neg_g_view</span><span class="s4">[:, </span><span class="s1">k</span><span class="s4">], </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s1">check_input</span><span class="s4">=</span><span class="s3">False</span>
            <span class="s4">)</span>

            <span class="s2"># update tree leaves</span>
            <span class="s1">X_for_tree_update </span><span class="s4">= </span><span class="s1">X_csr </span><span class="s3">if </span><span class="s1">X_csr </span><span class="s3">is not None else </span><span class="s1">X</span>
            <span class="s1">_update_terminal_regions</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_loss</span><span class="s4">,</span>
                <span class="s1">tree</span><span class="s4">.</span><span class="s1">tree_</span><span class="s4">,</span>
                <span class="s1">X_for_tree_update</span><span class="s4">,</span>
                <span class="s1">y</span><span class="s4">,</span>
                <span class="s1">neg_g_view</span><span class="s4">[:, </span><span class="s1">k</span><span class="s4">],</span>
                <span class="s1">raw_predictions</span><span class="s4">,</span>
                <span class="s1">sample_weight</span><span class="s4">,</span>
                <span class="s1">sample_mask</span><span class="s4">,</span>
                <span class="s1">learning_rate</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">learning_rate</span><span class="s4">,</span>
                <span class="s1">k</span><span class="s4">=</span><span class="s1">k</span><span class="s4">,</span>
            <span class="s4">)</span>

            <span class="s2"># add tree to ensemble</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, </span><span class="s1">k</span><span class="s4">] = </span><span class="s1">tree</span>

        <span class="s3">return </span><span class="s1">raw_predictions</span>

    <span class="s3">def </span><span class="s1">_set_max_features</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Set self.max_features_.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">max_features</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">max_features </span><span class="s4">== </span><span class="s5">&quot;auto&quot;</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">is_classifier</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
                    <span class="s1">max_features </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">int</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_features_in_</span><span class="s4">)))</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">max_features </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_features_in_</span>
            <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">max_features </span><span class="s4">== </span><span class="s5">&quot;sqrt&quot;</span><span class="s4">:</span>
                <span class="s1">max_features </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">int</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_features_in_</span><span class="s4">)))</span>
            <span class="s3">else</span><span class="s4">:  </span><span class="s2"># self.max_features == &quot;log2&quot;</span>
                <span class="s1">max_features </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">int</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">log2</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_features_in_</span><span class="s4">)))</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">max_features </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">max_features </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_features_in_</span>
        <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">max_features</span><span class="s4">, </span><span class="s1">Integral</span><span class="s4">):</span>
            <span class="s1">max_features </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">max_features</span>
        <span class="s3">else</span><span class="s4">:  </span><span class="s2"># float</span>
            <span class="s1">max_features </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">int</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">max_features </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_features_in_</span><span class="s4">))</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">max_features_ </span><span class="s4">= </span><span class="s1">max_features</span>

    <span class="s3">def </span><span class="s1">_init_state</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Initialize model state and allocate model state data structures.&quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">init_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">init</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">init_ </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">is_classifier</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">init_ </span><span class="s4">= </span><span class="s1">DummyClassifier</span><span class="s4">(</span><span class="s1">strategy</span><span class="s4">=</span><span class="s5">&quot;prior&quot;</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loss</span><span class="s4">, (</span><span class="s1">AbsoluteError</span><span class="s4">, </span><span class="s1">HuberLoss</span><span class="s4">)):</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">init_ </span><span class="s4">= </span><span class="s1">DummyRegressor</span><span class="s4">(</span><span class="s1">strategy</span><span class="s4">=</span><span class="s5">&quot;quantile&quot;</span><span class="s4">, </span><span class="s1">quantile</span><span class="s4">=</span><span class="s6">0.5</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loss</span><span class="s4">, </span><span class="s1">PinballLoss</span><span class="s4">):</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">init_ </span><span class="s4">= </span><span class="s1">DummyRegressor</span><span class="s4">(</span><span class="s1">strategy</span><span class="s4">=</span><span class="s5">&quot;quantile&quot;</span><span class="s4">, </span><span class="s1">quantile</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">alpha</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">init_ </span><span class="s4">= </span><span class="s1">DummyRegressor</span><span class="s4">(</span><span class="s1">strategy</span><span class="s4">=</span><span class="s5">&quot;mean&quot;</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">(</span>
            <span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_estimators</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_trees_per_iteration_</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">object</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">train_score_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_estimators</span><span class="s4">,), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>
        <span class="s2"># do oob?</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">subsample </span><span class="s4">&lt; </span><span class="s6">1.0</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">oob_improvement_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_estimators</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">oob_scores_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_estimators</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">oob_score_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">nan</span>

    <span class="s3">def </span><span class="s1">_clear_state</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Clear the state of the gradient boosting model.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;estimators_&quot;</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">((</span><span class="s6">0</span><span class="s4">, </span><span class="s6">0</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">object</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;train_score_&quot;</span><span class="s4">):</span>
            <span class="s3">del </span><span class="s1">self</span><span class="s4">.</span><span class="s1">train_score_</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;oob_improvement_&quot;</span><span class="s4">):</span>
            <span class="s3">del </span><span class="s1">self</span><span class="s4">.</span><span class="s1">oob_improvement_</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;oob_scores_&quot;</span><span class="s4">):</span>
            <span class="s3">del </span><span class="s1">self</span><span class="s4">.</span><span class="s1">oob_scores_</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;oob_score_&quot;</span><span class="s4">):</span>
            <span class="s3">del </span><span class="s1">self</span><span class="s4">.</span><span class="s1">oob_score_</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;init_&quot;</span><span class="s4">):</span>
            <span class="s3">del </span><span class="s1">self</span><span class="s4">.</span><span class="s1">init_</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;_rng&quot;</span><span class="s4">):</span>
            <span class="s3">del </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_rng</span>

    <span class="s3">def </span><span class="s1">_resize_state</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Add additional ``n_estimators`` entries to all attributes.&quot;&quot;&quot;</span>
        <span class="s2"># self.n_estimators is the number of additional est to fit</span>
        <span class="s1">total_n_estimators </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_estimators</span>
        <span class="s3">if </span><span class="s1">total_n_estimators </span><span class="s4">&lt; </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;resize with smaller n_estimators %d &lt; %d&quot;</span>
                <span class="s4">% (</span><span class="s1">total_n_estimators</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])</span>
            <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">resize</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">, (</span><span class="s1">total_n_estimators</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_trees_per_iteration_</span><span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">train_score_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">resize</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">train_score_</span><span class="s4">, </span><span class="s1">total_n_estimators</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">subsample </span><span class="s4">&lt; </span><span class="s6">1 </span><span class="s3">or </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;oob_improvement_&quot;</span><span class="s4">):</span>
            <span class="s2"># if do oob resize arrays or create new if not available</span>
            <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;oob_improvement_&quot;</span><span class="s4">):</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">oob_improvement_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">resize</span><span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">oob_improvement_</span><span class="s4">, </span><span class="s1">total_n_estimators</span>
                <span class="s4">)</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">oob_scores_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">resize</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">oob_scores_</span><span class="s4">, </span><span class="s1">total_n_estimators</span><span class="s4">)</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">oob_score_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">nan</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">oob_improvement_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span>
                    <span class="s4">(</span><span class="s1">total_n_estimators</span><span class="s4">,), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span>
                <span class="s4">)</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">oob_scores_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">total_n_estimators</span><span class="s4">,), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">oob_score_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">nan</span>

    <span class="s3">def </span><span class="s1">_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">len</span><span class="s4">(</span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;estimators_&quot;</span><span class="s4">, [])) &gt; </span><span class="s6">0</span>

    <span class="s3">def </span><span class="s1">_check_initialized</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Check that the estimator is initialized, raising an error if not.&quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_fit_context</span><span class="s4">(</span>
        <span class="s2"># GradientBoosting*.init is not validated yet</span>
        <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">False</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">monitor</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Fit the gradient boosting model. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, it will be converted to 
            ``dtype=np.float32`` and if a sparse matrix is provided 
            to a sparse ``csr_matrix``. 
 
        y : array-like of shape (n_samples,) 
            Target values (strings or integers in classification, real numbers 
            in regression) 
            For classification, labels must correspond to classes. 
 
        sample_weight : array-like of shape (n_samples,), default=None 
            Sample weights. If None, then samples are equally weighted. Splits 
            that would create child nodes with net zero or negative weight are 
            ignored while searching for a split in each node. In the case of 
            classification, splits are also ignored if they would result in any 
            single class carrying a negative weight in either child node. 
 
        monitor : callable, default=None 
            The monitor is called after each iteration with the current 
            iteration, a reference to the estimator and the local variables of 
            ``_fit_stages`` as keyword arguments ``callable(i, self, 
            locals())``. If the callable returns ``True`` the fitting procedure 
            is stopped. The monitor can be used for various things such as 
            computing held-out estimates, early stopping, model introspect, and 
            snapshotting. 
 
        Returns 
        ------- 
        self : object 
            Fitted estimator. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">warm_start</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_clear_state</span><span class="s4">()</span>

        <span class="s2"># Check input</span>
        <span class="s2"># Since check_array converts both X and y to the same dtype, but the</span>
        <span class="s2"># trees use different types for X and y, checking them separately.</span>

        <span class="s1">X</span><span class="s4">, </span><span class="s1">y </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">accept_sparse</span><span class="s4">=[</span><span class="s5">&quot;csr&quot;</span><span class="s4">, </span><span class="s5">&quot;csc&quot;</span><span class="s4">, </span><span class="s5">&quot;coo&quot;</span><span class="s4">], </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">DTYPE</span><span class="s4">, </span><span class="s1">multi_output</span><span class="s4">=</span><span class="s3">True</span>
        <span class="s4">)</span>
        <span class="s1">sample_weight_is_none </span><span class="s4">= </span><span class="s1">sample_weight </span><span class="s3">is None</span>
        <span class="s1">sample_weight </span><span class="s4">= </span><span class="s1">_check_sample_weight</span><span class="s4">(</span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s1">X</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">sample_weight_is_none</span><span class="s4">:</span>
            <span class="s1">y </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_encode_y</span><span class="s4">(</span><span class="s1">y</span><span class="s4">=</span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">y </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_encode_y</span><span class="s4">(</span><span class="s1">y</span><span class="s4">=</span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">)</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">column_or_1d</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">warn</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)  </span><span class="s2"># TODO: Is this still required?</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_set_max_features</span><span class="s4">()</span>

        <span class="s2"># self.loss is guaranteed to be a string</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_loss </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_loss</span><span class="s4">(</span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_iter_no_change </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">stratify </span><span class="s4">= </span><span class="s1">y </span><span class="s3">if </span><span class="s1">is_classifier</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s3">else None</span>
            <span class="s4">(</span>
                <span class="s1">X_train</span><span class="s4">,</span>
                <span class="s1">X_val</span><span class="s4">,</span>
                <span class="s1">y_train</span><span class="s4">,</span>
                <span class="s1">y_val</span><span class="s4">,</span>
                <span class="s1">sample_weight_train</span><span class="s4">,</span>
                <span class="s1">sample_weight_val</span><span class="s4">,</span>
            <span class="s4">) = </span><span class="s1">train_test_split</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">,</span>
                <span class="s1">y</span><span class="s4">,</span>
                <span class="s1">sample_weight</span><span class="s4">,</span>
                <span class="s1">random_state</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">random_state</span><span class="s4">,</span>
                <span class="s1">test_size</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">validation_fraction</span><span class="s4">,</span>
                <span class="s1">stratify</span><span class="s4">=</span><span class="s1">stratify</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s3">if </span><span class="s1">is_classifier</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
                <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_classes_ </span><span class="s4">!= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">unique</span><span class="s4">(</span><span class="s1">y_train</span><span class="s4">).</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
                    <span class="s2"># We choose to error here. The problem is that the init</span>
                    <span class="s2"># estimator would be trained on y, which has some missing</span>
                    <span class="s2"># classes now, so its predictions would not have the</span>
                    <span class="s2"># correct shape.</span>
                    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                        <span class="s5">&quot;The training data after the early stopping split &quot;</span>
                        <span class="s5">&quot;is missing some classes. Try using another random &quot;</span>
                        <span class="s5">&quot;seed.&quot;</span>
                    <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">X_train</span><span class="s4">, </span><span class="s1">y_train</span><span class="s4">, </span><span class="s1">sample_weight_train </span><span class="s4">= </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span>
            <span class="s1">X_val </span><span class="s4">= </span><span class="s1">y_val </span><span class="s4">= </span><span class="s1">sample_weight_val </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s1">n_samples </span><span class="s4">= </span><span class="s1">X_train</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

        <span class="s2"># First time calling fit.</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_fitted</span><span class="s4">():</span>
            <span class="s2"># init state</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_init_state</span><span class="s4">()</span>

            <span class="s2"># fit initial model and initialize raw predictions</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">init_ </span><span class="s4">== </span><span class="s5">&quot;zero&quot;</span><span class="s4">:</span>
                <span class="s1">raw_predictions </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span>
                    <span class="s1">shape</span><span class="s4">=(</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_trees_per_iteration_</span><span class="s4">),</span>
                    <span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">,</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s2"># XXX clean this once we have a support_sample_weight tag</span>
                <span class="s3">if </span><span class="s1">sample_weight_is_none</span><span class="s4">:</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">init_</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X_train</span><span class="s4">, </span><span class="s1">y_train</span><span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">msg </span><span class="s4">= (</span>
                        <span class="s5">&quot;The initial estimator {} does not support sample &quot;</span>
                        <span class="s5">&quot;weights.&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">init_</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">)</span>
                    <span class="s4">)</span>
                    <span class="s3">try</span><span class="s4">:</span>
                        <span class="s1">self</span><span class="s4">.</span><span class="s1">init_</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span>
                            <span class="s1">X_train</span><span class="s4">, </span><span class="s1">y_train</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight_train</span>
                        <span class="s4">)</span>
                    <span class="s3">except </span><span class="s1">TypeError </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
                        <span class="s3">if </span><span class="s5">&quot;unexpected keyword argument 'sample_weight'&quot; </span><span class="s3">in </span><span class="s1">str</span><span class="s4">(</span><span class="s1">e</span><span class="s4">):</span>
                            <span class="s2"># regular estimator without SW support</span>
                            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s1">msg</span><span class="s4">) </span><span class="s3">from </span><span class="s1">e</span>
                        <span class="s3">else</span><span class="s4">:  </span><span class="s2"># regular estimator whose input checking failed</span>
                            <span class="s3">raise</span>
                    <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
                        <span class="s3">if </span><span class="s4">(</span>
                            <span class="s5">&quot;pass parameters to specific steps of &quot;</span>
                            <span class="s5">&quot;your pipeline using the &quot;</span>
                            <span class="s5">&quot;stepname__parameter&quot; </span><span class="s3">in </span><span class="s1">str</span><span class="s4">(</span><span class="s1">e</span><span class="s4">)</span>
                        <span class="s4">):  </span><span class="s2"># pipeline</span>
                            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s1">msg</span><span class="s4">) </span><span class="s3">from </span><span class="s1">e</span>
                        <span class="s3">else</span><span class="s4">:  </span><span class="s2"># regular estimator whose input checking failed</span>
                            <span class="s3">raise</span>

                <span class="s1">raw_predictions </span><span class="s4">= </span><span class="s1">_init_raw_predictions</span><span class="s4">(</span>
                    <span class="s1">X_train</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">init_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loss</span><span class="s4">, </span><span class="s1">is_classifier</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
                <span class="s4">)</span>

            <span class="s1">begin_at_stage </span><span class="s4">= </span><span class="s6">0</span>

            <span class="s2"># The rng state must be preserved if warm_start is True</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_rng </span><span class="s4">= </span><span class="s1">check_random_state</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">random_state</span><span class="s4">)</span>

        <span class="s2"># warm start: this is not the first time fit was called</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># add more estimators to fitted model</span>
            <span class="s2"># invariant: warm_start = True</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_estimators </span><span class="s4">&lt; </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                    <span class="s5">&quot;n_estimators=%d must be larger or equal to &quot;</span>
                    <span class="s5">&quot;estimators_.shape[0]=%d when &quot;</span>
                    <span class="s5">&quot;warm_start==True&quot; </span><span class="s4">% (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_estimators</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])</span>
                <span class="s4">)</span>
            <span class="s1">begin_at_stage </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
            <span class="s2"># The requirements of _raw_predict</span>
            <span class="s2"># are more constrained than fit. It accepts only CSR</span>
            <span class="s2"># matrices. Finite values have already been checked in _validate_data.</span>
            <span class="s1">X_train </span><span class="s4">= </span><span class="s1">check_array</span><span class="s4">(</span>
                <span class="s1">X_train</span><span class="s4">,</span>
                <span class="s1">dtype</span><span class="s4">=</span><span class="s1">DTYPE</span><span class="s4">,</span>
                <span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">,</span>
                <span class="s1">accept_sparse</span><span class="s4">=</span><span class="s5">&quot;csr&quot;</span><span class="s4">,</span>
                <span class="s1">force_all_finite</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s1">raw_predictions </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_predict</span><span class="s4">(</span><span class="s1">X_train</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_resize_state</span><span class="s4">()</span>

        <span class="s2"># fit the boosting stages</span>
        <span class="s1">n_stages </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fit_stages</span><span class="s4">(</span>
            <span class="s1">X_train</span><span class="s4">,</span>
            <span class="s1">y_train</span><span class="s4">,</span>
            <span class="s1">raw_predictions</span><span class="s4">,</span>
            <span class="s1">sample_weight_train</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_rng</span><span class="s4">,</span>
            <span class="s1">X_val</span><span class="s4">,</span>
            <span class="s1">y_val</span><span class="s4">,</span>
            <span class="s1">sample_weight_val</span><span class="s4">,</span>
            <span class="s1">begin_at_stage</span><span class="s4">,</span>
            <span class="s1">monitor</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s2"># change shape of arrays after fit (early-stopping or additional ests)</span>
        <span class="s3">if </span><span class="s1">n_stages </span><span class="s4">!= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">[:</span><span class="s1">n_stages</span><span class="s4">]</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">train_score_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">train_score_</span><span class="s4">[:</span><span class="s1">n_stages</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;oob_improvement_&quot;</span><span class="s4">):</span>
                <span class="s2"># OOB scores were computed</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">oob_improvement_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">oob_improvement_</span><span class="s4">[:</span><span class="s1">n_stages</span><span class="s4">]</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">oob_scores_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">oob_scores_</span><span class="s4">[:</span><span class="s1">n_stages</span><span class="s4">]</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">oob_score_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">oob_scores_</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_estimators_ </span><span class="s4">= </span><span class="s1">n_stages</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_fit_stages</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">X</span><span class="s4">,</span>
        <span class="s1">y</span><span class="s4">,</span>
        <span class="s1">raw_predictions</span><span class="s4">,</span>
        <span class="s1">sample_weight</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">,</span>
        <span class="s1">X_val</span><span class="s4">,</span>
        <span class="s1">y_val</span><span class="s4">,</span>
        <span class="s1">sample_weight_val</span><span class="s4">,</span>
        <span class="s1">begin_at_stage</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
        <span class="s1">monitor</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Iteratively fits the stages. 
 
        For each stage it computes the progress (OOB, train score) 
        and delegates to ``_fit_stage``. 
        Returns the number of stages fit; might differ from ``n_estimators`` 
        due to early stopping. 
        &quot;&quot;&quot;</span>
        <span class="s1">n_samples </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s1">do_oob </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">subsample </span><span class="s4">&lt; </span><span class="s6">1.0</span>
        <span class="s1">sample_mask </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">((</span><span class="s1">n_samples</span><span class="s4">,), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">bool</span><span class="s4">)</span>
        <span class="s1">n_inbag </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">int</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">subsample </span><span class="s4">* </span><span class="s1">n_samples</span><span class="s4">))</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose</span><span class="s4">:</span>
            <span class="s1">verbose_reporter </span><span class="s4">= </span><span class="s1">VerboseReporter</span><span class="s4">(</span><span class="s1">verbose</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose</span><span class="s4">)</span>
            <span class="s1">verbose_reporter</span><span class="s4">.</span><span class="s1">init</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">begin_at_stage</span><span class="s4">)</span>

        <span class="s1">X_csc </span><span class="s4">= </span><span class="s1">csc_matrix</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">else None</span>
        <span class="s1">X_csr </span><span class="s4">= </span><span class="s1">csr_matrix</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">else None</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_iter_no_change </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">loss_history </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">full</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_iter_no_change</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span><span class="s4">)</span>
            <span class="s2"># We create a generator to get the predictions for X_val after</span>
            <span class="s2"># the addition of each successive stage</span>
            <span class="s1">y_val_pred_iter </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_staged_raw_predict</span><span class="s4">(</span><span class="s1">X_val</span><span class="s4">, </span><span class="s1">check_input</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

        <span class="s2"># Older versions of GBT had its own loss functions. With the new common</span>
        <span class="s2"># private loss function submodule _loss, we often are a factor of 2</span>
        <span class="s2"># away from the old version. Here we keep backward compatibility for</span>
        <span class="s2"># oob_scores_ and oob_improvement_, even if the old way is quite</span>
        <span class="s2"># inconsistent (sometimes the gradient is half the gradient, sometimes</span>
        <span class="s2"># not).</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_loss</span><span class="s4">,</span>
            <span class="s4">(</span>
                <span class="s1">HalfSquaredError</span><span class="s4">,</span>
                <span class="s1">HalfBinomialLoss</span><span class="s4">,</span>
            <span class="s4">),</span>
        <span class="s4">):</span>
            <span class="s1">factor </span><span class="s4">= </span><span class="s6">2</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">factor </span><span class="s4">= </span><span class="s6">1</span>

        <span class="s2"># perform boosting iterations</span>
        <span class="s1">i </span><span class="s4">= </span><span class="s1">begin_at_stage</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">begin_at_stage</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_estimators</span><span class="s4">):</span>
            <span class="s2"># subsampling</span>
            <span class="s3">if </span><span class="s1">do_oob</span><span class="s4">:</span>
                <span class="s1">sample_mask </span><span class="s4">= </span><span class="s1">_random_sample_mask</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_inbag</span><span class="s4">, </span><span class="s1">random_state</span><span class="s4">)</span>
                <span class="s1">y_oob_masked </span><span class="s4">= </span><span class="s1">y</span><span class="s4">[~</span><span class="s1">sample_mask</span><span class="s4">]</span>
                <span class="s1">sample_weight_oob_masked </span><span class="s4">= </span><span class="s1">sample_weight</span><span class="s4">[~</span><span class="s1">sample_mask</span><span class="s4">]</span>
                <span class="s3">if </span><span class="s1">i </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:  </span><span class="s2"># store the initial loss to compute the OOB score</span>
                    <span class="s1">initial_loss </span><span class="s4">= </span><span class="s1">factor </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loss</span><span class="s4">(</span>
                        <span class="s1">y_true</span><span class="s4">=</span><span class="s1">y_oob_masked</span><span class="s4">,</span>
                        <span class="s1">raw_prediction</span><span class="s4">=</span><span class="s1">raw_predictions</span><span class="s4">[~</span><span class="s1">sample_mask</span><span class="s4">],</span>
                        <span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight_oob_masked</span><span class="s4">,</span>
                    <span class="s4">)</span>

            <span class="s2"># fit next stage of trees</span>
            <span class="s1">raw_predictions </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fit_stage</span><span class="s4">(</span>
                <span class="s1">i</span><span class="s4">,</span>
                <span class="s1">X</span><span class="s4">,</span>
                <span class="s1">y</span><span class="s4">,</span>
                <span class="s1">raw_predictions</span><span class="s4">,</span>
                <span class="s1">sample_weight</span><span class="s4">,</span>
                <span class="s1">sample_mask</span><span class="s4">,</span>
                <span class="s1">random_state</span><span class="s4">,</span>
                <span class="s1">X_csc</span><span class="s4">=</span><span class="s1">X_csc</span><span class="s4">,</span>
                <span class="s1">X_csr</span><span class="s4">=</span><span class="s1">X_csr</span><span class="s4">,</span>
            <span class="s4">)</span>

            <span class="s2"># track loss</span>
            <span class="s3">if </span><span class="s1">do_oob</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">train_score_</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s1">factor </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loss</span><span class="s4">(</span>
                    <span class="s1">y_true</span><span class="s4">=</span><span class="s1">y</span><span class="s4">[</span><span class="s1">sample_mask</span><span class="s4">],</span>
                    <span class="s1">raw_prediction</span><span class="s4">=</span><span class="s1">raw_predictions</span><span class="s4">[</span><span class="s1">sample_mask</span><span class="s4">],</span>
                    <span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">[</span><span class="s1">sample_mask</span><span class="s4">],</span>
                <span class="s4">)</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">oob_scores_</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s1">factor </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loss</span><span class="s4">(</span>
                    <span class="s1">y_true</span><span class="s4">=</span><span class="s1">y_oob_masked</span><span class="s4">,</span>
                    <span class="s1">raw_prediction</span><span class="s4">=</span><span class="s1">raw_predictions</span><span class="s4">[~</span><span class="s1">sample_mask</span><span class="s4">],</span>
                    <span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight_oob_masked</span><span class="s4">,</span>
                <span class="s4">)</span>
                <span class="s1">previous_loss </span><span class="s4">= </span><span class="s1">initial_loss </span><span class="s3">if </span><span class="s1">i </span><span class="s4">== </span><span class="s6">0 </span><span class="s3">else </span><span class="s1">self</span><span class="s4">.</span><span class="s1">oob_scores_</span><span class="s4">[</span><span class="s1">i </span><span class="s4">- </span><span class="s6">1</span><span class="s4">]</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">oob_improvement_</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s1">previous_loss </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">oob_scores_</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">oob_score_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">oob_scores_</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s2"># no need to fancy index w/ no subsampling</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">train_score_</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s1">factor </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loss</span><span class="s4">(</span>
                    <span class="s1">y_true</span><span class="s4">=</span><span class="s1">y</span><span class="s4">,</span>
                    <span class="s1">raw_prediction</span><span class="s4">=</span><span class="s1">raw_predictions</span><span class="s4">,</span>
                    <span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">,</span>
                <span class="s4">)</span>

            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
                <span class="s1">verbose_reporter</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">i</span><span class="s4">, </span><span class="s1">self</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">monitor </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">early_stopping </span><span class="s4">= </span><span class="s1">monitor</span><span class="s4">(</span><span class="s1">i</span><span class="s4">, </span><span class="s1">self</span><span class="s4">, </span><span class="s1">locals</span><span class="s4">())</span>
                <span class="s3">if </span><span class="s1">early_stopping</span><span class="s4">:</span>
                    <span class="s3">break</span>

            <span class="s2"># We also provide an early stopping based on the score from</span>
            <span class="s2"># validation set (X_val, y_val), if n_iter_no_change is set</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_iter_no_change </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s2"># By calling next(y_val_pred_iter), we get the predictions</span>
                <span class="s2"># for X_val after the addition of the current stage</span>
                <span class="s1">validation_loss </span><span class="s4">= </span><span class="s1">factor </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loss</span><span class="s4">(</span>
                    <span class="s1">y_val</span><span class="s4">, </span><span class="s1">next</span><span class="s4">(</span><span class="s1">y_val_pred_iter</span><span class="s4">), </span><span class="s1">sample_weight_val</span>
                <span class="s4">)</span>

                <span class="s2"># Require validation_score to be better (less) than at least</span>
                <span class="s2"># one of the last n_iter_no_change evaluations</span>
                <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">any</span><span class="s4">(</span><span class="s1">validation_loss </span><span class="s4">+ </span><span class="s1">self</span><span class="s4">.</span><span class="s1">tol </span><span class="s4">&lt; </span><span class="s1">loss_history</span><span class="s4">):</span>
                    <span class="s1">loss_history</span><span class="s4">[</span><span class="s1">i </span><span class="s4">% </span><span class="s1">len</span><span class="s4">(</span><span class="s1">loss_history</span><span class="s4">)] = </span><span class="s1">validation_loss</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s3">break</span>

        <span class="s3">return </span><span class="s1">i </span><span class="s4">+ </span><span class="s6">1</span>

    <span class="s3">def </span><span class="s1">_make_estimator</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">append</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
        <span class="s2"># we don't need _make_estimator</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_raw_predict_init</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Check input and compute raw predictions of the init estimator.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_check_initialized</span><span class="s4">()</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">[</span><span class="s6">0</span><span class="s4">, </span><span class="s6">0</span><span class="s4">].</span><span class="s1">_validate_X_predict</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">check_input</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">init_ </span><span class="s4">== </span><span class="s5">&quot;zero&quot;</span><span class="s4">:</span>
            <span class="s1">raw_predictions </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span>
                <span class="s1">shape</span><span class="s4">=(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_trees_per_iteration_</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">raw_predictions </span><span class="s4">= </span><span class="s1">_init_raw_predictions</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">init_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loss</span><span class="s4">, </span><span class="s1">is_classifier</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">raw_predictions</span>

    <span class="s3">def </span><span class="s1">_raw_predict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return the sum of the trees raw predictions (+ init estimator).&quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s1">raw_predictions </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_predict_init</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s1">predict_stages</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">learning_rate</span><span class="s4">, </span><span class="s1">raw_predictions</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">raw_predictions</span>

    <span class="s3">def </span><span class="s1">_staged_raw_predict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">check_input</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Compute raw predictions of ``X`` for each iteration. 
 
        This method allows monitoring (i.e. determine error on testing set) 
        after each stage. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, it will be converted to 
            ``dtype=np.float32`` and if a sparse matrix is provided 
            to a sparse ``csr_matrix``. 
 
        check_input : bool, default=True 
            If False, the input arrays X will not be checked. 
 
        Returns 
        ------- 
        raw_predictions : generator of ndarray of shape (n_samples, k) 
            The raw predictions of the input samples. The order of the 
            classes corresponds to that in the attribute :term:`classes_`. 
            Regression and binary classification are special cases with 
            ``k == 1``, otherwise ``k==n_classes``. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">check_input</span><span class="s4">:</span>
            <span class="s1">X </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">DTYPE</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">, </span><span class="s1">accept_sparse</span><span class="s4">=</span><span class="s5">&quot;csr&quot;</span><span class="s4">, </span><span class="s1">reset</span><span class="s4">=</span><span class="s3">False</span>
            <span class="s4">)</span>
        <span class="s1">raw_predictions </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_predict_init</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]):</span>
            <span class="s1">predict_stage</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">learning_rate</span><span class="s4">, </span><span class="s1">raw_predictions</span><span class="s4">)</span>
            <span class="s3">yield </span><span class="s1">raw_predictions</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">feature_importances_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;The impurity-based feature importances. 
 
        The higher, the more important the feature. 
        The importance of a feature is computed as the (normalized) 
        total reduction of the criterion brought by that feature.  It is also 
        known as the Gini importance. 
 
        Warning: impurity-based feature importances can be misleading for 
        high cardinality features (many unique values). See 
        :func:`sklearn.inspection.permutation_importance` as an alternative. 
 
        Returns 
        ------- 
        feature_importances_ : ndarray of shape (n_features,) 
            The values of this array sum to 1, unless all trees are single node 
            trees consisting of only the root node, in which case it will be an 
            array of zeros. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_check_initialized</span><span class="s4">()</span>

        <span class="s1">relevant_trees </span><span class="s4">= [</span>
            <span class="s1">tree</span>
            <span class="s3">for </span><span class="s1">stage </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span>
            <span class="s3">for </span><span class="s1">tree </span><span class="s3">in </span><span class="s1">stage</span>
            <span class="s3">if </span><span class="s1">tree</span><span class="s4">.</span><span class="s1">tree_</span><span class="s4">.</span><span class="s1">node_count </span><span class="s4">&gt; </span><span class="s6">1</span>
        <span class="s4">]</span>
        <span class="s3">if not </span><span class="s1">relevant_trees</span><span class="s4">:</span>
            <span class="s2"># degenerate case where all trees have only one node</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">shape</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_features_in_</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>

        <span class="s1">relevant_feature_importances </span><span class="s4">= [</span>
            <span class="s1">tree</span><span class="s4">.</span><span class="s1">tree_</span><span class="s4">.</span><span class="s1">compute_feature_importances</span><span class="s4">(</span><span class="s1">normalize</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
            <span class="s3">for </span><span class="s1">tree </span><span class="s3">in </span><span class="s1">relevant_trees</span>
        <span class="s4">]</span>
        <span class="s1">avg_feature_importances </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">mean</span><span class="s4">(</span>
            <span class="s1">relevant_feature_importances</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">0</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">avg_feature_importances </span><span class="s4">/ </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">avg_feature_importances</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_compute_partial_dependence_recursion</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">grid</span><span class="s4">, </span><span class="s1">target_features</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Fast partial dependence computation. 
 
        Parameters 
        ---------- 
        grid : ndarray of shape (n_samples, n_target_features), dtype=np.float32 
            The grid points on which the partial dependence should be 
            evaluated. 
        target_features : ndarray of shape (n_target_features,), dtype=np.intp 
            The set of target features for which the partial dependence 
            should be evaluated. 
 
        Returns 
        ------- 
        averaged_predictions : ndarray of shape \ 
                (n_trees_per_iteration_, n_samples) 
            The value of the partial dependence function on each grid point. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">init </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                <span class="s5">&quot;Using recursion method with a non-constant init predictor &quot;</span>
                <span class="s5">&quot;will lead to incorrect partial dependence values. &quot;</span>
                <span class="s5">&quot;Got init=%s.&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">init</span><span class="s4">,</span>
                <span class="s1">UserWarning</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s1">grid </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">grid</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">DTYPE</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">)</span>
        <span class="s1">n_estimators</span><span class="s4">, </span><span class="s1">n_trees_per_stage </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">.</span><span class="s1">shape</span>
        <span class="s1">averaged_predictions </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span>
            <span class="s4">(</span><span class="s1">n_trees_per_stage</span><span class="s4">, </span><span class="s1">grid</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span>
        <span class="s4">)</span>
        <span class="s1">target_features </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">target_features</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">intp</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">)</span>

        <span class="s3">for </span><span class="s1">stage </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">n_estimators</span><span class="s4">):</span>
            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">n_trees_per_stage</span><span class="s4">):</span>
                <span class="s1">tree </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">[</span><span class="s1">stage</span><span class="s4">, </span><span class="s1">k</span><span class="s4">].</span><span class="s1">tree_</span>
                <span class="s1">tree</span><span class="s4">.</span><span class="s1">compute_partial_dependence</span><span class="s4">(</span>
                    <span class="s1">grid</span><span class="s4">, </span><span class="s1">target_features</span><span class="s4">, </span><span class="s1">averaged_predictions</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>
                <span class="s4">)</span>
        <span class="s1">averaged_predictions </span><span class="s4">*= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">learning_rate</span>

        <span class="s3">return </span><span class="s1">averaged_predictions</span>

    <span class="s3">def </span><span class="s1">apply</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Apply trees in the ensemble to X, return leaf indices. 
 
        .. versionadded:: 0.17 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, its dtype will be converted to 
            ``dtype=np.float32``. If a sparse matrix is provided, it will 
            be converted to a sparse ``csr_matrix``. 
 
        Returns 
        ------- 
        X_leaves : array-like of shape (n_samples, n_estimators, n_classes) 
            For each datapoint x in X and for each tree in the ensemble, 
            return the index of the leaf x ends up in each estimator. 
            In the case of binary classification n_classes is 1. 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_check_initialized</span><span class="s4">()</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">[</span><span class="s6">0</span><span class="s4">, </span><span class="s6">0</span><span class="s4">].</span><span class="s1">_validate_X_predict</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">check_input</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

        <span class="s2"># n_classes will be equal to 1 in the binary classification or the</span>
        <span class="s2"># regression case.</span>
        <span class="s1">n_estimators</span><span class="s4">, </span><span class="s1">n_classes </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">.</span><span class="s1">shape</span>
        <span class="s1">leaves </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">n_estimators</span><span class="s4">, </span><span class="s1">n_classes</span><span class="s4">))</span>

        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">n_estimators</span><span class="s4">):</span>
            <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">n_classes</span><span class="s4">):</span>
                <span class="s1">estimator </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, </span><span class="s1">j</span><span class="s4">]</span>
                <span class="s1">leaves</span><span class="s4">[:, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">j</span><span class="s4">] = </span><span class="s1">estimator</span><span class="s4">.</span><span class="s1">apply</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">check_input</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">leaves</span>


<span class="s3">class </span><span class="s1">GradientBoostingClassifier</span><span class="s4">(</span><span class="s1">ClassifierMixin</span><span class="s4">, </span><span class="s1">BaseGradientBoosting</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Gradient Boosting for classification. 
 
    This algorithm builds an additive model in a forward stage-wise fashion; it 
    allows for the optimization of arbitrary differentiable loss functions. In 
    each stage ``n_classes_`` regression trees are fit on the negative gradient 
    of the loss function, e.g. binary or multiclass log loss. Binary 
    classification is a special case where only a single regression tree is 
    induced. 
 
    :class:`~sklearn.ensemble.HistGradientBoostingClassifier` is a much faster variant 
    of this algorithm for intermediate and large datasets (`n_samples &gt;= 10_000`) and 
    supports monotonic constraints. 
 
    Read more in the :ref:`User Guide &lt;gradient_boosting&gt;`. 
 
    Parameters 
    ---------- 
    loss : {'log_loss', 'exponential'}, default='log_loss' 
        The loss function to be optimized. 'log_loss' refers to binomial and 
        multinomial deviance, the same as used in logistic regression. 
        It is a good choice for classification with probabilistic outputs. 
        For loss 'exponential', gradient boosting recovers the AdaBoost algorithm. 
 
    learning_rate : float, default=0.1 
        Learning rate shrinks the contribution of each tree by `learning_rate`. 
        There is a trade-off between learning_rate and n_estimators. 
        Values must be in the range `[0.0, inf)`. 
 
    n_estimators : int, default=100 
        The number of boosting stages to perform. Gradient boosting 
        is fairly robust to over-fitting so a large number usually 
        results in better performance. 
        Values must be in the range `[1, inf)`. 
 
    subsample : float, default=1.0 
        The fraction of samples to be used for fitting the individual base 
        learners. If smaller than 1.0 this results in Stochastic Gradient 
        Boosting. `subsample` interacts with the parameter `n_estimators`. 
        Choosing `subsample &lt; 1.0` leads to a reduction of variance 
        and an increase in bias. 
        Values must be in the range `(0.0, 1.0]`. 
 
    criterion : {'friedman_mse', 'squared_error'}, default='friedman_mse' 
        The function to measure the quality of a split. Supported criteria are 
        'friedman_mse' for the mean squared error with improvement score by 
        Friedman, 'squared_error' for mean squared error. The default value of 
        'friedman_mse' is generally the best as it can provide a better 
        approximation in some cases. 
 
        .. versionadded:: 0.18 
 
    min_samples_split : int or float, default=2 
        The minimum number of samples required to split an internal node: 
 
        - If int, values must be in the range `[2, inf)`. 
        - If float, values must be in the range `(0.0, 1.0]` and `min_samples_split` 
          will be `ceil(min_samples_split * n_samples)`. 
 
        .. versionchanged:: 0.18 
           Added float values for fractions. 
 
    min_samples_leaf : int or float, default=1 
        The minimum number of samples required to be at a leaf node. 
        A split point at any depth will only be considered if it leaves at 
        least ``min_samples_leaf`` training samples in each of the left and 
        right branches.  This may have the effect of smoothing the model, 
        especially in regression. 
 
        - If int, values must be in the range `[1, inf)`. 
        - If float, values must be in the range `(0.0, 1.0)` and `min_samples_leaf` 
          will be `ceil(min_samples_leaf * n_samples)`. 
 
        .. versionchanged:: 0.18 
           Added float values for fractions. 
 
    min_weight_fraction_leaf : float, default=0.0 
        The minimum weighted fraction of the sum total of weights (of all 
        the input samples) required to be at a leaf node. Samples have 
        equal weight when sample_weight is not provided. 
        Values must be in the range `[0.0, 0.5]`. 
 
    max_depth : int or None, default=3 
        Maximum depth of the individual regression estimators. The maximum 
        depth limits the number of nodes in the tree. Tune this parameter 
        for best performance; the best value depends on the interaction 
        of the input variables. If None, then nodes are expanded until 
        all leaves are pure or until all leaves contain less than 
        min_samples_split samples. 
        If int, values must be in the range `[1, inf)`. 
 
    min_impurity_decrease : float, default=0.0 
        A node will be split if this split induces a decrease of the impurity 
        greater than or equal to this value. 
        Values must be in the range `[0.0, inf)`. 
 
        The weighted impurity decrease equation is the following:: 
 
            N_t / N * (impurity - N_t_R / N_t * right_impurity 
                                - N_t_L / N_t * left_impurity) 
 
        where ``N`` is the total number of samples, ``N_t`` is the number of 
        samples at the current node, ``N_t_L`` is the number of samples in the 
        left child, and ``N_t_R`` is the number of samples in the right child. 
 
        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum, 
        if ``sample_weight`` is passed. 
 
        .. versionadded:: 0.19 
 
    init : estimator or 'zero', default=None 
        An estimator object that is used to compute the initial predictions. 
        ``init`` has to provide :term:`fit` and :term:`predict_proba`. If 
        'zero', the initial raw predictions are set to zero. By default, a 
        ``DummyEstimator`` predicting the classes priors is used. 
 
    random_state : int, RandomState instance or None, default=None 
        Controls the random seed given to each Tree estimator at each 
        boosting iteration. 
        In addition, it controls the random permutation of the features at 
        each split (see Notes for more details). 
        It also controls the random splitting of the training data to obtain a 
        validation set if `n_iter_no_change` is not None. 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    max_features : {'sqrt', 'log2'}, int or float, default=None 
        The number of features to consider when looking for the best split: 
 
        - If int, values must be in the range `[1, inf)`. 
        - If float, values must be in the range `(0.0, 1.0]` and the features 
          considered at each split will be `max(1, int(max_features * n_features_in_))`. 
        - If 'sqrt', then `max_features=sqrt(n_features)`. 
        - If 'log2', then `max_features=log2(n_features)`. 
        - If None, then `max_features=n_features`. 
 
        Choosing `max_features &lt; n_features` leads to a reduction of variance 
        and an increase in bias. 
 
        Note: the search for a split does not stop until at least one 
        valid partition of the node samples is found, even if it requires to 
        effectively inspect more than ``max_features`` features. 
 
    verbose : int, default=0 
        Enable verbose output. If 1 then it prints progress and performance 
        once in a while (the more trees the lower the frequency). If greater 
        than 1 then it prints progress and performance for every tree. 
        Values must be in the range `[0, inf)`. 
 
    max_leaf_nodes : int, default=None 
        Grow trees with ``max_leaf_nodes`` in best-first fashion. 
        Best nodes are defined as relative reduction in impurity. 
        Values must be in the range `[2, inf)`. 
        If `None`, then unlimited number of leaf nodes. 
 
    warm_start : bool, default=False 
        When set to ``True``, reuse the solution of the previous call to fit 
        and add more estimators to the ensemble, otherwise, just erase the 
        previous solution. See :term:`the Glossary &lt;warm_start&gt;`. 
 
    validation_fraction : float, default=0.1 
        The proportion of training data to set aside as validation set for 
        early stopping. Values must be in the range `(0.0, 1.0)`. 
        Only used if ``n_iter_no_change`` is set to an integer. 
 
        .. versionadded:: 0.20 
 
    n_iter_no_change : int, default=None 
        ``n_iter_no_change`` is used to decide if early stopping will be used 
        to terminate training when validation score is not improving. By 
        default it is set to None to disable early stopping. If set to a 
        number, it will set aside ``validation_fraction`` size of the training 
        data as validation and terminate training when validation score is not 
        improving in all of the previous ``n_iter_no_change`` numbers of 
        iterations. The split is stratified. 
        Values must be in the range `[1, inf)`. 
        See 
        :ref:`sphx_glr_auto_examples_ensemble_plot_gradient_boosting_early_stopping.py`. 
 
        .. versionadded:: 0.20 
 
    tol : float, default=1e-4 
        Tolerance for the early stopping. When the loss is not improving 
        by at least tol for ``n_iter_no_change`` iterations (if set to a 
        number), the training stops. 
        Values must be in the range `[0.0, inf)`. 
 
        .. versionadded:: 0.20 
 
    ccp_alpha : non-negative float, default=0.0 
        Complexity parameter used for Minimal Cost-Complexity Pruning. The 
        subtree with the largest cost complexity that is smaller than 
        ``ccp_alpha`` will be chosen. By default, no pruning is performed. 
        Values must be in the range `[0.0, inf)`. 
        See :ref:`minimal_cost_complexity_pruning` for details. 
 
        .. versionadded:: 0.22 
 
    Attributes 
    ---------- 
    n_estimators_ : int 
        The number of estimators as selected by early stopping (if 
        ``n_iter_no_change`` is specified). Otherwise it is set to 
        ``n_estimators``. 
 
        .. versionadded:: 0.20 
 
    n_trees_per_iteration_ : int 
        The number of trees that are built at each iteration. For binary classifiers, 
        this is always 1. 
 
        .. versionadded:: 1.4.0 
 
    feature_importances_ : ndarray of shape (n_features,) 
        The impurity-based feature importances. 
        The higher, the more important the feature. 
        The importance of a feature is computed as the (normalized) 
        total reduction of the criterion brought by that feature.  It is also 
        known as the Gini importance. 
 
        Warning: impurity-based feature importances can be misleading for 
        high cardinality features (many unique values). See 
        :func:`sklearn.inspection.permutation_importance` as an alternative. 
 
    oob_improvement_ : ndarray of shape (n_estimators,) 
        The improvement in loss on the out-of-bag samples 
        relative to the previous iteration. 
        ``oob_improvement_[0]`` is the improvement in 
        loss of the first stage over the ``init`` estimator. 
        Only available if ``subsample &lt; 1.0``. 
 
    oob_scores_ : ndarray of shape (n_estimators,) 
        The full history of the loss values on the out-of-bag 
        samples. Only available if `subsample &lt; 1.0`. 
 
        .. versionadded:: 1.3 
 
    oob_score_ : float 
        The last value of the loss on the out-of-bag samples. It is 
        the same as `oob_scores_[-1]`. Only available if `subsample &lt; 1.0`. 
 
        .. versionadded:: 1.3 
 
    train_score_ : ndarray of shape (n_estimators,) 
        The i-th score ``train_score_[i]`` is the loss of the 
        model at iteration ``i`` on the in-bag sample. 
        If ``subsample == 1`` this is the loss on the training data. 
 
    init_ : estimator 
        The estimator that provides the initial predictions. Set via the ``init`` 
        argument. 
 
    estimators_ : ndarray of DecisionTreeRegressor of \ 
            shape (n_estimators, ``n_trees_per_iteration_``) 
        The collection of fitted sub-estimators. ``n_trees_per_iteration_`` is 1 for 
        binary classification, otherwise ``n_classes``. 
 
    classes_ : ndarray of shape (n_classes,) 
        The classes labels. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    n_classes_ : int 
        The number of classes. 
 
    max_features_ : int 
        The inferred value of max_features. 
 
    See Also 
    -------- 
    HistGradientBoostingClassifier : Histogram-based Gradient Boosting 
        Classification Tree. 
    sklearn.tree.DecisionTreeClassifier : A decision tree classifier. 
    RandomForestClassifier : A meta-estimator that fits a number of decision 
        tree classifiers on various sub-samples of the dataset and uses 
        averaging to improve the predictive accuracy and control over-fitting. 
    AdaBoostClassifier : A meta-estimator that begins by fitting a classifier 
        on the original dataset and then fits additional copies of the 
        classifier on the same dataset where the weights of incorrectly 
        classified instances are adjusted such that subsequent classifiers 
        focus more on difficult cases. 
 
    Notes 
    ----- 
    The features are always randomly permuted at each split. Therefore, 
    the best found split may vary, even with the same training data and 
    ``max_features=n_features``, if the improvement of the criterion is 
    identical for several splits enumerated during the search of the best 
    split. To obtain a deterministic behaviour during fitting, 
    ``random_state`` has to be fixed. 
 
    References 
    ---------- 
    J. Friedman, Greedy Function Approximation: A Gradient Boosting 
    Machine, The Annals of Statistics, Vol. 29, No. 5, 2001. 
 
    J. Friedman, Stochastic Gradient Boosting, 1999 
 
    T. Hastie, R. Tibshirani and J. Friedman. 
    Elements of Statistical Learning Ed. 2, Springer, 2009. 
 
    Examples 
    -------- 
    The following example shows how to fit a gradient boosting classifier with 
    100 decision stumps as weak learners. 
 
    &gt;&gt;&gt; from sklearn.datasets import make_hastie_10_2 
    &gt;&gt;&gt; from sklearn.ensemble import GradientBoostingClassifier 
 
    &gt;&gt;&gt; X, y = make_hastie_10_2(random_state=0) 
    &gt;&gt;&gt; X_train, X_test = X[:2000], X[2000:] 
    &gt;&gt;&gt; y_train, y_test = y[:2000], y[2000:] 
 
    &gt;&gt;&gt; clf = GradientBoostingClassifier(n_estimators=100, learning_rate=1.0, 
    ...     max_depth=1, random_state=0).fit(X_train, y_train) 
    &gt;&gt;&gt; clf.score(X_test, y_test) 
    0.913... 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
        <span class="s4">**</span><span class="s1">BaseGradientBoosting</span><span class="s4">.</span><span class="s1">_parameter_constraints</span><span class="s4">,</span>
        <span class="s5">&quot;loss&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;log_loss&quot;</span><span class="s4">, </span><span class="s5">&quot;exponential&quot;</span><span class="s4">})],</span>
        <span class="s5">&quot;init&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;zero&quot;</span><span class="s4">}), </span><span class="s3">None</span><span class="s4">, </span><span class="s1">HasMethods</span><span class="s4">([</span><span class="s5">&quot;fit&quot;</span><span class="s4">, </span><span class="s5">&quot;predict_proba&quot;</span><span class="s4">])],</span>
    <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">loss</span><span class="s4">=</span><span class="s5">&quot;log_loss&quot;</span><span class="s4">,</span>
        <span class="s1">learning_rate</span><span class="s4">=</span><span class="s6">0.1</span><span class="s4">,</span>
        <span class="s1">n_estimators</span><span class="s4">=</span><span class="s6">100</span><span class="s4">,</span>
        <span class="s1">subsample</span><span class="s4">=</span><span class="s6">1.0</span><span class="s4">,</span>
        <span class="s1">criterion</span><span class="s4">=</span><span class="s5">&quot;friedman_mse&quot;</span><span class="s4">,</span>
        <span class="s1">min_samples_split</span><span class="s4">=</span><span class="s6">2</span><span class="s4">,</span>
        <span class="s1">min_samples_leaf</span><span class="s4">=</span><span class="s6">1</span><span class="s4">,</span>
        <span class="s1">min_weight_fraction_leaf</span><span class="s4">=</span><span class="s6">0.0</span><span class="s4">,</span>
        <span class="s1">max_depth</span><span class="s4">=</span><span class="s6">3</span><span class="s4">,</span>
        <span class="s1">min_impurity_decrease</span><span class="s4">=</span><span class="s6">0.0</span><span class="s4">,</span>
        <span class="s1">init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">max_features</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
        <span class="s1">max_leaf_nodes</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">warm_start</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">validation_fraction</span><span class="s4">=</span><span class="s6">0.1</span><span class="s4">,</span>
        <span class="s1">n_iter_no_change</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">tol</span><span class="s4">=</span><span class="s6">1e-4</span><span class="s4">,</span>
        <span class="s1">ccp_alpha</span><span class="s4">=</span><span class="s6">0.0</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span>
            <span class="s1">loss</span><span class="s4">=</span><span class="s1">loss</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">=</span><span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">n_estimators</span><span class="s4">=</span><span class="s1">n_estimators</span><span class="s4">,</span>
            <span class="s1">criterion</span><span class="s4">=</span><span class="s1">criterion</span><span class="s4">,</span>
            <span class="s1">min_samples_split</span><span class="s4">=</span><span class="s1">min_samples_split</span><span class="s4">,</span>
            <span class="s1">min_samples_leaf</span><span class="s4">=</span><span class="s1">min_samples_leaf</span><span class="s4">,</span>
            <span class="s1">min_weight_fraction_leaf</span><span class="s4">=</span><span class="s1">min_weight_fraction_leaf</span><span class="s4">,</span>
            <span class="s1">max_depth</span><span class="s4">=</span><span class="s1">max_depth</span><span class="s4">,</span>
            <span class="s1">init</span><span class="s4">=</span><span class="s1">init</span><span class="s4">,</span>
            <span class="s1">subsample</span><span class="s4">=</span><span class="s1">subsample</span><span class="s4">,</span>
            <span class="s1">max_features</span><span class="s4">=</span><span class="s1">max_features</span><span class="s4">,</span>
            <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
            <span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">,</span>
            <span class="s1">max_leaf_nodes</span><span class="s4">=</span><span class="s1">max_leaf_nodes</span><span class="s4">,</span>
            <span class="s1">min_impurity_decrease</span><span class="s4">=</span><span class="s1">min_impurity_decrease</span><span class="s4">,</span>
            <span class="s1">warm_start</span><span class="s4">=</span><span class="s1">warm_start</span><span class="s4">,</span>
            <span class="s1">validation_fraction</span><span class="s4">=</span><span class="s1">validation_fraction</span><span class="s4">,</span>
            <span class="s1">n_iter_no_change</span><span class="s4">=</span><span class="s1">n_iter_no_change</span><span class="s4">,</span>
            <span class="s1">tol</span><span class="s4">=</span><span class="s1">tol</span><span class="s4">,</span>
            <span class="s1">ccp_alpha</span><span class="s4">=</span><span class="s1">ccp_alpha</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_encode_y</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">):</span>
        <span class="s2"># encode classes into 0 ... n_classes - 1 and sets attributes classes_</span>
        <span class="s2"># and n_trees_per_iteration_</span>
        <span class="s1">check_classification_targets</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>

        <span class="s1">label_encoder </span><span class="s4">= </span><span class="s1">LabelEncoder</span><span class="s4">()</span>
        <span class="s1">encoded_y_int </span><span class="s4">= </span><span class="s1">label_encoder</span><span class="s4">.</span><span class="s1">fit_transform</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">classes_ </span><span class="s4">= </span><span class="s1">label_encoder</span><span class="s4">.</span><span class="s1">classes_</span>
        <span class="s1">n_classes </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s2"># only 1 tree for binary classification. For multiclass classification,</span>
        <span class="s2"># we build 1 tree per class.</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_trees_per_iteration_ </span><span class="s4">= </span><span class="s6">1 </span><span class="s3">if </span><span class="s1">n_classes </span><span class="s4">&lt;= </span><span class="s6">2 </span><span class="s3">else </span><span class="s1">n_classes</span>
        <span class="s1">encoded_y </span><span class="s4">= </span><span class="s1">encoded_y_int</span><span class="s4">.</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">float</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

        <span class="s2"># From here on, it is additional to the HGBT case.</span>
        <span class="s2"># expose n_classes_ attribute</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_classes_ </span><span class="s4">= </span><span class="s1">n_classes</span>
        <span class="s3">if </span><span class="s1">sample_weight </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">n_trim_classes </span><span class="s4">= </span><span class="s1">n_classes</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">n_trim_classes </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">count_nonzero</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">bincount</span><span class="s4">(</span><span class="s1">encoded_y_int</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">))</span>

        <span class="s3">if </span><span class="s1">n_trim_classes </span><span class="s4">&lt; </span><span class="s6">2</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;y contains %d class after sample_weight &quot;</span>
                <span class="s5">&quot;trimmed classes with zero weights, while a &quot;</span>
                <span class="s5">&quot;minimum of 2 classes are required.&quot; </span><span class="s4">% </span><span class="s1">n_trim_classes</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">encoded_y</span>

    <span class="s3">def </span><span class="s1">_get_loss</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss </span><span class="s4">== </span><span class="s5">&quot;log_loss&quot;</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_classes_ </span><span class="s4">== </span><span class="s6">2</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">HalfBinomialLoss</span><span class="s4">(</span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">HalfMultinomialLoss</span><span class="s4">(</span>
                    <span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s1">n_classes</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_classes_</span>
                <span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss </span><span class="s4">== </span><span class="s5">&quot;exponential&quot;</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_classes_ </span><span class="s4">&gt; </span><span class="s6">2</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                    <span class="s5">f&quot;loss='</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss</span><span class="s3">}</span><span class="s5">' is only suitable for a binary classification &quot;</span>
                    <span class="s5">f&quot;problem, you have n_classes=</span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_classes_</span><span class="s3">}</span><span class="s5">. &quot;</span>
                    <span class="s5">&quot;Please use loss='log_loss' instead.&quot;</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">ExponentialLoss</span><span class="s4">(</span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">decision_function</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Compute the decision function of ``X``. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, it will be converted to 
            ``dtype=np.float32`` and if a sparse matrix is provided 
            to a sparse ``csr_matrix``. 
 
        Returns 
        ------- 
        score : ndarray of shape (n_samples, n_classes) or (n_samples,) 
            The decision function of the input samples, which corresponds to 
            the raw values predicted from the trees of the ensemble . The 
            order of the classes corresponds to that in the attribute 
            :term:`classes_`. Regression and binary classification produce an 
            array of shape (n_samples,). 
        &quot;&quot;&quot;</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">DTYPE</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">, </span><span class="s1">accept_sparse</span><span class="s4">=</span><span class="s5">&quot;csr&quot;</span><span class="s4">, </span><span class="s1">reset</span><span class="s4">=</span><span class="s3">False</span>
        <span class="s4">)</span>
        <span class="s1">raw_predictions </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_predict</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">raw_predictions</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] == </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">raw_predictions</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">raw_predictions</span>

    <span class="s3">def </span><span class="s1">staged_decision_function</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Compute decision function of ``X`` for each iteration. 
 
        This method allows monitoring (i.e. determine error on testing set) 
        after each stage. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, it will be converted to 
            ``dtype=np.float32`` and if a sparse matrix is provided 
            to a sparse ``csr_matrix``. 
 
        Yields 
        ------ 
        score : generator of ndarray of shape (n_samples, k) 
            The decision function of the input samples, which corresponds to 
            the raw values predicted from the trees of the ensemble . The 
            classes corresponds to that in the attribute :term:`classes_`. 
            Regression and binary classification are special cases with 
            ``k == 1``, otherwise ``k==n_classes``. 
        &quot;&quot;&quot;</span>
        <span class="s3">yield from </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_staged_raw_predict</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">predict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Predict class for X. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, it will be converted to 
            ``dtype=np.float32`` and if a sparse matrix is provided 
            to a sparse ``csr_matrix``. 
 
        Returns 
        ------- 
        y : ndarray of shape (n_samples,) 
            The predicted values. 
        &quot;&quot;&quot;</span>
        <span class="s1">raw_predictions </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">decision_function</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">raw_predictions</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">== </span><span class="s6">1</span><span class="s4">:  </span><span class="s2"># decision_function already squeezed it</span>
            <span class="s1">encoded_classes </span><span class="s4">= (</span><span class="s1">raw_predictions </span><span class="s4">&gt;= </span><span class="s6">0</span><span class="s4">).</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">int</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">encoded_classes </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">argmax</span><span class="s4">(</span><span class="s1">raw_predictions</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">[</span><span class="s1">encoded_classes</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">staged_predict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Predict class at each stage for X. 
 
        This method allows monitoring (i.e. determine error on testing set) 
        after each stage. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, it will be converted to 
            ``dtype=np.float32`` and if a sparse matrix is provided 
            to a sparse ``csr_matrix``. 
 
        Yields 
        ------ 
        y : generator of ndarray of shape (n_samples,) 
            The predicted value of the input samples. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_classes_ </span><span class="s4">== </span><span class="s6">2</span><span class="s4">:  </span><span class="s2"># n_trees_per_iteration_ = 1</span>
            <span class="s3">for </span><span class="s1">raw_predictions </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_staged_raw_predict</span><span class="s4">(</span><span class="s1">X</span><span class="s4">):</span>
                <span class="s1">encoded_classes </span><span class="s4">= (</span><span class="s1">raw_predictions</span><span class="s4">.</span><span class="s1">squeeze</span><span class="s4">() &gt;= </span><span class="s6">0</span><span class="s4">).</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">int</span><span class="s4">)</span>
                <span class="s3">yield </span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">.</span><span class="s1">take</span><span class="s4">(</span><span class="s1">encoded_classes</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">0</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">raw_predictions </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_staged_raw_predict</span><span class="s4">(</span><span class="s1">X</span><span class="s4">):</span>
                <span class="s1">encoded_classes </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">argmax</span><span class="s4">(</span><span class="s1">raw_predictions</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>
                <span class="s3">yield </span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">.</span><span class="s1">take</span><span class="s4">(</span><span class="s1">encoded_classes</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">0</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">predict_proba</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Predict class probabilities for X. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, it will be converted to 
            ``dtype=np.float32`` and if a sparse matrix is provided 
            to a sparse ``csr_matrix``. 
 
        Returns 
        ------- 
        p : ndarray of shape (n_samples, n_classes) 
            The class probabilities of the input samples. The order of the 
            classes corresponds to that in the attribute :term:`classes_`. 
 
        Raises 
        ------ 
        AttributeError 
            If the ``loss`` does not support probabilities. 
        &quot;&quot;&quot;</span>
        <span class="s1">raw_predictions </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">decision_function</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loss</span><span class="s4">.</span><span class="s1">predict_proba</span><span class="s4">(</span><span class="s1">raw_predictions</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">predict_log_proba</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Predict class log-probabilities for X. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, it will be converted to 
            ``dtype=np.float32`` and if a sparse matrix is provided 
            to a sparse ``csr_matrix``. 
 
        Returns 
        ------- 
        p : ndarray of shape (n_samples, n_classes) 
            The class log-probabilities of the input samples. The order of the 
            classes corresponds to that in the attribute :term:`classes_`. 
 
        Raises 
        ------ 
        AttributeError 
            If the ``loss`` does not support probabilities. 
        &quot;&quot;&quot;</span>
        <span class="s1">proba </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">predict_proba</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">log</span><span class="s4">(</span><span class="s1">proba</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">staged_predict_proba</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Predict class probabilities at each stage for X. 
 
        This method allows monitoring (i.e. determine error on testing set) 
        after each stage. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, it will be converted to 
            ``dtype=np.float32`` and if a sparse matrix is provided 
            to a sparse ``csr_matrix``. 
 
        Yields 
        ------ 
        y : generator of ndarray of shape (n_samples,) 
            The predicted value of the input samples. 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">raw_predictions </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_staged_raw_predict</span><span class="s4">(</span><span class="s1">X</span><span class="s4">):</span>
                <span class="s3">yield </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loss</span><span class="s4">.</span><span class="s1">predict_proba</span><span class="s4">(</span><span class="s1">raw_predictions</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">NotFittedError</span><span class="s4">:</span>
            <span class="s3">raise</span>
        <span class="s3">except </span><span class="s1">AttributeError </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span>
                <span class="s5">&quot;loss=%r does not support predict_proba&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss</span>
            <span class="s4">) </span><span class="s3">from </span><span class="s1">e</span>


<span class="s3">class </span><span class="s1">GradientBoostingRegressor</span><span class="s4">(</span><span class="s1">RegressorMixin</span><span class="s4">, </span><span class="s1">BaseGradientBoosting</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Gradient Boosting for regression. 
 
    This estimator builds an additive model in a forward stage-wise fashion; it 
    allows for the optimization of arbitrary differentiable loss functions. In 
    each stage a regression tree is fit on the negative gradient of the given 
    loss function. 
 
    :class:`~sklearn.ensemble.HistGradientBoostingRegressor` is a much faster variant 
    of this algorithm for intermediate and large datasets (`n_samples &gt;= 10_000`) and 
    supports monotonic constraints. 
 
    Read more in the :ref:`User Guide &lt;gradient_boosting&gt;`. 
 
    Parameters 
    ---------- 
    loss : {'squared_error', 'absolute_error', 'huber', 'quantile'}, \ 
            default='squared_error' 
        Loss function to be optimized. 'squared_error' refers to the squared 
        error for regression. 'absolute_error' refers to the absolute error of 
        regression and is a robust loss function. 'huber' is a 
        combination of the two. 'quantile' allows quantile regression (use 
        `alpha` to specify the quantile). 
 
    learning_rate : float, default=0.1 
        Learning rate shrinks the contribution of each tree by `learning_rate`. 
        There is a trade-off between learning_rate and n_estimators. 
        Values must be in the range `[0.0, inf)`. 
 
    n_estimators : int, default=100 
        The number of boosting stages to perform. Gradient boosting 
        is fairly robust to over-fitting so a large number usually 
        results in better performance. 
        Values must be in the range `[1, inf)`. 
 
    subsample : float, default=1.0 
        The fraction of samples to be used for fitting the individual base 
        learners. If smaller than 1.0 this results in Stochastic Gradient 
        Boosting. `subsample` interacts with the parameter `n_estimators`. 
        Choosing `subsample &lt; 1.0` leads to a reduction of variance 
        and an increase in bias. 
        Values must be in the range `(0.0, 1.0]`. 
 
    criterion : {'friedman_mse', 'squared_error'}, default='friedman_mse' 
        The function to measure the quality of a split. Supported criteria are 
        &quot;friedman_mse&quot; for the mean squared error with improvement score by 
        Friedman, &quot;squared_error&quot; for mean squared error. The default value of 
        &quot;friedman_mse&quot; is generally the best as it can provide a better 
        approximation in some cases. 
 
        .. versionadded:: 0.18 
 
    min_samples_split : int or float, default=2 
        The minimum number of samples required to split an internal node: 
 
        - If int, values must be in the range `[2, inf)`. 
        - If float, values must be in the range `(0.0, 1.0]` and `min_samples_split` 
          will be `ceil(min_samples_split * n_samples)`. 
 
        .. versionchanged:: 0.18 
           Added float values for fractions. 
 
    min_samples_leaf : int or float, default=1 
        The minimum number of samples required to be at a leaf node. 
        A split point at any depth will only be considered if it leaves at 
        least ``min_samples_leaf`` training samples in each of the left and 
        right branches.  This may have the effect of smoothing the model, 
        especially in regression. 
 
        - If int, values must be in the range `[1, inf)`. 
        - If float, values must be in the range `(0.0, 1.0)` and `min_samples_leaf` 
          will be `ceil(min_samples_leaf * n_samples)`. 
 
        .. versionchanged:: 0.18 
           Added float values for fractions. 
 
    min_weight_fraction_leaf : float, default=0.0 
        The minimum weighted fraction of the sum total of weights (of all 
        the input samples) required to be at a leaf node. Samples have 
        equal weight when sample_weight is not provided. 
        Values must be in the range `[0.0, 0.5]`. 
 
    max_depth : int or None, default=3 
        Maximum depth of the individual regression estimators. The maximum 
        depth limits the number of nodes in the tree. Tune this parameter 
        for best performance; the best value depends on the interaction 
        of the input variables. If None, then nodes are expanded until 
        all leaves are pure or until all leaves contain less than 
        min_samples_split samples. 
        If int, values must be in the range `[1, inf)`. 
 
    min_impurity_decrease : float, default=0.0 
        A node will be split if this split induces a decrease of the impurity 
        greater than or equal to this value. 
        Values must be in the range `[0.0, inf)`. 
 
        The weighted impurity decrease equation is the following:: 
 
            N_t / N * (impurity - N_t_R / N_t * right_impurity 
                                - N_t_L / N_t * left_impurity) 
 
        where ``N`` is the total number of samples, ``N_t`` is the number of 
        samples at the current node, ``N_t_L`` is the number of samples in the 
        left child, and ``N_t_R`` is the number of samples in the right child. 
 
        ``N``, ``N_t``, ``N_t_R`` and ``N_t_L`` all refer to the weighted sum, 
        if ``sample_weight`` is passed. 
 
        .. versionadded:: 0.19 
 
    init : estimator or 'zero', default=None 
        An estimator object that is used to compute the initial predictions. 
        ``init`` has to provide :term:`fit` and :term:`predict`. If 'zero', the 
        initial raw predictions are set to zero. By default a 
        ``DummyEstimator`` is used, predicting either the average target value 
        (for loss='squared_error'), or a quantile for the other losses. 
 
    random_state : int, RandomState instance or None, default=None 
        Controls the random seed given to each Tree estimator at each 
        boosting iteration. 
        In addition, it controls the random permutation of the features at 
        each split (see Notes for more details). 
        It also controls the random splitting of the training data to obtain a 
        validation set if `n_iter_no_change` is not None. 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    max_features : {'sqrt', 'log2'}, int or float, default=None 
        The number of features to consider when looking for the best split: 
 
        - If int, values must be in the range `[1, inf)`. 
        - If float, values must be in the range `(0.0, 1.0]` and the features 
          considered at each split will be `max(1, int(max_features * n_features_in_))`. 
        - If &quot;sqrt&quot;, then `max_features=sqrt(n_features)`. 
        - If &quot;log2&quot;, then `max_features=log2(n_features)`. 
        - If None, then `max_features=n_features`. 
 
        Choosing `max_features &lt; n_features` leads to a reduction of variance 
        and an increase in bias. 
 
        Note: the search for a split does not stop until at least one 
        valid partition of the node samples is found, even if it requires to 
        effectively inspect more than ``max_features`` features. 
 
    alpha : float, default=0.9 
        The alpha-quantile of the huber loss function and the quantile 
        loss function. Only if ``loss='huber'`` or ``loss='quantile'``. 
        Values must be in the range `(0.0, 1.0)`. 
 
    verbose : int, default=0 
        Enable verbose output. If 1 then it prints progress and performance 
        once in a while (the more trees the lower the frequency). If greater 
        than 1 then it prints progress and performance for every tree. 
        Values must be in the range `[0, inf)`. 
 
    max_leaf_nodes : int, default=None 
        Grow trees with ``max_leaf_nodes`` in best-first fashion. 
        Best nodes are defined as relative reduction in impurity. 
        Values must be in the range `[2, inf)`. 
        If None, then unlimited number of leaf nodes. 
 
    warm_start : bool, default=False 
        When set to ``True``, reuse the solution of the previous call to fit 
        and add more estimators to the ensemble, otherwise, just erase the 
        previous solution. See :term:`the Glossary &lt;warm_start&gt;`. 
 
    validation_fraction : float, default=0.1 
        The proportion of training data to set aside as validation set for 
        early stopping. Values must be in the range `(0.0, 1.0)`. 
        Only used if ``n_iter_no_change`` is set to an integer. 
 
        .. versionadded:: 0.20 
 
    n_iter_no_change : int, default=None 
        ``n_iter_no_change`` is used to decide if early stopping will be used 
        to terminate training when validation score is not improving. By 
        default it is set to None to disable early stopping. If set to a 
        number, it will set aside ``validation_fraction`` size of the training 
        data as validation and terminate training when validation score is not 
        improving in all of the previous ``n_iter_no_change`` numbers of 
        iterations. 
        Values must be in the range `[1, inf)`. 
        See 
        :ref:`sphx_glr_auto_examples_ensemble_plot_gradient_boosting_early_stopping.py`. 
 
        .. versionadded:: 0.20 
 
    tol : float, default=1e-4 
        Tolerance for the early stopping. When the loss is not improving 
        by at least tol for ``n_iter_no_change`` iterations (if set to a 
        number), the training stops. 
        Values must be in the range `[0.0, inf)`. 
 
        .. versionadded:: 0.20 
 
    ccp_alpha : non-negative float, default=0.0 
        Complexity parameter used for Minimal Cost-Complexity Pruning. The 
        subtree with the largest cost complexity that is smaller than 
        ``ccp_alpha`` will be chosen. By default, no pruning is performed. 
        Values must be in the range `[0.0, inf)`. 
        See :ref:`minimal_cost_complexity_pruning` for details. 
 
        .. versionadded:: 0.22 
 
    Attributes 
    ---------- 
    n_estimators_ : int 
        The number of estimators as selected by early stopping (if 
        ``n_iter_no_change`` is specified). Otherwise it is set to 
        ``n_estimators``. 
 
    n_trees_per_iteration_ : int 
        The number of trees that are built at each iteration. For regressors, this is 
        always 1. 
 
        .. versionadded:: 1.4.0 
 
    feature_importances_ : ndarray of shape (n_features,) 
        The impurity-based feature importances. 
        The higher, the more important the feature. 
        The importance of a feature is computed as the (normalized) 
        total reduction of the criterion brought by that feature.  It is also 
        known as the Gini importance. 
 
        Warning: impurity-based feature importances can be misleading for 
        high cardinality features (many unique values). See 
        :func:`sklearn.inspection.permutation_importance` as an alternative. 
 
    oob_improvement_ : ndarray of shape (n_estimators,) 
        The improvement in loss on the out-of-bag samples 
        relative to the previous iteration. 
        ``oob_improvement_[0]`` is the improvement in 
        loss of the first stage over the ``init`` estimator. 
        Only available if ``subsample &lt; 1.0``. 
 
    oob_scores_ : ndarray of shape (n_estimators,) 
        The full history of the loss values on the out-of-bag 
        samples. Only available if `subsample &lt; 1.0`. 
 
        .. versionadded:: 1.3 
 
    oob_score_ : float 
        The last value of the loss on the out-of-bag samples. It is 
        the same as `oob_scores_[-1]`. Only available if `subsample &lt; 1.0`. 
 
        .. versionadded:: 1.3 
 
    train_score_ : ndarray of shape (n_estimators,) 
        The i-th score ``train_score_[i]`` is the loss of the 
        model at iteration ``i`` on the in-bag sample. 
        If ``subsample == 1`` this is the loss on the training data. 
 
    init_ : estimator 
        The estimator that provides the initial predictions. Set via the ``init`` 
        argument. 
 
    estimators_ : ndarray of DecisionTreeRegressor of shape (n_estimators, 1) 
        The collection of fitted sub-estimators. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    max_features_ : int 
        The inferred value of max_features. 
 
    See Also 
    -------- 
    HistGradientBoostingRegressor : Histogram-based Gradient Boosting 
        Classification Tree. 
    sklearn.tree.DecisionTreeRegressor : A decision tree regressor. 
    sklearn.ensemble.RandomForestRegressor : A random forest regressor. 
 
    Notes 
    ----- 
    The features are always randomly permuted at each split. Therefore, 
    the best found split may vary, even with the same training data and 
    ``max_features=n_features``, if the improvement of the criterion is 
    identical for several splits enumerated during the search of the best 
    split. To obtain a deterministic behaviour during fitting, 
    ``random_state`` has to be fixed. 
 
    References 
    ---------- 
    J. Friedman, Greedy Function Approximation: A Gradient Boosting 
    Machine, The Annals of Statistics, Vol. 29, No. 5, 2001. 
 
    J. Friedman, Stochastic Gradient Boosting, 1999 
 
    T. Hastie, R. Tibshirani and J. Friedman. 
    Elements of Statistical Learning Ed. 2, Springer, 2009. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.datasets import make_regression 
    &gt;&gt;&gt; from sklearn.ensemble import GradientBoostingRegressor 
    &gt;&gt;&gt; from sklearn.model_selection import train_test_split 
    &gt;&gt;&gt; X, y = make_regression(random_state=0) 
    &gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split( 
    ...     X, y, random_state=0) 
    &gt;&gt;&gt; reg = GradientBoostingRegressor(random_state=0) 
    &gt;&gt;&gt; reg.fit(X_train, y_train) 
    GradientBoostingRegressor(random_state=0) 
    &gt;&gt;&gt; reg.predict(X_test[1:2]) 
    array([-61...]) 
    &gt;&gt;&gt; reg.score(X_test, y_test) 
    0.4... 
 
    For a detailed example of utilizing 
    :class:`~sklearn.ensemble.GradientBoostingRegressor` 
    to fit an ensemble of weak predictive models, please refer to 
    :ref:`sphx_glr_auto_examples_ensemble_plot_gradient_boosting_regression.py`. 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
        <span class="s4">**</span><span class="s1">BaseGradientBoosting</span><span class="s4">.</span><span class="s1">_parameter_constraints</span><span class="s4">,</span>
        <span class="s5">&quot;loss&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;squared_error&quot;</span><span class="s4">, </span><span class="s5">&quot;absolute_error&quot;</span><span class="s4">, </span><span class="s5">&quot;huber&quot;</span><span class="s4">, </span><span class="s5">&quot;quantile&quot;</span><span class="s4">})],</span>
        <span class="s5">&quot;init&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;zero&quot;</span><span class="s4">}), </span><span class="s3">None</span><span class="s4">, </span><span class="s1">HasMethods</span><span class="s4">([</span><span class="s5">&quot;fit&quot;</span><span class="s4">, </span><span class="s5">&quot;predict&quot;</span><span class="s4">])],</span>
        <span class="s5">&quot;alpha&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">, </span><span class="s6">1.0</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;neither&quot;</span><span class="s4">)],</span>
    <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">loss</span><span class="s4">=</span><span class="s5">&quot;squared_error&quot;</span><span class="s4">,</span>
        <span class="s1">learning_rate</span><span class="s4">=</span><span class="s6">0.1</span><span class="s4">,</span>
        <span class="s1">n_estimators</span><span class="s4">=</span><span class="s6">100</span><span class="s4">,</span>
        <span class="s1">subsample</span><span class="s4">=</span><span class="s6">1.0</span><span class="s4">,</span>
        <span class="s1">criterion</span><span class="s4">=</span><span class="s5">&quot;friedman_mse&quot;</span><span class="s4">,</span>
        <span class="s1">min_samples_split</span><span class="s4">=</span><span class="s6">2</span><span class="s4">,</span>
        <span class="s1">min_samples_leaf</span><span class="s4">=</span><span class="s6">1</span><span class="s4">,</span>
        <span class="s1">min_weight_fraction_leaf</span><span class="s4">=</span><span class="s6">0.0</span><span class="s4">,</span>
        <span class="s1">max_depth</span><span class="s4">=</span><span class="s6">3</span><span class="s4">,</span>
        <span class="s1">min_impurity_decrease</span><span class="s4">=</span><span class="s6">0.0</span><span class="s4">,</span>
        <span class="s1">init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">max_features</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">alpha</span><span class="s4">=</span><span class="s6">0.9</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
        <span class="s1">max_leaf_nodes</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">warm_start</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">validation_fraction</span><span class="s4">=</span><span class="s6">0.1</span><span class="s4">,</span>
        <span class="s1">n_iter_no_change</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">tol</span><span class="s4">=</span><span class="s6">1e-4</span><span class="s4">,</span>
        <span class="s1">ccp_alpha</span><span class="s4">=</span><span class="s6">0.0</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span>
            <span class="s1">loss</span><span class="s4">=</span><span class="s1">loss</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">=</span><span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">n_estimators</span><span class="s4">=</span><span class="s1">n_estimators</span><span class="s4">,</span>
            <span class="s1">criterion</span><span class="s4">=</span><span class="s1">criterion</span><span class="s4">,</span>
            <span class="s1">min_samples_split</span><span class="s4">=</span><span class="s1">min_samples_split</span><span class="s4">,</span>
            <span class="s1">min_samples_leaf</span><span class="s4">=</span><span class="s1">min_samples_leaf</span><span class="s4">,</span>
            <span class="s1">min_weight_fraction_leaf</span><span class="s4">=</span><span class="s1">min_weight_fraction_leaf</span><span class="s4">,</span>
            <span class="s1">max_depth</span><span class="s4">=</span><span class="s1">max_depth</span><span class="s4">,</span>
            <span class="s1">init</span><span class="s4">=</span><span class="s1">init</span><span class="s4">,</span>
            <span class="s1">subsample</span><span class="s4">=</span><span class="s1">subsample</span><span class="s4">,</span>
            <span class="s1">max_features</span><span class="s4">=</span><span class="s1">max_features</span><span class="s4">,</span>
            <span class="s1">min_impurity_decrease</span><span class="s4">=</span><span class="s1">min_impurity_decrease</span><span class="s4">,</span>
            <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">=</span><span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">,</span>
            <span class="s1">max_leaf_nodes</span><span class="s4">=</span><span class="s1">max_leaf_nodes</span><span class="s4">,</span>
            <span class="s1">warm_start</span><span class="s4">=</span><span class="s1">warm_start</span><span class="s4">,</span>
            <span class="s1">validation_fraction</span><span class="s4">=</span><span class="s1">validation_fraction</span><span class="s4">,</span>
            <span class="s1">n_iter_no_change</span><span class="s4">=</span><span class="s1">n_iter_no_change</span><span class="s4">,</span>
            <span class="s1">tol</span><span class="s4">=</span><span class="s1">tol</span><span class="s4">,</span>
            <span class="s1">ccp_alpha</span><span class="s4">=</span><span class="s1">ccp_alpha</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_encode_y</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s2"># Just convert y to the expected dtype</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_trees_per_iteration_ </span><span class="s4">= </span><span class="s6">1</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">y</span><span class="s4">.</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">DOUBLE</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">y</span>

    <span class="s3">def </span><span class="s1">_get_loss</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss </span><span class="s3">in </span><span class="s4">(</span><span class="s5">&quot;quantile&quot;</span><span class="s4">, </span><span class="s5">&quot;huber&quot;</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">_LOSSES</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss</span><span class="s4">](</span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s1">quantile</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">alpha</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_LOSSES</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss</span><span class="s4">](</span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">predict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Predict regression target for X. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, it will be converted to 
            ``dtype=np.float32`` and if a sparse matrix is provided 
            to a sparse ``csr_matrix``. 
 
        Returns 
        ------- 
        y : ndarray of shape (n_samples,) 
            The predicted values. 
        &quot;&quot;&quot;</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">DTYPE</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">, </span><span class="s1">accept_sparse</span><span class="s4">=</span><span class="s5">&quot;csr&quot;</span><span class="s4">, </span><span class="s1">reset</span><span class="s4">=</span><span class="s3">False</span>
        <span class="s4">)</span>
        <span class="s2"># In regression we can directly return the raw value from the trees.</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_predict</span><span class="s4">(</span><span class="s1">X</span><span class="s4">).</span><span class="s1">ravel</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">staged_predict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Predict regression target at each stage for X. 
 
        This method allows monitoring (i.e. determine error on testing set) 
        after each stage. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, it will be converted to 
            ``dtype=np.float32`` and if a sparse matrix is provided 
            to a sparse ``csr_matrix``. 
 
        Yields 
        ------ 
        y : generator of ndarray of shape (n_samples,) 
            The predicted value of the input samples. 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">raw_predictions </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_staged_raw_predict</span><span class="s4">(</span><span class="s1">X</span><span class="s4">):</span>
            <span class="s3">yield </span><span class="s1">raw_predictions</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">apply</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Apply trees in the ensemble to X, return leaf indices. 
 
        .. versionadded:: 0.17 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The input samples. Internally, its dtype will be converted to 
            ``dtype=np.float32``. If a sparse matrix is provided, it will 
            be converted to a sparse ``csr_matrix``. 
 
        Returns 
        ------- 
        X_leaves : array-like of shape (n_samples, n_estimators) 
            For each datapoint x in X and for each tree in the ensemble, 
            return the index of the leaf x ends up in each estimator. 
        &quot;&quot;&quot;</span>

        <span class="s1">leaves </span><span class="s4">= </span><span class="s1">super</span><span class="s4">().</span><span class="s1">apply</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s1">leaves </span><span class="s4">= </span><span class="s1">leaves</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])</span>
        <span class="s3">return </span><span class="s1">leaves</span>
</pre>
</body>
</html>