<html>
<head>
<title>_selectable_constructors.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_selectable_constructors.py</font>
</center></td></tr></table>
<pre><span class="s0"># sql/_selectable_constructors.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">overload</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Tuple</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TypeVar</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Union</span>

<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">coercions</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">roles</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_ColumnsClauseArgument</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_no_kw</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">elements </span><span class="s2">import </span><span class="s1">ColumnClause</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">Alias</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">CompoundSelect</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">Exists</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">FromClause</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">Join</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">Lateral</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">LateralFromClause</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">NamedFromClause</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">Select</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">TableClause</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">TableSample</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">Values</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_FromClauseArgument</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_OnClauseArgument</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_SelectStatementForCompoundArgument</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T0</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T1</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T2</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T3</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T4</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T5</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T6</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T7</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T8</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_T9</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">_TypedColumnClauseArgument </span><span class="s2">as </span><span class="s1">_TCCA</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">functions </span><span class="s2">import </span><span class="s1">Function</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">CTE</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">HasCTE</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">ScalarSelect</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">selectable </span><span class="s2">import </span><span class="s1">SelectBase</span>


<span class="s1">_T </span><span class="s3">= </span><span class="s1">TypeVar</span><span class="s3">(</span><span class="s4">&quot;_T&quot;</span><span class="s3">, </span><span class="s1">bound</span><span class="s3">=</span><span class="s1">Any</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">alias</span><span class="s3">(</span>
    <span class="s1">selectable</span><span class="s3">: </span><span class="s1">FromClause</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">, </span><span class="s1">flat</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span>
<span class="s3">) </span><span class="s1">-&gt; NamedFromClause</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot;Return a named alias of the given :class:`.FromClause`. 
 
    For :class:`.Table` and :class:`.Join` objects, the return type is the 
    :class:`_expression.Alias` object. Other kinds of :class:`.NamedFromClause` 
    objects may be returned for other kinds of :class:`.FromClause` objects. 
 
    The named alias represents any :class:`_expression.FromClause` with an 
    alternate name assigned within SQL, typically using the ``AS`` clause when 
    generated, e.g. ``SELECT * FROM table AS aliasname``. 
 
    Equivalent functionality is available via the 
    :meth:`_expression.FromClause.alias` 
    method available on all :class:`_expression.FromClause` objects. 
 
    :param selectable: any :class:`_expression.FromClause` subclass, 
        such as a table, select statement, etc. 
 
    :param name: string name to be assigned as the alias. 
        If ``None``, a name will be deterministically generated at compile 
        time. Deterministic means the name is guaranteed to be unique against 
        other constructs used in the same statement, and will also be the same 
        name for each successive compilation of the same statement object. 
 
    :param flat: Will be passed through to if the given selectable 
     is an instance of :class:`_expression.Join` - see 
     :meth:`_expression.Join.alias` for details. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">Alias</span><span class="s3">.</span><span class="s1">_factory</span><span class="s3">(</span><span class="s1">selectable</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">, </span><span class="s1">flat</span><span class="s3">=</span><span class="s1">flat</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">cte</span><span class="s3">(</span>
    <span class="s1">selectable</span><span class="s3">: </span><span class="s1">HasCTE</span><span class="s3">, </span><span class="s1">name</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">, </span><span class="s1">recursive</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span>
<span class="s3">) </span><span class="s1">-&gt; CTE</span><span class="s3">:</span>
    <span class="s5">r&quot;&quot;&quot;Return a new :class:`_expression.CTE`, 
    or Common Table Expression instance. 
 
    Please see :meth:`_expression.HasCTE.cte` for detail on CTE usage. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">coercions</span><span class="s3">.</span><span class="s1">expect</span><span class="s3">(</span><span class="s1">roles</span><span class="s3">.</span><span class="s1">HasCTERole</span><span class="s3">, </span><span class="s1">selectable</span><span class="s3">).</span><span class="s1">cte</span><span class="s3">(</span>
        <span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">, </span><span class="s1">recursive</span><span class="s3">=</span><span class="s1">recursive</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">except_</span><span class="s3">(</span>
    <span class="s3">*</span><span class="s1">selects</span><span class="s3">: </span><span class="s1">_SelectStatementForCompoundArgument</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s3">:</span>
    <span class="s5">r&quot;&quot;&quot;Return an ``EXCEPT`` of multiple selectables. 
 
    The returned object is an instance of 
    :class:`_expression.CompoundSelect`. 
 
    :param \*selects: 
      a list of :class:`_expression.Select` instances. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">CompoundSelect</span><span class="s3">.</span><span class="s1">_create_except</span><span class="s3">(*</span><span class="s1">selects</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">except_all</span><span class="s3">(</span>
    <span class="s3">*</span><span class="s1">selects</span><span class="s3">: </span><span class="s1">_SelectStatementForCompoundArgument</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s3">:</span>
    <span class="s5">r&quot;&quot;&quot;Return an ``EXCEPT ALL`` of multiple selectables. 
 
    The returned object is an instance of 
    :class:`_expression.CompoundSelect`. 
 
    :param \*selects: 
      a list of :class:`_expression.Select` instances. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">CompoundSelect</span><span class="s3">.</span><span class="s1">_create_except_all</span><span class="s3">(*</span><span class="s1">selects</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">exists</span><span class="s3">(</span>
    <span class="s1">__argument</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span>
        <span class="s1">Union</span><span class="s3">[</span><span class="s1">_ColumnsClauseArgument</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">], </span><span class="s1">SelectBase</span><span class="s3">, </span><span class="s1">ScalarSelect</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]]</span>
    <span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; Exists</span><span class="s3">:</span>
    <span class="s4">&quot;&quot;&quot;Construct a new :class:`_expression.Exists` construct. 
 
    The :func:`_sql.exists` can be invoked by itself to produce an 
    :class:`_sql.Exists` construct, which will accept simple WHERE 
    criteria:: 
 
        exists_criteria = exists().where(table1.c.col1 == table2.c.col2) 
 
    However, for greater flexibility in constructing the SELECT, an 
    existing :class:`_sql.Select` construct may be converted to an 
    :class:`_sql.Exists`, most conveniently by making use of the 
    :meth:`_sql.SelectBase.exists` method:: 
 
        exists_criteria = ( 
            select(table2.c.col2). 
            where(table1.c.col1 == table2.c.col2). 
            exists() 
        ) 
 
    The EXISTS criteria is then used inside of an enclosing SELECT:: 
 
        stmt = select(table1.c.col1).where(exists_criteria) 
 
    The above statement will then be of the form:: 
 
        SELECT col1 FROM table1 WHERE EXISTS 
        (SELECT table2.col2 FROM table2 WHERE table2.col2 = table1.col1) 
 
    .. seealso:: 
 
        :ref:`tutorial_exists` - in the :term:`2.0 style` tutorial. 
 
        :meth:`_sql.SelectBase.exists` - method to transform a ``SELECT`` to an 
        ``EXISTS`` clause. 
 
    &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

    <span class="s2">return </span><span class="s1">Exists</span><span class="s3">(</span><span class="s1">__argument</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">intersect</span><span class="s3">(</span>
    <span class="s3">*</span><span class="s1">selects</span><span class="s3">: </span><span class="s1">_SelectStatementForCompoundArgument</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s3">:</span>
    <span class="s5">r&quot;&quot;&quot;Return an ``INTERSECT`` of multiple selectables. 
 
    The returned object is an instance of 
    :class:`_expression.CompoundSelect`. 
 
    :param \*selects: 
      a list of :class:`_expression.Select` instances. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">CompoundSelect</span><span class="s3">.</span><span class="s1">_create_intersect</span><span class="s3">(*</span><span class="s1">selects</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">intersect_all</span><span class="s3">(</span>
    <span class="s3">*</span><span class="s1">selects</span><span class="s3">: </span><span class="s1">_SelectStatementForCompoundArgument</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s3">:</span>
    <span class="s5">r&quot;&quot;&quot;Return an ``INTERSECT ALL`` of multiple selectables. 
 
    The returned object is an instance of 
    :class:`_expression.CompoundSelect`. 
 
    :param \*selects: 
      a list of :class:`_expression.Select` instances. 
 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">CompoundSelect</span><span class="s3">.</span><span class="s1">_create_intersect_all</span><span class="s3">(*</span><span class="s1">selects</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">join</span><span class="s3">(</span>
    <span class="s1">left</span><span class="s3">: </span><span class="s1">_FromClauseArgument</span><span class="s3">,</span>
    <span class="s1">right</span><span class="s3">: </span><span class="s1">_FromClauseArgument</span><span class="s3">,</span>
    <span class="s1">onclause</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_OnClauseArgument</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">isouter</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s1">full</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; Join</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot;Produce a :class:`_expression.Join` object, given two 
    :class:`_expression.FromClause` 
    expressions. 
 
    E.g.:: 
 
        j = join(user_table, address_table, 
                 user_table.c.id == address_table.c.user_id) 
        stmt = select(user_table).select_from(j) 
 
    would emit SQL along the lines of:: 
 
        SELECT user.id, user.name FROM user 
        JOIN address ON user.id = address.user_id 
 
    Similar functionality is available given any 
    :class:`_expression.FromClause` object (e.g. such as a 
    :class:`_schema.Table`) using 
    the :meth:`_expression.FromClause.join` method. 
 
    :param left: The left side of the join. 
 
    :param right: the right side of the join; this is any 
     :class:`_expression.FromClause` object such as a 
     :class:`_schema.Table` object, and 
     may also be a selectable-compatible object such as an ORM-mapped 
     class. 
 
    :param onclause: a SQL expression representing the ON clause of the 
     join.  If left at ``None``, :meth:`_expression.FromClause.join` 
     will attempt to 
     join the two tables based on a foreign key relationship. 
 
    :param isouter: if True, render a LEFT OUTER JOIN, instead of JOIN. 
 
    :param full: if True, render a FULL OUTER JOIN, instead of JOIN. 
 
    .. seealso:: 
 
        :meth:`_expression.FromClause.join` - method form, 
        based on a given left side. 
 
        :class:`_expression.Join` - the type of object produced. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">return </span><span class="s1">Join</span><span class="s3">(</span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">, </span><span class="s1">onclause</span><span class="s3">, </span><span class="s1">isouter</span><span class="s3">, </span><span class="s1">full</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">lateral</span><span class="s3">(</span>
    <span class="s1">selectable</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">SelectBase</span><span class="s3">, </span><span class="s1">_FromClauseArgument</span><span class="s3">],</span>
    <span class="s1">name</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; LateralFromClause</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot;Return a :class:`_expression.Lateral` object. 
 
    :class:`_expression.Lateral` is an :class:`_expression.Alias` 
    subclass that represents 
    a subquery with the LATERAL keyword applied to it. 
 
    The special behavior of a LATERAL subquery is that it appears in the 
    FROM clause of an enclosing SELECT, but may correlate to other 
    FROM clauses of that SELECT.   It is a special case of subquery 
    only supported by a small number of backends, currently more recent 
    PostgreSQL versions. 
 
    .. seealso:: 
 
        :ref:`tutorial_lateral_correlation` -  overview of usage. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">Lateral</span><span class="s3">.</span><span class="s1">_factory</span><span class="s3">(</span><span class="s1">selectable</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">outerjoin</span><span class="s3">(</span>
    <span class="s1">left</span><span class="s3">: </span><span class="s1">_FromClauseArgument</span><span class="s3">,</span>
    <span class="s1">right</span><span class="s3">: </span><span class="s1">_FromClauseArgument</span><span class="s3">,</span>
    <span class="s1">onclause</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">_OnClauseArgument</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">full</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; Join</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot;Return an ``OUTER JOIN`` clause element. 
 
    The returned object is an instance of :class:`_expression.Join`. 
 
    Similar functionality is also available via the 
    :meth:`_expression.FromClause.outerjoin` method on any 
    :class:`_expression.FromClause`. 
 
    :param left: The left side of the join. 
 
    :param right: The right side of the join. 
 
    :param onclause:  Optional criterion for the ``ON`` clause, is 
      derived from foreign key relationships established between 
      left and right otherwise. 
 
    To chain joins together, use the :meth:`_expression.FromClause.join` 
    or 
    :meth:`_expression.FromClause.outerjoin` methods on the resulting 
    :class:`_expression.Join` object. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">Join</span><span class="s3">(</span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">, </span><span class="s1">onclause</span><span class="s3">, </span><span class="s1">isouter</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">full</span><span class="s3">=</span><span class="s1">full</span><span class="s3">)</span>


<span class="s0"># START OVERLOADED FUNCTIONS select Select 1-10</span>

<span class="s0"># code within this block is **programmatically,</span>
<span class="s0"># statically generated** by tools/generate_tuple_map_overloads.py</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">select</span><span class="s3">(</span><span class="s1">__ent0</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">]) </span><span class="s1">-&gt; Select</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">]]: ...</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">select</span><span class="s3">(</span>
    <span class="s1">__ent0</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">], </span><span class="s1">__ent1</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T1</span><span class="s3">]</span>
<span class="s3">) </span><span class="s1">-&gt; Select</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">, </span><span class="s1">_T1</span><span class="s3">]]: ...</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">select</span><span class="s3">(</span>
    <span class="s1">__ent0</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">], </span><span class="s1">__ent1</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T1</span><span class="s3">], </span><span class="s1">__ent2</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T2</span><span class="s3">]</span>
<span class="s3">) </span><span class="s1">-&gt; Select</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">, </span><span class="s1">_T1</span><span class="s3">, </span><span class="s1">_T2</span><span class="s3">]]: ...</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">select</span><span class="s3">(</span>
    <span class="s1">__ent0</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">],</span>
    <span class="s1">__ent1</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T1</span><span class="s3">],</span>
    <span class="s1">__ent2</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T2</span><span class="s3">],</span>
    <span class="s1">__ent3</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T3</span><span class="s3">],</span>
<span class="s3">) </span><span class="s1">-&gt; Select</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">, </span><span class="s1">_T1</span><span class="s3">, </span><span class="s1">_T2</span><span class="s3">, </span><span class="s1">_T3</span><span class="s3">]]: ...</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">select</span><span class="s3">(</span>
    <span class="s1">__ent0</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">],</span>
    <span class="s1">__ent1</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T1</span><span class="s3">],</span>
    <span class="s1">__ent2</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T2</span><span class="s3">],</span>
    <span class="s1">__ent3</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T3</span><span class="s3">],</span>
    <span class="s1">__ent4</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T4</span><span class="s3">],</span>
<span class="s3">) </span><span class="s1">-&gt; Select</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">, </span><span class="s1">_T1</span><span class="s3">, </span><span class="s1">_T2</span><span class="s3">, </span><span class="s1">_T3</span><span class="s3">, </span><span class="s1">_T4</span><span class="s3">]]: ...</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">select</span><span class="s3">(</span>
    <span class="s1">__ent0</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">],</span>
    <span class="s1">__ent1</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T1</span><span class="s3">],</span>
    <span class="s1">__ent2</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T2</span><span class="s3">],</span>
    <span class="s1">__ent3</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T3</span><span class="s3">],</span>
    <span class="s1">__ent4</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T4</span><span class="s3">],</span>
    <span class="s1">__ent5</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T5</span><span class="s3">],</span>
<span class="s3">) </span><span class="s1">-&gt; Select</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">, </span><span class="s1">_T1</span><span class="s3">, </span><span class="s1">_T2</span><span class="s3">, </span><span class="s1">_T3</span><span class="s3">, </span><span class="s1">_T4</span><span class="s3">, </span><span class="s1">_T5</span><span class="s3">]]: ...</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">select</span><span class="s3">(</span>
    <span class="s1">__ent0</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">],</span>
    <span class="s1">__ent1</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T1</span><span class="s3">],</span>
    <span class="s1">__ent2</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T2</span><span class="s3">],</span>
    <span class="s1">__ent3</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T3</span><span class="s3">],</span>
    <span class="s1">__ent4</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T4</span><span class="s3">],</span>
    <span class="s1">__ent5</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T5</span><span class="s3">],</span>
    <span class="s1">__ent6</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T6</span><span class="s3">],</span>
<span class="s3">) </span><span class="s1">-&gt; Select</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">, </span><span class="s1">_T1</span><span class="s3">, </span><span class="s1">_T2</span><span class="s3">, </span><span class="s1">_T3</span><span class="s3">, </span><span class="s1">_T4</span><span class="s3">, </span><span class="s1">_T5</span><span class="s3">, </span><span class="s1">_T6</span><span class="s3">]]: ...</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">select</span><span class="s3">(</span>
    <span class="s1">__ent0</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">],</span>
    <span class="s1">__ent1</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T1</span><span class="s3">],</span>
    <span class="s1">__ent2</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T2</span><span class="s3">],</span>
    <span class="s1">__ent3</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T3</span><span class="s3">],</span>
    <span class="s1">__ent4</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T4</span><span class="s3">],</span>
    <span class="s1">__ent5</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T5</span><span class="s3">],</span>
    <span class="s1">__ent6</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T6</span><span class="s3">],</span>
    <span class="s1">__ent7</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T7</span><span class="s3">],</span>
<span class="s3">) </span><span class="s1">-&gt; Select</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">, </span><span class="s1">_T1</span><span class="s3">, </span><span class="s1">_T2</span><span class="s3">, </span><span class="s1">_T3</span><span class="s3">, </span><span class="s1">_T4</span><span class="s3">, </span><span class="s1">_T5</span><span class="s3">, </span><span class="s1">_T6</span><span class="s3">, </span><span class="s1">_T7</span><span class="s3">]]: ...</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">select</span><span class="s3">(</span>
    <span class="s1">__ent0</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">],</span>
    <span class="s1">__ent1</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T1</span><span class="s3">],</span>
    <span class="s1">__ent2</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T2</span><span class="s3">],</span>
    <span class="s1">__ent3</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T3</span><span class="s3">],</span>
    <span class="s1">__ent4</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T4</span><span class="s3">],</span>
    <span class="s1">__ent5</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T5</span><span class="s3">],</span>
    <span class="s1">__ent6</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T6</span><span class="s3">],</span>
    <span class="s1">__ent7</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T7</span><span class="s3">],</span>
    <span class="s1">__ent8</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T8</span><span class="s3">],</span>
<span class="s3">) </span><span class="s1">-&gt; Select</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">, </span><span class="s1">_T1</span><span class="s3">, </span><span class="s1">_T2</span><span class="s3">, </span><span class="s1">_T3</span><span class="s3">, </span><span class="s1">_T4</span><span class="s3">, </span><span class="s1">_T5</span><span class="s3">, </span><span class="s1">_T6</span><span class="s3">, </span><span class="s1">_T7</span><span class="s3">, </span><span class="s1">_T8</span><span class="s3">]]: ...</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">select</span><span class="s3">(</span>
    <span class="s1">__ent0</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">],</span>
    <span class="s1">__ent1</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T1</span><span class="s3">],</span>
    <span class="s1">__ent2</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T2</span><span class="s3">],</span>
    <span class="s1">__ent3</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T3</span><span class="s3">],</span>
    <span class="s1">__ent4</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T4</span><span class="s3">],</span>
    <span class="s1">__ent5</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T5</span><span class="s3">],</span>
    <span class="s1">__ent6</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T6</span><span class="s3">],</span>
    <span class="s1">__ent7</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T7</span><span class="s3">],</span>
    <span class="s1">__ent8</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T8</span><span class="s3">],</span>
    <span class="s1">__ent9</span><span class="s3">: </span><span class="s1">_TCCA</span><span class="s3">[</span><span class="s1">_T9</span><span class="s3">],</span>
<span class="s3">) </span><span class="s1">-&gt; Select</span><span class="s3">[</span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">_T0</span><span class="s3">, </span><span class="s1">_T1</span><span class="s3">, </span><span class="s1">_T2</span><span class="s3">, </span><span class="s1">_T3</span><span class="s3">, </span><span class="s1">_T4</span><span class="s3">, </span><span class="s1">_T5</span><span class="s3">, </span><span class="s1">_T6</span><span class="s3">, </span><span class="s1">_T7</span><span class="s3">, </span><span class="s1">_T8</span><span class="s3">, </span><span class="s1">_T9</span><span class="s3">]]: ...</span>


<span class="s0"># END OVERLOADED FUNCTIONS select</span>


<span class="s3">@</span><span class="s1">overload</span>
<span class="s2">def </span><span class="s1">select</span><span class="s3">(</span>
    <span class="s3">*</span><span class="s1">entities</span><span class="s3">: </span><span class="s1">_ColumnsClauseArgument</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">], **</span><span class="s1">__kw</span><span class="s3">: </span><span class="s1">Any</span>
<span class="s3">) </span><span class="s1">-&gt; Select</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]: ...</span>


<span class="s2">def </span><span class="s1">select</span><span class="s3">(*</span><span class="s1">entities</span><span class="s3">: </span><span class="s1">_ColumnsClauseArgument</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">], **</span><span class="s1">__kw</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; Select</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]:</span>
    <span class="s5">r&quot;&quot;&quot;Construct a new :class:`_expression.Select`. 
 
 
    .. versionadded:: 1.4 - The :func:`_sql.select` function now accepts 
       column arguments positionally.   The top-level :func:`_sql.select` 
       function will automatically use the 1.x or 2.x style API based on 
       the incoming arguments; using :func:`_sql.select` from the 
       ``sqlalchemy.future`` module will enforce that only the 2.x style 
       constructor is used. 
 
    Similar functionality is also available via the 
    :meth:`_expression.FromClause.select` method on any 
    :class:`_expression.FromClause`. 
 
    .. seealso:: 
 
        :ref:`tutorial_selecting_data` - in the :ref:`unified_tutorial` 
 
    :param \*entities: 
      Entities to SELECT from.  For Core usage, this is typically a series 
      of :class:`_expression.ColumnElement` and / or 
      :class:`_expression.FromClause` 
      objects which will form the columns clause of the resulting 
      statement.   For those objects that are instances of 
      :class:`_expression.FromClause` (typically :class:`_schema.Table` 
      or :class:`_expression.Alias` 
      objects), the :attr:`_expression.FromClause.c` 
      collection is extracted 
      to form a collection of :class:`_expression.ColumnElement` objects. 
 
      This parameter will also accept :class:`_expression.TextClause` 
      constructs as 
      given, as well as ORM-mapped classes. 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># the keyword args are a necessary element in order for the typing</span>
    <span class="s0"># to work out w/ the varargs vs. having named &quot;keyword&quot; arguments that</span>
    <span class="s0"># aren't always present.</span>
    <span class="s2">if </span><span class="s1">__kw</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">_no_kw</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">Select</span><span class="s3">(*</span><span class="s1">entities</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">table</span><span class="s3">(</span><span class="s1">name</span><span class="s3">: </span><span class="s1">str</span><span class="s3">, *</span><span class="s1">columns</span><span class="s3">: </span><span class="s1">ColumnClause</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">], **</span><span class="s1">kw</span><span class="s3">: </span><span class="s1">Any</span><span class="s3">) </span><span class="s1">-&gt; TableClause</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot;Produce a new :class:`_expression.TableClause`. 
 
    The object returned is an instance of 
    :class:`_expression.TableClause`, which 
    represents the &quot;syntactical&quot; portion of the schema-level 
    :class:`_schema.Table` object. 
    It may be used to construct lightweight table constructs. 
 
    :param name: Name of the table. 
 
    :param columns: A collection of :func:`_expression.column` constructs. 
 
    :param schema: The schema name for this table. 
 
        .. versionadded:: 1.3.18 :func:`_expression.table` can now 
           accept a ``schema`` argument. 
    &quot;&quot;&quot;</span>

    <span class="s2">return </span><span class="s1">TableClause</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, *</span><span class="s1">columns</span><span class="s3">, **</span><span class="s1">kw</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">tablesample</span><span class="s3">(</span>
    <span class="s1">selectable</span><span class="s3">: </span><span class="s1">_FromClauseArgument</span><span class="s3">,</span>
    <span class="s1">sampling</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">float</span><span class="s3">, </span><span class="s1">Function</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]],</span>
    <span class="s1">name</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">seed</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">roles</span><span class="s3">.</span><span class="s1">ExpressionElementRole</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; TableSample</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot;Return a :class:`_expression.TableSample` object. 
 
    :class:`_expression.TableSample` is an :class:`_expression.Alias` 
    subclass that represents 
    a table with the TABLESAMPLE clause applied to it. 
    :func:`_expression.tablesample` 
    is also available from the :class:`_expression.FromClause` 
    class via the 
    :meth:`_expression.FromClause.tablesample` method. 
 
    The TABLESAMPLE clause allows selecting a randomly selected approximate 
    percentage of rows from a table. It supports multiple sampling methods, 
    most commonly BERNOULLI and SYSTEM. 
 
    e.g.:: 
 
        from sqlalchemy import func 
 
        selectable = people.tablesample( 
                    func.bernoulli(1), 
                    name='alias', 
                    seed=func.random()) 
        stmt = select(selectable.c.people_id) 
 
    Assuming ``people`` with a column ``people_id``, the above 
    statement would render as:: 
 
        SELECT alias.people_id FROM 
        people AS alias TABLESAMPLE bernoulli(:bernoulli_1) 
        REPEATABLE (random()) 
 
    :param sampling: a ``float`` percentage between 0 and 100 or 
        :class:`_functions.Function`. 
 
    :param name: optional alias name 
 
    :param seed: any real-valued SQL expression.  When specified, the 
     REPEATABLE sub-clause is also rendered. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">TableSample</span><span class="s3">.</span><span class="s1">_factory</span><span class="s3">(</span><span class="s1">selectable</span><span class="s3">, </span><span class="s1">sampling</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">, </span><span class="s1">seed</span><span class="s3">=</span><span class="s1">seed</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">union</span><span class="s3">(</span>
    <span class="s3">*</span><span class="s1">selects</span><span class="s3">: </span><span class="s1">_SelectStatementForCompoundArgument</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s3">:</span>
    <span class="s5">r&quot;&quot;&quot;Return a ``UNION`` of multiple selectables. 
 
    The returned object is an instance of 
    :class:`_expression.CompoundSelect`. 
 
    A similar :func:`union()` method is available on all 
    :class:`_expression.FromClause` subclasses. 
 
    :param \*selects: 
      a list of :class:`_expression.Select` instances. 
 
    :param \**kwargs: 
      available keyword arguments are the same as those of 
      :func:`select`. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">CompoundSelect</span><span class="s3">.</span><span class="s1">_create_union</span><span class="s3">(*</span><span class="s1">selects</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">union_all</span><span class="s3">(</span>
    <span class="s3">*</span><span class="s1">selects</span><span class="s3">: </span><span class="s1">_SelectStatementForCompoundArgument</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; CompoundSelect</span><span class="s3">:</span>
    <span class="s5">r&quot;&quot;&quot;Return a ``UNION ALL`` of multiple selectables. 
 
    The returned object is an instance of 
    :class:`_expression.CompoundSelect`. 
 
    A similar :func:`union_all()` method is available on all 
    :class:`_expression.FromClause` subclasses. 
 
    :param \*selects: 
      a list of :class:`_expression.Select` instances. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">CompoundSelect</span><span class="s3">.</span><span class="s1">_create_union_all</span><span class="s3">(*</span><span class="s1">selects</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">values</span><span class="s3">(</span>
    <span class="s3">*</span><span class="s1">columns</span><span class="s3">: </span><span class="s1">ColumnClause</span><span class="s3">[</span><span class="s1">Any</span><span class="s3">],</span>
    <span class="s1">name</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">str</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">literal_binds</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; Values</span><span class="s3">:</span>
    <span class="s5">r&quot;&quot;&quot;Construct a :class:`_expression.Values` construct. 
 
    The column expressions and the actual data for 
    :class:`_expression.Values` are given in two separate steps.  The 
    constructor receives the column expressions typically as 
    :func:`_expression.column` constructs, 
    and the data is then passed via the 
    :meth:`_expression.Values.data` method as a list, 
    which can be called multiple 
    times to add more data, e.g.:: 
 
        from sqlalchemy import column 
        from sqlalchemy import values 
 
        value_expr = values( 
            column('id', Integer), 
            column('name', String), 
            name=&quot;my_values&quot; 
        ).data( 
            [(1, 'name1'), (2, 'name2'), (3, 'name3')] 
        ) 
 
    :param \*columns: column expressions, typically composed using 
     :func:`_expression.column` objects. 
 
    :param name: the name for this VALUES construct.  If omitted, the 
     VALUES construct will be unnamed in a SQL expression.   Different 
     backends may have different requirements here. 
 
    :param literal_binds: Defaults to False.  Whether or not to render 
     the data values inline in the SQL output, rather than using bound 
     parameters. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">Values</span><span class="s3">(*</span><span class="s1">columns</span><span class="s3">, </span><span class="s1">literal_binds</span><span class="s3">=</span><span class="s1">literal_binds</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">name</span><span class="s3">)</span>
</pre>
</body>
</html>