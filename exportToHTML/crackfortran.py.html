<html>
<head>
<title>crackfortran.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
crackfortran.py</font>
</center></td></tr></table>
<pre><span class="s0">#!/usr/bin/env python3</span>
<span class="s2">&quot;&quot;&quot; 
crackfortran --- read fortran (77,90) code and extract declaration information. 
 
Copyright 1999 -- 2011 Pearu Peterson all rights reserved. 
Copyright 2011 -- present NumPy Developers. 
Permission to use, modify, and distribute this software is given under the 
terms of the NumPy License. 
 
NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK. 
 
 
Usage of crackfortran: 
====================== 
Command line keys: -quiet,-verbose,-fix,-f77,-f90,-show,-h &lt;pyffilename&gt; 
                   -m &lt;module name for f77 routines&gt;,--ignore-contains 
Functions: crackfortran, crack2fortran 
The following Fortran statements/constructions are supported 
(or will be if needed): 
   block data,byte,call,character,common,complex,contains,data, 
   dimension,double complex,double precision,end,external,function, 
   implicit,integer,intent,interface,intrinsic, 
   logical,module,optional,parameter,private,public, 
   program,real,(sequence?),subroutine,type,use,virtual, 
   include,pythonmodule 
Note: 'virtual' is mapped to 'dimension'. 
Note: 'implicit integer (z) static (z)' is 'implicit static (z)' (this is minor bug). 
Note: code after 'contains' will be ignored until its scope ends. 
Note: 'common' statement is extended: dimensions are moved to variable definitions 
Note: f2py directive: &lt;commentchar&gt;f2py&lt;line&gt; is read as &lt;line&gt; 
Note: pythonmodule is introduced to represent Python module 
 
Usage: 
  `postlist=crackfortran(files)` 
  `postlist` contains declaration information read from the list of files `files`. 
  `crack2fortran(postlist)` returns a fortran code to be saved to pyf-file 
 
  `postlist` has the following structure: 
 *** it is a list of dictionaries containing `blocks': 
     B = {'block','body','vars','parent_block'[,'name','prefix','args','result', 
          'implicit','externals','interfaced','common','sortvars', 
          'commonvars','note']} 
     B['block'] = 'interface' | 'function' | 'subroutine' | 'module' | 
                  'program' | 'block data' | 'type' | 'pythonmodule' | 
                  'abstract interface' 
     B['body'] --- list containing `subblocks' with the same structure as `blocks' 
     B['parent_block'] --- dictionary of a parent block: 
                             C['body'][&lt;index&gt;]['parent_block'] is C 
     B['vars'] --- dictionary of variable definitions 
     B['sortvars'] --- dictionary of variable definitions sorted by dependence (independent first) 
     B['name'] --- name of the block (not if B['block']=='interface') 
     B['prefix'] --- prefix string (only if B['block']=='function') 
     B['args'] --- list of argument names if B['block']== 'function' | 'subroutine' 
     B['result'] --- name of the return value (only if B['block']=='function') 
     B['implicit'] --- dictionary {'a':&lt;variable definition&gt;,'b':...} | None 
     B['externals'] --- list of variables being external 
     B['interfaced'] --- list of variables being external and defined 
     B['common'] --- dictionary of common blocks (list of objects) 
     B['commonvars'] --- list of variables used in common blocks (dimensions are moved to variable definitions) 
     B['from'] --- string showing the 'parents' of the current block 
     B['use'] --- dictionary of modules used in current block: 
         {&lt;modulename&gt;:{['only':&lt;0|1&gt;],['map':{&lt;local_name1&gt;:&lt;use_name1&gt;,...}]}} 
     B['note'] --- list of LaTeX comments on the block 
     B['f2pyenhancements'] --- optional dictionary 
          {'threadsafe':'','fortranname':&lt;name&gt;, 
           'callstatement':&lt;C-expr&gt;|&lt;multi-line block&gt;, 
           'callprotoargument':&lt;C-expr-list&gt;, 
           'usercode':&lt;multi-line block&gt;|&lt;list of multi-line blocks&gt;, 
           'pymethoddef:&lt;multi-line block&gt;' 
           } 
     B['entry'] --- dictionary {entryname:argslist,..} 
     B['varnames'] --- list of variable names given in the order of reading the 
                       Fortran code, useful for derived types. 
     B['saved_interface'] --- a string of scanned routine signature, defines explicit interface 
 *** Variable definition is a dictionary 
     D = B['vars'][&lt;variable name&gt;] = 
     {'typespec'[,'attrspec','kindselector','charselector','=','typename']} 
     D['typespec'] = 'byte' | 'character' | 'complex' | 'double complex' | 
                     'double precision' | 'integer' | 'logical' | 'real' | 'type' 
     D['attrspec'] --- list of attributes (e.g. 'dimension(&lt;arrayspec&gt;)', 
                       'external','intent(in|out|inout|hide|c|callback|cache|aligned4|aligned8|aligned16)', 
                       'optional','required', etc) 
     K = D['kindselector'] = {['*','kind']} (only if D['typespec'] = 
                         'complex' | 'integer' | 'logical' | 'real' ) 
     C = D['charselector'] = {['*','len','kind','f2py_len']} 
                             (only if D['typespec']=='character') 
     D['='] --- initialization expression string 
     D['typename'] --- name of the type if D['typespec']=='type' 
     D['dimension'] --- list of dimension bounds 
     D['intent'] --- list of intent specifications 
     D['depend'] --- list of variable names on which current variable depends on 
     D['check'] --- list of C-expressions; if C-expr returns zero, exception is raised 
     D['note'] --- list of LaTeX comments on the variable 
 *** Meaning of kind/char selectors (few examples): 
     D['typespec&gt;']*K['*'] 
     D['typespec'](kind=K['kind']) 
     character*C['*'] 
     character(len=C['len'],kind=C['kind'], f2py_len=C['f2py_len']) 
     (see also fortran type declaration statement formats below) 
 
Fortran 90 type declaration statement format (F77 is subset of F90) 
==================================================================== 
(Main source: IBM XL Fortran 5.1 Language Reference Manual) 
type declaration = &lt;typespec&gt; [[&lt;attrspec&gt;]::] &lt;entitydecl&gt; 
&lt;typespec&gt; = byte                          | 
             character[&lt;charselector&gt;]     | 
             complex[&lt;kindselector&gt;]       | 
             double complex                | 
             double precision              | 
             integer[&lt;kindselector&gt;]       | 
             logical[&lt;kindselector&gt;]       | 
             real[&lt;kindselector&gt;]          | 
             type(&lt;typename&gt;) 
&lt;charselector&gt; = * &lt;charlen&gt;               | 
             ([len=]&lt;len&gt;[,[kind=]&lt;kind&gt;]) | 
             (kind=&lt;kind&gt;[,len=&lt;len&gt;]) 
&lt;kindselector&gt; = * &lt;intlen&gt;                | 
             ([kind=]&lt;kind&gt;) 
&lt;attrspec&gt; = comma separated list of attributes. 
             Only the following attributes are used in 
             building up the interface: 
                external 
                (parameter --- affects '=' key) 
                optional 
                intent 
             Other attributes are ignored. 
&lt;intentspec&gt; = in | out | inout 
&lt;arrayspec&gt; = comma separated list of dimension bounds. 
&lt;entitydecl&gt; = &lt;name&gt; [[*&lt;charlen&gt;][(&lt;arrayspec&gt;)] | [(&lt;arrayspec&gt;)]*&lt;charlen&gt;] 
                      [/&lt;init_expr&gt;/ | =&lt;init_expr&gt;] [,&lt;entitydecl&gt;] 
 
In addition, the following attributes are used: check,depend,note 
 
TODO: 
    * Apply 'parameter' attribute (e.g. 'integer parameter :: i=2' 'real x(i)' 
                                   -&gt; 'real x(2)') 
    The above may be solved by creating appropriate preprocessor program, for example. 
 
&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">string</span>
<span class="s3">import </span><span class="s1">fileinput</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">copy</span>
<span class="s3">import </span><span class="s1">platform</span>
<span class="s3">import </span><span class="s1">codecs</span>
<span class="s3">from </span><span class="s1">pathlib </span><span class="s3">import </span><span class="s1">Path</span>
<span class="s3">try</span><span class="s4">:</span>
    <span class="s3">import </span><span class="s1">charset_normalizer</span>
<span class="s3">except </span><span class="s1">ImportError</span><span class="s4">:</span>
    <span class="s1">charset_normalizer </span><span class="s4">= </span><span class="s3">None</span>

<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">__version__</span>

<span class="s0"># The environment provided by auxfuncs.py is needed for some calls to eval.</span>
<span class="s0"># As the needed functions cannot be determined by static inspection of the</span>
<span class="s0"># code, it is safest to use import * pending a major refactoring of f2py.</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">auxfuncs </span><span class="s3">import </span><span class="s4">*</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">symbolic</span>

<span class="s1">f2py_version </span><span class="s4">= </span><span class="s1">__version__</span><span class="s4">.</span><span class="s1">version</span>

<span class="s0"># Global flags:</span>
<span class="s1">strictf77 </span><span class="s4">= </span><span class="s5">1          </span><span class="s0"># Ignore `!' comments unless line[0]=='!'</span>
<span class="s1">sourcecodeform </span><span class="s4">= </span><span class="s6">'fix'  </span><span class="s0"># 'fix','free'</span>
<span class="s1">quiet </span><span class="s4">= </span><span class="s5">0              </span><span class="s0"># Be verbose if 0 (Obsolete: not used any more)</span>
<span class="s1">verbose </span><span class="s4">= </span><span class="s5">1            </span><span class="s0"># Be quiet if 0, extra verbose if &gt; 1.</span>
<span class="s1">tabchar </span><span class="s4">= </span><span class="s5">4 </span><span class="s4">* </span><span class="s6">' '</span>
<span class="s1">pyffilename </span><span class="s4">= </span><span class="s6">''</span>
<span class="s1">f77modulename </span><span class="s4">= </span><span class="s6">''</span>
<span class="s1">skipemptyends </span><span class="s4">= </span><span class="s5">0      </span><span class="s0"># for old F77 programs without 'program' statement</span>
<span class="s1">ignorecontains </span><span class="s4">= </span><span class="s5">1</span>
<span class="s1">dolowercase </span><span class="s4">= </span><span class="s5">1</span>
<span class="s1">debug </span><span class="s4">= []</span>

<span class="s0"># Global variables</span>
<span class="s1">beginpattern </span><span class="s4">= </span><span class="s6">''</span>
<span class="s1">currentfilename </span><span class="s4">= </span><span class="s6">''</span>
<span class="s1">expectbegin </span><span class="s4">= </span><span class="s5">1</span>
<span class="s1">f90modulevars </span><span class="s4">= {}</span>
<span class="s1">filepositiontext </span><span class="s4">= </span><span class="s6">''</span>
<span class="s1">gotnextfile </span><span class="s4">= </span><span class="s5">1</span>
<span class="s1">groupcache </span><span class="s4">= </span><span class="s3">None</span>
<span class="s1">groupcounter </span><span class="s4">= </span><span class="s5">0</span>
<span class="s1">grouplist </span><span class="s4">= {</span><span class="s1">groupcounter</span><span class="s4">: []}</span>
<span class="s1">groupname </span><span class="s4">= </span><span class="s6">''</span>
<span class="s1">include_paths </span><span class="s4">= []</span>
<span class="s1">neededmodule </span><span class="s4">= -</span><span class="s5">1</span>
<span class="s1">onlyfuncs </span><span class="s4">= []</span>
<span class="s1">previous_context </span><span class="s4">= </span><span class="s3">None</span>
<span class="s1">skipblocksuntil </span><span class="s4">= -</span><span class="s5">1</span>
<span class="s1">skipfuncs </span><span class="s4">= []</span>
<span class="s1">skipfunctions </span><span class="s4">= []</span>
<span class="s1">usermodules </span><span class="s4">= []</span>


<span class="s3">def </span><span class="s1">reset_global_f2py_vars</span><span class="s4">():</span>
    <span class="s3">global </span><span class="s1">groupcounter</span><span class="s4">, </span><span class="s1">grouplist</span><span class="s4">, </span><span class="s1">neededmodule</span><span class="s4">, </span><span class="s1">expectbegin</span>
    <span class="s3">global </span><span class="s1">skipblocksuntil</span><span class="s4">, </span><span class="s1">usermodules</span><span class="s4">, </span><span class="s1">f90modulevars</span><span class="s4">, </span><span class="s1">gotnextfile</span>
    <span class="s3">global </span><span class="s1">filepositiontext</span><span class="s4">, </span><span class="s1">currentfilename</span><span class="s4">, </span><span class="s1">skipfunctions</span><span class="s4">, </span><span class="s1">skipfuncs</span>
    <span class="s3">global </span><span class="s1">onlyfuncs</span><span class="s4">, </span><span class="s1">include_paths</span><span class="s4">, </span><span class="s1">previous_context</span>
    <span class="s3">global </span><span class="s1">strictf77</span><span class="s4">, </span><span class="s1">sourcecodeform</span><span class="s4">, </span><span class="s1">quiet</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">, </span><span class="s1">tabchar</span><span class="s4">, </span><span class="s1">pyffilename</span>
    <span class="s3">global </span><span class="s1">f77modulename</span><span class="s4">, </span><span class="s1">skipemptyends</span><span class="s4">, </span><span class="s1">ignorecontains</span><span class="s4">, </span><span class="s1">dolowercase</span><span class="s4">, </span><span class="s1">debug</span>

    <span class="s0"># flags</span>
    <span class="s1">strictf77 </span><span class="s4">= </span><span class="s5">1</span>
    <span class="s1">sourcecodeform </span><span class="s4">= </span><span class="s6">'fix'</span>
    <span class="s1">quiet </span><span class="s4">= </span><span class="s5">0</span>
    <span class="s1">verbose </span><span class="s4">= </span><span class="s5">1</span>
    <span class="s1">tabchar </span><span class="s4">= </span><span class="s5">4 </span><span class="s4">* </span><span class="s6">' '</span>
    <span class="s1">pyffilename </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s1">f77modulename </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s1">skipemptyends </span><span class="s4">= </span><span class="s5">0</span>
    <span class="s1">ignorecontains </span><span class="s4">= </span><span class="s5">1</span>
    <span class="s1">dolowercase </span><span class="s4">= </span><span class="s5">1</span>
    <span class="s1">debug </span><span class="s4">= []</span>
    <span class="s0"># variables</span>
    <span class="s1">groupcounter </span><span class="s4">= </span><span class="s5">0</span>
    <span class="s1">grouplist </span><span class="s4">= {</span><span class="s1">groupcounter</span><span class="s4">: []}</span>
    <span class="s1">neededmodule </span><span class="s4">= -</span><span class="s5">1</span>
    <span class="s1">expectbegin </span><span class="s4">= </span><span class="s5">1</span>
    <span class="s1">skipblocksuntil </span><span class="s4">= -</span><span class="s5">1</span>
    <span class="s1">usermodules </span><span class="s4">= []</span>
    <span class="s1">f90modulevars </span><span class="s4">= {}</span>
    <span class="s1">gotnextfile </span><span class="s4">= </span><span class="s5">1</span>
    <span class="s1">filepositiontext </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s1">currentfilename </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s1">skipfunctions </span><span class="s4">= []</span>
    <span class="s1">skipfuncs </span><span class="s4">= []</span>
    <span class="s1">onlyfuncs </span><span class="s4">= []</span>
    <span class="s1">include_paths </span><span class="s4">= []</span>
    <span class="s1">previous_context </span><span class="s4">= </span><span class="s3">None</span>


<span class="s3">def </span><span class="s1">outmess</span><span class="s4">(</span><span class="s1">line</span><span class="s4">, </span><span class="s1">flag</span><span class="s4">=</span><span class="s5">1</span><span class="s4">):</span>
    <span class="s3">global </span><span class="s1">filepositiontext</span>

    <span class="s3">if not </span><span class="s1">verbose</span><span class="s4">:</span>
        <span class="s3">return</span>
    <span class="s3">if not </span><span class="s1">quiet</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">flag</span><span class="s4">:</span>
            <span class="s1">sys</span><span class="s4">.</span><span class="s1">stdout</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s1">filepositiontext</span><span class="s4">)</span>
        <span class="s1">sys</span><span class="s4">.</span><span class="s1">stdout</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s1">line</span><span class="s4">)</span>

<span class="s1">re</span><span class="s4">.</span><span class="s1">_MAXCACHE </span><span class="s4">= </span><span class="s5">50</span>
<span class="s1">defaultimplicitrules </span><span class="s4">= {}</span>
<span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s6">&quot;abcdefghopqrstuvwxyz$_&quot;</span><span class="s4">:</span>
    <span class="s1">defaultimplicitrules</span><span class="s4">[</span><span class="s1">c</span><span class="s4">] = {</span><span class="s6">'typespec'</span><span class="s4">: </span><span class="s6">'real'</span><span class="s4">}</span>
<span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s6">&quot;ijklmn&quot;</span><span class="s4">:</span>
    <span class="s1">defaultimplicitrules</span><span class="s4">[</span><span class="s1">c</span><span class="s4">] = {</span><span class="s6">'typespec'</span><span class="s4">: </span><span class="s6">'integer'</span><span class="s4">}</span>
<span class="s1">badnames </span><span class="s4">= {}</span>
<span class="s1">invbadnames </span><span class="s4">= {}</span>
<span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'int'</span><span class="s4">, </span><span class="s6">'double'</span><span class="s4">, </span><span class="s6">'float'</span><span class="s4">, </span><span class="s6">'char'</span><span class="s4">, </span><span class="s6">'short'</span><span class="s4">, </span><span class="s6">'long'</span><span class="s4">, </span><span class="s6">'void'</span><span class="s4">, </span><span class="s6">'case'</span><span class="s4">, </span><span class="s6">'while'</span><span class="s4">,</span>
          <span class="s6">'return'</span><span class="s4">, </span><span class="s6">'signed'</span><span class="s4">, </span><span class="s6">'unsigned'</span><span class="s4">, </span><span class="s6">'if'</span><span class="s4">, </span><span class="s6">'for'</span><span class="s4">, </span><span class="s6">'typedef'</span><span class="s4">, </span><span class="s6">'sizeof'</span><span class="s4">, </span><span class="s6">'union'</span><span class="s4">,</span>
          <span class="s6">'struct'</span><span class="s4">, </span><span class="s6">'static'</span><span class="s4">, </span><span class="s6">'register'</span><span class="s4">, </span><span class="s6">'new'</span><span class="s4">, </span><span class="s6">'break'</span><span class="s4">, </span><span class="s6">'do'</span><span class="s4">, </span><span class="s6">'goto'</span><span class="s4">, </span><span class="s6">'switch'</span><span class="s4">,</span>
          <span class="s6">'continue'</span><span class="s4">, </span><span class="s6">'else'</span><span class="s4">, </span><span class="s6">'inline'</span><span class="s4">, </span><span class="s6">'extern'</span><span class="s4">, </span><span class="s6">'delete'</span><span class="s4">, </span><span class="s6">'const'</span><span class="s4">, </span><span class="s6">'auto'</span><span class="s4">,</span>
          <span class="s6">'len'</span><span class="s4">, </span><span class="s6">'rank'</span><span class="s4">, </span><span class="s6">'shape'</span><span class="s4">, </span><span class="s6">'index'</span><span class="s4">, </span><span class="s6">'slen'</span><span class="s4">, </span><span class="s6">'size'</span><span class="s4">, </span><span class="s6">'_i'</span><span class="s4">,</span>
          <span class="s6">'max'</span><span class="s4">, </span><span class="s6">'min'</span><span class="s4">,</span>
          <span class="s6">'flen'</span><span class="s4">, </span><span class="s6">'fshape'</span><span class="s4">,</span>
          <span class="s6">'string'</span><span class="s4">, </span><span class="s6">'complex_double'</span><span class="s4">, </span><span class="s6">'float_double'</span><span class="s4">, </span><span class="s6">'stdin'</span><span class="s4">, </span><span class="s6">'stderr'</span><span class="s4">, </span><span class="s6">'stdout'</span><span class="s4">,</span>
          <span class="s6">'type'</span><span class="s4">, </span><span class="s6">'default'</span><span class="s4">]:</span>
    <span class="s1">badnames</span><span class="s4">[</span><span class="s1">n</span><span class="s4">] = </span><span class="s1">n </span><span class="s4">+ </span><span class="s6">'_bn'</span>
    <span class="s1">invbadnames</span><span class="s4">[</span><span class="s1">n </span><span class="s4">+ </span><span class="s6">'_bn'</span><span class="s4">] = </span><span class="s1">n</span>


<span class="s3">def </span><span class="s1">rmbadname1</span><span class="s4">(</span><span class="s1">name</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">badnames</span><span class="s4">:</span>
        <span class="s1">errmess</span><span class="s4">(</span><span class="s6">'rmbadname1: Replacing &quot;%s&quot; with &quot;%s&quot;.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">%</span>
                <span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">badnames</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]))</span>
        <span class="s3">return </span><span class="s1">badnames</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">name</span>


<span class="s3">def </span><span class="s1">rmbadname</span><span class="s4">(</span><span class="s1">names</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s4">[</span><span class="s1">rmbadname1</span><span class="s4">(</span><span class="s1">_m</span><span class="s4">) </span><span class="s3">for </span><span class="s1">_m </span><span class="s3">in </span><span class="s1">names</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">undo_rmbadname1</span><span class="s4">(</span><span class="s1">name</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">invbadnames</span><span class="s4">:</span>
        <span class="s1">errmess</span><span class="s4">(</span><span class="s6">'undo_rmbadname1: Replacing &quot;%s&quot; with &quot;%s&quot;.</span><span class="s3">\n</span><span class="s6">'</span>
                <span class="s4">% (</span><span class="s1">name</span><span class="s4">, </span><span class="s1">invbadnames</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]))</span>
        <span class="s3">return </span><span class="s1">invbadnames</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">name</span>


<span class="s3">def </span><span class="s1">undo_rmbadname</span><span class="s4">(</span><span class="s1">names</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s4">[</span><span class="s1">undo_rmbadname1</span><span class="s4">(</span><span class="s1">_m</span><span class="s4">) </span><span class="s3">for </span><span class="s1">_m </span><span class="s3">in </span><span class="s1">names</span><span class="s4">]</span>


<span class="s1">_has_f_header </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'-\*-\s*fortran\s*-\*-'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">).</span><span class="s1">search</span>
<span class="s1">_has_f90_header </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'-\*-\s*f90\s*-\*-'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">).</span><span class="s1">search</span>
<span class="s1">_has_fix_header </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'-\*-\s*fix\s*-\*-'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">).</span><span class="s1">search</span>
<span class="s1">_free_f90_start </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'[^c*]\s*[^\s\d\t]'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">).</span><span class="s1">match</span>

<span class="s0"># Extensions</span>
<span class="s1">COMMON_FREE_EXTENSIONS </span><span class="s4">= [</span><span class="s6">'.f90'</span><span class="s4">, </span><span class="s6">'.f95'</span><span class="s4">, </span><span class="s6">'.f03'</span><span class="s4">, </span><span class="s6">'.f08'</span><span class="s4">]</span>
<span class="s1">COMMON_FIXED_EXTENSIONS </span><span class="s4">= [</span><span class="s6">'.for'</span><span class="s4">, </span><span class="s6">'.ftn'</span><span class="s4">, </span><span class="s6">'.f77'</span><span class="s4">, </span><span class="s6">'.f'</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">openhook</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">, </span><span class="s1">mode</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Ensures that filename is opened with correct encoding parameter. 
 
    This function uses charset_normalizer package, when available, for 
    determining the encoding of the file to be opened. When charset_normalizer 
    is not available, the function detects only UTF encodings, otherwise, ASCII 
    encoding is used as fallback. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Reads in the entire file. Robust detection of encoding.</span>
    <span class="s0"># Correctly handles comments or late stage unicode characters</span>
    <span class="s0"># gh-22871</span>
    <span class="s3">if </span><span class="s1">charset_normalizer </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">encoding </span><span class="s4">= </span><span class="s1">charset_normalizer</span><span class="s4">.</span><span class="s1">from_path</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">).</span><span class="s1">best</span><span class="s4">().</span><span class="s1">encoding</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s0"># hint: install charset_normalizer for correct encoding handling</span>
        <span class="s0"># No need to read the whole file for trying with startswith</span>
        <span class="s1">nbytes </span><span class="s4">= </span><span class="s1">min</span><span class="s4">(</span><span class="s5">32</span><span class="s4">, </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">getsize</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">))</span>
        <span class="s3">with </span><span class="s1">open</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">, </span><span class="s6">'rb'</span><span class="s4">) </span><span class="s3">as </span><span class="s1">fhandle</span><span class="s4">:</span>
            <span class="s1">raw </span><span class="s4">= </span><span class="s1">fhandle</span><span class="s4">.</span><span class="s1">read</span><span class="s4">(</span><span class="s1">nbytes</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">raw</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s1">codecs</span><span class="s4">.</span><span class="s1">BOM_UTF8</span><span class="s4">):</span>
                <span class="s1">encoding </span><span class="s4">= </span><span class="s6">'UTF-8-SIG'</span>
            <span class="s3">elif </span><span class="s1">raw</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">((</span><span class="s1">codecs</span><span class="s4">.</span><span class="s1">BOM_UTF32_LE</span><span class="s4">, </span><span class="s1">codecs</span><span class="s4">.</span><span class="s1">BOM_UTF32_BE</span><span class="s4">)):</span>
                <span class="s1">encoding </span><span class="s4">= </span><span class="s6">'UTF-32'</span>
            <span class="s3">elif </span><span class="s1">raw</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">((</span><span class="s1">codecs</span><span class="s4">.</span><span class="s1">BOM_LE</span><span class="s4">, </span><span class="s1">codecs</span><span class="s4">.</span><span class="s1">BOM_BE</span><span class="s4">)):</span>
                <span class="s1">encoding </span><span class="s4">= </span><span class="s6">'UTF-16'</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s0"># Fallback, without charset_normalizer</span>
                <span class="s1">encoding </span><span class="s4">= </span><span class="s6">'ascii'</span>
    <span class="s3">return </span><span class="s1">open</span><span class="s4">(</span><span class="s1">filename</span><span class="s4">, </span><span class="s1">mode</span><span class="s4">, </span><span class="s1">encoding</span><span class="s4">=</span><span class="s1">encoding</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">is_free_format</span><span class="s4">(</span><span class="s1">fname</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Check if file is in free format Fortran.&quot;&quot;&quot;</span>
    <span class="s0"># f90 allows both fixed and free format, assuming fixed unless</span>
    <span class="s0"># signs of free format are detected.</span>
    <span class="s1">result </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s3">if </span><span class="s1">Path</span><span class="s4">(</span><span class="s1">fname</span><span class="s4">).</span><span class="s1">suffix</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">() </span><span class="s3">in </span><span class="s1">COMMON_FREE_EXTENSIONS</span><span class="s4">:</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s3">with </span><span class="s1">openhook</span><span class="s4">(</span><span class="s1">fname</span><span class="s4">, </span><span class="s6">'r'</span><span class="s4">) </span><span class="s3">as </span><span class="s1">fhandle</span><span class="s4">:</span>
        <span class="s1">line </span><span class="s4">= </span><span class="s1">fhandle</span><span class="s4">.</span><span class="s1">readline</span><span class="s4">()</span>
        <span class="s1">n </span><span class="s4">= </span><span class="s5">15  </span><span class="s0"># the number of non-comment lines to scan for hints</span>
        <span class="s3">if </span><span class="s1">_has_f_header</span><span class="s4">(</span><span class="s1">line</span><span class="s4">):</span>
            <span class="s1">n </span><span class="s4">= </span><span class="s5">0</span>
        <span class="s3">elif </span><span class="s1">_has_f90_header</span><span class="s4">(</span><span class="s1">line</span><span class="s4">):</span>
            <span class="s1">n </span><span class="s4">= </span><span class="s5">0</span>
            <span class="s1">result </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s3">while </span><span class="s1">n </span><span class="s4">&gt; </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">line</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">line</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] != </span><span class="s6">'!' </span><span class="s3">and </span><span class="s1">line</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">():</span>
                <span class="s1">n </span><span class="s4">-= </span><span class="s5">1</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s1">line</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] != </span><span class="s6">'</span><span class="s3">\t</span><span class="s6">' </span><span class="s3">and </span><span class="s1">_free_f90_start</span><span class="s4">(</span><span class="s1">line</span><span class="s4">[:</span><span class="s5">5</span><span class="s4">])) </span><span class="s3">or </span><span class="s1">line</span><span class="s4">[-</span><span class="s5">2</span><span class="s4">:-</span><span class="s5">1</span><span class="s4">] == </span><span class="s6">'&amp;'</span><span class="s4">:</span>
                    <span class="s1">result </span><span class="s4">= </span><span class="s3">True</span>
                    <span class="s3">break</span>
            <span class="s1">line </span><span class="s4">= </span><span class="s1">fhandle</span><span class="s4">.</span><span class="s1">readline</span><span class="s4">()</span>
    <span class="s3">return </span><span class="s1">result</span>


<span class="s0"># Read fortran (77,90) code</span>
<span class="s3">def </span><span class="s1">readfortrancode</span><span class="s4">(</span><span class="s1">ffile</span><span class="s4">, </span><span class="s1">dowithline</span><span class="s4">=</span><span class="s1">show</span><span class="s4">, </span><span class="s1">istop</span><span class="s4">=</span><span class="s5">1</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Read fortran codes from files and 
     1) Get rid of comments, line continuations, and empty lines; lower cases. 
     2) Call dowithline(line) on every line. 
     3) Recursively call itself when statement \&quot;include '&lt;filename&gt;'\&quot; is met. 
    &quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">gotnextfile</span><span class="s4">, </span><span class="s1">filepositiontext</span><span class="s4">, </span><span class="s1">currentfilename</span><span class="s4">, </span><span class="s1">sourcecodeform</span><span class="s4">, </span><span class="s1">strictf77</span>
    <span class="s3">global </span><span class="s1">beginpattern</span><span class="s4">, </span><span class="s1">quiet</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">, </span><span class="s1">dolowercase</span><span class="s4">, </span><span class="s1">include_paths</span>

    <span class="s3">if not </span><span class="s1">istop</span><span class="s4">:</span>
        <span class="s1">saveglobals </span><span class="s4">= </span><span class="s1">gotnextfile</span><span class="s4">, </span><span class="s1">filepositiontext</span><span class="s4">, </span><span class="s1">currentfilename</span><span class="s4">, </span><span class="s1">sourcecodeform</span><span class="s4">, </span><span class="s1">strictf77</span><span class="s4">,</span><span class="s1">\</span>
            <span class="s1">beginpattern</span><span class="s4">, </span><span class="s1">quiet</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">, </span><span class="s1">dolowercase</span>
    <span class="s3">if </span><span class="s1">ffile </span><span class="s4">== []:</span>
        <span class="s3">return</span>
    <span class="s1">localdolowercase </span><span class="s4">= </span><span class="s1">dolowercase</span>
    <span class="s0"># cont: set to True when the content of the last line read</span>
    <span class="s0"># indicates statement continuation</span>
    <span class="s1">cont </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">finalline </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s1">ll </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s1">includeline </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
        <span class="s6">r'\s*include\s*(\'|&quot;)(?P&lt;name&gt;[^\'&quot;]*)(\'|&quot;)'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
    <span class="s1">cont1 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'(?P&lt;line&gt;.*)&amp;\s*\Z'</span><span class="s4">)</span>
    <span class="s1">cont2 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'(\s*&amp;|)(?P&lt;line&gt;.*)'</span><span class="s4">)</span>
    <span class="s1">mline_mark </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r&quot;.*?'''&quot;</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">istop</span><span class="s4">:</span>
        <span class="s1">dowithline</span><span class="s4">(</span><span class="s6">''</span><span class="s4">, -</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s1">ll</span><span class="s4">, </span><span class="s1">l1 </span><span class="s4">= </span><span class="s6">''</span><span class="s4">, </span><span class="s6">''</span>
    <span class="s1">spacedigits </span><span class="s4">= [</span><span class="s6">' '</span><span class="s4">] + [</span><span class="s1">str</span><span class="s4">(</span><span class="s1">_m</span><span class="s4">) </span><span class="s3">for </span><span class="s1">_m </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s5">10</span><span class="s4">)]</span>
    <span class="s1">filepositiontext </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s1">fin </span><span class="s4">= </span><span class="s1">fileinput</span><span class="s4">.</span><span class="s1">FileInput</span><span class="s4">(</span><span class="s1">ffile</span><span class="s4">, </span><span class="s1">openhook</span><span class="s4">=</span><span class="s1">openhook</span><span class="s4">)</span>
    <span class="s3">while True</span><span class="s4">:</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">l </span><span class="s4">= </span><span class="s1">fin</span><span class="s4">.</span><span class="s1">readline</span><span class="s4">()</span>
        <span class="s3">except </span><span class="s1">UnicodeDecodeError </span><span class="s3">as </span><span class="s1">msg</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">Exception</span><span class="s4">(</span>
                <span class="s6">f'readfortrancode: reading </span><span class="s3">{</span><span class="s1">fin</span><span class="s4">.</span><span class="s1">filename</span><span class="s4">()</span><span class="s3">}</span><span class="s6">#</span><span class="s3">{</span><span class="s1">fin</span><span class="s4">.</span><span class="s1">lineno</span><span class="s4">()</span><span class="s3">}</span><span class="s6">'</span>
                <span class="s6">f' failed with</span><span class="s3">\n{</span><span class="s1">msg</span><span class="s3">}</span><span class="s6">.</span><span class="s3">\n</span><span class="s6">It is likely that installing charset_normalizer'</span>
                <span class="s6">' package will help f2py determine the input file encoding'</span>
                <span class="s6">' correctly.'</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">l</span><span class="s4">:</span>
            <span class="s3">break</span>
        <span class="s3">if </span><span class="s1">fin</span><span class="s4">.</span><span class="s1">isfirstline</span><span class="s4">():</span>
            <span class="s1">filepositiontext </span><span class="s4">= </span><span class="s6">''</span>
            <span class="s1">currentfilename </span><span class="s4">= </span><span class="s1">fin</span><span class="s4">.</span><span class="s1">filename</span><span class="s4">()</span>
            <span class="s1">gotnextfile </span><span class="s4">= </span><span class="s5">1</span>
            <span class="s1">l1 </span><span class="s4">= </span><span class="s1">l</span>
            <span class="s1">strictf77 </span><span class="s4">= </span><span class="s5">0</span>
            <span class="s1">sourcecodeform </span><span class="s4">= </span><span class="s6">'fix'</span>
            <span class="s1">ext </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">splitext</span><span class="s4">(</span><span class="s1">currentfilename</span><span class="s4">)[</span><span class="s5">1</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">Path</span><span class="s4">(</span><span class="s1">currentfilename</span><span class="s4">).</span><span class="s1">suffix</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">() </span><span class="s3">in </span><span class="s1">COMMON_FIXED_EXTENSIONS </span><span class="s3">and </span><span class="s1">\</span>
                    <span class="s3">not </span><span class="s4">(</span><span class="s1">_has_f90_header</span><span class="s4">(</span><span class="s1">l</span><span class="s4">) </span><span class="s3">or </span><span class="s1">_has_fix_header</span><span class="s4">(</span><span class="s1">l</span><span class="s4">)):</span>
                <span class="s1">strictf77 </span><span class="s4">= </span><span class="s5">1</span>
            <span class="s3">elif </span><span class="s1">is_free_format</span><span class="s4">(</span><span class="s1">currentfilename</span><span class="s4">) </span><span class="s3">and not </span><span class="s1">_has_fix_header</span><span class="s4">(</span><span class="s1">l</span><span class="s4">):</span>
                <span class="s1">sourcecodeform </span><span class="s4">= </span><span class="s6">'free'</span>
            <span class="s3">if </span><span class="s1">strictf77</span><span class="s4">:</span>
                <span class="s1">beginpattern </span><span class="s4">= </span><span class="s1">beginpattern77</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">beginpattern </span><span class="s4">= </span><span class="s1">beginpattern90</span>
            <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'</span><span class="s3">\t</span><span class="s6">Reading file %s (format:%s%s)</span><span class="s3">\n</span><span class="s6">'</span>
                    <span class="s4">% (</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">currentfilename</span><span class="s4">), </span><span class="s1">sourcecodeform</span><span class="s4">,</span>
                       <span class="s1">strictf77 </span><span class="s3">and </span><span class="s6">',strict' </span><span class="s3">or </span><span class="s6">''</span><span class="s4">))</span>

        <span class="s1">l </span><span class="s4">= </span><span class="s1">l</span><span class="s4">.</span><span class="s1">expandtabs</span><span class="s4">().</span><span class="s1">replace</span><span class="s4">(</span><span class="s6">'</span><span class="s3">\xa0</span><span class="s6">'</span><span class="s4">, </span><span class="s6">' '</span><span class="s4">)</span>
        <span class="s0"># Get rid of newline characters</span>
        <span class="s3">while not </span><span class="s1">l </span><span class="s4">== </span><span class="s6">''</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">l</span><span class="s4">[-</span><span class="s5">1</span><span class="s4">] </span><span class="s3">not in </span><span class="s6">&quot;</span><span class="s3">\n\r\f</span><span class="s6">&quot;</span><span class="s4">:</span>
                <span class="s3">break</span>
            <span class="s1">l </span><span class="s4">= </span><span class="s1">l</span><span class="s4">[:-</span><span class="s5">1</span><span class="s4">]</span>
        <span class="s0"># Unconditionally remove comments</span>
        <span class="s4">(</span><span class="s1">l</span><span class="s4">, </span><span class="s1">rl</span><span class="s4">) = </span><span class="s1">split_by_unquoted</span><span class="s4">(</span><span class="s1">l</span><span class="s4">, </span><span class="s6">'!'</span><span class="s4">)</span>
        <span class="s1">l </span><span class="s4">+= </span><span class="s6">' '</span>
        <span class="s3">if </span><span class="s1">rl</span><span class="s4">[:</span><span class="s5">5</span><span class="s4">].</span><span class="s1">lower</span><span class="s4">() == </span><span class="s6">'!f2py'</span><span class="s4">:  </span><span class="s0"># f2py directive</span>
            <span class="s1">l</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">split_by_unquoted</span><span class="s4">(</span><span class="s1">l </span><span class="s4">+ </span><span class="s5">4 </span><span class="s4">* </span><span class="s6">' ' </span><span class="s4">+ </span><span class="s1">rl</span><span class="s4">[</span><span class="s5">5</span><span class="s4">:], </span><span class="s6">'!'</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">l</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">() == </span><span class="s6">''</span><span class="s4">:  </span><span class="s0"># Skip empty line</span>
            <span class="s3">if </span><span class="s1">sourcecodeform </span><span class="s4">== </span><span class="s6">'free'</span><span class="s4">:</span>
                <span class="s0"># In free form, a statement continues in the next line</span>
                <span class="s0"># that is not a comment line [3.3.2.4^1], lines with</span>
                <span class="s0"># blanks are comment lines [3.3.2.3^1]. Hence, the</span>
                <span class="s0"># line continuation flag must retain its state.</span>
                <span class="s3">pass</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s0"># In fixed form, statement continuation is determined</span>
                <span class="s0"># by a non-blank character at the 6-th position. Empty</span>
                <span class="s0"># line indicates a start of a new statement</span>
                <span class="s0"># [3.3.3.3^1]. Hence, the line continuation flag must</span>
                <span class="s0"># be reset.</span>
                <span class="s1">cont </span><span class="s4">= </span><span class="s3">False</span>
            <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">sourcecodeform </span><span class="s4">== </span><span class="s6">'fix'</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">l</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'*'</span><span class="s4">, </span><span class="s6">'c'</span><span class="s4">, </span><span class="s6">'!'</span><span class="s4">, </span><span class="s6">'C'</span><span class="s4">, </span><span class="s6">'#'</span><span class="s4">]:</span>
                <span class="s3">if </span><span class="s1">l</span><span class="s4">[</span><span class="s5">1</span><span class="s4">:</span><span class="s5">5</span><span class="s4">].</span><span class="s1">lower</span><span class="s4">() == </span><span class="s6">'f2py'</span><span class="s4">:  </span><span class="s0"># f2py directive</span>
                    <span class="s1">l </span><span class="s4">= </span><span class="s6">'     ' </span><span class="s4">+ </span><span class="s1">l</span><span class="s4">[</span><span class="s5">5</span><span class="s4">:]</span>
                <span class="s3">else</span><span class="s4">:  </span><span class="s0"># Skip comment line</span>
                    <span class="s1">cont </span><span class="s4">= </span><span class="s3">False</span>
                    <span class="s3">continue</span>
            <span class="s3">elif </span><span class="s1">strictf77</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">l</span><span class="s4">) &gt; </span><span class="s5">72</span><span class="s4">:</span>
                    <span class="s1">l </span><span class="s4">= </span><span class="s1">l</span><span class="s4">[:</span><span class="s5">72</span><span class="s4">]</span>
            <span class="s3">if not </span><span class="s4">(</span><span class="s1">l</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] </span><span class="s3">in </span><span class="s1">spacedigits</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">Exception</span><span class="s4">(</span><span class="s6">'readfortrancode: Found non-(space,digit) char '</span>
                                <span class="s6">'in the first column.</span><span class="s3">\n\t</span><span class="s6">Are you sure that '</span>
                                <span class="s6">'this code is in fix form?</span><span class="s3">\n\t</span><span class="s6">line=%s' </span><span class="s4">% </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">l</span><span class="s4">))</span>

            <span class="s3">if </span><span class="s4">(</span><span class="s3">not </span><span class="s1">cont </span><span class="s3">or </span><span class="s1">strictf77</span><span class="s4">) </span><span class="s3">and </span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">l</span><span class="s4">) &gt; </span><span class="s5">5 </span><span class="s3">and not </span><span class="s1">l</span><span class="s4">[</span><span class="s5">5</span><span class="s4">] == </span><span class="s6">' '</span><span class="s4">):</span>
                <span class="s0"># Continuation of a previous line</span>
                <span class="s1">ll </span><span class="s4">= </span><span class="s1">ll </span><span class="s4">+ </span><span class="s1">l</span><span class="s4">[</span><span class="s5">6</span><span class="s4">:]</span>
                <span class="s1">finalline </span><span class="s4">= </span><span class="s6">''</span>
                <span class="s1">origfinalline </span><span class="s4">= </span><span class="s6">''</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">r </span><span class="s4">= </span><span class="s1">cont1</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">l</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">r</span><span class="s4">:</span>
                    <span class="s1">l </span><span class="s4">= </span><span class="s1">r</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'line'</span><span class="s4">) </span><span class="s0"># Continuation follows ..</span>
                <span class="s3">if </span><span class="s1">cont</span><span class="s4">:</span>
                    <span class="s1">ll </span><span class="s4">= </span><span class="s1">ll </span><span class="s4">+ </span><span class="s1">cont2</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">l</span><span class="s4">).</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'line'</span><span class="s4">)</span>
                    <span class="s1">finalline </span><span class="s4">= </span><span class="s6">''</span>
                    <span class="s1">origfinalline </span><span class="s4">= </span><span class="s6">''</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s0"># clean up line beginning from possible digits.</span>
                    <span class="s1">l </span><span class="s4">= </span><span class="s6">'     ' </span><span class="s4">+ </span><span class="s1">l</span><span class="s4">[</span><span class="s5">5</span><span class="s4">:]</span>
                    <span class="s3">if </span><span class="s1">localdolowercase</span><span class="s4">:</span>
                        <span class="s1">finalline </span><span class="s4">= </span><span class="s1">ll</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">()</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">finalline </span><span class="s4">= </span><span class="s1">ll</span>
                    <span class="s1">origfinalline </span><span class="s4">= </span><span class="s1">ll</span>
                    <span class="s1">ll </span><span class="s4">= </span><span class="s1">l</span>

        <span class="s3">elif </span><span class="s1">sourcecodeform </span><span class="s4">== </span><span class="s6">'free'</span><span class="s4">:</span>
            <span class="s3">if not </span><span class="s1">cont </span><span class="s3">and </span><span class="s1">ext </span><span class="s4">== </span><span class="s6">'.pyf' </span><span class="s3">and </span><span class="s1">mline_mark</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">l</span><span class="s4">):</span>
                <span class="s1">l </span><span class="s4">= </span><span class="s1">l </span><span class="s4">+ </span><span class="s6">'</span><span class="s3">\n</span><span class="s6">'</span>
                <span class="s3">while True</span><span class="s4">:</span>
                    <span class="s1">lc </span><span class="s4">= </span><span class="s1">fin</span><span class="s4">.</span><span class="s1">readline</span><span class="s4">()</span>
                    <span class="s3">if not </span><span class="s1">lc</span><span class="s4">:</span>
                        <span class="s1">errmess</span><span class="s4">(</span>
                            <span class="s6">'Unexpected end of file when reading multiline</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">)</span>
                        <span class="s3">break</span>
                    <span class="s1">l </span><span class="s4">= </span><span class="s1">l </span><span class="s4">+ </span><span class="s1">lc</span>
                    <span class="s3">if </span><span class="s1">mline_mark</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">lc</span><span class="s4">):</span>
                        <span class="s3">break</span>
                <span class="s1">l </span><span class="s4">= </span><span class="s1">l</span><span class="s4">.</span><span class="s1">rstrip</span><span class="s4">()</span>
            <span class="s1">r </span><span class="s4">= </span><span class="s1">cont1</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">l</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">r</span><span class="s4">:</span>
                <span class="s1">l </span><span class="s4">= </span><span class="s1">r</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'line'</span><span class="s4">)  </span><span class="s0"># Continuation follows ..</span>
            <span class="s3">if </span><span class="s1">cont</span><span class="s4">:</span>
                <span class="s1">ll </span><span class="s4">= </span><span class="s1">ll </span><span class="s4">+ </span><span class="s1">cont2</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">l</span><span class="s4">).</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'line'</span><span class="s4">)</span>
                <span class="s1">finalline </span><span class="s4">= </span><span class="s6">''</span>
                <span class="s1">origfinalline </span><span class="s4">= </span><span class="s6">''</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">localdolowercase</span><span class="s4">:</span>
                    <span class="s1">finalline </span><span class="s4">= </span><span class="s1">ll</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">()</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">finalline </span><span class="s4">= </span><span class="s1">ll</span>
                <span class="s1">origfinalline </span><span class="s4">= </span><span class="s1">ll</span>
                <span class="s1">ll </span><span class="s4">= </span><span class="s1">l</span>
            <span class="s1">cont </span><span class="s4">= (</span><span class="s1">r </span><span class="s3">is not None</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s6">&quot;Flag sourcecodeform must be either 'fix' or 'free': %s&quot; </span><span class="s4">% </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">sourcecodeform</span><span class="s4">))</span>
        <span class="s1">filepositiontext </span><span class="s4">= </span><span class="s6">'Line #%d in %s:&quot;%s&quot;</span><span class="s3">\n\t</span><span class="s6">' </span><span class="s4">% (</span>
            <span class="s1">fin</span><span class="s4">.</span><span class="s1">filelineno</span><span class="s4">() - </span><span class="s5">1</span><span class="s4">, </span><span class="s1">currentfilename</span><span class="s4">, </span><span class="s1">l1</span><span class="s4">)</span>
        <span class="s1">m </span><span class="s4">= </span><span class="s1">includeline</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">origfinalline</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">m</span><span class="s4">:</span>
            <span class="s1">fn </span><span class="s4">= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'name'</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">isfile</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">):</span>
                <span class="s1">readfortrancode</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">, </span><span class="s1">dowithline</span><span class="s4">=</span><span class="s1">dowithline</span><span class="s4">, </span><span class="s1">istop</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">include_dirs </span><span class="s4">= [</span>
                    <span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">dirname</span><span class="s4">(</span><span class="s1">currentfilename</span><span class="s4">)] + </span><span class="s1">include_paths</span>
                <span class="s1">foundfile </span><span class="s4">= </span><span class="s5">0</span>
                <span class="s3">for </span><span class="s1">inc_dir </span><span class="s3">in </span><span class="s1">include_dirs</span><span class="s4">:</span>
                    <span class="s1">fn1 </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">inc_dir</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">isfile</span><span class="s4">(</span><span class="s1">fn1</span><span class="s4">):</span>
                        <span class="s1">foundfile </span><span class="s4">= </span><span class="s5">1</span>
                        <span class="s1">readfortrancode</span><span class="s4">(</span><span class="s1">fn1</span><span class="s4">, </span><span class="s1">dowithline</span><span class="s4">=</span><span class="s1">dowithline</span><span class="s4">, </span><span class="s1">istop</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
                        <span class="s3">break</span>
                <span class="s3">if not </span><span class="s1">foundfile</span><span class="s4">:</span>
                    <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'readfortrancode: could not find include file %s in %s. Ignoring.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span>
                        <span class="s1">repr</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">), </span><span class="s1">os</span><span class="s4">.</span><span class="s1">pathsep</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">include_dirs</span><span class="s4">)))</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">dowithline</span><span class="s4">(</span><span class="s1">finalline</span><span class="s4">)</span>
        <span class="s1">l1 </span><span class="s4">= </span><span class="s1">ll</span>
    <span class="s3">if </span><span class="s1">localdolowercase</span><span class="s4">:</span>
        <span class="s1">finalline </span><span class="s4">= </span><span class="s1">ll</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">()</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">finalline </span><span class="s4">= </span><span class="s1">ll</span>
    <span class="s1">origfinalline </span><span class="s4">= </span><span class="s1">ll</span>
    <span class="s1">filepositiontext </span><span class="s4">= </span><span class="s6">'Line #%d in %s:&quot;%s&quot;</span><span class="s3">\n\t</span><span class="s6">' </span><span class="s4">% (</span>
        <span class="s1">fin</span><span class="s4">.</span><span class="s1">filelineno</span><span class="s4">() - </span><span class="s5">1</span><span class="s4">, </span><span class="s1">currentfilename</span><span class="s4">, </span><span class="s1">l1</span><span class="s4">)</span>
    <span class="s1">m </span><span class="s4">= </span><span class="s1">includeline</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">origfinalline</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">m</span><span class="s4">:</span>
        <span class="s1">fn </span><span class="s4">= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'name'</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">isfile</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">):</span>
            <span class="s1">readfortrancode</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">, </span><span class="s1">dowithline</span><span class="s4">=</span><span class="s1">dowithline</span><span class="s4">, </span><span class="s1">istop</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">include_dirs </span><span class="s4">= [</span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">dirname</span><span class="s4">(</span><span class="s1">currentfilename</span><span class="s4">)] + </span><span class="s1">include_paths</span>
            <span class="s1">foundfile </span><span class="s4">= </span><span class="s5">0</span>
            <span class="s3">for </span><span class="s1">inc_dir </span><span class="s3">in </span><span class="s1">include_dirs</span><span class="s4">:</span>
                <span class="s1">fn1 </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">inc_dir</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">isfile</span><span class="s4">(</span><span class="s1">fn1</span><span class="s4">):</span>
                    <span class="s1">foundfile </span><span class="s4">= </span><span class="s5">1</span>
                    <span class="s1">readfortrancode</span><span class="s4">(</span><span class="s1">fn1</span><span class="s4">, </span><span class="s1">dowithline</span><span class="s4">=</span><span class="s1">dowithline</span><span class="s4">, </span><span class="s1">istop</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
                    <span class="s3">break</span>
            <span class="s3">if not </span><span class="s1">foundfile</span><span class="s4">:</span>
                <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'readfortrancode: could not find include file %s in %s. Ignoring.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span>
                    <span class="s1">repr</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">), </span><span class="s1">os</span><span class="s4">.</span><span class="s1">pathsep</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">include_dirs</span><span class="s4">)))</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">dowithline</span><span class="s4">(</span><span class="s1">finalline</span><span class="s4">)</span>
    <span class="s1">filepositiontext </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s1">fin</span><span class="s4">.</span><span class="s1">close</span><span class="s4">()</span>
    <span class="s3">if </span><span class="s1">istop</span><span class="s4">:</span>
        <span class="s1">dowithline</span><span class="s4">(</span><span class="s6">''</span><span class="s4">, </span><span class="s5">1</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">gotnextfile</span><span class="s4">, </span><span class="s1">filepositiontext</span><span class="s4">, </span><span class="s1">currentfilename</span><span class="s4">, </span><span class="s1">sourcecodeform</span><span class="s4">, </span><span class="s1">strictf77</span><span class="s4">,</span><span class="s1">\</span>
            <span class="s1">beginpattern</span><span class="s4">, </span><span class="s1">quiet</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">, </span><span class="s1">dolowercase </span><span class="s4">= </span><span class="s1">saveglobals</span>

<span class="s0"># Crack line</span>
<span class="s1">beforethisafter </span><span class="s4">= </span><span class="s6">r'\s*(?P&lt;before&gt;%s(?=\s*(\b(%s)\b)))' </span><span class="s4">+ </span><span class="s1">\</span>
    <span class="s6">r'\s*(?P&lt;this&gt;(\b(%s)\b))' </span><span class="s4">+ </span><span class="s1">\</span>
    <span class="s6">r'\s*(?P&lt;after&gt;%s)\s*\Z'</span>
<span class="s0">##</span>
<span class="s1">fortrantypes </span><span class="s4">= </span><span class="s6">r'character|logical|integer|real|complex|double\s*(precision\s*(complex|)|complex)|type(?=\s*\([\w\s,=(*)]*\))|byte'</span>
<span class="s1">typespattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s1">fortrantypes</span><span class="s4">, </span><span class="s1">fortrantypes</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'type'</span>
<span class="s1">typespattern4implicit </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s1">beforethisafter </span><span class="s4">% (</span>
    <span class="s6">''</span><span class="s4">, </span><span class="s1">fortrantypes </span><span class="s4">+ </span><span class="s6">'|static|automatic|undefined'</span><span class="s4">, </span><span class="s1">fortrantypes </span><span class="s4">+ </span><span class="s6">'|static|automatic|undefined'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
<span class="s0">#</span>
<span class="s1">functionpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s1">beforethisafter </span><span class="s4">% (</span>
    <span class="s6">r'([a-z]+[\w\s(=*+-/)]*?|)'</span><span class="s4">, </span><span class="s6">'function'</span><span class="s4">, </span><span class="s6">'function'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'begin'</span>
<span class="s1">subroutinepattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s1">beforethisafter </span><span class="s4">% (</span>
    <span class="s6">r'[a-z\s]*?'</span><span class="s4">, </span><span class="s6">'subroutine'</span><span class="s4">, </span><span class="s6">'subroutine'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'begin'</span>
<span class="s0"># modulepattern=re.compile(beforethisafter%('[a-z\s]*?','module','module','.*'),re.I),'begin'</span>
<span class="s0">#</span>
<span class="s1">groupbegins77 </span><span class="s4">= </span><span class="s6">r'program|block\s*data'</span>
<span class="s1">beginpattern77 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s1">groupbegins77</span><span class="s4">, </span><span class="s1">groupbegins77</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'begin'</span>
<span class="s1">groupbegins90 </span><span class="s4">= </span><span class="s1">groupbegins77 </span><span class="s4">+ </span><span class="s1">\</span>
    <span class="s6">r'|module(?!\s*procedure)|python\s*module|(abstract|)\s*interface|' </span><span class="s4">+ </span><span class="s1">\</span>
    <span class="s6">r'type(?!\s*\()'</span>
<span class="s1">beginpattern90 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s1">groupbegins90</span><span class="s4">, </span><span class="s1">groupbegins90</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'begin'</span>
<span class="s1">groupends </span><span class="s4">= (</span><span class="s6">r'end|endprogram|endblockdata|endmodule|endpythonmodule|'</span>
             <span class="s6">r'endinterface|endsubroutine|endfunction'</span><span class="s4">)</span>
<span class="s1">endpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s1">groupends</span><span class="s4">, </span><span class="s1">groupends</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'end'</span>
<span class="s0"># block, the Fortran 2008 construct needs special handling in the rest of the file</span>
<span class="s1">endifs </span><span class="s4">= </span><span class="s6">r'end\s*(if|do|where|select|while|forall|associate|' </span><span class="s4">+ </span><span class="s1">\</span>
         <span class="s6">r'critical|enum|team)'</span>
<span class="s1">endifpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">r'[\w]*?'</span><span class="s4">, </span><span class="s1">endifs</span><span class="s4">, </span><span class="s1">endifs</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'endif'</span>
<span class="s0">#</span>
<span class="s1">moduleprocedures </span><span class="s4">= </span><span class="s6">r'module\s*procedure'</span>
<span class="s1">moduleprocedurepattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s1">moduleprocedures</span><span class="s4">, </span><span class="s1">moduleprocedures</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s1">\</span>
    <span class="s6">'moduleprocedure'</span>
<span class="s1">implicitpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s6">'implicit'</span><span class="s4">, </span><span class="s6">'implicit'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'implicit'</span>
<span class="s1">dimensionpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s1">beforethisafter </span><span class="s4">% (</span>
    <span class="s6">''</span><span class="s4">, </span><span class="s6">'dimension|virtual'</span><span class="s4">, </span><span class="s6">'dimension|virtual'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'dimension'</span>
<span class="s1">externalpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s6">'external'</span><span class="s4">, </span><span class="s6">'external'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'external'</span>
<span class="s1">optionalpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s6">'optional'</span><span class="s4">, </span><span class="s6">'optional'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'optional'</span>
<span class="s1">requiredpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s6">'required'</span><span class="s4">, </span><span class="s6">'required'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'required'</span>
<span class="s1">publicpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s6">'public'</span><span class="s4">, </span><span class="s6">'public'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'public'</span>
<span class="s1">privatepattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s6">'private'</span><span class="s4">, </span><span class="s6">'private'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'private'</span>
<span class="s1">intrinsicpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s6">'intrinsic'</span><span class="s4">, </span><span class="s6">'intrinsic'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'intrinsic'</span>
<span class="s1">intentpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s1">beforethisafter </span><span class="s4">% (</span>
    <span class="s6">''</span><span class="s4">, </span><span class="s6">'intent|depend|note|check'</span><span class="s4">, </span><span class="s6">'intent|depend|note|check'</span><span class="s4">, </span><span class="s6">r'\s*\(.*?\).*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'intent'</span>
<span class="s1">parameterpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s6">'parameter'</span><span class="s4">, </span><span class="s6">'parameter'</span><span class="s4">, </span><span class="s6">r'\s*\(.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'parameter'</span>
<span class="s1">datapattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s6">'data'</span><span class="s4">, </span><span class="s6">'data'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'data'</span>
<span class="s1">callpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s6">'call'</span><span class="s4">, </span><span class="s6">'call'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'call'</span>
<span class="s1">entrypattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s6">'entry'</span><span class="s4">, </span><span class="s6">'entry'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'entry'</span>
<span class="s1">callfunpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s6">'callfun'</span><span class="s4">, </span><span class="s6">'callfun'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'callfun'</span>
<span class="s1">commonpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s6">'common'</span><span class="s4">, </span><span class="s6">'common'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'common'</span>
<span class="s1">usepattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s6">'use'</span><span class="s4">, </span><span class="s6">'use'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'use'</span>
<span class="s1">containspattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s6">'contains'</span><span class="s4">, </span><span class="s6">'contains'</span><span class="s4">, </span><span class="s6">''</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'contains'</span>
<span class="s1">formatpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s6">'format'</span><span class="s4">, </span><span class="s6">'format'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">), </span><span class="s6">'format'</span>
<span class="s0"># Non-fortran and f2py-specific statements</span>
<span class="s1">f2pyenhancementspattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s1">beforethisafter </span><span class="s4">% (</span><span class="s6">''</span><span class="s4">, </span><span class="s6">'threadsafe|fortranname|callstatement|callprotoargument|usercode|pymethoddef'</span><span class="s4">,</span>
                                                        <span class="s6">'threadsafe|fortranname|callstatement|callprotoargument|usercode|pymethoddef'</span><span class="s4">, </span><span class="s6">'.*'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I </span><span class="s4">| </span><span class="s1">re</span><span class="s4">.</span><span class="s1">S</span><span class="s4">), </span><span class="s6">'f2pyenhancements'</span>
<span class="s1">multilinepattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s6">r&quot;\s*(?P&lt;before&gt;''')(?P&lt;this&gt;.*?)(?P&lt;after&gt;''')\s*\Z&quot;</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">S</span><span class="s4">), </span><span class="s6">'multiline'</span>
<span class="s0">##</span>

<span class="s3">def </span><span class="s1">split_by_unquoted</span><span class="s4">(</span><span class="s1">line</span><span class="s4">, </span><span class="s1">characters</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Splits the line into (line[:i], line[i:]), 
    where i is the index of first occurrence of one of the characters 
    not within quotes, or len(line) if no such index exists 
    &quot;&quot;&quot;</span>
    <span class="s3">assert not </span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s6">'&quot;</span><span class="s3">\'</span><span class="s6">'</span><span class="s4">) &amp; </span><span class="s1">set</span><span class="s4">(</span><span class="s1">characters</span><span class="s4">)), </span><span class="s6">&quot;cannot split by unquoted quotes&quot;</span>
    <span class="s1">r </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
        <span class="s6">r&quot;\A(?P&lt;before&gt;({single_quoted}|{double_quoted}|{not_quoted})*)&quot;</span>
        <span class="s6">r&quot;(?P&lt;after&gt;{char}.*)\Z&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span>
            <span class="s1">not_quoted</span><span class="s4">=</span><span class="s6">&quot;[^</span><span class="s3">\&quot;</span><span class="s6">'{}]&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">re</span><span class="s4">.</span><span class="s1">escape</span><span class="s4">(</span><span class="s1">characters</span><span class="s4">)),</span>
            <span class="s1">char</span><span class="s4">=</span><span class="s6">&quot;[{}]&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">re</span><span class="s4">.</span><span class="s1">escape</span><span class="s4">(</span><span class="s1">characters</span><span class="s4">)),</span>
            <span class="s1">single_quoted</span><span class="s4">=</span><span class="s6">r&quot;('([^'\\]|(\\.))*')&quot;</span><span class="s4">,</span>
            <span class="s1">double_quoted</span><span class="s4">=</span><span class="s6">r'(&quot;([^&quot;\\]|(\\.))*&quot;)'</span><span class="s4">))</span>
    <span class="s1">m </span><span class="s4">= </span><span class="s1">r</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">line</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">m</span><span class="s4">:</span>
        <span class="s1">d </span><span class="s4">= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">groupdict</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">d</span><span class="s4">[</span><span class="s6">&quot;before&quot;</span><span class="s4">], </span><span class="s1">d</span><span class="s4">[</span><span class="s6">&quot;after&quot;</span><span class="s4">])</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">line</span><span class="s4">, </span><span class="s6">&quot;&quot;</span><span class="s4">)</span>

<span class="s3">def </span><span class="s1">_simplifyargs</span><span class="s4">(</span><span class="s1">argsline</span><span class="s4">):</span>
    <span class="s1">a </span><span class="s4">= []</span>
    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">argsline</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@,@'</span><span class="s4">):</span>
        <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s6">'(),'</span><span class="s4">:</span>
            <span class="s1">n </span><span class="s4">= </span><span class="s1">n</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s1">r</span><span class="s4">, </span><span class="s6">'_'</span><span class="s4">)</span>
        <span class="s1">a</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s6">','</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>

<span class="s1">crackline_re_1 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'\s*(?P&lt;result&gt;\b[a-z]+\w*\b)\s*=.*'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
<span class="s1">crackline_bind_1 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'\s*(?P&lt;bind&gt;\b[a-z]+\w*\b)\s*=.*'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
<span class="s1">crackline_bindlang </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'\s*bind\(\s*(?P&lt;lang&gt;[^,]+)\s*,\s*name\s*=\s*&quot;(?P&lt;lang_name&gt;[^&quot;]+)&quot;\s*\)'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>

<span class="s3">def </span><span class="s1">crackline</span><span class="s4">(</span><span class="s1">line</span><span class="s4">, </span><span class="s1">reset</span><span class="s4">=</span><span class="s5">0</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    reset=-1  --- initialize 
    reset=0   --- crack the line 
    reset=1   --- final check if mismatch of blocks occurred 
 
    Cracked data is saved in grouplist[0]. 
    &quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">beginpattern</span><span class="s4">, </span><span class="s1">groupcounter</span><span class="s4">, </span><span class="s1">groupname</span><span class="s4">, </span><span class="s1">groupcache</span><span class="s4">, </span><span class="s1">grouplist</span>
    <span class="s3">global </span><span class="s1">filepositiontext</span><span class="s4">, </span><span class="s1">currentfilename</span><span class="s4">, </span><span class="s1">neededmodule</span><span class="s4">, </span><span class="s1">expectbegin</span>
    <span class="s3">global </span><span class="s1">skipblocksuntil</span><span class="s4">, </span><span class="s1">skipemptyends</span><span class="s4">, </span><span class="s1">previous_context</span><span class="s4">, </span><span class="s1">gotnextfile</span>

    <span class="s1">_</span><span class="s4">, </span><span class="s1">has_semicolon </span><span class="s4">= </span><span class="s1">split_by_unquoted</span><span class="s4">(</span><span class="s1">line</span><span class="s4">, </span><span class="s6">&quot;;&quot;</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">has_semicolon </span><span class="s3">and not </span><span class="s4">(</span><span class="s1">f2pyenhancementspattern</span><span class="s4">[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">match</span><span class="s4">(</span><span class="s1">line</span><span class="s4">) </span><span class="s3">or</span>
                               <span class="s1">multilinepattern</span><span class="s4">[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">match</span><span class="s4">(</span><span class="s1">line</span><span class="s4">)):</span>
        <span class="s0"># XXX: non-zero reset values need testing</span>
        <span class="s3">assert </span><span class="s1">reset </span><span class="s4">== </span><span class="s5">0</span><span class="s4">, </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">reset</span><span class="s4">)</span>
        <span class="s0"># split line on unquoted semicolons</span>
        <span class="s1">line</span><span class="s4">, </span><span class="s1">semicolon_line </span><span class="s4">= </span><span class="s1">split_by_unquoted</span><span class="s4">(</span><span class="s1">line</span><span class="s4">, </span><span class="s6">&quot;;&quot;</span><span class="s4">)</span>
        <span class="s3">while </span><span class="s1">semicolon_line</span><span class="s4">:</span>
            <span class="s1">crackline</span><span class="s4">(</span><span class="s1">line</span><span class="s4">, </span><span class="s1">reset</span><span class="s4">)</span>
            <span class="s1">line</span><span class="s4">, </span><span class="s1">semicolon_line </span><span class="s4">= </span><span class="s1">split_by_unquoted</span><span class="s4">(</span><span class="s1">semicolon_line</span><span class="s4">[</span><span class="s5">1</span><span class="s4">:], </span><span class="s6">&quot;;&quot;</span><span class="s4">)</span>
        <span class="s1">crackline</span><span class="s4">(</span><span class="s1">line</span><span class="s4">, </span><span class="s1">reset</span><span class="s4">)</span>
        <span class="s3">return</span>
    <span class="s3">if </span><span class="s1">reset </span><span class="s4">&lt; </span><span class="s5">0</span><span class="s4">:</span>
        <span class="s1">groupcounter </span><span class="s4">= </span><span class="s5">0</span>
        <span class="s1">groupname </span><span class="s4">= {</span><span class="s1">groupcounter</span><span class="s4">: </span><span class="s6">''</span><span class="s4">}</span>
        <span class="s1">groupcache </span><span class="s4">= {</span><span class="s1">groupcounter</span><span class="s4">: {}}</span>
        <span class="s1">grouplist </span><span class="s4">= {</span><span class="s1">groupcounter</span><span class="s4">: []}</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'body'</span><span class="s4">] = []</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">] = {}</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'block'</span><span class="s4">] = </span><span class="s6">''</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'name'</span><span class="s4">] = </span><span class="s6">''</span>
        <span class="s1">neededmodule </span><span class="s4">= -</span><span class="s5">1</span>
        <span class="s1">skipblocksuntil </span><span class="s4">= -</span><span class="s5">1</span>
        <span class="s3">return</span>
    <span class="s3">if </span><span class="s1">reset </span><span class="s4">&gt; </span><span class="s5">0</span><span class="s4">:</span>
        <span class="s1">fl </span><span class="s4">= </span><span class="s5">0</span>
        <span class="s3">if </span><span class="s1">f77modulename </span><span class="s3">and </span><span class="s1">neededmodule </span><span class="s4">== </span><span class="s1">groupcounter</span><span class="s4">:</span>
            <span class="s1">fl </span><span class="s4">= </span><span class="s5">2</span>
        <span class="s3">while </span><span class="s1">groupcounter </span><span class="s4">&gt; </span><span class="s1">fl</span><span class="s4">:</span>
            <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'crackline: groupcounter=%s groupname=%s</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">%</span>
                    <span class="s4">(</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">groupcounter</span><span class="s4">), </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">groupname</span><span class="s4">)))</span>
            <span class="s1">outmess</span><span class="s4">(</span>
                <span class="s6">'crackline: Mismatch of blocks encountered. Trying to fix it by assuming &quot;end&quot; statement.</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">)</span>
            <span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">])</span>
            <span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span><span class="s4">][-</span><span class="s5">1</span><span class="s4">][</span><span class="s6">'body'</span><span class="s4">] = </span><span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]</span>
            <span class="s3">del </span><span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]</span>
            <span class="s1">groupcounter </span><span class="s4">= </span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span>
        <span class="s3">if </span><span class="s1">f77modulename </span><span class="s3">and </span><span class="s1">neededmodule </span><span class="s4">== </span><span class="s1">groupcounter</span><span class="s4">:</span>
            <span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">])</span>
            <span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span><span class="s4">][-</span><span class="s5">1</span><span class="s4">][</span><span class="s6">'body'</span><span class="s4">] = </span><span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]</span>
            <span class="s3">del </span><span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]</span>
            <span class="s1">groupcounter </span><span class="s4">= </span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1  </span><span class="s0"># end interface</span>
            <span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">])</span>
            <span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span><span class="s4">][-</span><span class="s5">1</span><span class="s4">][</span><span class="s6">'body'</span><span class="s4">] = </span><span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]</span>
            <span class="s3">del </span><span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]</span>
            <span class="s1">groupcounter </span><span class="s4">= </span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1  </span><span class="s0"># end module</span>
            <span class="s1">neededmodule </span><span class="s4">= -</span><span class="s5">1</span>
        <span class="s3">return</span>
    <span class="s3">if </span><span class="s1">line </span><span class="s4">== </span><span class="s6">''</span><span class="s4">:</span>
        <span class="s3">return</span>
    <span class="s1">flag </span><span class="s4">= </span><span class="s5">0</span>
    <span class="s3">for </span><span class="s1">pat </span><span class="s3">in </span><span class="s4">[</span><span class="s1">dimensionpattern</span><span class="s4">, </span><span class="s1">externalpattern</span><span class="s4">, </span><span class="s1">intentpattern</span><span class="s4">, </span><span class="s1">optionalpattern</span><span class="s4">,</span>
                <span class="s1">requiredpattern</span><span class="s4">,</span>
                <span class="s1">parameterpattern</span><span class="s4">, </span><span class="s1">datapattern</span><span class="s4">, </span><span class="s1">publicpattern</span><span class="s4">, </span><span class="s1">privatepattern</span><span class="s4">,</span>
                <span class="s1">intrinsicpattern</span><span class="s4">,</span>
                <span class="s1">endifpattern</span><span class="s4">, </span><span class="s1">endpattern</span><span class="s4">,</span>
                <span class="s1">formatpattern</span><span class="s4">,</span>
                <span class="s1">beginpattern</span><span class="s4">, </span><span class="s1">functionpattern</span><span class="s4">, </span><span class="s1">subroutinepattern</span><span class="s4">,</span>
                <span class="s1">implicitpattern</span><span class="s4">, </span><span class="s1">typespattern</span><span class="s4">, </span><span class="s1">commonpattern</span><span class="s4">,</span>
                <span class="s1">callpattern</span><span class="s4">, </span><span class="s1">usepattern</span><span class="s4">, </span><span class="s1">containspattern</span><span class="s4">,</span>
                <span class="s1">entrypattern</span><span class="s4">,</span>
                <span class="s1">f2pyenhancementspattern</span><span class="s4">,</span>
                <span class="s1">multilinepattern</span><span class="s4">,</span>
                <span class="s1">moduleprocedurepattern</span>
                <span class="s4">]:</span>
        <span class="s1">m </span><span class="s4">= </span><span class="s1">pat</span><span class="s4">[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">match</span><span class="s4">(</span><span class="s1">line</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">m</span><span class="s4">:</span>
            <span class="s3">break</span>
        <span class="s1">flag </span><span class="s4">= </span><span class="s1">flag </span><span class="s4">+ </span><span class="s5">1</span>
    <span class="s3">if not </span><span class="s1">m</span><span class="s4">:</span>
        <span class="s1">re_1 </span><span class="s4">= </span><span class="s1">crackline_re_1</span>
        <span class="s3">if </span><span class="s5">0 </span><span class="s4">&lt;= </span><span class="s1">skipblocksuntil </span><span class="s4">&lt;= </span><span class="s1">groupcounter</span><span class="s4">:</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s6">'externals' </span><span class="s3">in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]:</span>
            <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'externals'</span><span class="s4">]:</span>
                <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">invbadnames</span><span class="s4">:</span>
                    <span class="s1">name </span><span class="s4">= </span><span class="s1">invbadnames</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]</span>
                <span class="s3">if </span><span class="s6">'interfaced' </span><span class="s3">in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">] </span><span class="s3">and </span><span class="s1">name </span><span class="s3">in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'interfaced'</span><span class="s4">]:</span>
                    <span class="s3">continue</span>
                <span class="s1">m1 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span>
                    <span class="s6">r'(?P&lt;before&gt;[^&quot;]*)\b%s\b\s*@\(@(?P&lt;args&gt;[^@]*)@\)@.*\Z' </span><span class="s4">% </span><span class="s1">name</span><span class="s4">, </span><span class="s1">markouterparen</span><span class="s4">(</span><span class="s1">line</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">m1</span><span class="s4">:</span>
                    <span class="s1">m2 </span><span class="s4">= </span><span class="s1">re_1</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'before'</span><span class="s4">))</span>
                    <span class="s1">a </span><span class="s4">= </span><span class="s1">_simplifyargs</span><span class="s4">(</span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'args'</span><span class="s4">))</span>
                    <span class="s3">if </span><span class="s1">m2</span><span class="s4">:</span>
                        <span class="s1">line </span><span class="s4">= </span><span class="s6">'callfun %s(%s) result (%s)' </span><span class="s4">% (</span>
                            <span class="s1">name</span><span class="s4">, </span><span class="s1">a</span><span class="s4">, </span><span class="s1">m2</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'result'</span><span class="s4">))</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">line </span><span class="s4">= </span><span class="s6">'callfun %s(%s)' </span><span class="s4">% (</span><span class="s1">name</span><span class="s4">, </span><span class="s1">a</span><span class="s4">)</span>
                    <span class="s1">m </span><span class="s4">= </span><span class="s1">callfunpattern</span><span class="s4">[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">match</span><span class="s4">(</span><span class="s1">line</span><span class="s4">)</span>
                    <span class="s3">if not </span><span class="s1">m</span><span class="s4">:</span>
                        <span class="s1">outmess</span><span class="s4">(</span>
                            <span class="s6">'crackline: could not resolve function call for line=%s.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">line</span><span class="s4">))</span>
                        <span class="s3">return</span>
                    <span class="s1">analyzeline</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s6">'callfun'</span><span class="s4">, </span><span class="s1">line</span><span class="s4">)</span>
                    <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">verbose </span><span class="s4">&gt; </span><span class="s5">1 </span><span class="s3">or </span><span class="s4">(</span><span class="s1">verbose </span><span class="s4">== </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">currentfilename</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">().</span><span class="s1">endswith</span><span class="s4">(</span><span class="s6">'.pyf'</span><span class="s4">)):</span>
            <span class="s1">previous_context </span><span class="s4">= </span><span class="s3">None</span>
            <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'crackline:%d: No pattern for line</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">groupcounter</span><span class="s4">))</span>
        <span class="s3">return</span>
    <span class="s3">elif </span><span class="s1">pat</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] == </span><span class="s6">'end'</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s5">0 </span><span class="s4">&lt;= </span><span class="s1">skipblocksuntil </span><span class="s4">&lt; </span><span class="s1">groupcounter</span><span class="s4">:</span>
            <span class="s1">groupcounter </span><span class="s4">= </span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span>
            <span class="s3">if </span><span class="s1">skipblocksuntil </span><span class="s4">&lt;= </span><span class="s1">groupcounter</span><span class="s4">:</span>
                <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">groupcounter </span><span class="s4">&lt;= </span><span class="s5">0</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">Exception</span><span class="s4">(</span><span class="s6">'crackline: groupcounter(=%s) is nonpositive. '</span>
                            <span class="s6">'Check the blocks.'</span>
                            <span class="s4">% (</span><span class="s1">groupcounter</span><span class="s4">))</span>
        <span class="s1">m1 </span><span class="s4">= </span><span class="s1">beginpattern</span><span class="s4">[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">match</span><span class="s4">(</span><span class="s1">line</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s1">m1</span><span class="s4">) </span><span class="s3">and </span><span class="s4">(</span><span class="s3">not </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'this'</span><span class="s4">) == </span><span class="s1">groupname</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]):</span>
            <span class="s3">raise </span><span class="s1">Exception</span><span class="s4">(</span><span class="s6">'crackline: End group %s does not match with '</span>
                            <span class="s6">'previous Begin group %s</span><span class="s3">\n\t</span><span class="s6">%s' </span><span class="s4">%</span>
                            <span class="s4">(</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'this'</span><span class="s4">)), </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">groupname</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]),</span>
                             <span class="s1">filepositiontext</span><span class="s4">)</span>
                            <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">skipblocksuntil </span><span class="s4">== </span><span class="s1">groupcounter</span><span class="s4">:</span>
            <span class="s1">skipblocksuntil </span><span class="s4">= -</span><span class="s5">1</span>
        <span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">])</span>
        <span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span><span class="s4">][-</span><span class="s5">1</span><span class="s4">][</span><span class="s6">'body'</span><span class="s4">] = </span><span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]</span>
        <span class="s3">del </span><span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]</span>
        <span class="s1">groupcounter </span><span class="s4">= </span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span>
        <span class="s3">if not </span><span class="s1">skipemptyends</span><span class="s4">:</span>
            <span class="s1">expectbegin </span><span class="s4">= </span><span class="s5">1</span>
    <span class="s3">elif </span><span class="s1">pat</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] == </span><span class="s6">'begin'</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s5">0 </span><span class="s4">&lt;= </span><span class="s1">skipblocksuntil </span><span class="s4">&lt;= </span><span class="s1">groupcounter</span><span class="s4">:</span>
            <span class="s1">groupcounter </span><span class="s4">= </span><span class="s1">groupcounter </span><span class="s4">+ </span><span class="s5">1</span>
            <span class="s3">return</span>
        <span class="s1">gotnextfile </span><span class="s4">= </span><span class="s5">0</span>
        <span class="s1">analyzeline</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">pat</span><span class="s4">[</span><span class="s5">1</span><span class="s4">], </span><span class="s1">line</span><span class="s4">)</span>
        <span class="s1">expectbegin </span><span class="s4">= </span><span class="s5">0</span>
    <span class="s3">elif </span><span class="s1">pat</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] == </span><span class="s6">'endif'</span><span class="s4">:</span>
        <span class="s3">pass</span>
    <span class="s3">elif </span><span class="s1">pat</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] == </span><span class="s6">'moduleprocedure'</span><span class="s4">:</span>
        <span class="s1">analyzeline</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">pat</span><span class="s4">[</span><span class="s5">1</span><span class="s4">], </span><span class="s1">line</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">pat</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] == </span><span class="s6">'contains'</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">ignorecontains</span><span class="s4">:</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s5">0 </span><span class="s4">&lt;= </span><span class="s1">skipblocksuntil </span><span class="s4">&lt;= </span><span class="s1">groupcounter</span><span class="s4">:</span>
            <span class="s3">return</span>
        <span class="s1">skipblocksuntil </span><span class="s4">= </span><span class="s1">groupcounter</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s5">0 </span><span class="s4">&lt;= </span><span class="s1">skipblocksuntil </span><span class="s4">&lt;= </span><span class="s1">groupcounter</span><span class="s4">:</span>
            <span class="s3">return</span>
        <span class="s1">analyzeline</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">pat</span><span class="s4">[</span><span class="s5">1</span><span class="s4">], </span><span class="s1">line</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">markouterparen</span><span class="s4">(</span><span class="s1">line</span><span class="s4">):</span>
    <span class="s1">l </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s1">f </span><span class="s4">= </span><span class="s5">0</span>
    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">line</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">c </span><span class="s4">== </span><span class="s6">'('</span><span class="s4">:</span>
            <span class="s1">f </span><span class="s4">= </span><span class="s1">f </span><span class="s4">+ </span><span class="s5">1</span>
            <span class="s3">if </span><span class="s1">f </span><span class="s4">== </span><span class="s5">1</span><span class="s4">:</span>
                <span class="s1">l </span><span class="s4">= </span><span class="s1">l </span><span class="s4">+ </span><span class="s6">'@(@'</span>
                <span class="s3">continue</span>
        <span class="s3">elif </span><span class="s1">c </span><span class="s4">== </span><span class="s6">')'</span><span class="s4">:</span>
            <span class="s1">f </span><span class="s4">= </span><span class="s1">f </span><span class="s4">- </span><span class="s5">1</span>
            <span class="s3">if </span><span class="s1">f </span><span class="s4">== </span><span class="s5">0</span><span class="s4">:</span>
                <span class="s1">l </span><span class="s4">= </span><span class="s1">l </span><span class="s4">+ </span><span class="s6">'@)@'</span>
                <span class="s3">continue</span>
        <span class="s1">l </span><span class="s4">= </span><span class="s1">l </span><span class="s4">+ </span><span class="s1">c</span>
    <span class="s3">return </span><span class="s1">l</span>


<span class="s3">def </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">line</span><span class="s4">, </span><span class="s1">comma</span><span class="s4">=</span><span class="s6">','</span><span class="s4">):</span>
    <span class="s1">l </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s1">f </span><span class="s4">= </span><span class="s5">0</span>
    <span class="s1">before</span><span class="s4">, </span><span class="s1">after </span><span class="s4">= </span><span class="s1">split_by_unquoted</span><span class="s4">(</span><span class="s1">line</span><span class="s4">, </span><span class="s1">comma </span><span class="s4">+ </span><span class="s6">'()'</span><span class="s4">)</span>
    <span class="s1">l </span><span class="s4">+= </span><span class="s1">before</span>
    <span class="s3">while </span><span class="s1">after</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s1">after</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] == </span><span class="s1">comma</span><span class="s4">) </span><span class="s3">and </span><span class="s4">(</span><span class="s1">f </span><span class="s4">== </span><span class="s5">0</span><span class="s4">):</span>
            <span class="s1">l </span><span class="s4">+= </span><span class="s6">'@' </span><span class="s4">+ </span><span class="s1">comma </span><span class="s4">+ </span><span class="s6">'@'</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">l </span><span class="s4">+= </span><span class="s1">after</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">after</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] == </span><span class="s6">'('</span><span class="s4">:</span>
                <span class="s1">f </span><span class="s4">+= </span><span class="s5">1</span>
            <span class="s3">elif </span><span class="s1">after</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] == </span><span class="s6">')'</span><span class="s4">:</span>
                <span class="s1">f </span><span class="s4">-= </span><span class="s5">1</span>
        <span class="s1">before</span><span class="s4">, </span><span class="s1">after </span><span class="s4">= </span><span class="s1">split_by_unquoted</span><span class="s4">(</span><span class="s1">after</span><span class="s4">[</span><span class="s5">1</span><span class="s4">:], </span><span class="s1">comma </span><span class="s4">+ </span><span class="s6">'()'</span><span class="s4">)</span>
        <span class="s1">l </span><span class="s4">+= </span><span class="s1">before</span>
    <span class="s3">assert not </span><span class="s1">f</span><span class="s4">, </span><span class="s1">repr</span><span class="s4">((</span><span class="s1">f</span><span class="s4">, </span><span class="s1">line</span><span class="s4">, </span><span class="s1">l</span><span class="s4">))</span>
    <span class="s3">return </span><span class="s1">l</span>

<span class="s3">def </span><span class="s1">unmarkouterparen</span><span class="s4">(</span><span class="s1">line</span><span class="s4">):</span>
    <span class="s1">r </span><span class="s4">= </span><span class="s1">line</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s6">'@(@'</span><span class="s4">, </span><span class="s6">'('</span><span class="s4">).</span><span class="s1">replace</span><span class="s4">(</span><span class="s6">'@)@'</span><span class="s4">, </span><span class="s6">')'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">r</span>


<span class="s3">def </span><span class="s1">appenddecl</span><span class="s4">(</span><span class="s1">decl</span><span class="s4">, </span><span class="s1">decl2</span><span class="s4">, </span><span class="s1">force</span><span class="s4">=</span><span class="s5">1</span><span class="s4">):</span>
    <span class="s3">if not </span><span class="s1">decl</span><span class="s4">:</span>
        <span class="s1">decl </span><span class="s4">= {}</span>
    <span class="s3">if not </span><span class="s1">decl2</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">decl</span>
    <span class="s3">if </span><span class="s1">decl </span><span class="s3">is </span><span class="s1">decl2</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">decl</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">decl2</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
        <span class="s3">if </span><span class="s1">k </span><span class="s4">== </span><span class="s6">'typespec'</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">force </span><span class="s3">or </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">decl</span><span class="s4">:</span>
                <span class="s1">decl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] = </span><span class="s1">decl2</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>
        <span class="s3">elif </span><span class="s1">k </span><span class="s4">== </span><span class="s6">'attrspec'</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">decl2</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]:</span>
                <span class="s1">decl </span><span class="s4">= </span><span class="s1">setattrspec</span><span class="s4">(</span><span class="s1">decl</span><span class="s4">, </span><span class="s1">l</span><span class="s4">, </span><span class="s1">force</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">k </span><span class="s4">== </span><span class="s6">'kindselector'</span><span class="s4">:</span>
            <span class="s1">decl </span><span class="s4">= </span><span class="s1">setkindselector</span><span class="s4">(</span><span class="s1">decl</span><span class="s4">, </span><span class="s1">decl2</span><span class="s4">[</span><span class="s1">k</span><span class="s4">], </span><span class="s1">force</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">k </span><span class="s4">== </span><span class="s6">'charselector'</span><span class="s4">:</span>
            <span class="s1">decl </span><span class="s4">= </span><span class="s1">setcharselector</span><span class="s4">(</span><span class="s1">decl</span><span class="s4">, </span><span class="s1">decl2</span><span class="s4">[</span><span class="s1">k</span><span class="s4">], </span><span class="s1">force</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">k </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'='</span><span class="s4">, </span><span class="s6">'typename'</span><span class="s4">]:</span>
            <span class="s3">if </span><span class="s1">force </span><span class="s3">or </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">decl</span><span class="s4">:</span>
                <span class="s1">decl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] = </span><span class="s1">decl2</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>
        <span class="s3">elif </span><span class="s1">k </span><span class="s4">== </span><span class="s6">'note'</span><span class="s4">:</span>
            <span class="s3">pass</span>
        <span class="s3">elif </span><span class="s1">k </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'intent'</span><span class="s4">, </span><span class="s6">'check'</span><span class="s4">, </span><span class="s6">'dimension'</span><span class="s4">, </span><span class="s6">'optional'</span><span class="s4">,</span>
                   <span class="s6">'required'</span><span class="s4">, </span><span class="s6">'depend'</span><span class="s4">]:</span>
            <span class="s1">errmess</span><span class="s4">(</span><span class="s6">'appenddecl: &quot;%s&quot; not implemented.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">k</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">Exception</span><span class="s4">(</span><span class="s6">'appenddecl: Unknown variable definition key: ' </span><span class="s4">+</span>
                            <span class="s1">str</span><span class="s4">(</span><span class="s1">k</span><span class="s4">))</span>
    <span class="s3">return </span><span class="s1">decl</span>

<span class="s1">selectpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s6">r'\s*(?P&lt;this&gt;(@\(@.*?@\)@|\*[\d*]+|\*\s*@\(@.*?@\)@|))(?P&lt;after&gt;.*)\Z'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
<span class="s1">typedefpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s6">r'(?:,(?P&lt;attributes&gt;[\w(),]+))?(::)?(?P&lt;name&gt;\b[a-z$_][\w$]*\b)'</span>
    <span class="s6">r'(?:\((?P&lt;params&gt;[\w,]*)\))?\Z'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
<span class="s1">nameargspattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s6">r'\s*(?P&lt;name&gt;\b[\w$]+\b)\s*(@\(@\s*(?P&lt;args&gt;[\w\s,]*)\s*@\)@|)\s*((result(\s*@\(@\s*(?P&lt;result&gt;\b[\w$]+\b)\s*@\)@|))|(bind\s*@\(@\s*(?P&lt;bind&gt;(?:(?!@\)@).)*)\s*@\)@))*\s*\Z'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
<span class="s1">operatorpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s6">r'\s*(?P&lt;scheme&gt;(operator|assignment))'</span>
    <span class="s6">r'@\(@\s*(?P&lt;name&gt;[^)]+)\s*@\)@\s*\Z'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
<span class="s1">callnameargspattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s6">r'\s*(?P&lt;name&gt;\b[\w$]+\b)\s*@\(@\s*(?P&lt;args&gt;.*)\s*@\)@\s*\Z'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
<span class="s1">real16pattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s6">r'([-+]?(?:\d+(?:\.\d*)?|\d*\.\d+))[dD]((?:[-+]?\d+)?)'</span><span class="s4">)</span>
<span class="s1">real8pattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s6">r'([-+]?((?:\d+(?:\.\d*)?|\d*\.\d+))[eE]((?:[-+]?\d+)?)|(\d+\.\d*))'</span><span class="s4">)</span>

<span class="s1">_intentcallbackpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'intent\s*\(.*?\bcallback\b'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_is_intent_callback</span><span class="s4">(</span><span class="s1">vdecl</span><span class="s4">):</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">vdecl</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s6">'attrspec'</span><span class="s4">, []):</span>
        <span class="s3">if </span><span class="s1">_intentcallbackpattern</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">a</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s5">1</span>
    <span class="s3">return </span><span class="s5">0</span>


<span class="s3">def </span><span class="s1">_resolvetypedefpattern</span><span class="s4">(</span><span class="s1">line</span><span class="s4">):</span>
    <span class="s1">line </span><span class="s4">= </span><span class="s6">''</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">line</span><span class="s4">.</span><span class="s1">split</span><span class="s4">())  </span><span class="s0"># removes whitespace</span>
    <span class="s1">m1 </span><span class="s4">= </span><span class="s1">typedefpattern</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">line</span><span class="s4">)</span>
    <span class="s1">print</span><span class="s4">(</span><span class="s1">line</span><span class="s4">, </span><span class="s1">m1</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">m1</span><span class="s4">:</span>
        <span class="s1">attrs </span><span class="s4">= </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'attributes'</span><span class="s4">)</span>
        <span class="s1">attrs </span><span class="s4">= [</span><span class="s1">a</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">() </span><span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">attrs</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s6">','</span><span class="s4">)] </span><span class="s3">if </span><span class="s1">attrs </span><span class="s3">else </span><span class="s4">[]</span>
        <span class="s3">return </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'name'</span><span class="s4">), </span><span class="s1">attrs</span><span class="s4">, </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'params'</span><span class="s4">)</span>
    <span class="s3">return None</span><span class="s4">, [], </span><span class="s3">None</span>

<span class="s3">def </span><span class="s1">parse_name_for_bind</span><span class="s4">(</span><span class="s1">line</span><span class="s4">):</span>
    <span class="s1">pattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'bind\(\s*(?P&lt;lang&gt;[^,]+)(?:\s*,\s*name\s*=\s*[&quot;\'](?P&lt;name&gt;[^&quot;\']+)[&quot;\']\s*)?\)'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
    <span class="s1">match </span><span class="s4">= </span><span class="s1">pattern</span><span class="s4">.</span><span class="s1">search</span><span class="s4">(</span><span class="s1">line</span><span class="s4">)</span>
    <span class="s1">bind_statement </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">match</span><span class="s4">:</span>
        <span class="s1">bind_statement </span><span class="s4">= </span><span class="s1">match</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>
        <span class="s0"># Remove the 'bind' construct from the line.</span>
        <span class="s1">line </span><span class="s4">= </span><span class="s1">line</span><span class="s4">[:</span><span class="s1">match</span><span class="s4">.</span><span class="s1">start</span><span class="s4">()] + </span><span class="s1">line</span><span class="s4">[</span><span class="s1">match</span><span class="s4">.</span><span class="s1">end</span><span class="s4">():]</span>
    <span class="s3">return </span><span class="s1">line</span><span class="s4">, </span><span class="s1">bind_statement</span>

<span class="s3">def </span><span class="s1">_resolvenameargspattern</span><span class="s4">(</span><span class="s1">line</span><span class="s4">):</span>
    <span class="s1">line</span><span class="s4">, </span><span class="s1">bind_cname </span><span class="s4">= </span><span class="s1">parse_name_for_bind</span><span class="s4">(</span><span class="s1">line</span><span class="s4">)</span>
    <span class="s1">line </span><span class="s4">= </span><span class="s1">markouterparen</span><span class="s4">(</span><span class="s1">line</span><span class="s4">)</span>
    <span class="s1">m1 </span><span class="s4">= </span><span class="s1">nameargspattern</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">line</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">m1</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'name'</span><span class="s4">), </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'args'</span><span class="s4">), </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'result'</span><span class="s4">), </span><span class="s1">bind_cname</span>
    <span class="s1">m1 </span><span class="s4">= </span><span class="s1">operatorpattern</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">line</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">m1</span><span class="s4">:</span>
        <span class="s1">name </span><span class="s4">= </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'scheme'</span><span class="s4">) + </span><span class="s6">'(' </span><span class="s4">+ </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'name'</span><span class="s4">) + </span><span class="s6">')'</span>
        <span class="s3">return </span><span class="s1">name</span><span class="s4">, [], </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span>
    <span class="s1">m1 </span><span class="s4">= </span><span class="s1">callnameargspattern</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">line</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">m1</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'name'</span><span class="s4">), </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'args'</span><span class="s4">), </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span>
    <span class="s3">return None</span><span class="s4">, [], </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span>


<span class="s3">def </span><span class="s1">analyzeline</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">case</span><span class="s4">, </span><span class="s1">line</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reads each line in the input file in sequence and updates global vars. 
 
    Effectively reads and collects information from the input file to the 
    global variable groupcache, a dictionary containing info about each part 
    of the fortran module. 
 
    At the end of analyzeline, information is filtered into the correct dict 
    keys, but parameter values and dimensions are not yet interpreted. 
    &quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">groupcounter</span><span class="s4">, </span><span class="s1">groupname</span><span class="s4">, </span><span class="s1">groupcache</span><span class="s4">, </span><span class="s1">grouplist</span><span class="s4">, </span><span class="s1">filepositiontext</span>
    <span class="s3">global </span><span class="s1">currentfilename</span><span class="s4">, </span><span class="s1">f77modulename</span><span class="s4">, </span><span class="s1">neededinterface</span><span class="s4">, </span><span class="s1">neededmodule</span>
    <span class="s3">global </span><span class="s1">expectbegin</span><span class="s4">, </span><span class="s1">gotnextfile</span><span class="s4">, </span><span class="s1">previous_context</span>

    <span class="s1">block </span><span class="s4">= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'this'</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">case </span><span class="s4">!= </span><span class="s6">'multiline'</span><span class="s4">:</span>
        <span class="s1">previous_context </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">expectbegin </span><span class="s3">and </span><span class="s1">case </span><span class="s3">not in </span><span class="s4">[</span><span class="s6">'begin'</span><span class="s4">, </span><span class="s6">'call'</span><span class="s4">, </span><span class="s6">'callfun'</span><span class="s4">, </span><span class="s6">'type'</span><span class="s4">] </span><span class="s1">\</span>
       <span class="s3">and not </span><span class="s1">skipemptyends </span><span class="s3">and </span><span class="s1">groupcounter </span><span class="s4">&lt; </span><span class="s5">1</span><span class="s4">:</span>
        <span class="s1">newname </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">basename</span><span class="s4">(</span><span class="s1">currentfilename</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'.'</span><span class="s4">)[</span><span class="s5">0</span><span class="s4">]</span>
        <span class="s1">outmess</span><span class="s4">(</span>
            <span class="s6">'analyzeline: no group yet. Creating program group with name &quot;%s&quot;.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">newname</span><span class="s4">)</span>
        <span class="s1">gotnextfile </span><span class="s4">= </span><span class="s5">0</span>
        <span class="s1">groupcounter </span><span class="s4">= </span><span class="s1">groupcounter </span><span class="s4">+ </span><span class="s5">1</span>
        <span class="s1">groupname</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">] = </span><span class="s6">'program'</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">] = {}</span>
        <span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">] = []</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'body'</span><span class="s4">] = []</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">] = {}</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'block'</span><span class="s4">] = </span><span class="s6">'program'</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'name'</span><span class="s4">] = </span><span class="s1">newname</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'from'</span><span class="s4">] = </span><span class="s6">'fromsky'</span>
        <span class="s1">expectbegin </span><span class="s4">= </span><span class="s5">0</span>
    <span class="s3">if </span><span class="s1">case </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'begin'</span><span class="s4">, </span><span class="s6">'call'</span><span class="s4">, </span><span class="s6">'callfun'</span><span class="s4">]:</span>
        <span class="s0"># Crack line =&gt; block,name,args,result</span>
        <span class="s1">block </span><span class="s4">= </span><span class="s1">block</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s6">r'block\s*data'</span><span class="s4">, </span><span class="s1">block</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">):</span>
            <span class="s1">block </span><span class="s4">= </span><span class="s6">'block data'</span>
        <span class="s3">elif </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s6">r'python\s*module'</span><span class="s4">, </span><span class="s1">block</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">):</span>
            <span class="s1">block </span><span class="s4">= </span><span class="s6">'python module'</span>
        <span class="s3">elif </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s6">r'abstract\s*interface'</span><span class="s4">, </span><span class="s1">block</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">):</span>
            <span class="s1">block </span><span class="s4">= </span><span class="s6">'abstract interface'</span>
        <span class="s3">if </span><span class="s1">block </span><span class="s4">== </span><span class="s6">'type'</span><span class="s4">:</span>
            <span class="s1">name</span><span class="s4">, </span><span class="s1">attrs</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">_resolvetypedefpattern</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">))</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">attrspec </span><span class="s4">= </span><span class="s1">attrs</span><span class="s4">)</span>
            <span class="s1">args </span><span class="s4">= []</span>
            <span class="s1">result </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">name</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">result</span><span class="s4">, </span><span class="s1">bindcline </span><span class="s4">= </span><span class="s1">_resolvenameargspattern</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">))</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">block </span><span class="s4">== </span><span class="s6">'block data'</span><span class="s4">:</span>
                <span class="s1">name </span><span class="s4">= </span><span class="s6">'_BLOCK_DATA_'</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">name </span><span class="s4">= </span><span class="s6">''</span>
            <span class="s3">if </span><span class="s1">block </span><span class="s3">not in </span><span class="s4">[</span><span class="s6">'interface'</span><span class="s4">, </span><span class="s6">'block data'</span><span class="s4">, </span><span class="s6">'abstract interface'</span><span class="s4">]:</span>
                <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'analyzeline: No name/args pattern found for line.</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">)</span>

        <span class="s1">previous_context </span><span class="s4">= (</span><span class="s1">block</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">groupcounter</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">args</span><span class="s4">:</span>
            <span class="s1">args </span><span class="s4">= </span><span class="s1">rmbadname</span><span class="s4">([</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">()</span>
                              <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">args</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@,@'</span><span class="s4">)])</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">args </span><span class="s4">= []</span>
        <span class="s3">if </span><span class="s6">'' </span><span class="s3">in </span><span class="s1">args</span><span class="s4">:</span>
            <span class="s3">while </span><span class="s6">'' </span><span class="s3">in </span><span class="s1">args</span><span class="s4">:</span>
                <span class="s1">args</span><span class="s4">.</span><span class="s1">remove</span><span class="s4">(</span><span class="s6">''</span><span class="s4">)</span>
            <span class="s1">outmess</span><span class="s4">(</span>
                <span class="s6">'analyzeline: argument list is malformed (missing argument).</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">)</span>

        <span class="s0"># end of crack line =&gt; block,name,args,result</span>
        <span class="s1">needmodule </span><span class="s4">= </span><span class="s5">0</span>
        <span class="s1">needinterface </span><span class="s4">= </span><span class="s5">0</span>

        <span class="s3">if </span><span class="s1">case </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'call'</span><span class="s4">, </span><span class="s6">'callfun'</span><span class="s4">]:</span>
            <span class="s1">needinterface </span><span class="s4">= </span><span class="s5">1</span>
            <span class="s3">if </span><span class="s6">'args' </span><span class="s3">not in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]:</span>
                <span class="s3">return</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'args'</span><span class="s4">]:</span>
                <span class="s3">return</span>
            <span class="s3">for </span><span class="s1">it </span><span class="s3">in </span><span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]:</span>
                <span class="s3">if </span><span class="s1">it</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">] == </span><span class="s1">name</span><span class="s4">:</span>
                    <span class="s3">return</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'interfaced'</span><span class="s4">]:</span>
                <span class="s3">return</span>
            <span class="s1">block </span><span class="s4">= {</span><span class="s6">'call'</span><span class="s4">: </span><span class="s6">'subroutine'</span><span class="s4">, </span><span class="s6">'callfun'</span><span class="s4">: </span><span class="s6">'function'</span><span class="s4">}[</span><span class="s1">case</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">f77modulename </span><span class="s3">and </span><span class="s1">neededmodule </span><span class="s4">== -</span><span class="s5">1 </span><span class="s3">and </span><span class="s1">groupcounter </span><span class="s4">&lt;= </span><span class="s5">1</span><span class="s4">:</span>
            <span class="s1">neededmodule </span><span class="s4">= </span><span class="s1">groupcounter </span><span class="s4">+ </span><span class="s5">2</span>
            <span class="s1">needmodule </span><span class="s4">= </span><span class="s5">1</span>
            <span class="s3">if </span><span class="s1">block </span><span class="s3">not in </span><span class="s4">[</span><span class="s6">'interface'</span><span class="s4">, </span><span class="s6">'abstract interface'</span><span class="s4">]:</span>
                <span class="s1">needinterface </span><span class="s4">= </span><span class="s5">1</span>
        <span class="s0"># Create new block(s)</span>
        <span class="s1">groupcounter </span><span class="s4">= </span><span class="s1">groupcounter </span><span class="s4">+ </span><span class="s5">1</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">] = {}</span>
        <span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">] = []</span>
        <span class="s3">if </span><span class="s1">needmodule</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">verbose </span><span class="s4">&gt; </span><span class="s5">1</span><span class="s4">:</span>
                <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'analyzeline: Creating module block %s</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">%</span>
                        <span class="s1">repr</span><span class="s4">(</span><span class="s1">f77modulename</span><span class="s4">), </span><span class="s5">0</span><span class="s4">)</span>
            <span class="s1">groupname</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">] = </span><span class="s6">'module'</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'block'</span><span class="s4">] = </span><span class="s6">'python module'</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'name'</span><span class="s4">] = </span><span class="s1">f77modulename</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'from'</span><span class="s4">] = </span><span class="s6">''</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'body'</span><span class="s4">] = []</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'externals'</span><span class="s4">] = []</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'interfaced'</span><span class="s4">] = []</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">] = {}</span>
            <span class="s1">groupcounter </span><span class="s4">= </span><span class="s1">groupcounter </span><span class="s4">+ </span><span class="s5">1</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">] = {}</span>
            <span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">] = []</span>
        <span class="s3">if </span><span class="s1">needinterface</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">verbose </span><span class="s4">&gt; </span><span class="s5">1</span><span class="s4">:</span>
                <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'analyzeline: Creating additional interface block (groupcounter=%s).</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span>
                    <span class="s1">groupcounter</span><span class="s4">), </span><span class="s5">0</span><span class="s4">)</span>
            <span class="s1">groupname</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">] = </span><span class="s6">'interface'</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'block'</span><span class="s4">] = </span><span class="s6">'interface'</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'name'</span><span class="s4">] = </span><span class="s6">'unknown_interface'</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'from'</span><span class="s4">] = </span><span class="s6">'%s:%s' </span><span class="s4">% (</span>
                <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span><span class="s4">][</span><span class="s6">'from'</span><span class="s4">], </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span><span class="s4">][</span><span class="s6">'name'</span><span class="s4">])</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'body'</span><span class="s4">] = []</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'externals'</span><span class="s4">] = []</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'interfaced'</span><span class="s4">] = []</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">] = {}</span>
            <span class="s1">groupcounter </span><span class="s4">= </span><span class="s1">groupcounter </span><span class="s4">+ </span><span class="s5">1</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">] = {}</span>
            <span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">] = []</span>
        <span class="s1">groupname</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">] = </span><span class="s1">block</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'block'</span><span class="s4">] = </span><span class="s1">block</span>
        <span class="s3">if not </span><span class="s1">name</span><span class="s4">:</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s6">'unknown_' </span><span class="s4">+ </span><span class="s1">block</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s6">' '</span><span class="s4">, </span><span class="s6">'_'</span><span class="s4">)</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'prefix'</span><span class="s4">] = </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'before'</span><span class="s4">)</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'name'</span><span class="s4">] = </span><span class="s1">rmbadname1</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'result'</span><span class="s4">] = </span><span class="s1">result</span>
        <span class="s3">if </span><span class="s1">groupcounter </span><span class="s4">== </span><span class="s5">1</span><span class="s4">:</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'from'</span><span class="s4">] = </span><span class="s1">currentfilename</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">f77modulename </span><span class="s3">and </span><span class="s1">groupcounter </span><span class="s4">== </span><span class="s5">3</span><span class="s4">:</span>
                <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'from'</span><span class="s4">] = </span><span class="s6">'%s:%s' </span><span class="s4">% (</span>
                    <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span><span class="s4">][</span><span class="s6">'from'</span><span class="s4">], </span><span class="s1">currentfilename</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'from'</span><span class="s4">] = </span><span class="s6">'%s:%s' </span><span class="s4">% (</span>
                    <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span><span class="s4">][</span><span class="s6">'from'</span><span class="s4">], </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span><span class="s4">][</span><span class="s6">'name'</span><span class="s4">])</span>
        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">].</span><span class="s1">keys</span><span class="s4">()):</span>
            <span class="s3">if not </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s1">k</span><span class="s4">]:</span>
                <span class="s3">del </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s1">k</span><span class="s4">]</span>

        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'args'</span><span class="s4">] = </span><span class="s1">args</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'body'</span><span class="s4">] = []</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'externals'</span><span class="s4">] = []</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'interfaced'</span><span class="s4">] = []</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">] = {}</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'entry'</span><span class="s4">] = {}</span>
        <span class="s0"># end of creation</span>
        <span class="s3">if </span><span class="s1">block </span><span class="s4">== </span><span class="s6">'type'</span><span class="s4">:</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'varnames'</span><span class="s4">] = []</span>

        <span class="s3">if </span><span class="s1">case </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'call'</span><span class="s4">, </span><span class="s6">'callfun'</span><span class="s4">]:  </span><span class="s0"># set parents variables</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">2</span><span class="s4">][</span><span class="s6">'externals'</span><span class="s4">]:</span>
                <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">2</span><span class="s4">][</span><span class="s6">'externals'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">] = </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">deepcopy</span><span class="s4">(</span>
                <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">2</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">])</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s3">del </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">name</span><span class="s4">][</span>
                    <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">name</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">].</span><span class="s1">index</span><span class="s4">(</span><span class="s6">'external'</span><span class="s4">)]</span>
            <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
                <span class="s3">pass</span>
        <span class="s3">if </span><span class="s1">block </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'function'</span><span class="s4">, </span><span class="s6">'subroutine'</span><span class="s4">]:  </span><span class="s0"># set global attributes</span>
            <span class="s0"># name is fortran name</span>
            <span class="s3">if </span><span class="s1">bindcline</span><span class="s4">:</span>
                <span class="s1">bindcdat </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">search</span><span class="s4">(</span><span class="s1">crackline_bindlang</span><span class="s4">, </span><span class="s1">bindcline</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">bindcdat</span><span class="s4">:</span>
                    <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'bindlang'</span><span class="s4">] = {</span><span class="s1">name </span><span class="s4">: {}}</span>
                    <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'bindlang'</span><span class="s4">][</span><span class="s1">name</span><span class="s4">][</span><span class="s6">&quot;lang&quot;</span><span class="s4">] = </span><span class="s1">bindcdat</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'lang'</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">bindcdat</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'lang_name'</span><span class="s4">):</span>
                        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'bindlang'</span><span class="s4">][</span><span class="s1">name</span><span class="s4">][</span><span class="s6">&quot;name&quot;</span><span class="s4">] = </span><span class="s1">bindcdat</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'lang_name'</span><span class="s4">)</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">appenddecl</span><span class="s4">(</span>
                    <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">name</span><span class="s4">], </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">2</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s6">''</span><span class="s4">])</span>
            <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
                <span class="s3">pass</span>
            <span class="s3">if </span><span class="s1">case </span><span class="s4">== </span><span class="s6">'callfun'</span><span class="s4">:  </span><span class="s0"># return type</span>
                <span class="s3">if </span><span class="s1">result </span><span class="s3">and </span><span class="s1">result </span><span class="s3">in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">]:</span>
                    <span class="s3">if not </span><span class="s1">name </span><span class="s4">== </span><span class="s1">result</span><span class="s4">:</span>
                        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">appenddecl</span><span class="s4">(</span>
                            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">name</span><span class="s4">], </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">result</span><span class="s4">])</span>
            <span class="s0"># if groupcounter&gt;1: # name is interfaced</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">2</span><span class="s4">][</span><span class="s6">'interfaced'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
                <span class="s3">pass</span>
        <span class="s3">if </span><span class="s1">block </span><span class="s4">== </span><span class="s6">'function'</span><span class="s4">:</span>
            <span class="s1">t </span><span class="s4">= </span><span class="s1">typespattern</span><span class="s4">[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">match</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'before'</span><span class="s4">) + </span><span class="s6">' ' </span><span class="s4">+ </span><span class="s1">name</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">t</span><span class="s4">:</span>
                <span class="s1">typespec</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">, </span><span class="s1">edecl </span><span class="s4">= </span><span class="s1">cracktypespec0</span><span class="s4">(</span>
                    <span class="s1">t</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'this'</span><span class="s4">), </span><span class="s1">t</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">))</span>
                <span class="s1">updatevars</span><span class="s4">(</span><span class="s1">typespec</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">, </span><span class="s1">edecl</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">case </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'call'</span><span class="s4">, </span><span class="s6">'callfun'</span><span class="s4">]:</span>
            <span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">])</span>
            <span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span><span class="s4">][-</span><span class="s5">1</span><span class="s4">][</span><span class="s6">'body'</span><span class="s4">] = </span><span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]</span>
            <span class="s3">del </span><span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]</span>
            <span class="s1">groupcounter </span><span class="s4">= </span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1  </span><span class="s0"># end routine</span>
            <span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">])</span>
            <span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1</span><span class="s4">][-</span><span class="s5">1</span><span class="s4">][</span><span class="s6">'body'</span><span class="s4">] = </span><span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]</span>
            <span class="s3">del </span><span class="s1">grouplist</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]</span>
            <span class="s1">groupcounter </span><span class="s4">= </span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">1  </span><span class="s0"># end interface</span>

    <span class="s3">elif </span><span class="s1">case </span><span class="s4">== </span><span class="s6">'entry'</span><span class="s4">:</span>
        <span class="s1">name</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">result</span><span class="s4">, </span><span class="s1">_</span><span class="s4">= </span><span class="s1">_resolvenameargspattern</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">))</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">args</span><span class="s4">:</span>
                <span class="s1">args </span><span class="s4">= </span><span class="s1">rmbadname</span><span class="s4">([</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">()</span>
                                  <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">args</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@,@'</span><span class="s4">)])</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">args </span><span class="s4">= []</span>
            <span class="s3">assert </span><span class="s1">result </span><span class="s3">is None</span><span class="s4">, </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">result</span><span class="s4">)</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'entry'</span><span class="s4">][</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">args</span>
            <span class="s1">previous_context </span><span class="s4">= (</span><span class="s6">'entry'</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">groupcounter</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">case </span><span class="s4">== </span><span class="s6">'type'</span><span class="s4">:</span>
        <span class="s1">typespec</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">, </span><span class="s1">edecl </span><span class="s4">= </span><span class="s1">cracktypespec0</span><span class="s4">(</span>
            <span class="s1">block</span><span class="s4">, </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">))</span>
        <span class="s1">last_name </span><span class="s4">= </span><span class="s1">updatevars</span><span class="s4">(</span><span class="s1">typespec</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">, </span><span class="s1">edecl</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">last_name </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">previous_context </span><span class="s4">= (</span><span class="s6">'variable'</span><span class="s4">, </span><span class="s1">last_name</span><span class="s4">, </span><span class="s1">groupcounter</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">case </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'dimension'</span><span class="s4">, </span><span class="s6">'intent'</span><span class="s4">, </span><span class="s6">'optional'</span><span class="s4">, </span><span class="s6">'required'</span><span class="s4">, </span><span class="s6">'external'</span><span class="s4">, </span><span class="s6">'public'</span><span class="s4">, </span><span class="s6">'private'</span><span class="s4">, </span><span class="s6">'intrinsic'</span><span class="s4">]:</span>
        <span class="s1">edecl </span><span class="s4">= </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">]</span>
        <span class="s1">ll </span><span class="s4">= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">).</span><span class="s1">strip</span><span class="s4">()</span>
        <span class="s1">i </span><span class="s4">= </span><span class="s1">ll</span><span class="s4">.</span><span class="s1">find</span><span class="s4">(</span><span class="s6">'::'</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">i </span><span class="s4">&lt; </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">case </span><span class="s4">== </span><span class="s6">'intent'</span><span class="s4">:</span>
            <span class="s1">i </span><span class="s4">= </span><span class="s1">markouterparen</span><span class="s4">(</span><span class="s1">ll</span><span class="s4">).</span><span class="s1">find</span><span class="s4">(</span><span class="s6">'@)@'</span><span class="s4">) - </span><span class="s5">2</span>
            <span class="s1">ll </span><span class="s4">= </span><span class="s1">ll</span><span class="s4">[:</span><span class="s1">i </span><span class="s4">+ </span><span class="s5">1</span><span class="s4">] + </span><span class="s6">'::' </span><span class="s4">+ </span><span class="s1">ll</span><span class="s4">[</span><span class="s1">i </span><span class="s4">+ </span><span class="s5">1</span><span class="s4">:]</span>
            <span class="s1">i </span><span class="s4">= </span><span class="s1">ll</span><span class="s4">.</span><span class="s1">find</span><span class="s4">(</span><span class="s6">'::'</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">ll</span><span class="s4">[</span><span class="s1">i</span><span class="s4">:] == </span><span class="s6">'::' </span><span class="s3">and </span><span class="s6">'args' </span><span class="s3">in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]:</span>
                <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'All arguments will have attribute %s%s</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">%</span>
                        <span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'this'</span><span class="s4">), </span><span class="s1">ll</span><span class="s4">[:</span><span class="s1">i</span><span class="s4">]))</span>
                <span class="s1">ll </span><span class="s4">= </span><span class="s1">ll </span><span class="s4">+ </span><span class="s6">','</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'args'</span><span class="s4">])</span>
        <span class="s3">if </span><span class="s1">i </span><span class="s4">&lt; </span><span class="s5">0</span><span class="s4">:</span>
            <span class="s1">i </span><span class="s4">= </span><span class="s5">0</span>
            <span class="s1">pl </span><span class="s4">= </span><span class="s6">''</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">pl </span><span class="s4">= </span><span class="s1">ll</span><span class="s4">[:</span><span class="s1">i</span><span class="s4">].</span><span class="s1">strip</span><span class="s4">()</span>
            <span class="s1">ll </span><span class="s4">= </span><span class="s1">ll</span><span class="s4">[</span><span class="s1">i </span><span class="s4">+ </span><span class="s5">2</span><span class="s4">:]</span>
        <span class="s1">ch </span><span class="s4">= </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">pl</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@,@'</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">ch</span><span class="s4">) &gt; </span><span class="s5">1</span><span class="s4">:</span>
            <span class="s1">pl </span><span class="s4">= </span><span class="s1">ch</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
            <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'analyzeline: cannot handle multiple attributes without type specification. Ignoring %r.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span>
                <span class="s6">','</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">ch</span><span class="s4">[</span><span class="s5">1</span><span class="s4">:])))</span>
        <span class="s1">last_name </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s4">[</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">ll</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@,@'</span><span class="s4">)]:</span>
            <span class="s1">m1 </span><span class="s4">= </span><span class="s1">namepattern</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">e</span><span class="s4">)</span>
            <span class="s3">if not </span><span class="s1">m1</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">case </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'public'</span><span class="s4">, </span><span class="s6">'private'</span><span class="s4">]:</span>
                    <span class="s1">k </span><span class="s4">= </span><span class="s6">''</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">print</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">groupdict</span><span class="s4">())</span>
                    <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'analyzeline: no name pattern found in %s statement for %s. Skipping.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span>
                        <span class="s1">case</span><span class="s4">, </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">e</span><span class="s4">)))</span>
                    <span class="s3">continue</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">k </span><span class="s4">= </span><span class="s1">rmbadname1</span><span class="s4">(</span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'name'</span><span class="s4">))</span>
            <span class="s3">if </span><span class="s1">case </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'public'</span><span class="s4">, </span><span class="s6">'private'</span><span class="s4">] </span><span class="s3">and </span><span class="s1">\</span>
               <span class="s4">(</span><span class="s1">k </span><span class="s4">== </span><span class="s6">'operator' </span><span class="s3">or </span><span class="s1">k </span><span class="s4">== </span><span class="s6">'assignment'</span><span class="s4">):</span>
                <span class="s1">k </span><span class="s4">+= </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">edecl</span><span class="s4">:</span>
                <span class="s1">edecl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] = {}</span>
            <span class="s3">if </span><span class="s1">case </span><span class="s4">== </span><span class="s6">'dimension'</span><span class="s4">:</span>
                <span class="s1">ap </span><span class="s4">= </span><span class="s1">case </span><span class="s4">+ </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">case </span><span class="s4">== </span><span class="s6">'intent'</span><span class="s4">:</span>
                <span class="s1">ap </span><span class="s4">= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'this'</span><span class="s4">) + </span><span class="s1">pl</span>
                <span class="s3">if </span><span class="s1">_intentcallbackpattern</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">ap</span><span class="s4">):</span>
                    <span class="s3">if </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'args'</span><span class="s4">]:</span>
                        <span class="s3">if </span><span class="s1">groupcounter </span><span class="s4">&gt; </span><span class="s5">1</span><span class="s4">:</span>
                            <span class="s3">if </span><span class="s6">'__user__' </span><span class="s3">not in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter </span><span class="s4">- </span><span class="s5">2</span><span class="s4">][</span><span class="s6">'name'</span><span class="s4">]:</span>
                                <span class="s1">outmess</span><span class="s4">(</span>
                                    <span class="s6">'analyzeline: missing __user__ module (could be nothing)</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">)</span>
                            <span class="s0"># fixes ticket 1693</span>
                            <span class="s3">if </span><span class="s1">k </span><span class="s4">!= </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'name'</span><span class="s4">]:</span>
                                <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'analyzeline: appending intent(callback) %s'</span>
                                        <span class="s6">' to %s arguments</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">k</span><span class="s4">, </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'name'</span><span class="s4">]))</span>
                                <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'args'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">k</span><span class="s4">)</span>
                        <span class="s3">else</span><span class="s4">:</span>
                            <span class="s1">errmess</span><span class="s4">(</span>
                                <span class="s6">'analyzeline: intent(callback) %s is ignored</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">k</span><span class="s4">))</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">errmess</span><span class="s4">(</span><span class="s6">'analyzeline: intent(callback) %s is already'</span>
                                <span class="s6">' in argument list</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">k</span><span class="s4">))</span>
            <span class="s3">if </span><span class="s1">case </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'optional'</span><span class="s4">, </span><span class="s6">'required'</span><span class="s4">, </span><span class="s6">'public'</span><span class="s4">, </span><span class="s6">'external'</span><span class="s4">, </span><span class="s6">'private'</span><span class="s4">, </span><span class="s6">'intrinsic'</span><span class="s4">]:</span>
                <span class="s1">ap </span><span class="s4">= </span><span class="s1">case</span>
            <span class="s3">if </span><span class="s6">'attrspec' </span><span class="s3">in </span><span class="s1">edecl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]:</span>
                <span class="s1">edecl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">ap</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">edecl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">] = [</span><span class="s1">ap</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">case </span><span class="s4">== </span><span class="s6">'external'</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'block'</span><span class="s4">] == </span><span class="s6">'program'</span><span class="s4">:</span>
                    <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'analyzeline: ignoring program arguments</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">)</span>
                    <span class="s3">continue</span>
                <span class="s3">if </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'args'</span><span class="s4">]:</span>
                    <span class="s3">continue</span>
                <span class="s3">if </span><span class="s6">'externals' </span><span class="s3">not in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]:</span>
                    <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'externals'</span><span class="s4">] = []</span>
                <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'externals'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">k</span><span class="s4">)</span>
            <span class="s1">last_name </span><span class="s4">= </span><span class="s1">k</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">] = </span><span class="s1">edecl</span>
        <span class="s3">if </span><span class="s1">last_name </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">previous_context </span><span class="s4">= (</span><span class="s6">'variable'</span><span class="s4">, </span><span class="s1">last_name</span><span class="s4">, </span><span class="s1">groupcounter</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">case </span><span class="s4">== </span><span class="s6">'moduleprocedure'</span><span class="s4">:</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'implementedby'</span><span class="s4">] = </span><span class="s1">\</span>
            <span class="s4">[</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">','</span><span class="s4">)]</span>
    <span class="s3">elif </span><span class="s1">case </span><span class="s4">== </span><span class="s6">'parameter'</span><span class="s4">:</span>
        <span class="s1">edecl </span><span class="s4">= </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">]</span>
        <span class="s1">ll </span><span class="s4">= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">).</span><span class="s1">strip</span><span class="s4">()[</span><span class="s5">1</span><span class="s4">:-</span><span class="s5">1</span><span class="s4">]</span>
        <span class="s1">last_name </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">ll</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@,@'</span><span class="s4">):</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">k</span><span class="s4">, </span><span class="s1">initexpr </span><span class="s4">= [</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">e</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'='</span><span class="s4">)]</span>
            <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
                <span class="s1">outmess</span><span class="s4">(</span>
                    <span class="s6">'analyzeline: could not extract name,expr in parameter statement &quot;%s&quot; of &quot;%s&quot;</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">e</span><span class="s4">, </span><span class="s1">ll</span><span class="s4">))</span>
                <span class="s3">continue</span>
            <span class="s1">params </span><span class="s4">= </span><span class="s1">get_parameters</span><span class="s4">(</span><span class="s1">edecl</span><span class="s4">)</span>
            <span class="s1">k </span><span class="s4">= </span><span class="s1">rmbadname1</span><span class="s4">(</span><span class="s1">k</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">edecl</span><span class="s4">:</span>
                <span class="s1">edecl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] = {}</span>
            <span class="s3">if </span><span class="s6">'=' </span><span class="s3">in </span><span class="s1">edecl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] </span><span class="s3">and </span><span class="s4">(</span><span class="s3">not </span><span class="s1">edecl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">][</span><span class="s6">'='</span><span class="s4">] == </span><span class="s1">initexpr</span><span class="s4">):</span>
                <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'analyzeline: Overwriting the value of parameter &quot;%s&quot; (&quot;%s&quot;) with &quot;%s&quot;.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span>
                    <span class="s1">k</span><span class="s4">, </span><span class="s1">edecl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">][</span><span class="s6">'='</span><span class="s4">], </span><span class="s1">initexpr</span><span class="s4">))</span>
            <span class="s1">t </span><span class="s4">= </span><span class="s1">determineexprtype</span><span class="s4">(</span><span class="s1">initexpr</span><span class="s4">, </span><span class="s1">params</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">t</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">t</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s6">'typespec'</span><span class="s4">) == </span><span class="s6">'real'</span><span class="s4">:</span>
                    <span class="s1">tt </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">initexpr</span><span class="s4">)</span>
                    <span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">real16pattern</span><span class="s4">.</span><span class="s1">finditer</span><span class="s4">(</span><span class="s1">initexpr</span><span class="s4">):</span>
                        <span class="s1">tt</span><span class="s4">[</span><span class="s1">m</span><span class="s4">.</span><span class="s1">start</span><span class="s4">():</span><span class="s1">m</span><span class="s4">.</span><span class="s1">end</span><span class="s4">()] = </span><span class="s1">list</span><span class="s4">(</span>
                            <span class="s1">initexpr</span><span class="s4">[</span><span class="s1">m</span><span class="s4">.</span><span class="s1">start</span><span class="s4">():</span><span class="s1">m</span><span class="s4">.</span><span class="s1">end</span><span class="s4">()].</span><span class="s1">lower</span><span class="s4">().</span><span class="s1">replace</span><span class="s4">(</span><span class="s6">'d'</span><span class="s4">, </span><span class="s6">'e'</span><span class="s4">))</span>
                    <span class="s1">initexpr </span><span class="s4">= </span><span class="s6">''</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">tt</span><span class="s4">)</span>
                <span class="s3">elif </span><span class="s1">t</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s6">'typespec'</span><span class="s4">) == </span><span class="s6">'complex'</span><span class="s4">:</span>
                    <span class="s1">initexpr </span><span class="s4">= </span><span class="s1">initexpr</span><span class="s4">[</span><span class="s5">1</span><span class="s4">:].</span><span class="s1">lower</span><span class="s4">().</span><span class="s1">replace</span><span class="s4">(</span><span class="s6">'d'</span><span class="s4">, </span><span class="s6">'e'</span><span class="s4">).</span><span class="s1">\</span>
                        <span class="s1">replace</span><span class="s4">(</span><span class="s6">','</span><span class="s4">, </span><span class="s6">'+1j*('</span><span class="s4">)</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">v </span><span class="s4">= </span><span class="s1">eval</span><span class="s4">(</span><span class="s1">initexpr</span><span class="s4">, {}, </span><span class="s1">params</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s4">(</span><span class="s1">SyntaxError</span><span class="s4">, </span><span class="s1">NameError</span><span class="s4">, </span><span class="s1">TypeError</span><span class="s4">) </span><span class="s3">as </span><span class="s1">msg</span><span class="s4">:</span>
                <span class="s1">errmess</span><span class="s4">(</span><span class="s6">'analyzeline: Failed to evaluate %r. Ignoring: %s</span><span class="s3">\n</span><span class="s6">'</span>
                        <span class="s4">% (</span><span class="s1">initexpr</span><span class="s4">, </span><span class="s1">msg</span><span class="s4">))</span>
                <span class="s3">continue</span>
            <span class="s1">edecl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">][</span><span class="s6">'='</span><span class="s4">] = </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">v</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s6">'attrspec' </span><span class="s3">in </span><span class="s1">edecl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]:</span>
                <span class="s1">edecl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s6">'parameter'</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">edecl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">] = [</span><span class="s6">'parameter'</span><span class="s4">]</span>
            <span class="s1">last_name </span><span class="s4">= </span><span class="s1">k</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">] = </span><span class="s1">edecl</span>
        <span class="s3">if </span><span class="s1">last_name </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">previous_context </span><span class="s4">= (</span><span class="s6">'variable'</span><span class="s4">, </span><span class="s1">last_name</span><span class="s4">, </span><span class="s1">groupcounter</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">case </span><span class="s4">== </span><span class="s6">'implicit'</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">).</span><span class="s1">strip</span><span class="s4">().</span><span class="s1">lower</span><span class="s4">() == </span><span class="s6">'none'</span><span class="s4">:</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'implicit'</span><span class="s4">] = </span><span class="s3">None</span>
        <span class="s3">elif </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s6">'implicit' </span><span class="s3">in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]:</span>
                <span class="s1">impl </span><span class="s4">= </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'implicit'</span><span class="s4">]</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">impl </span><span class="s4">= {}</span>
            <span class="s3">if </span><span class="s1">impl </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">outmess</span><span class="s4">(</span>
                    <span class="s6">'analyzeline: Overwriting earlier &quot;implicit none&quot; statement.</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">)</span>
                <span class="s1">impl </span><span class="s4">= {}</span>
            <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">)).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@,@'</span><span class="s4">):</span>
                <span class="s1">decl </span><span class="s4">= {}</span>
                <span class="s1">m1 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span>
                    <span class="s6">r'\s*(?P&lt;this&gt;.*?)\s*(\(\s*(?P&lt;after&gt;[a-z-, ]+)\s*\)\s*|)\Z'</span><span class="s4">, </span><span class="s1">e</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
                <span class="s3">if not </span><span class="s1">m1</span><span class="s4">:</span>
                    <span class="s1">outmess</span><span class="s4">(</span>
                        <span class="s6">'analyzeline: could not extract info of implicit statement part &quot;%s&quot;</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">e</span><span class="s4">))</span>
                    <span class="s3">continue</span>
                <span class="s1">m2 </span><span class="s4">= </span><span class="s1">typespattern4implicit</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'this'</span><span class="s4">))</span>
                <span class="s3">if not </span><span class="s1">m2</span><span class="s4">:</span>
                    <span class="s1">outmess</span><span class="s4">(</span>
                        <span class="s6">'analyzeline: could not extract types pattern of implicit statement part &quot;%s&quot;</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">e</span><span class="s4">))</span>
                    <span class="s3">continue</span>
                <span class="s1">typespec</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">, </span><span class="s1">edecl </span><span class="s4">= </span><span class="s1">cracktypespec0</span><span class="s4">(</span>
                    <span class="s1">m2</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'this'</span><span class="s4">), </span><span class="s1">m2</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">))</span>
                <span class="s1">kindselect</span><span class="s4">, </span><span class="s1">charselect</span><span class="s4">, </span><span class="s1">typename </span><span class="s4">= </span><span class="s1">cracktypespec</span><span class="s4">(</span>
                    <span class="s1">typespec</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">)</span>
                <span class="s1">decl</span><span class="s4">[</span><span class="s6">'typespec'</span><span class="s4">] = </span><span class="s1">typespec</span>
                <span class="s1">decl</span><span class="s4">[</span><span class="s6">'kindselector'</span><span class="s4">] = </span><span class="s1">kindselect</span>
                <span class="s1">decl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">] = </span><span class="s1">charselect</span>
                <span class="s1">decl</span><span class="s4">[</span><span class="s6">'typename'</span><span class="s4">] = </span><span class="s1">typename</span>
                <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">decl</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
                    <span class="s3">if not </span><span class="s1">decl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]:</span>
                        <span class="s3">del </span><span class="s1">decl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>
                <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">)).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@,@'</span><span class="s4">):</span>
                    <span class="s3">if </span><span class="s6">'-' </span><span class="s3">in </span><span class="s1">r</span><span class="s4">:</span>
                        <span class="s3">try</span><span class="s4">:</span>
                            <span class="s1">begc</span><span class="s4">, </span><span class="s1">endc </span><span class="s4">= [</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">r</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'-'</span><span class="s4">)]</span>
                        <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
                            <span class="s1">outmess</span><span class="s4">(</span>
                                <span class="s6">'analyzeline: expected &quot;&lt;char&gt;-&lt;char&gt;&quot; instead of &quot;%s&quot; in range list of implicit statement</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">r</span><span class="s4">)</span>
                            <span class="s3">continue</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">begc </span><span class="s4">= </span><span class="s1">endc </span><span class="s4">= </span><span class="s1">r</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">()</span>
                    <span class="s3">if not </span><span class="s1">len</span><span class="s4">(</span><span class="s1">begc</span><span class="s4">) == </span><span class="s1">len</span><span class="s4">(</span><span class="s1">endc</span><span class="s4">) == </span><span class="s5">1</span><span class="s4">:</span>
                        <span class="s1">outmess</span><span class="s4">(</span>
                            <span class="s6">'analyzeline: expected &quot;&lt;char&gt;-&lt;char&gt;&quot; instead of &quot;%s&quot; in range list of implicit statement (2)</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">r</span><span class="s4">)</span>
                        <span class="s3">continue</span>
                    <span class="s3">for </span><span class="s1">o </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">ord</span><span class="s4">(</span><span class="s1">begc</span><span class="s4">), </span><span class="s1">ord</span><span class="s4">(</span><span class="s1">endc</span><span class="s4">) + </span><span class="s5">1</span><span class="s4">):</span>
                        <span class="s1">impl</span><span class="s4">[</span><span class="s1">chr</span><span class="s4">(</span><span class="s1">o</span><span class="s4">)] = </span><span class="s1">decl</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'implicit'</span><span class="s4">] = </span><span class="s1">impl</span>
    <span class="s3">elif </span><span class="s1">case </span><span class="s4">== </span><span class="s6">'data'</span><span class="s4">:</span>
        <span class="s1">ll </span><span class="s4">= []</span>
        <span class="s1">dl </span><span class="s4">= </span><span class="s6">''</span>
        <span class="s1">il </span><span class="s4">= </span><span class="s6">''</span>
        <span class="s1">f </span><span class="s4">= </span><span class="s5">0</span>
        <span class="s1">fc </span><span class="s4">= </span><span class="s5">1</span>
        <span class="s1">inp </span><span class="s4">= </span><span class="s5">0</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">):</span>
            <span class="s3">if not </span><span class="s1">inp</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">c </span><span class="s4">== </span><span class="s6">&quot;'&quot;</span><span class="s4">:</span>
                    <span class="s1">fc </span><span class="s4">= </span><span class="s3">not </span><span class="s1">fc</span>
                <span class="s3">if </span><span class="s1">c </span><span class="s4">== </span><span class="s6">'/' </span><span class="s3">and </span><span class="s1">fc</span><span class="s4">:</span>
                    <span class="s1">f </span><span class="s4">= </span><span class="s1">f </span><span class="s4">+ </span><span class="s5">1</span>
                    <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">c </span><span class="s4">== </span><span class="s6">'('</span><span class="s4">:</span>
                <span class="s1">inp </span><span class="s4">= </span><span class="s1">inp </span><span class="s4">+ </span><span class="s5">1</span>
            <span class="s3">elif </span><span class="s1">c </span><span class="s4">== </span><span class="s6">')'</span><span class="s4">:</span>
                <span class="s1">inp </span><span class="s4">= </span><span class="s1">inp </span><span class="s4">- </span><span class="s5">1</span>
            <span class="s3">if </span><span class="s1">f </span><span class="s4">== </span><span class="s5">0</span><span class="s4">:</span>
                <span class="s1">dl </span><span class="s4">= </span><span class="s1">dl </span><span class="s4">+ </span><span class="s1">c</span>
            <span class="s3">elif </span><span class="s1">f </span><span class="s4">== </span><span class="s5">1</span><span class="s4">:</span>
                <span class="s1">il </span><span class="s4">= </span><span class="s1">il </span><span class="s4">+ </span><span class="s1">c</span>
            <span class="s3">elif </span><span class="s1">f </span><span class="s4">== </span><span class="s5">2</span><span class="s4">:</span>
                <span class="s1">dl </span><span class="s4">= </span><span class="s1">dl</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">()</span>
                <span class="s3">if </span><span class="s1">dl</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s6">','</span><span class="s4">):</span>
                    <span class="s1">dl </span><span class="s4">= </span><span class="s1">dl</span><span class="s4">[</span><span class="s5">1</span><span class="s4">:].</span><span class="s1">strip</span><span class="s4">()</span>
                <span class="s1">ll</span><span class="s4">.</span><span class="s1">append</span><span class="s4">([</span><span class="s1">dl</span><span class="s4">, </span><span class="s1">il</span><span class="s4">])</span>
                <span class="s1">dl </span><span class="s4">= </span><span class="s1">c</span>
                <span class="s1">il </span><span class="s4">= </span><span class="s6">''</span>
                <span class="s1">f </span><span class="s4">= </span><span class="s5">0</span>
        <span class="s3">if </span><span class="s1">f </span><span class="s4">== </span><span class="s5">2</span><span class="s4">:</span>
            <span class="s1">dl </span><span class="s4">= </span><span class="s1">dl</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s1">dl</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s6">','</span><span class="s4">):</span>
                <span class="s1">dl </span><span class="s4">= </span><span class="s1">dl</span><span class="s4">[</span><span class="s5">1</span><span class="s4">:].</span><span class="s1">strip</span><span class="s4">()</span>
            <span class="s1">ll</span><span class="s4">.</span><span class="s1">append</span><span class="s4">([</span><span class="s1">dl</span><span class="s4">, </span><span class="s1">il</span><span class="s4">])</span>
        <span class="s1">vars </span><span class="s4">= </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">].</span><span class="s1">get</span><span class="s4">(</span><span class="s6">'vars'</span><span class="s4">, {})</span>
        <span class="s1">last_name </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">ll</span><span class="s4">:</span>
            <span class="s1">l</span><span class="s4">[</span><span class="s5">0</span><span class="s4">], </span><span class="s1">l</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] = </span><span class="s1">l</span><span class="s4">[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">strip</span><span class="s4">(), </span><span class="s1">l</span><span class="s4">[</span><span class="s5">1</span><span class="s4">].</span><span class="s1">strip</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s1">l</span><span class="s4">[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">startswith</span><span class="s4">(</span><span class="s6">','</span><span class="s4">):</span>
                <span class="s1">l</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] = </span><span class="s1">l</span><span class="s4">[</span><span class="s5">0</span><span class="s4">][</span><span class="s5">1</span><span class="s4">:]</span>
            <span class="s3">if </span><span class="s1">l</span><span class="s4">[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">startswith</span><span class="s4">(</span><span class="s6">'('</span><span class="s4">):</span>
                <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'analyzeline: implied-DO list &quot;%s&quot; is not supported. Skipping.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">l</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>
                <span class="s3">continue</span>
            <span class="s3">for </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">rmbadname</span><span class="s4">([</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">l</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@,@'</span><span class="s4">)])):</span>
                <span class="s3">if </span><span class="s1">v</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s6">'('</span><span class="s4">):</span>
                    <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'analyzeline: implied-DO list &quot;%s&quot; is not supported. Skipping.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">v</span><span class="s4">)</span>
                    <span class="s0"># XXX: subsequent init expressions may get wrong values.</span>
                    <span class="s0"># Ignoring since data statements are irrelevant for</span>
                    <span class="s0"># wrapping.</span>
                    <span class="s3">continue</span>
                <span class="s3">if </span><span class="s6">'!' </span><span class="s3">in </span><span class="s1">l</span><span class="s4">[</span><span class="s5">1</span><span class="s4">]:</span>
                    <span class="s0"># Fixes gh-24746 pyf generation</span>
                    <span class="s0"># XXX: This essentially ignores the value for generating the pyf which is fine:</span>
                    <span class="s0"># integer dimension(3) :: mytab</span>
                    <span class="s0"># common /mycom/ mytab</span>
                    <span class="s0"># Since in any case it is initialized in the Fortran code</span>
                    <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'Comment line in declaration &quot;%s&quot; is not supported. Skipping.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">l</span><span class="s4">[</span><span class="s5">1</span><span class="s4">])</span>
                    <span class="s3">continue</span>
                <span class="s1">vars</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s1">v</span><span class="s4">, {})</span>
                <span class="s1">vtype </span><span class="s4">= </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">].</span><span class="s1">get</span><span class="s4">(</span><span class="s6">'typespec'</span><span class="s4">)</span>
                <span class="s1">vdim </span><span class="s4">= </span><span class="s1">getdimension</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">])</span>
                <span class="s1">matches </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">findall</span><span class="s4">(</span><span class="s6">r&quot;\(.*?\)&quot;</span><span class="s4">, </span><span class="s1">l</span><span class="s4">[</span><span class="s5">1</span><span class="s4">]) </span><span class="s3">if </span><span class="s1">vtype </span><span class="s4">== </span><span class="s6">'complex' </span><span class="s3">else </span><span class="s1">l</span><span class="s4">[</span><span class="s5">1</span><span class="s4">].</span><span class="s1">split</span><span class="s4">(</span><span class="s6">','</span><span class="s4">)</span>
                <span class="s3">try</span><span class="s4">:</span>
                    <span class="s1">new_val </span><span class="s4">= </span><span class="s6">&quot;(/{}/)&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s6">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">matches</span><span class="s4">)) </span><span class="s3">if </span><span class="s1">vdim </span><span class="s3">else </span><span class="s1">matches</span><span class="s4">[</span><span class="s1">idx</span><span class="s4">]</span>
                <span class="s3">except </span><span class="s1">IndexError</span><span class="s4">:</span>
                    <span class="s0"># gh-24746</span>
                    <span class="s0"># Runs only if above code fails. Fixes the line</span>
                    <span class="s0"># DATA IVAR1, IVAR2, IVAR3, IVAR4, EVAR5 /4*0,0.0D0/</span>
                    <span class="s0"># by expanding to ['0', '0', '0', '0', '0.0d0']</span>
                    <span class="s3">if </span><span class="s1">any</span><span class="s4">(</span><span class="s6">&quot;*&quot; </span><span class="s3">in </span><span class="s1">m </span><span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">matches</span><span class="s4">):</span>
                        <span class="s1">expanded_list </span><span class="s4">= []</span>
                        <span class="s3">for </span><span class="s1">match </span><span class="s3">in </span><span class="s1">matches</span><span class="s4">:</span>
                            <span class="s3">if </span><span class="s6">&quot;*&quot; </span><span class="s3">in </span><span class="s1">match</span><span class="s4">:</span>
                                <span class="s3">try</span><span class="s4">:</span>
                                    <span class="s1">multiplier</span><span class="s4">, </span><span class="s1">value </span><span class="s4">= </span><span class="s1">match</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s6">&quot;*&quot;</span><span class="s4">)</span>
                                    <span class="s1">expanded_list</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">([</span><span class="s1">value</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">()] * </span><span class="s1">int</span><span class="s4">(</span><span class="s1">multiplier</span><span class="s4">))</span>
                                <span class="s3">except </span><span class="s1">ValueError</span><span class="s4">: </span><span class="s0"># if int(multiplier) fails</span>
                                    <span class="s1">expanded_list</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">match</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">())</span>
                            <span class="s3">else</span><span class="s4">:</span>
                                <span class="s1">expanded_list</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">match</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">())</span>
                        <span class="s1">matches </span><span class="s4">= </span><span class="s1">expanded_list</span>
                    <span class="s1">new_val </span><span class="s4">= </span><span class="s6">&quot;(/{}/)&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s6">&quot;, &quot;</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">matches</span><span class="s4">)) </span><span class="s3">if </span><span class="s1">vdim </span><span class="s3">else </span><span class="s1">matches</span><span class="s4">[</span><span class="s1">idx</span><span class="s4">]</span>
                <span class="s1">current_val </span><span class="s4">= </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">].</span><span class="s1">get</span><span class="s4">(</span><span class="s6">'='</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">current_val </span><span class="s3">and </span><span class="s4">(</span><span class="s1">current_val </span><span class="s4">!= </span><span class="s1">new_val</span><span class="s4">):</span>
                    <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'analyzeline: changing init expression of &quot;%s&quot; (&quot;%s&quot;) to &quot;%s&quot;</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">v</span><span class="s4">, </span><span class="s1">current_val</span><span class="s4">, </span><span class="s1">new_val</span><span class="s4">))</span>
                <span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">][</span><span class="s6">'='</span><span class="s4">] = </span><span class="s1">new_val</span>
                <span class="s1">last_name </span><span class="s4">= </span><span class="s1">v</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">] = </span><span class="s1">vars</span>
        <span class="s3">if </span><span class="s1">last_name</span><span class="s4">:</span>
            <span class="s1">previous_context </span><span class="s4">= (</span><span class="s6">'variable'</span><span class="s4">, </span><span class="s1">last_name</span><span class="s4">, </span><span class="s1">groupcounter</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">case </span><span class="s4">== </span><span class="s6">'common'</span><span class="s4">:</span>
        <span class="s1">line </span><span class="s4">= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">).</span><span class="s1">strip</span><span class="s4">()</span>
        <span class="s3">if not </span><span class="s1">line</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] == </span><span class="s6">'/'</span><span class="s4">:</span>
            <span class="s1">line </span><span class="s4">= </span><span class="s6">'//' </span><span class="s4">+ </span><span class="s1">line</span>
        <span class="s1">cl </span><span class="s4">= []</span>
        <span class="s1">f </span><span class="s4">= </span><span class="s5">0</span>
        <span class="s1">bn </span><span class="s4">= </span><span class="s6">''</span>
        <span class="s1">ol </span><span class="s4">= </span><span class="s6">''</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">line</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">c </span><span class="s4">== </span><span class="s6">'/'</span><span class="s4">:</span>
                <span class="s1">f </span><span class="s4">= </span><span class="s1">f </span><span class="s4">+ </span><span class="s5">1</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">f </span><span class="s4">&gt;= </span><span class="s5">3</span><span class="s4">:</span>
                <span class="s1">bn </span><span class="s4">= </span><span class="s1">bn</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">()</span>
                <span class="s3">if not </span><span class="s1">bn</span><span class="s4">:</span>
                    <span class="s1">bn </span><span class="s4">= </span><span class="s6">'_BLNK_'</span>
                <span class="s1">cl</span><span class="s4">.</span><span class="s1">append</span><span class="s4">([</span><span class="s1">bn</span><span class="s4">, </span><span class="s1">ol</span><span class="s4">])</span>
                <span class="s1">f </span><span class="s4">= </span><span class="s1">f </span><span class="s4">- </span><span class="s5">2</span>
                <span class="s1">bn </span><span class="s4">= </span><span class="s6">''</span>
                <span class="s1">ol </span><span class="s4">= </span><span class="s6">''</span>
            <span class="s3">if </span><span class="s1">f </span><span class="s4">% </span><span class="s5">2</span><span class="s4">:</span>
                <span class="s1">bn </span><span class="s4">= </span><span class="s1">bn </span><span class="s4">+ </span><span class="s1">c</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">ol </span><span class="s4">= </span><span class="s1">ol </span><span class="s4">+ </span><span class="s1">c</span>
        <span class="s1">bn </span><span class="s4">= </span><span class="s1">bn</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">()</span>
        <span class="s3">if not </span><span class="s1">bn</span><span class="s4">:</span>
            <span class="s1">bn </span><span class="s4">= </span><span class="s6">'_BLNK_'</span>
        <span class="s1">cl</span><span class="s4">.</span><span class="s1">append</span><span class="s4">([</span><span class="s1">bn</span><span class="s4">, </span><span class="s1">ol</span><span class="s4">])</span>
        <span class="s1">commonkey </span><span class="s4">= {}</span>
        <span class="s3">if </span><span class="s6">'common' </span><span class="s3">in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]:</span>
            <span class="s1">commonkey </span><span class="s4">= </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'common'</span><span class="s4">]</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">cl</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">c</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] </span><span class="s3">not in </span><span class="s1">commonkey</span><span class="s4">:</span>
                <span class="s1">commonkey</span><span class="s4">[</span><span class="s1">c</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]] = []</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s4">[</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">c</span><span class="s4">[</span><span class="s5">1</span><span class="s4">]).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@,@'</span><span class="s4">)]:</span>
                <span class="s3">if </span><span class="s1">i</span><span class="s4">:</span>
                    <span class="s1">commonkey</span><span class="s4">[</span><span class="s1">c</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'common'</span><span class="s4">] = </span><span class="s1">commonkey</span>
        <span class="s1">previous_context </span><span class="s4">= (</span><span class="s6">'common'</span><span class="s4">, </span><span class="s1">bn</span><span class="s4">, </span><span class="s1">groupcounter</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">case </span><span class="s4">== </span><span class="s6">'use'</span><span class="s4">:</span>
        <span class="s1">m1 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span>
            <span class="s6">r'\A\s*(?P&lt;name&gt;\b\w+\b)\s*((,(\s*\bonly\b\s*:|(?P&lt;notonly&gt;))\s*(?P&lt;list&gt;.*))|)\s*\Z'</span><span class="s4">, </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">m1</span><span class="s4">:</span>
            <span class="s1">mm </span><span class="s4">= </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">groupdict</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s6">'use' </span><span class="s3">not in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]:</span>
                <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'use'</span><span class="s4">] = {}</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'name'</span><span class="s4">)</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'use'</span><span class="s4">][</span><span class="s1">name</span><span class="s4">] = {}</span>
            <span class="s1">isonly </span><span class="s4">= </span><span class="s5">0</span>
            <span class="s3">if </span><span class="s6">'list' </span><span class="s3">in </span><span class="s1">mm </span><span class="s3">and </span><span class="s1">mm</span><span class="s4">[</span><span class="s6">'list'</span><span class="s4">] </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s6">'notonly' </span><span class="s3">in </span><span class="s1">mm </span><span class="s3">and </span><span class="s1">mm</span><span class="s4">[</span><span class="s6">'notonly'</span><span class="s4">] </span><span class="s3">is None</span><span class="s4">:</span>
                    <span class="s1">isonly </span><span class="s4">= </span><span class="s5">1</span>
                <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'use'</span><span class="s4">][</span><span class="s1">name</span><span class="s4">][</span><span class="s6">'only'</span><span class="s4">] = </span><span class="s1">isonly</span>
                <span class="s1">ll </span><span class="s4">= [</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">mm</span><span class="s4">[</span><span class="s6">'list'</span><span class="s4">].</span><span class="s1">split</span><span class="s4">(</span><span class="s6">','</span><span class="s4">)]</span>
                <span class="s1">rl </span><span class="s4">= {}</span>
                <span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">ll</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s6">'=' </span><span class="s3">in </span><span class="s1">l</span><span class="s4">:</span>
                        <span class="s1">m2 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span>
                            <span class="s6">r'\A\s*(?P&lt;local&gt;\b\w+\b)\s*=\s*&gt;\s*(?P&lt;use&gt;\b\w+\b)\s*\Z'</span><span class="s4">, </span><span class="s1">l</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
                        <span class="s3">if </span><span class="s1">m2</span><span class="s4">:</span>
                            <span class="s1">rl</span><span class="s4">[</span><span class="s1">m2</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'local'</span><span class="s4">).</span><span class="s1">strip</span><span class="s4">()] = </span><span class="s1">m2</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span>
                                <span class="s6">'use'</span><span class="s4">).</span><span class="s1">strip</span><span class="s4">()</span>
                        <span class="s3">else</span><span class="s4">:</span>
                            <span class="s1">outmess</span><span class="s4">(</span>
                                <span class="s6">'analyzeline: Not local=&gt;use pattern found in %s</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">l</span><span class="s4">))</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">rl</span><span class="s4">[</span><span class="s1">l</span><span class="s4">] = </span><span class="s1">l</span>
                    <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'use'</span><span class="s4">][</span><span class="s1">name</span><span class="s4">][</span><span class="s6">'map'</span><span class="s4">] = </span><span class="s1">rl</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">pass</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">print</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">groupdict</span><span class="s4">())</span>
            <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'analyzeline: Could not crack the use statement.</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">case </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'f2pyenhancements'</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s6">'f2pyenhancements' </span><span class="s3">not in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]:</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'f2pyenhancements'</span><span class="s4">] = {}</span>
        <span class="s1">d </span><span class="s4">= </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'f2pyenhancements'</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'this'</span><span class="s4">) == </span><span class="s6">'usercode' </span><span class="s3">and </span><span class="s6">'usercode' </span><span class="s3">in </span><span class="s1">d</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">d</span><span class="s4">[</span><span class="s6">'usercode'</span><span class="s4">], </span><span class="s1">str</span><span class="s4">):</span>
                <span class="s1">d</span><span class="s4">[</span><span class="s6">'usercode'</span><span class="s4">] = [</span><span class="s1">d</span><span class="s4">[</span><span class="s6">'usercode'</span><span class="s4">]]</span>
            <span class="s1">d</span><span class="s4">[</span><span class="s6">'usercode'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">))</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">d</span><span class="s4">[</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'this'</span><span class="s4">)] = </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">case </span><span class="s4">== </span><span class="s6">'multiline'</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">previous_context </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">verbose</span><span class="s4">:</span>
                <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'analyzeline: No context for multiline block.</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">)</span>
            <span class="s3">return</span>
        <span class="s1">gc </span><span class="s4">= </span><span class="s1">groupcounter</span>
        <span class="s1">appendmultiline</span><span class="s4">(</span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">gc</span><span class="s4">],</span>
                        <span class="s1">previous_context</span><span class="s4">[:</span><span class="s5">2</span><span class="s4">],</span>
                        <span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'this'</span><span class="s4">))</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">verbose </span><span class="s4">&gt; </span><span class="s5">1</span><span class="s4">:</span>
            <span class="s1">print</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">groupdict</span><span class="s4">())</span>
            <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'analyzeline: No code implemented for line.</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">appendmultiline</span><span class="s4">(</span><span class="s1">group</span><span class="s4">, </span><span class="s1">context_name</span><span class="s4">, </span><span class="s1">ml</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s6">'f2pymultilines' </span><span class="s3">not in </span><span class="s1">group</span><span class="s4">:</span>
        <span class="s1">group</span><span class="s4">[</span><span class="s6">'f2pymultilines'</span><span class="s4">] = {}</span>
    <span class="s1">d </span><span class="s4">= </span><span class="s1">group</span><span class="s4">[</span><span class="s6">'f2pymultilines'</span><span class="s4">]</span>
    <span class="s3">if </span><span class="s1">context_name </span><span class="s3">not in </span><span class="s1">d</span><span class="s4">:</span>
        <span class="s1">d</span><span class="s4">[</span><span class="s1">context_name</span><span class="s4">] = []</span>
    <span class="s1">d</span><span class="s4">[</span><span class="s1">context_name</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">ml</span><span class="s4">)</span>
    <span class="s3">return</span>


<span class="s3">def </span><span class="s1">cracktypespec0</span><span class="s4">(</span><span class="s1">typespec</span><span class="s4">, </span><span class="s1">ll</span><span class="s4">):</span>
    <span class="s1">selector </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s1">attr </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s6">r'double\s*complex'</span><span class="s4">, </span><span class="s1">typespec</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">):</span>
        <span class="s1">typespec </span><span class="s4">= </span><span class="s6">'double complex'</span>
    <span class="s3">elif </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s6">r'double\s*precision'</span><span class="s4">, </span><span class="s1">typespec</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">):</span>
        <span class="s1">typespec </span><span class="s4">= </span><span class="s6">'double precision'</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">typespec </span><span class="s4">= </span><span class="s1">typespec</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">().</span><span class="s1">lower</span><span class="s4">()</span>
    <span class="s1">m1 </span><span class="s4">= </span><span class="s1">selectpattern</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">markouterparen</span><span class="s4">(</span><span class="s1">ll</span><span class="s4">))</span>
    <span class="s3">if not </span><span class="s1">m1</span><span class="s4">:</span>
        <span class="s1">outmess</span><span class="s4">(</span>
            <span class="s6">'cracktypespec0: no kind/char_selector pattern found for line.</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">)</span>
        <span class="s3">return</span>
    <span class="s1">d </span><span class="s4">= </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">groupdict</span><span class="s4">()</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">d</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
        <span class="s1">d</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] = </span><span class="s1">unmarkouterparen</span><span class="s4">(</span><span class="s1">d</span><span class="s4">[</span><span class="s1">k</span><span class="s4">])</span>
    <span class="s3">if </span><span class="s1">typespec </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'complex'</span><span class="s4">, </span><span class="s6">'integer'</span><span class="s4">, </span><span class="s6">'logical'</span><span class="s4">, </span><span class="s6">'real'</span><span class="s4">, </span><span class="s6">'character'</span><span class="s4">, </span><span class="s6">'type'</span><span class="s4">]:</span>
        <span class="s1">selector </span><span class="s4">= </span><span class="s1">d</span><span class="s4">[</span><span class="s6">'this'</span><span class="s4">]</span>
        <span class="s1">ll </span><span class="s4">= </span><span class="s1">d</span><span class="s4">[</span><span class="s6">'after'</span><span class="s4">]</span>
    <span class="s1">i </span><span class="s4">= </span><span class="s1">ll</span><span class="s4">.</span><span class="s1">find</span><span class="s4">(</span><span class="s6">'::'</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">i </span><span class="s4">&gt;= </span><span class="s5">0</span><span class="s4">:</span>
        <span class="s1">attr </span><span class="s4">= </span><span class="s1">ll</span><span class="s4">[:</span><span class="s1">i</span><span class="s4">].</span><span class="s1">strip</span><span class="s4">()</span>
        <span class="s1">ll </span><span class="s4">= </span><span class="s1">ll</span><span class="s4">[</span><span class="s1">i </span><span class="s4">+ </span><span class="s5">2</span><span class="s4">:]</span>
    <span class="s3">return </span><span class="s1">typespec</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">, </span><span class="s1">ll</span>
<span class="s0">#####</span>
<span class="s1">namepattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'\s*(?P&lt;name&gt;\b\w+\b)\s*(?P&lt;after&gt;.*)\s*\Z'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
<span class="s1">kindselector </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s6">r'\s*(\(\s*(kind\s*=)?\s*(?P&lt;kind&gt;.*)\s*\)|\*\s*(?P&lt;kind2&gt;.*?))\s*\Z'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
<span class="s1">charselector </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s6">r'\s*(\((?P&lt;lenkind&gt;.*)\)|\*\s*(?P&lt;charlen&gt;.*))\s*\Z'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
<span class="s1">lenkindpattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s6">r'\s*(kind\s*=\s*(?P&lt;kind&gt;.*?)\s*(@,@\s*len\s*=\s*(?P&lt;len&gt;.*)|)'</span>
    <span class="s6">r'|(len\s*=\s*|)(?P&lt;len2&gt;.*?)\s*(@,@\s*(kind\s*=\s*|)(?P&lt;kind2&gt;.*)'</span>
    <span class="s6">r'|(f2py_len\s*=\s*(?P&lt;f2py_len&gt;.*))|))\s*\Z'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
<span class="s1">lenarraypattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s6">r'\s*(@\(@\s*(?!/)\s*(?P&lt;array&gt;.*?)\s*@\)@\s*\*\s*(?P&lt;len&gt;.*?)|(\*\s*(?P&lt;len2&gt;.*?)|)\s*(@\(@\s*(?!/)\s*(?P&lt;array2&gt;.*?)\s*@\)@|))\s*(=\s*(?P&lt;init&gt;.*?)|(@\(@|)/\s*(?P&lt;init2&gt;.*?)\s*/(@\)@|)|)\s*\Z'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">removespaces</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">):</span>
    <span class="s1">expr </span><span class="s4">= </span><span class="s1">expr</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">()</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">) &lt;= </span><span class="s5">1</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">expr</span>
    <span class="s1">expr2 </span><span class="s4">= </span><span class="s1">expr</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s5">1</span><span class="s4">, </span><span class="s1">len</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">) - </span><span class="s5">1</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s1">expr</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] == </span><span class="s6">' ' </span><span class="s3">and</span>
            <span class="s4">((</span><span class="s1">expr</span><span class="s4">[</span><span class="s1">i </span><span class="s4">+ </span><span class="s5">1</span><span class="s4">] </span><span class="s3">in </span><span class="s6">&quot;()[]{}=+-/* &quot;</span><span class="s4">) </span><span class="s3">or</span>
                <span class="s4">(</span><span class="s1">expr</span><span class="s4">[</span><span class="s1">i </span><span class="s4">- </span><span class="s5">1</span><span class="s4">] </span><span class="s3">in </span><span class="s6">&quot;()[]{}=+-/* &quot;</span><span class="s4">))):</span>
            <span class="s3">continue</span>
        <span class="s1">expr2 </span><span class="s4">= </span><span class="s1">expr2 </span><span class="s4">+ </span><span class="s1">expr</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
    <span class="s1">expr2 </span><span class="s4">= </span><span class="s1">expr2 </span><span class="s4">+ </span><span class="s1">expr</span><span class="s4">[-</span><span class="s5">1</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">expr2</span>


<span class="s3">def </span><span class="s1">markinnerspaces</span><span class="s4">(</span><span class="s1">line</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    The function replace all spaces in the input variable line which are  
    surrounded with quotation marks, with the triplet &quot;@_@&quot;. 
 
    For instance, for the input &quot;a 'b c'&quot; the function returns &quot;a 'b@_@c'&quot; 
 
    Parameters 
    ---------- 
    line : str 
 
    Returns 
    ------- 
    str 
 
    &quot;&quot;&quot;  </span>
    <span class="s1">fragment </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s1">inside </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">current_quote </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s1">escaped </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">line</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">escaped </span><span class="s4">== </span><span class="s6">'</span><span class="s3">\\</span><span class="s6">' </span><span class="s3">and </span><span class="s1">c </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'</span><span class="s3">\\</span><span class="s6">'</span><span class="s4">, </span><span class="s6">'</span><span class="s3">\'</span><span class="s6">'</span><span class="s4">, </span><span class="s6">'&quot;'</span><span class="s4">]:</span>
            <span class="s1">fragment </span><span class="s4">+= </span><span class="s1">c</span>
            <span class="s1">escaped </span><span class="s4">= </span><span class="s1">c</span>
            <span class="s3">continue</span>
        <span class="s3">if not </span><span class="s1">inside </span><span class="s3">and </span><span class="s1">c </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'</span><span class="s3">\'</span><span class="s6">'</span><span class="s4">, </span><span class="s6">'&quot;'</span><span class="s4">]:</span>
            <span class="s1">current_quote </span><span class="s4">= </span><span class="s1">c</span>
        <span class="s3">if </span><span class="s1">c </span><span class="s4">== </span><span class="s1">current_quote</span><span class="s4">:</span>
            <span class="s1">inside </span><span class="s4">= </span><span class="s3">not </span><span class="s1">inside</span>
        <span class="s3">elif </span><span class="s1">c </span><span class="s4">== </span><span class="s6">' ' </span><span class="s3">and </span><span class="s1">inside</span><span class="s4">:</span>
            <span class="s1">fragment </span><span class="s4">+= </span><span class="s6">'@_@'</span>
            <span class="s3">continue</span>
        <span class="s1">fragment </span><span class="s4">+= </span><span class="s1">c</span>
        <span class="s1">escaped </span><span class="s4">= </span><span class="s1">c  </span><span class="s0"># reset to non-backslash</span>
    <span class="s3">return </span><span class="s1">fragment</span>


<span class="s3">def </span><span class="s1">updatevars</span><span class="s4">(</span><span class="s1">typespec</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">, </span><span class="s1">attrspec</span><span class="s4">, </span><span class="s1">entitydecl</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Returns last_name, the variable name without special chars, parenthesis 
        or dimension specifiers. 
 
    Alters groupcache to add the name, typespec, attrspec (and possibly value) 
    of current variable. 
    &quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">groupcache</span><span class="s4">, </span><span class="s1">groupcounter</span>

    <span class="s1">last_name </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s1">kindselect</span><span class="s4">, </span><span class="s1">charselect</span><span class="s4">, </span><span class="s1">typename </span><span class="s4">= </span><span class="s1">cracktypespec</span><span class="s4">(</span><span class="s1">typespec</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">)</span>
    <span class="s0"># Clean up outer commas, whitespace and undesired chars from attrspec</span>
    <span class="s3">if </span><span class="s1">attrspec</span><span class="s4">:</span>
        <span class="s1">attrspec </span><span class="s4">= [</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">attrspec</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@,@'</span><span class="s4">)]</span>
        <span class="s1">l </span><span class="s4">= []</span>
        <span class="s1">c </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'(?P&lt;start&gt;[a-zA-Z]+)'</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">attrspec</span><span class="s4">:</span>
            <span class="s3">if not </span><span class="s1">a</span><span class="s4">:</span>
                <span class="s3">continue</span>
            <span class="s1">m </span><span class="s4">= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">m</span><span class="s4">:</span>
                <span class="s1">s </span><span class="s4">= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'start'</span><span class="s4">).</span><span class="s1">lower</span><span class="s4">()</span>
                <span class="s1">a </span><span class="s4">= </span><span class="s1">s </span><span class="s4">+ </span><span class="s1">a</span><span class="s4">[</span><span class="s1">len</span><span class="s4">(</span><span class="s1">s</span><span class="s4">):]</span>
            <span class="s1">l</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
        <span class="s1">attrspec </span><span class="s4">= </span><span class="s1">l</span>
    <span class="s1">el </span><span class="s4">= [</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">entitydecl</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@,@'</span><span class="s4">)]</span>
    <span class="s1">el1 </span><span class="s4">= []</span>
    <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">el</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">e1 </span><span class="s3">in </span><span class="s4">[</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">removespaces</span><span class="s4">(</span><span class="s1">markinnerspaces</span><span class="s4">(</span><span class="s1">e</span><span class="s4">)), </span><span class="s1">comma</span><span class="s4">=</span><span class="s6">' '</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@ @'</span><span class="s4">)]:</span>
            <span class="s3">if </span><span class="s1">e1</span><span class="s4">:</span>
                <span class="s1">el1</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">e1</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s6">'@_@'</span><span class="s4">, </span><span class="s6">' '</span><span class="s4">))</span>
    <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">el1</span><span class="s4">:</span>
        <span class="s1">m </span><span class="s4">= </span><span class="s1">namepattern</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">e</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">m</span><span class="s4">:</span>
            <span class="s1">outmess</span><span class="s4">(</span>
                <span class="s6">'updatevars: no name pattern found for entity=%s. Skipping.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">e</span><span class="s4">)))</span>
            <span class="s3">continue</span>
        <span class="s1">ename </span><span class="s4">= </span><span class="s1">rmbadname1</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'name'</span><span class="s4">))</span>
        <span class="s1">edecl </span><span class="s4">= {}</span>
        <span class="s3">if </span><span class="s1">ename </span><span class="s3">in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">]:</span>
            <span class="s1">edecl </span><span class="s4">= </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">ename</span><span class="s4">].</span><span class="s1">copy</span><span class="s4">()</span>
            <span class="s1">not_has_typespec </span><span class="s4">= </span><span class="s6">'typespec' </span><span class="s3">not in </span><span class="s1">edecl</span>
            <span class="s3">if </span><span class="s1">not_has_typespec</span><span class="s4">:</span>
                <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'typespec'</span><span class="s4">] = </span><span class="s1">typespec</span>
            <span class="s3">elif </span><span class="s1">typespec </span><span class="s3">and </span><span class="s4">(</span><span class="s3">not </span><span class="s1">typespec </span><span class="s4">== </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'typespec'</span><span class="s4">]):</span>
                <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'updatevars: attempt to change the type of &quot;%s&quot; (&quot;%s&quot;) to &quot;%s&quot;. Ignoring.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span>
                    <span class="s1">ename</span><span class="s4">, </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'typespec'</span><span class="s4">], </span><span class="s1">typespec</span><span class="s4">))</span>
            <span class="s3">if </span><span class="s6">'kindselector' </span><span class="s3">not in </span><span class="s1">edecl</span><span class="s4">:</span>
                <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'kindselector'</span><span class="s4">] = </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">kindselect</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">kindselect</span><span class="s4">:</span>
                <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">kindselect</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
                    <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'kindselector'</span><span class="s4">] </span><span class="s3">and </span><span class="s4">(</span><span class="s3">not </span><span class="s1">kindselect</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] == </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'kindselector'</span><span class="s4">][</span><span class="s1">k</span><span class="s4">]):</span>
                        <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'updatevars: attempt to change the kindselector &quot;%s&quot; of &quot;%s&quot; (&quot;%s&quot;) to &quot;%s&quot;. Ignoring.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span>
                            <span class="s1">k</span><span class="s4">, </span><span class="s1">ename</span><span class="s4">, </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'kindselector'</span><span class="s4">][</span><span class="s1">k</span><span class="s4">], </span><span class="s1">kindselect</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]))</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'kindselector'</span><span class="s4">][</span><span class="s1">k</span><span class="s4">] = </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">kindselect</span><span class="s4">[</span><span class="s1">k</span><span class="s4">])</span>
            <span class="s3">if </span><span class="s6">'charselector' </span><span class="s3">not in </span><span class="s1">edecl </span><span class="s3">and </span><span class="s1">charselect</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">not_has_typespec</span><span class="s4">:</span>
                    <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">] = </span><span class="s1">charselect</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">errmess</span><span class="s4">(</span><span class="s6">'updatevars:%s: attempt to change empty charselector to %r. Ignoring.</span><span class="s3">\n</span><span class="s6">'</span>
                            <span class="s4">% (</span><span class="s1">ename</span><span class="s4">, </span><span class="s1">charselect</span><span class="s4">))</span>
            <span class="s3">elif </span><span class="s1">charselect</span><span class="s4">:</span>
                <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">charselect</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
                    <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">] </span><span class="s3">and </span><span class="s4">(</span><span class="s3">not </span><span class="s1">charselect</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] == </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">][</span><span class="s1">k</span><span class="s4">]):</span>
                        <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'updatevars: attempt to change the charselector &quot;%s&quot; of &quot;%s&quot; (&quot;%s&quot;) to &quot;%s&quot;. Ignoring.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span>
                            <span class="s1">k</span><span class="s4">, </span><span class="s1">ename</span><span class="s4">, </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">][</span><span class="s1">k</span><span class="s4">], </span><span class="s1">charselect</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]))</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">][</span><span class="s1">k</span><span class="s4">] = </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">charselect</span><span class="s4">[</span><span class="s1">k</span><span class="s4">])</span>
            <span class="s3">if </span><span class="s6">'typename' </span><span class="s3">not in </span><span class="s1">edecl</span><span class="s4">:</span>
                <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'typename'</span><span class="s4">] = </span><span class="s1">typename</span>
            <span class="s3">elif </span><span class="s1">typename </span><span class="s3">and </span><span class="s4">(</span><span class="s3">not </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'typename'</span><span class="s4">] == </span><span class="s1">typename</span><span class="s4">):</span>
                <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'updatevars: attempt to change the typename of &quot;%s&quot; (&quot;%s&quot;) to &quot;%s&quot;. Ignoring.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span>
                    <span class="s1">ename</span><span class="s4">, </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'typename'</span><span class="s4">], </span><span class="s1">typename</span><span class="s4">))</span>
            <span class="s3">if </span><span class="s6">'attrspec' </span><span class="s3">not in </span><span class="s1">edecl</span><span class="s4">:</span>
                <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">] = </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">attrspec</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">attrspec</span><span class="s4">:</span>
                <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">attrspec</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">a </span><span class="s3">not in </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">]:</span>
                        <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'typespec'</span><span class="s4">] = </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">typespec</span><span class="s4">)</span>
            <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'kindselector'</span><span class="s4">] = </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">kindselect</span><span class="s4">)</span>
            <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">] = </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">charselect</span><span class="s4">)</span>
            <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'typename'</span><span class="s4">] = </span><span class="s1">typename</span>
            <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">] = </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">attrspec</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s6">'external' </span><span class="s3">in </span><span class="s4">(</span><span class="s1">edecl</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s6">'attrspec'</span><span class="s4">) </span><span class="s3">or </span><span class="s4">[]) </span><span class="s3">and </span><span class="s1">e </span><span class="s3">in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'args'</span><span class="s4">]:</span>
            <span class="s3">if </span><span class="s6">'externals' </span><span class="s3">not in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]:</span>
                <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'externals'</span><span class="s4">] = []</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'externals'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">e</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">):</span>
            <span class="s1">m1 </span><span class="s4">= </span><span class="s1">lenarraypattern</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">markouterparen</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">)))</span>
            <span class="s3">if </span><span class="s1">m1</span><span class="s4">:</span>
                <span class="s1">d1 </span><span class="s4">= </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">groupdict</span><span class="s4">()</span>
                <span class="s3">for </span><span class="s1">lk </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'len'</span><span class="s4">, </span><span class="s6">'array'</span><span class="s4">, </span><span class="s6">'init'</span><span class="s4">]:</span>
                    <span class="s3">if </span><span class="s1">d1</span><span class="s4">[</span><span class="s1">lk </span><span class="s4">+ </span><span class="s6">'2'</span><span class="s4">] </span><span class="s3">is not None</span><span class="s4">:</span>
                        <span class="s1">d1</span><span class="s4">[</span><span class="s1">lk</span><span class="s4">] = </span><span class="s1">d1</span><span class="s4">[</span><span class="s1">lk </span><span class="s4">+ </span><span class="s6">'2'</span><span class="s4">]</span>
                        <span class="s3">del </span><span class="s1">d1</span><span class="s4">[</span><span class="s1">lk </span><span class="s4">+ </span><span class="s6">'2'</span><span class="s4">]</span>
                <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">d1</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
                    <span class="s3">if </span><span class="s1">d1</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] </span><span class="s3">is not None</span><span class="s4">:</span>
                        <span class="s1">d1</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] = </span><span class="s1">unmarkouterparen</span><span class="s4">(</span><span class="s1">d1</span><span class="s4">[</span><span class="s1">k</span><span class="s4">])</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s3">del </span><span class="s1">d1</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>

                <span class="s3">if </span><span class="s6">'len' </span><span class="s3">in </span><span class="s1">d1 </span><span class="s3">and </span><span class="s6">'array' </span><span class="s3">in </span><span class="s1">d1</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">'len'</span><span class="s4">] == </span><span class="s6">''</span><span class="s4">:</span>
                        <span class="s1">d1</span><span class="s4">[</span><span class="s6">'len'</span><span class="s4">] = </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">'array'</span><span class="s4">]</span>
                        <span class="s3">del </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">'array'</span><span class="s4">]</span>
                    <span class="s3">elif </span><span class="s1">typespec </span><span class="s4">== </span><span class="s6">'character'</span><span class="s4">:</span>
                        <span class="s3">if </span><span class="s4">(</span><span class="s6">'charselector' </span><span class="s3">not in </span><span class="s1">edecl</span><span class="s4">) </span><span class="s3">or </span><span class="s4">(</span><span class="s3">not </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">]):</span>
                            <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">] = {}</span>
                        <span class="s3">if </span><span class="s6">'len' </span><span class="s3">in </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">]:</span>
                            <span class="s3">del </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">][</span><span class="s6">'len'</span><span class="s4">]</span>
                        <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">][</span><span class="s6">'*'</span><span class="s4">] = </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">'len'</span><span class="s4">]</span>
                        <span class="s3">del </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">'len'</span><span class="s4">]</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">d1</span><span class="s4">[</span><span class="s6">'array'</span><span class="s4">] = </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">'array'</span><span class="s4">] + </span><span class="s6">',' </span><span class="s4">+ </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">'len'</span><span class="s4">]</span>
                        <span class="s3">del </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">'len'</span><span class="s4">]</span>
                        <span class="s1">errmess</span><span class="s4">(</span><span class="s6">'updatevars: &quot;%s %s&quot; is mapped to &quot;%s %s(%s)&quot;</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span>
                            <span class="s1">typespec</span><span class="s4">, </span><span class="s1">e</span><span class="s4">, </span><span class="s1">typespec</span><span class="s4">, </span><span class="s1">ename</span><span class="s4">, </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">'array'</span><span class="s4">]))</span>

                <span class="s3">if </span><span class="s6">'len' </span><span class="s3">in </span><span class="s1">d1</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">typespec </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'complex'</span><span class="s4">, </span><span class="s6">'integer'</span><span class="s4">, </span><span class="s6">'logical'</span><span class="s4">, </span><span class="s6">'real'</span><span class="s4">]:</span>
                        <span class="s3">if </span><span class="s4">(</span><span class="s6">'kindselector' </span><span class="s3">not in </span><span class="s1">edecl</span><span class="s4">) </span><span class="s3">or </span><span class="s4">(</span><span class="s3">not </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'kindselector'</span><span class="s4">]):</span>
                            <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'kindselector'</span><span class="s4">] = {}</span>
                        <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'kindselector'</span><span class="s4">][</span><span class="s6">'*'</span><span class="s4">] = </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">'len'</span><span class="s4">]</span>
                        <span class="s3">del </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">'len'</span><span class="s4">]</span>
                    <span class="s3">elif </span><span class="s1">typespec </span><span class="s4">== </span><span class="s6">'character'</span><span class="s4">:</span>
                        <span class="s3">if </span><span class="s4">(</span><span class="s6">'charselector' </span><span class="s3">not in </span><span class="s1">edecl</span><span class="s4">) </span><span class="s3">or </span><span class="s4">(</span><span class="s3">not </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">]):</span>
                            <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">] = {}</span>
                        <span class="s3">if </span><span class="s6">'len' </span><span class="s3">in </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">]:</span>
                            <span class="s3">del </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">][</span><span class="s6">'len'</span><span class="s4">]</span>
                        <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">][</span><span class="s6">'*'</span><span class="s4">] = </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">'len'</span><span class="s4">]</span>
                        <span class="s3">del </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">'len'</span><span class="s4">]</span>

                <span class="s3">if </span><span class="s6">'init' </span><span class="s3">in </span><span class="s1">d1</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s6">'=' </span><span class="s3">in </span><span class="s1">edecl </span><span class="s3">and </span><span class="s4">(</span><span class="s3">not </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'='</span><span class="s4">] == </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">'init'</span><span class="s4">]):</span>
                        <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'updatevars: attempt to change the init expression of &quot;%s&quot; (&quot;%s&quot;) to &quot;%s&quot;. Ignoring.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span>
                            <span class="s1">ename</span><span class="s4">, </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'='</span><span class="s4">], </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">'init'</span><span class="s4">]))</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'='</span><span class="s4">] = </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">'init'</span><span class="s4">]</span>

                <span class="s3">if </span><span class="s6">'array' </span><span class="s3">in </span><span class="s1">d1</span><span class="s4">:</span>
                    <span class="s1">dm </span><span class="s4">= </span><span class="s6">'dimension(%s)' </span><span class="s4">% </span><span class="s1">d1</span><span class="s4">[</span><span class="s6">'array'</span><span class="s4">]</span>
                    <span class="s3">if </span><span class="s6">'attrspec' </span><span class="s3">not in </span><span class="s1">edecl </span><span class="s3">or </span><span class="s4">(</span><span class="s3">not </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">]):</span>
                        <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">] = [</span><span class="s1">dm</span><span class="s4">]</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">edecl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">dm</span><span class="s4">)</span>
                        <span class="s3">for </span><span class="s1">dm1 </span><span class="s3">in </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">]:</span>
                            <span class="s3">if </span><span class="s1">dm1</span><span class="s4">[:</span><span class="s5">9</span><span class="s4">] == </span><span class="s6">'dimension' </span><span class="s3">and </span><span class="s1">dm1 </span><span class="s4">!= </span><span class="s1">dm</span><span class="s4">:</span>
                                <span class="s3">del </span><span class="s1">edecl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">][-</span><span class="s5">1</span><span class="s4">]</span>
                                <span class="s1">errmess</span><span class="s4">(</span><span class="s6">'updatevars:%s: attempt to change %r to %r. Ignoring.</span><span class="s3">\n</span><span class="s6">'</span>
                                        <span class="s4">% (</span><span class="s1">ename</span><span class="s4">, </span><span class="s1">dm1</span><span class="s4">, </span><span class="s1">dm</span><span class="s4">))</span>
                                <span class="s3">break</span>

            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'updatevars: could not crack entity declaration &quot;%s&quot;. Ignoring.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span>
                    <span class="s1">ename </span><span class="s4">+ </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">)))</span>
        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">edecl</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
            <span class="s3">if not </span><span class="s1">edecl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]:</span>
                <span class="s3">del </span><span class="s1">edecl</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>
        <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">ename</span><span class="s4">] = </span><span class="s1">edecl</span>
        <span class="s3">if </span><span class="s6">'varnames' </span><span class="s3">in </span><span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">]:</span>
            <span class="s1">groupcache</span><span class="s4">[</span><span class="s1">groupcounter</span><span class="s4">][</span><span class="s6">'varnames'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">ename</span><span class="s4">)</span>
        <span class="s1">last_name </span><span class="s4">= </span><span class="s1">ename</span>
    <span class="s3">return </span><span class="s1">last_name</span>


<span class="s3">def </span><span class="s1">cracktypespec</span><span class="s4">(</span><span class="s1">typespec</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">):</span>
    <span class="s1">kindselect </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s1">charselect </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s1">typename </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">selector</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">typespec </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'complex'</span><span class="s4">, </span><span class="s6">'integer'</span><span class="s4">, </span><span class="s6">'logical'</span><span class="s4">, </span><span class="s6">'real'</span><span class="s4">]:</span>
            <span class="s1">kindselect </span><span class="s4">= </span><span class="s1">kindselector</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">selector</span><span class="s4">)</span>
            <span class="s3">if not </span><span class="s1">kindselect</span><span class="s4">:</span>
                <span class="s1">outmess</span><span class="s4">(</span>
                    <span class="s6">'cracktypespec: no kindselector pattern found for %s</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">selector</span><span class="s4">)))</span>
                <span class="s3">return</span>
            <span class="s1">kindselect </span><span class="s4">= </span><span class="s1">kindselect</span><span class="s4">.</span><span class="s1">groupdict</span><span class="s4">()</span>
            <span class="s1">kindselect</span><span class="s4">[</span><span class="s6">'*'</span><span class="s4">] = </span><span class="s1">kindselect</span><span class="s4">[</span><span class="s6">'kind2'</span><span class="s4">]</span>
            <span class="s3">del </span><span class="s1">kindselect</span><span class="s4">[</span><span class="s6">'kind2'</span><span class="s4">]</span>
            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">kindselect</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
                <span class="s3">if not </span><span class="s1">kindselect</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]:</span>
                    <span class="s3">del </span><span class="s1">kindselect</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>
            <span class="s3">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">i </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">kindselect</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()):</span>
                <span class="s1">kindselect</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] = </span><span class="s1">rmbadname1</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">typespec </span><span class="s4">== </span><span class="s6">'character'</span><span class="s4">:</span>
            <span class="s1">charselect </span><span class="s4">= </span><span class="s1">charselector</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">selector</span><span class="s4">)</span>
            <span class="s3">if not </span><span class="s1">charselect</span><span class="s4">:</span>
                <span class="s1">outmess</span><span class="s4">(</span>
                    <span class="s6">'cracktypespec: no charselector pattern found for %s</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">selector</span><span class="s4">)))</span>
                <span class="s3">return</span>
            <span class="s1">charselect </span><span class="s4">= </span><span class="s1">charselect</span><span class="s4">.</span><span class="s1">groupdict</span><span class="s4">()</span>
            <span class="s1">charselect</span><span class="s4">[</span><span class="s6">'*'</span><span class="s4">] = </span><span class="s1">charselect</span><span class="s4">[</span><span class="s6">'charlen'</span><span class="s4">]</span>
            <span class="s3">del </span><span class="s1">charselect</span><span class="s4">[</span><span class="s6">'charlen'</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">charselect</span><span class="s4">[</span><span class="s6">'lenkind'</span><span class="s4">]:</span>
                <span class="s1">lenkind </span><span class="s4">= </span><span class="s1">lenkindpattern</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span>
                    <span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">charselect</span><span class="s4">[</span><span class="s6">'lenkind'</span><span class="s4">]))</span>
                <span class="s1">lenkind </span><span class="s4">= </span><span class="s1">lenkind</span><span class="s4">.</span><span class="s1">groupdict</span><span class="s4">()</span>
                <span class="s3">for </span><span class="s1">lk </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'len'</span><span class="s4">, </span><span class="s6">'kind'</span><span class="s4">]:</span>
                    <span class="s3">if </span><span class="s1">lenkind</span><span class="s4">[</span><span class="s1">lk </span><span class="s4">+ </span><span class="s6">'2'</span><span class="s4">]:</span>
                        <span class="s1">lenkind</span><span class="s4">[</span><span class="s1">lk</span><span class="s4">] = </span><span class="s1">lenkind</span><span class="s4">[</span><span class="s1">lk </span><span class="s4">+ </span><span class="s6">'2'</span><span class="s4">]</span>
                    <span class="s1">charselect</span><span class="s4">[</span><span class="s1">lk</span><span class="s4">] = </span><span class="s1">lenkind</span><span class="s4">[</span><span class="s1">lk</span><span class="s4">]</span>
                    <span class="s3">del </span><span class="s1">lenkind</span><span class="s4">[</span><span class="s1">lk </span><span class="s4">+ </span><span class="s6">'2'</span><span class="s4">]</span>
                <span class="s3">if </span><span class="s1">lenkind</span><span class="s4">[</span><span class="s6">'f2py_len'</span><span class="s4">] </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s0"># used to specify the length of assumed length strings</span>
                    <span class="s1">charselect</span><span class="s4">[</span><span class="s6">'f2py_len'</span><span class="s4">] = </span><span class="s1">lenkind</span><span class="s4">[</span><span class="s6">'f2py_len'</span><span class="s4">]</span>
            <span class="s3">del </span><span class="s1">charselect</span><span class="s4">[</span><span class="s6">'lenkind'</span><span class="s4">]</span>
            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">charselect</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
                <span class="s3">if not </span><span class="s1">charselect</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]:</span>
                    <span class="s3">del </span><span class="s1">charselect</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>
            <span class="s3">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">i </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">charselect</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()):</span>
                <span class="s1">charselect</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] = </span><span class="s1">rmbadname1</span><span class="s4">(</span><span class="s1">i</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">typespec </span><span class="s4">== </span><span class="s6">'type'</span><span class="s4">:</span>
            <span class="s1">typename </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s6">r'\s*\(\s*(?P&lt;name&gt;\w+)\s*\)'</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">typename</span><span class="s4">:</span>
                <span class="s1">typename </span><span class="s4">= </span><span class="s1">typename</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'name'</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'cracktypespec: no typename found in %s</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">%</span>
                        <span class="s4">(</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">typespec </span><span class="s4">+ </span><span class="s1">selector</span><span class="s4">)))</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'cracktypespec: no selector used for %s</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">%</span>
                    <span class="s4">(</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">selector</span><span class="s4">)))</span>
    <span class="s3">return </span><span class="s1">kindselect</span><span class="s4">, </span><span class="s1">charselect</span><span class="s4">, </span><span class="s1">typename</span>
<span class="s0">######</span>


<span class="s3">def </span><span class="s1">setattrspec</span><span class="s4">(</span><span class="s1">decl</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">, </span><span class="s1">force</span><span class="s4">=</span><span class="s5">0</span><span class="s4">):</span>
    <span class="s3">if not </span><span class="s1">decl</span><span class="s4">:</span>
        <span class="s1">decl </span><span class="s4">= {}</span>
    <span class="s3">if not </span><span class="s1">attr</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">decl</span>
    <span class="s3">if </span><span class="s6">'attrspec' </span><span class="s3">not in </span><span class="s1">decl</span><span class="s4">:</span>
        <span class="s1">decl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">] = [</span><span class="s1">attr</span><span class="s4">]</span>
        <span class="s3">return </span><span class="s1">decl</span>
    <span class="s3">if </span><span class="s1">force</span><span class="s4">:</span>
        <span class="s1">decl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">decl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">decl</span>
    <span class="s3">if </span><span class="s1">attr </span><span class="s4">== </span><span class="s6">'static' </span><span class="s3">and </span><span class="s6">'automatic' </span><span class="s3">not in </span><span class="s1">decl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">]:</span>
        <span class="s1">decl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">attr </span><span class="s4">== </span><span class="s6">'automatic' </span><span class="s3">and </span><span class="s6">'static' </span><span class="s3">not in </span><span class="s1">decl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">]:</span>
        <span class="s1">decl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">attr </span><span class="s4">== </span><span class="s6">'public'</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s6">'private' </span><span class="s3">not in </span><span class="s1">decl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">]:</span>
            <span class="s1">decl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">attr </span><span class="s4">== </span><span class="s6">'private'</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s6">'public' </span><span class="s3">not in </span><span class="s1">decl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">]:</span>
            <span class="s1">decl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">decl</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">decl</span>


<span class="s3">def </span><span class="s1">setkindselector</span><span class="s4">(</span><span class="s1">decl</span><span class="s4">, </span><span class="s1">sel</span><span class="s4">, </span><span class="s1">force</span><span class="s4">=</span><span class="s5">0</span><span class="s4">):</span>
    <span class="s3">if not </span><span class="s1">decl</span><span class="s4">:</span>
        <span class="s1">decl </span><span class="s4">= {}</span>
    <span class="s3">if not </span><span class="s1">sel</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">decl</span>
    <span class="s3">if </span><span class="s6">'kindselector' </span><span class="s3">not in </span><span class="s1">decl</span><span class="s4">:</span>
        <span class="s1">decl</span><span class="s4">[</span><span class="s6">'kindselector'</span><span class="s4">] = </span><span class="s1">sel</span>
        <span class="s3">return </span><span class="s1">decl</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">sel</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
        <span class="s3">if </span><span class="s1">force </span><span class="s3">or </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">decl</span><span class="s4">[</span><span class="s6">'kindselector'</span><span class="s4">]:</span>
            <span class="s1">decl</span><span class="s4">[</span><span class="s6">'kindselector'</span><span class="s4">][</span><span class="s1">k</span><span class="s4">] = </span><span class="s1">sel</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">decl</span>


<span class="s3">def </span><span class="s1">setcharselector</span><span class="s4">(</span><span class="s1">decl</span><span class="s4">, </span><span class="s1">sel</span><span class="s4">, </span><span class="s1">force</span><span class="s4">=</span><span class="s5">0</span><span class="s4">):</span>
    <span class="s3">if not </span><span class="s1">decl</span><span class="s4">:</span>
        <span class="s1">decl </span><span class="s4">= {}</span>
    <span class="s3">if not </span><span class="s1">sel</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">decl</span>
    <span class="s3">if </span><span class="s6">'charselector' </span><span class="s3">not in </span><span class="s1">decl</span><span class="s4">:</span>
        <span class="s1">decl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">] = </span><span class="s1">sel</span>
        <span class="s3">return </span><span class="s1">decl</span>

    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">sel</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
        <span class="s3">if </span><span class="s1">force </span><span class="s3">or </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">decl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">]:</span>
            <span class="s1">decl</span><span class="s4">[</span><span class="s6">'charselector'</span><span class="s4">][</span><span class="s1">k</span><span class="s4">] = </span><span class="s1">sel</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">decl</span>


<span class="s3">def </span><span class="s1">getblockname</span><span class="s4">(</span><span class="s1">block</span><span class="s4">, </span><span class="s1">unknown</span><span class="s4">=</span><span class="s6">'unknown'</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s6">'name' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">unknown</span>

<span class="s0"># post processing</span>


<span class="s3">def </span><span class="s1">setmesstext</span><span class="s4">(</span><span class="s1">block</span><span class="s4">):</span>
    <span class="s3">global </span><span class="s1">filepositiontext</span>

    <span class="s3">try</span><span class="s4">:</span>
        <span class="s1">filepositiontext </span><span class="s4">= </span><span class="s6">'In: %s:%s</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'from'</span><span class="s4">], </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">])</span>
    <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
        <span class="s3">pass</span>


<span class="s3">def </span><span class="s1">get_usedict</span><span class="s4">(</span><span class="s1">block</span><span class="s4">):</span>
    <span class="s1">usedict </span><span class="s4">= {}</span>
    <span class="s3">if </span><span class="s6">'parent_block' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s1">usedict </span><span class="s4">= </span><span class="s1">get_usedict</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'parent_block'</span><span class="s4">])</span>
    <span class="s3">if </span><span class="s6">'use' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s1">usedict</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'use'</span><span class="s4">])</span>
    <span class="s3">return </span><span class="s1">usedict</span>


<span class="s3">def </span><span class="s1">get_useparameters</span><span class="s4">(</span><span class="s1">block</span><span class="s4">, </span><span class="s1">param_map</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s3">global </span><span class="s1">f90modulevars</span>

    <span class="s3">if </span><span class="s1">param_map </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">param_map </span><span class="s4">= {}</span>
    <span class="s1">usedict </span><span class="s4">= </span><span class="s1">get_usedict</span><span class="s4">(</span><span class="s1">block</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">usedict</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">param_map</span>
    <span class="s3">for </span><span class="s1">usename</span><span class="s4">, </span><span class="s1">mapping </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">usedict</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()):</span>
        <span class="s1">usename </span><span class="s4">= </span><span class="s1">usename</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">usename </span><span class="s3">not in </span><span class="s1">f90modulevars</span><span class="s4">:</span>
            <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'get_useparameters: no module %s info used by %s</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">%</span>
                    <span class="s4">(</span><span class="s1">usename</span><span class="s4">, </span><span class="s1">block</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s6">'name'</span><span class="s4">)))</span>
            <span class="s3">continue</span>
        <span class="s1">mvars </span><span class="s4">= </span><span class="s1">f90modulevars</span><span class="s4">[</span><span class="s1">usename</span><span class="s4">]</span>
        <span class="s1">params </span><span class="s4">= </span><span class="s1">get_parameters</span><span class="s4">(</span><span class="s1">mvars</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">params</span><span class="s4">:</span>
            <span class="s3">continue</span>
        <span class="s0"># XXX: apply mapping</span>
        <span class="s3">if </span><span class="s1">mapping</span><span class="s4">:</span>
            <span class="s1">errmess</span><span class="s4">(</span><span class="s6">'get_useparameters: mapping for %s not impl.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">mapping</span><span class="s4">))</span>
        <span class="s3">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">params</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()):</span>
            <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">param_map</span><span class="s4">:</span>
                <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'get_useparameters: overriding parameter %s with'</span>
                        <span class="s6">' value from module %s</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">k</span><span class="s4">), </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">usename</span><span class="s4">)))</span>
            <span class="s1">param_map</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] = </span><span class="s1">v</span>

    <span class="s3">return </span><span class="s1">param_map</span>


<span class="s3">def </span><span class="s1">postcrack2</span><span class="s4">(</span><span class="s1">block</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">=</span><span class="s6">''</span><span class="s4">, </span><span class="s1">param_map</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s3">global </span><span class="s1">f90modulevars</span>

    <span class="s3">if not </span><span class="s1">f90modulevars</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">block</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">block</span><span class="s4">, </span><span class="s1">list</span><span class="s4">):</span>
        <span class="s1">ret </span><span class="s4">= [</span><span class="s1">postcrack2</span><span class="s4">(</span><span class="s1">g</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">=</span><span class="s1">tab </span><span class="s4">+ </span><span class="s6">'</span><span class="s3">\t</span><span class="s6">'</span><span class="s4">, </span><span class="s1">param_map</span><span class="s4">=</span><span class="s1">param_map</span><span class="s4">)</span>
               <span class="s3">for </span><span class="s1">g </span><span class="s3">in </span><span class="s1">block</span><span class="s4">]</span>
        <span class="s3">return </span><span class="s1">ret</span>
    <span class="s1">setmesstext</span><span class="s4">(</span><span class="s1">block</span><span class="s4">)</span>
    <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'%sBlock: %s</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">tab</span><span class="s4">, </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">]), </span><span class="s5">0</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">param_map </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">param_map </span><span class="s4">= </span><span class="s1">get_useparameters</span><span class="s4">(</span><span class="s1">block</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">param_map </span><span class="s3">is not None and </span><span class="s6">'vars' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s1">vars </span><span class="s4">= </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">]</span>
        <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
            <span class="s1">var </span><span class="s4">= </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s6">'kindselector' </span><span class="s3">in </span><span class="s1">var</span><span class="s4">:</span>
                <span class="s1">kind </span><span class="s4">= </span><span class="s1">var</span><span class="s4">[</span><span class="s6">'kindselector'</span><span class="s4">]</span>
                <span class="s3">if </span><span class="s6">'kind' </span><span class="s3">in </span><span class="s1">kind</span><span class="s4">:</span>
                    <span class="s1">val </span><span class="s4">= </span><span class="s1">kind</span><span class="s4">[</span><span class="s6">'kind'</span><span class="s4">]</span>
                    <span class="s3">if </span><span class="s1">val </span><span class="s3">in </span><span class="s1">param_map</span><span class="s4">:</span>
                        <span class="s1">kind</span><span class="s4">[</span><span class="s6">'kind'</span><span class="s4">] = </span><span class="s1">param_map</span><span class="s4">[</span><span class="s1">val</span><span class="s4">]</span>
    <span class="s1">new_body </span><span class="s4">= [</span><span class="s1">postcrack2</span><span class="s4">(</span><span class="s1">b</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">=</span><span class="s1">tab </span><span class="s4">+ </span><span class="s6">'</span><span class="s3">\t</span><span class="s6">'</span><span class="s4">, </span><span class="s1">param_map</span><span class="s4">=</span><span class="s1">param_map</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'body'</span><span class="s4">]]</span>
    <span class="s1">block</span><span class="s4">[</span><span class="s6">'body'</span><span class="s4">] = </span><span class="s1">new_body</span>

    <span class="s3">return </span><span class="s1">block</span>


<span class="s3">def </span><span class="s1">postcrack</span><span class="s4">(</span><span class="s1">block</span><span class="s4">, </span><span class="s1">args</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">=</span><span class="s6">''</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    TODO: 
          function return values 
          determine expression types if in argument list 
    &quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">usermodules</span><span class="s4">, </span><span class="s1">onlyfunctions</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">block</span><span class="s4">, </span><span class="s1">list</span><span class="s4">):</span>
        <span class="s1">gret </span><span class="s4">= []</span>
        <span class="s1">uret </span><span class="s4">= []</span>
        <span class="s3">for </span><span class="s1">g </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
            <span class="s1">setmesstext</span><span class="s4">(</span><span class="s1">g</span><span class="s4">)</span>
            <span class="s1">g </span><span class="s4">= </span><span class="s1">postcrack</span><span class="s4">(</span><span class="s1">g</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">=</span><span class="s1">tab </span><span class="s4">+ </span><span class="s6">'</span><span class="s3">\t</span><span class="s6">'</span><span class="s4">)</span>
            <span class="s0"># sort user routines to appear first</span>
            <span class="s3">if </span><span class="s6">'name' </span><span class="s3">in </span><span class="s1">g </span><span class="s3">and </span><span class="s6">'__user__' </span><span class="s3">in </span><span class="s1">g</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">]:</span>
                <span class="s1">uret</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">g</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">gret</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">g</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">uret </span><span class="s4">+ </span><span class="s1">gret</span>
    <span class="s1">setmesstext</span><span class="s4">(</span><span class="s1">block</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">block</span><span class="s4">, </span><span class="s1">dict</span><span class="s4">) </span><span class="s3">and </span><span class="s6">'block' </span><span class="s3">not in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">Exception</span><span class="s4">(</span><span class="s6">'postcrack: Expected block dictionary instead of ' </span><span class="s4">+</span>
                        <span class="s1">str</span><span class="s4">(</span><span class="s1">block</span><span class="s4">))</span>
    <span class="s3">if </span><span class="s6">'name' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and not </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">] == </span><span class="s6">'unknown_interface'</span><span class="s4">:</span>
        <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'%sBlock: %s</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">tab</span><span class="s4">, </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">]), </span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">block </span><span class="s4">= </span><span class="s1">analyzeargs</span><span class="s4">(</span><span class="s1">block</span><span class="s4">)</span>
    <span class="s1">block </span><span class="s4">= </span><span class="s1">analyzecommon</span><span class="s4">(</span><span class="s1">block</span><span class="s4">)</span>
    <span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">] = </span><span class="s1">analyzevars</span><span class="s4">(</span><span class="s1">block</span><span class="s4">)</span>
    <span class="s1">block</span><span class="s4">[</span><span class="s6">'sortvars'</span><span class="s4">] = </span><span class="s1">sortvarnames</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">])</span>
    <span class="s3">if </span><span class="s6">'args' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'args'</span><span class="s4">]:</span>
        <span class="s1">args </span><span class="s4">= </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'args'</span><span class="s4">]</span>
    <span class="s1">block</span><span class="s4">[</span><span class="s6">'body'</span><span class="s4">] = </span><span class="s1">analyzebody</span><span class="s4">(</span><span class="s1">block</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">=</span><span class="s1">tab</span><span class="s4">)</span>

    <span class="s1">userisdefined </span><span class="s4">= []</span>
    <span class="s3">if </span><span class="s6">'use' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s1">useblock </span><span class="s4">= </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'use'</span><span class="s4">]</span>
        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">useblock</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
            <span class="s3">if </span><span class="s6">'__user__' </span><span class="s3">in </span><span class="s1">k</span><span class="s4">:</span>
                <span class="s1">userisdefined</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">k</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">useblock </span><span class="s4">= {}</span>
    <span class="s1">name </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s3">if </span><span class="s6">'name' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s1">name </span><span class="s4">= </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">]</span>
    <span class="s0"># and not userisdefined: # Build a __user__ module</span>
    <span class="s3">if </span><span class="s6">'externals' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'externals'</span><span class="s4">]:</span>
        <span class="s1">interfaced </span><span class="s4">= []</span>
        <span class="s3">if </span><span class="s6">'interfaced' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
            <span class="s1">interfaced </span><span class="s4">= </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'interfaced'</span><span class="s4">]</span>
        <span class="s1">mvars </span><span class="s4">= </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">])</span>
        <span class="s3">if </span><span class="s1">name</span><span class="s4">:</span>
            <span class="s1">mname </span><span class="s4">= </span><span class="s1">name </span><span class="s4">+ </span><span class="s6">'__user__routines'</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">mname </span><span class="s4">= </span><span class="s6">'unknown__user__routines'</span>
        <span class="s3">if </span><span class="s1">mname </span><span class="s3">in </span><span class="s1">userisdefined</span><span class="s4">:</span>
            <span class="s1">i </span><span class="s4">= </span><span class="s5">1</span>
            <span class="s3">while </span><span class="s6">'%s_%i' </span><span class="s4">% (</span><span class="s1">mname</span><span class="s4">, </span><span class="s1">i</span><span class="s4">) </span><span class="s3">in </span><span class="s1">userisdefined</span><span class="s4">:</span>
                <span class="s1">i </span><span class="s4">= </span><span class="s1">i </span><span class="s4">+ </span><span class="s5">1</span>
            <span class="s1">mname </span><span class="s4">= </span><span class="s6">'%s_%i' </span><span class="s4">% (</span><span class="s1">mname</span><span class="s4">, </span><span class="s1">i</span><span class="s4">)</span>
        <span class="s1">interface </span><span class="s4">= {</span><span class="s6">'block'</span><span class="s4">: </span><span class="s6">'interface'</span><span class="s4">, </span><span class="s6">'body'</span><span class="s4">: [],</span>
                     <span class="s6">'vars'</span><span class="s4">: {}, </span><span class="s6">'name'</span><span class="s4">: </span><span class="s1">name </span><span class="s4">+ </span><span class="s6">'_user_interface'</span><span class="s4">}</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'externals'</span><span class="s4">]:</span>
            <span class="s3">if </span><span class="s1">e </span><span class="s3">in </span><span class="s1">interfaced</span><span class="s4">:</span>
                <span class="s1">edef </span><span class="s4">= []</span>
                <span class="s1">j </span><span class="s4">= -</span><span class="s5">1</span>
                <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'body'</span><span class="s4">]:</span>
                    <span class="s1">j </span><span class="s4">= </span><span class="s1">j </span><span class="s4">+ </span><span class="s5">1</span>
                    <span class="s3">if </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'block'</span><span class="s4">] == </span><span class="s6">'interface'</span><span class="s4">:</span>
                        <span class="s1">i </span><span class="s4">= -</span><span class="s5">1</span>
                        <span class="s3">for </span><span class="s1">bb </span><span class="s3">in </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'body'</span><span class="s4">]:</span>
                            <span class="s1">i </span><span class="s4">= </span><span class="s1">i </span><span class="s4">+ </span><span class="s5">1</span>
                            <span class="s3">if </span><span class="s6">'name' </span><span class="s3">in </span><span class="s1">bb </span><span class="s3">and </span><span class="s1">bb</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">] == </span><span class="s1">e</span><span class="s4">:</span>
                                <span class="s1">edef </span><span class="s4">= </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">bb</span><span class="s4">)</span>
                                <span class="s3">del </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'body'</span><span class="s4">][</span><span class="s1">i</span><span class="s4">]</span>
                                <span class="s3">break</span>
                        <span class="s3">if </span><span class="s1">edef</span><span class="s4">:</span>
                            <span class="s3">if not </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'body'</span><span class="s4">]:</span>
                                <span class="s3">del </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'body'</span><span class="s4">][</span><span class="s1">j</span><span class="s4">]</span>
                            <span class="s3">del </span><span class="s1">interfaced</span><span class="s4">[</span><span class="s1">interfaced</span><span class="s4">.</span><span class="s1">index</span><span class="s4">(</span><span class="s1">e</span><span class="s4">)]</span>
                            <span class="s3">break</span>
                <span class="s1">interface</span><span class="s4">[</span><span class="s6">'body'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">edef</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">e </span><span class="s3">in </span><span class="s1">mvars </span><span class="s3">and not </span><span class="s1">isexternal</span><span class="s4">(</span><span class="s1">mvars</span><span class="s4">[</span><span class="s1">e</span><span class="s4">]):</span>
                    <span class="s1">interface</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">e</span><span class="s4">] = </span><span class="s1">mvars</span><span class="s4">[</span><span class="s1">e</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">interface</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">] </span><span class="s3">or </span><span class="s1">interface</span><span class="s4">[</span><span class="s6">'body'</span><span class="s4">]:</span>
            <span class="s1">block</span><span class="s4">[</span><span class="s6">'interfaced'</span><span class="s4">] = </span><span class="s1">interfaced</span>
            <span class="s1">mblock </span><span class="s4">= {</span><span class="s6">'block'</span><span class="s4">: </span><span class="s6">'python module'</span><span class="s4">, </span><span class="s6">'body'</span><span class="s4">: [</span>
                <span class="s1">interface</span><span class="s4">], </span><span class="s6">'vars'</span><span class="s4">: {}, </span><span class="s6">'name'</span><span class="s4">: </span><span class="s1">mname</span><span class="s4">, </span><span class="s6">'interfaced'</span><span class="s4">: </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'externals'</span><span class="s4">]}</span>
            <span class="s1">useblock</span><span class="s4">[</span><span class="s1">mname</span><span class="s4">] = {}</span>
            <span class="s1">usermodules</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">mblock</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">useblock</span><span class="s4">:</span>
        <span class="s1">block</span><span class="s4">[</span><span class="s6">'use'</span><span class="s4">] = </span><span class="s1">useblock</span>
    <span class="s3">return </span><span class="s1">block</span>


<span class="s3">def </span><span class="s1">sortvarnames</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">):</span>
    <span class="s1">indep </span><span class="s4">= []</span>
    <span class="s1">dep </span><span class="s4">= []</span>
    <span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
        <span class="s3">if </span><span class="s6">'depend' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">] </span><span class="s3">and </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">][</span><span class="s6">'depend'</span><span class="s4">]:</span>
            <span class="s1">dep</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">v</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">indep</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">v</span><span class="s4">)</span>
    <span class="s1">n </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">dep</span><span class="s4">)</span>
    <span class="s1">i </span><span class="s4">= </span><span class="s5">0</span>
    <span class="s3">while </span><span class="s1">dep</span><span class="s4">:  </span><span class="s0"># XXX: How to catch dependence cycles correctly?</span>
        <span class="s1">v </span><span class="s4">= </span><span class="s1">dep</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
        <span class="s1">fl </span><span class="s4">= </span><span class="s5">0</span>
        <span class="s3">for </span><span class="s1">w </span><span class="s3">in </span><span class="s1">dep</span><span class="s4">[</span><span class="s5">1</span><span class="s4">:]:</span>
            <span class="s3">if </span><span class="s1">w </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">][</span><span class="s6">'depend'</span><span class="s4">]:</span>
                <span class="s1">fl </span><span class="s4">= </span><span class="s5">1</span>
                <span class="s3">break</span>
        <span class="s3">if </span><span class="s1">fl</span><span class="s4">:</span>
            <span class="s1">dep </span><span class="s4">= </span><span class="s1">dep</span><span class="s4">[</span><span class="s5">1</span><span class="s4">:] + [</span><span class="s1">v</span><span class="s4">]</span>
            <span class="s1">i </span><span class="s4">= </span><span class="s1">i </span><span class="s4">+ </span><span class="s5">1</span>
            <span class="s3">if </span><span class="s1">i </span><span class="s4">&gt; </span><span class="s1">n</span><span class="s4">:</span>
                <span class="s1">errmess</span><span class="s4">(</span><span class="s6">'sortvarnames: failed to compute dependencies because'</span>
                        <span class="s6">' of cyclic dependencies between '</span>
                        <span class="s4">+ </span><span class="s6">', '</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">dep</span><span class="s4">) + </span><span class="s6">'</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">)</span>
                <span class="s1">indep </span><span class="s4">= </span><span class="s1">indep </span><span class="s4">+ </span><span class="s1">dep</span>
                <span class="s3">break</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">indep</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">v</span><span class="s4">)</span>
            <span class="s1">dep </span><span class="s4">= </span><span class="s1">dep</span><span class="s4">[</span><span class="s5">1</span><span class="s4">:]</span>
            <span class="s1">n </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">dep</span><span class="s4">)</span>
            <span class="s1">i </span><span class="s4">= </span><span class="s5">0</span>
    <span class="s3">return </span><span class="s1">indep</span>


<span class="s3">def </span><span class="s1">analyzecommon</span><span class="s4">(</span><span class="s1">block</span><span class="s4">):</span>
    <span class="s3">if not </span><span class="s1">hascommon</span><span class="s4">(</span><span class="s1">block</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">block</span>
    <span class="s1">commonvars </span><span class="s4">= []</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'common'</span><span class="s4">].</span><span class="s1">keys</span><span class="s4">()):</span>
        <span class="s1">comvars </span><span class="s4">= []</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'common'</span><span class="s4">][</span><span class="s1">k</span><span class="s4">]:</span>
            <span class="s1">m </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span>
                <span class="s6">r'\A\s*\b(?P&lt;name&gt;.*?)\b\s*(\((?P&lt;dims&gt;.*?)\)|)\s*\Z'</span><span class="s4">, </span><span class="s1">e</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">m</span><span class="s4">:</span>
                <span class="s1">dims </span><span class="s4">= []</span>
                <span class="s3">if </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'dims'</span><span class="s4">):</span>
                    <span class="s1">dims </span><span class="s4">= [</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">()</span>
                            <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'dims'</span><span class="s4">)).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@,@'</span><span class="s4">)]</span>
                <span class="s1">n </span><span class="s4">= </span><span class="s1">rmbadname1</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'name'</span><span class="s4">).</span><span class="s1">strip</span><span class="s4">())</span>
                <span class="s3">if </span><span class="s1">n </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">]:</span>
                    <span class="s3">if </span><span class="s6">'attrspec' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">n</span><span class="s4">]:</span>
                        <span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span>
                            <span class="s6">'dimension(%s)' </span><span class="s4">% (</span><span class="s6">','</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">dims</span><span class="s4">)))</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">] = [</span>
                            <span class="s6">'dimension(%s)' </span><span class="s4">% (</span><span class="s6">','</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">dims</span><span class="s4">))]</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">dims</span><span class="s4">:</span>
                        <span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">n</span><span class="s4">] = {</span>
                            <span class="s6">'attrspec'</span><span class="s4">: [</span><span class="s6">'dimension(%s)' </span><span class="s4">% (</span><span class="s6">','</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">dims</span><span class="s4">))]}</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">n</span><span class="s4">] = {}</span>
                <span class="s3">if </span><span class="s1">n </span><span class="s3">not in </span><span class="s1">commonvars</span><span class="s4">:</span>
                    <span class="s1">commonvars</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">n </span><span class="s4">= </span><span class="s1">e</span>
                <span class="s1">errmess</span><span class="s4">(</span>
                    <span class="s6">'analyzecommon: failed to extract &quot;&lt;name&gt;[(&lt;dims&gt;)]&quot; from &quot;%s&quot; in common /%s/.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">e</span><span class="s4">, </span><span class="s1">k</span><span class="s4">))</span>
            <span class="s1">comvars</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)</span>
        <span class="s1">block</span><span class="s4">[</span><span class="s6">'common'</span><span class="s4">][</span><span class="s1">k</span><span class="s4">] = </span><span class="s1">comvars</span>
    <span class="s3">if </span><span class="s6">'commonvars' </span><span class="s3">not in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s1">block</span><span class="s4">[</span><span class="s6">'commonvars'</span><span class="s4">] = </span><span class="s1">commonvars</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">block</span><span class="s4">[</span><span class="s6">'commonvars'</span><span class="s4">] = </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'commonvars'</span><span class="s4">] + </span><span class="s1">commonvars</span>
    <span class="s3">return </span><span class="s1">block</span>


<span class="s3">def </span><span class="s1">analyzebody</span><span class="s4">(</span><span class="s1">block</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">=</span><span class="s6">''</span><span class="s4">):</span>
    <span class="s3">global </span><span class="s1">usermodules</span><span class="s4">, </span><span class="s1">skipfuncs</span><span class="s4">, </span><span class="s1">onlyfuncs</span><span class="s4">, </span><span class="s1">f90modulevars</span>

    <span class="s1">setmesstext</span><span class="s4">(</span><span class="s1">block</span><span class="s4">)</span>

    <span class="s1">maybe_private </span><span class="s4">= {</span>
        <span class="s1">key</span><span class="s4">: </span><span class="s1">value</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">].</span><span class="s1">items</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s6">'attrspec' </span><span class="s3">not in </span><span class="s1">value </span><span class="s3">or </span><span class="s6">'public' </span><span class="s3">not in </span><span class="s1">value</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">]</span>
    <span class="s4">}</span>

    <span class="s1">body </span><span class="s4">= []</span>
    <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'body'</span><span class="s4">]:</span>
        <span class="s1">b</span><span class="s4">[</span><span class="s6">'parent_block'</span><span class="s4">] = </span><span class="s1">block</span>
        <span class="s3">if </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'block'</span><span class="s4">] </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'function'</span><span class="s4">, </span><span class="s6">'subroutine'</span><span class="s4">]:</span>
            <span class="s3">if </span><span class="s1">args </span><span class="s3">is not None and </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">] </span><span class="s3">not in </span><span class="s1">args</span><span class="s4">:</span>
                <span class="s3">continue</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">as_ </span><span class="s4">= </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'args'</span><span class="s4">]</span>
            <span class="s0"># Add private members to skipfuncs for gh-23879</span>
            <span class="s3">if </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">] </span><span class="s3">in </span><span class="s1">maybe_private</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">():</span>
                <span class="s1">skipfuncs</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">b</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">])</span>
            <span class="s3">if </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">] </span><span class="s3">in </span><span class="s1">skipfuncs</span><span class="s4">:</span>
                <span class="s3">continue</span>
            <span class="s3">if </span><span class="s1">onlyfuncs </span><span class="s3">and </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">] </span><span class="s3">not in </span><span class="s1">onlyfuncs</span><span class="s4">:</span>
                <span class="s3">continue</span>
            <span class="s1">b</span><span class="s4">[</span><span class="s6">'saved_interface'</span><span class="s4">] = </span><span class="s1">crack2fortrangen</span><span class="s4">(</span>
                <span class="s1">b</span><span class="s4">, </span><span class="s6">'</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">+ </span><span class="s6">' ' </span><span class="s4">* </span><span class="s5">6</span><span class="s4">, </span><span class="s1">as_interface</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">as_ </span><span class="s4">= </span><span class="s1">args</span>
        <span class="s1">b </span><span class="s4">= </span><span class="s1">postcrack</span><span class="s4">(</span><span class="s1">b</span><span class="s4">, </span><span class="s1">as_</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">=</span><span class="s1">tab </span><span class="s4">+ </span><span class="s6">'</span><span class="s3">\t</span><span class="s6">'</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'block'</span><span class="s4">] </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'interface'</span><span class="s4">, </span><span class="s6">'abstract interface'</span><span class="s4">] </span><span class="s3">and </span><span class="s1">\</span>
           <span class="s3">not </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'body'</span><span class="s4">] </span><span class="s3">and not </span><span class="s1">b</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s6">'implementedby'</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s6">'f2pyenhancements' </span><span class="s3">not in </span><span class="s1">b</span><span class="s4">:</span>
                <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'block'</span><span class="s4">].</span><span class="s1">replace</span><span class="s4">(</span><span class="s6">' '</span><span class="s4">, </span><span class="s6">''</span><span class="s4">) == </span><span class="s6">'pythonmodule'</span><span class="s4">:</span>
            <span class="s1">usermodules</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">b</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'block'</span><span class="s4">] == </span><span class="s6">'module'</span><span class="s4">:</span>
                <span class="s1">f90modulevars</span><span class="s4">[</span><span class="s1">b</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">]] = </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">]</span>
            <span class="s1">body</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">b</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">body</span>


<span class="s3">def </span><span class="s1">buildimplicitrules</span><span class="s4">(</span><span class="s1">block</span><span class="s4">):</span>
    <span class="s1">setmesstext</span><span class="s4">(</span><span class="s1">block</span><span class="s4">)</span>
    <span class="s1">implicitrules </span><span class="s4">= </span><span class="s1">defaultimplicitrules</span>
    <span class="s1">attrrules </span><span class="s4">= {}</span>
    <span class="s3">if </span><span class="s6">'implicit' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'implicit'</span><span class="s4">] </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">implicitrules </span><span class="s4">= </span><span class="s3">None</span>
            <span class="s3">if </span><span class="s1">verbose </span><span class="s4">&gt; </span><span class="s5">1</span><span class="s4">:</span>
                <span class="s1">outmess</span><span class="s4">(</span>
                    <span class="s6">'buildimplicitrules: no implicit rules for routine %s.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">]))</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'implicit'</span><span class="s4">].</span><span class="s1">keys</span><span class="s4">()):</span>
                <span class="s3">if </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'implicit'</span><span class="s4">][</span><span class="s1">k</span><span class="s4">].</span><span class="s1">get</span><span class="s4">(</span><span class="s6">'typespec'</span><span class="s4">) </span><span class="s3">not in </span><span class="s4">[</span><span class="s6">'static'</span><span class="s4">, </span><span class="s6">'automatic'</span><span class="s4">]:</span>
                    <span class="s1">implicitrules</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] = </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'implicit'</span><span class="s4">][</span><span class="s1">k</span><span class="s4">]</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">attrrules</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] = </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'implicit'</span><span class="s4">][</span><span class="s1">k</span><span class="s4">][</span><span class="s6">'typespec'</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">implicitrules</span><span class="s4">, </span><span class="s1">attrrules</span>


<span class="s3">def </span><span class="s1">myeval</span><span class="s4">(</span><span class="s1">e</span><span class="s4">, </span><span class="s1">g</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">l</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; Like `eval` but returns only integers and floats &quot;&quot;&quot;</span>
    <span class="s1">r </span><span class="s4">= </span><span class="s1">eval</span><span class="s4">(</span><span class="s1">e</span><span class="s4">, </span><span class="s1">g</span><span class="s4">, </span><span class="s1">l</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">type</span><span class="s4">(</span><span class="s1">r</span><span class="s4">) </span><span class="s3">in </span><span class="s4">[</span><span class="s1">int</span><span class="s4">, </span><span class="s1">float</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">r</span>
    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s6">'r=%r' </span><span class="s4">% (</span><span class="s1">r</span><span class="s4">))</span>

<span class="s1">getlincoef_re_1 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'\A\b\w+\b\Z'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">getlincoef</span><span class="s4">(</span><span class="s1">e</span><span class="s4">, </span><span class="s1">xset</span><span class="s4">):  </span><span class="s0"># e = a*x+b ; x in xset</span>
    <span class="s2">&quot;&quot;&quot; 
    Obtain ``a`` and ``b`` when ``e == &quot;a*x+b&quot;``, where ``x`` is a symbol in 
    xset. 
 
    &gt;&gt;&gt; getlincoef('2*x + 1', {'x'}) 
    (2, 1, 'x') 
    &gt;&gt;&gt; getlincoef('3*x + x*2 + 2 + 1', {'x'}) 
    (5, 3, 'x') 
    &gt;&gt;&gt; getlincoef('0', {'x'}) 
    (0, 0, None) 
    &gt;&gt;&gt; getlincoef('0*x', {'x'}) 
    (0, 0, 'x') 
    &gt;&gt;&gt; getlincoef('x*x', {'x'}) 
    (None, None, None) 
 
    This can be tricked by sufficiently complex expressions 
 
    &gt;&gt;&gt; getlincoef('(x - 0.5)*(x - 1.5)*(x - 1)*x + 2*x + 3', {'x'}) 
    (2.0, 3.0, 'x') 
    &quot;&quot;&quot;</span>
    <span class="s3">try</span><span class="s4">:</span>
        <span class="s1">c </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">myeval</span><span class="s4">(</span><span class="s1">e</span><span class="s4">, {}, {}))</span>
        <span class="s3">return </span><span class="s5">0</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s3">None</span>
    <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
        <span class="s3">pass</span>
    <span class="s3">if </span><span class="s1">getlincoef_re_1</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">e</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s5">1</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s1">e</span>
    <span class="s1">len_e </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">e</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">xset</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">x</span><span class="s4">) &gt; </span><span class="s1">len_e</span><span class="s4">:</span>
            <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">re</span><span class="s4">.</span><span class="s1">search</span><span class="s4">(</span><span class="s6">r'\w\s*\([^)]*\b' </span><span class="s4">+ </span><span class="s1">x </span><span class="s4">+ </span><span class="s6">r'\b'</span><span class="s4">, </span><span class="s1">e</span><span class="s4">):</span>
            <span class="s0"># skip function calls having x as an argument, e.g max(1, x)</span>
            <span class="s3">continue</span>
        <span class="s1">re_1 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'(?P&lt;before&gt;.*?)\b' </span><span class="s4">+ </span><span class="s1">x </span><span class="s4">+ </span><span class="s6">r'\b(?P&lt;after&gt;.*)'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
        <span class="s1">m </span><span class="s4">= </span><span class="s1">re_1</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">e</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">m</span><span class="s4">:</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">m1 </span><span class="s4">= </span><span class="s1">re_1</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">e</span><span class="s4">)</span>
                <span class="s3">while </span><span class="s1">m1</span><span class="s4">:</span>
                    <span class="s1">ee </span><span class="s4">= </span><span class="s6">'%s(%s)%s' </span><span class="s4">% (</span>
                        <span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'before'</span><span class="s4">), </span><span class="s5">0</span><span class="s4">, </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">))</span>
                    <span class="s1">m1 </span><span class="s4">= </span><span class="s1">re_1</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">ee</span><span class="s4">)</span>
                <span class="s1">b </span><span class="s4">= </span><span class="s1">myeval</span><span class="s4">(</span><span class="s1">ee</span><span class="s4">, {}, {})</span>
                <span class="s1">m1 </span><span class="s4">= </span><span class="s1">re_1</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">e</span><span class="s4">)</span>
                <span class="s3">while </span><span class="s1">m1</span><span class="s4">:</span>
                    <span class="s1">ee </span><span class="s4">= </span><span class="s6">'%s(%s)%s' </span><span class="s4">% (</span>
                        <span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'before'</span><span class="s4">), </span><span class="s5">1</span><span class="s4">, </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">))</span>
                    <span class="s1">m1 </span><span class="s4">= </span><span class="s1">re_1</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">ee</span><span class="s4">)</span>
                <span class="s1">a </span><span class="s4">= </span><span class="s1">myeval</span><span class="s4">(</span><span class="s1">ee</span><span class="s4">, {}, {}) - </span><span class="s1">b</span>
                <span class="s1">m1 </span><span class="s4">= </span><span class="s1">re_1</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">e</span><span class="s4">)</span>
                <span class="s3">while </span><span class="s1">m1</span><span class="s4">:</span>
                    <span class="s1">ee </span><span class="s4">= </span><span class="s6">'%s(%s)%s' </span><span class="s4">% (</span>
                        <span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'before'</span><span class="s4">), </span><span class="s5">0.5</span><span class="s4">, </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">))</span>
                    <span class="s1">m1 </span><span class="s4">= </span><span class="s1">re_1</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">ee</span><span class="s4">)</span>
                <span class="s1">c </span><span class="s4">= </span><span class="s1">myeval</span><span class="s4">(</span><span class="s1">ee</span><span class="s4">, {}, {})</span>
                <span class="s0"># computing another point to be sure that expression is linear</span>
                <span class="s1">m1 </span><span class="s4">= </span><span class="s1">re_1</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">e</span><span class="s4">)</span>
                <span class="s3">while </span><span class="s1">m1</span><span class="s4">:</span>
                    <span class="s1">ee </span><span class="s4">= </span><span class="s6">'%s(%s)%s' </span><span class="s4">% (</span>
                        <span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'before'</span><span class="s4">), </span><span class="s5">1.5</span><span class="s4">, </span><span class="s1">m1</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">))</span>
                    <span class="s1">m1 </span><span class="s4">= </span><span class="s1">re_1</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">ee</span><span class="s4">)</span>
                <span class="s1">c2 </span><span class="s4">= </span><span class="s1">myeval</span><span class="s4">(</span><span class="s1">ee</span><span class="s4">, {}, {})</span>
                <span class="s3">if </span><span class="s4">(</span><span class="s1">a </span><span class="s4">* </span><span class="s5">0.5 </span><span class="s4">+ </span><span class="s1">b </span><span class="s4">== </span><span class="s1">c </span><span class="s3">and </span><span class="s1">a </span><span class="s4">* </span><span class="s5">1.5 </span><span class="s4">+ </span><span class="s1">b </span><span class="s4">== </span><span class="s1">c2</span><span class="s4">):</span>
                    <span class="s3">return </span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">x</span>
            <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
                <span class="s3">pass</span>
            <span class="s3">break</span>
    <span class="s3">return None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span>


<span class="s1">word_pattern </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'\b[a-z][\w$]*\b'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_get_depend_dict</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">vars</span><span class="s4">, </span><span class="s1">deps</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">:</span>
        <span class="s1">words </span><span class="s4">= </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">name</span><span class="s4">].</span><span class="s1">get</span><span class="s4">(</span><span class="s6">'depend'</span><span class="s4">, [])</span>

        <span class="s3">if </span><span class="s6">'=' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] </span><span class="s3">and not </span><span class="s1">isstring</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]):</span>
            <span class="s3">for </span><span class="s1">word </span><span class="s3">in </span><span class="s1">word_pattern</span><span class="s4">.</span><span class="s1">findall</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">name</span><span class="s4">][</span><span class="s6">'='</span><span class="s4">]):</span>
                <span class="s0"># The word_pattern may return values that are not</span>
                <span class="s0"># only variables, they can be string content for instance</span>
                <span class="s3">if </span><span class="s1">word </span><span class="s3">not in </span><span class="s1">words </span><span class="s3">and </span><span class="s1">word </span><span class="s3">in </span><span class="s1">vars </span><span class="s3">and </span><span class="s1">word </span><span class="s4">!= </span><span class="s1">name</span><span class="s4">:</span>
                    <span class="s1">words</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">word</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">word </span><span class="s3">in </span><span class="s1">words</span><span class="s4">[:]:</span>
            <span class="s3">for </span><span class="s1">w </span><span class="s3">in </span><span class="s1">deps</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">word</span><span class="s4">, []) </span><span class="s1">\</span>
                    <span class="s3">or </span><span class="s1">_get_depend_dict</span><span class="s4">(</span><span class="s1">word</span><span class="s4">, </span><span class="s1">vars</span><span class="s4">, </span><span class="s1">deps</span><span class="s4">):</span>
                <span class="s3">if </span><span class="s1">w </span><span class="s3">not in </span><span class="s1">words</span><span class="s4">:</span>
                    <span class="s1">words</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">w</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'_get_depend_dict: no dependence info for %s</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)))</span>
        <span class="s1">words </span><span class="s4">= []</span>
    <span class="s1">deps</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">words</span>
    <span class="s3">return </span><span class="s1">words</span>


<span class="s3">def </span><span class="s1">_calc_depend_dict</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">):</span>
    <span class="s1">names </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">())</span>
    <span class="s1">depend_dict </span><span class="s4">= {}</span>
    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">names</span><span class="s4">:</span>
        <span class="s1">_get_depend_dict</span><span class="s4">(</span><span class="s1">n</span><span class="s4">, </span><span class="s1">vars</span><span class="s4">, </span><span class="s1">depend_dict</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">depend_dict</span>


<span class="s3">def </span><span class="s1">get_sorted_names</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">):</span>
    <span class="s1">depend_dict </span><span class="s4">= </span><span class="s1">_calc_depend_dict</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">)</span>
    <span class="s1">names </span><span class="s4">= []</span>
    <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">depend_dict</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
        <span class="s3">if not </span><span class="s1">depend_dict</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]:</span>
            <span class="s1">names</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
            <span class="s3">del </span><span class="s1">depend_dict</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]</span>
    <span class="s3">while </span><span class="s1">depend_dict</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">lst </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">depend_dict</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()):</span>
            <span class="s1">new_lst </span><span class="s4">= [</span><span class="s1">n </span><span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">lst </span><span class="s3">if </span><span class="s1">n </span><span class="s3">in </span><span class="s1">depend_dict</span><span class="s4">]</span>
            <span class="s3">if not </span><span class="s1">new_lst</span><span class="s4">:</span>
                <span class="s1">names</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
                <span class="s3">del </span><span class="s1">depend_dict</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">depend_dict</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">new_lst</span>
    <span class="s3">return </span><span class="s4">[</span><span class="s1">name </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">names </span><span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">_kind_func</span><span class="s4">(</span><span class="s1">string</span><span class="s4">):</span>
    <span class="s0"># XXX: return something sensible.</span>
    <span class="s3">if </span><span class="s1">string</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] </span><span class="s3">in </span><span class="s6">&quot;'</span><span class="s3">\&quot;</span><span class="s6">&quot;</span><span class="s4">:</span>
        <span class="s1">string </span><span class="s4">= </span><span class="s1">string</span><span class="s4">[</span><span class="s5">1</span><span class="s4">:-</span><span class="s5">1</span><span class="s4">]</span>
    <span class="s3">if </span><span class="s1">real16pattern</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">string</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s5">8</span>
    <span class="s3">elif </span><span class="s1">real8pattern</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">string</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s5">4</span>
    <span class="s3">return </span><span class="s6">'kind(' </span><span class="s4">+ </span><span class="s1">string </span><span class="s4">+ </span><span class="s6">')'</span>


<span class="s3">def </span><span class="s1">_selected_int_kind_func</span><span class="s4">(</span><span class="s1">r</span><span class="s4">):</span>
    <span class="s0"># XXX: This should be processor dependent</span>
    <span class="s1">m </span><span class="s4">= </span><span class="s5">10 </span><span class="s4">** </span><span class="s1">r</span>
    <span class="s3">if </span><span class="s1">m </span><span class="s4">&lt;= </span><span class="s5">2 </span><span class="s4">** </span><span class="s5">8</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s5">1</span>
    <span class="s3">if </span><span class="s1">m </span><span class="s4">&lt;= </span><span class="s5">2 </span><span class="s4">** </span><span class="s5">16</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s5">2</span>
    <span class="s3">if </span><span class="s1">m </span><span class="s4">&lt;= </span><span class="s5">2 </span><span class="s4">** </span><span class="s5">32</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s5">4</span>
    <span class="s3">if </span><span class="s1">m </span><span class="s4">&lt;= </span><span class="s5">2 </span><span class="s4">** </span><span class="s5">63</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s5">8</span>
    <span class="s3">if </span><span class="s1">m </span><span class="s4">&lt;= </span><span class="s5">2 </span><span class="s4">** </span><span class="s5">128</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s5">16</span>
    <span class="s3">return </span><span class="s4">-</span><span class="s5">1</span>


<span class="s3">def </span><span class="s1">_selected_real_kind_func</span><span class="s4">(</span><span class="s1">p</span><span class="s4">, </span><span class="s1">r</span><span class="s4">=</span><span class="s5">0</span><span class="s4">, </span><span class="s1">radix</span><span class="s4">=</span><span class="s5">0</span><span class="s4">):</span>
    <span class="s0"># XXX: This should be processor dependent</span>
    <span class="s0"># This is only verified for 0 &lt;= p &lt;= 20, possibly good for p &lt;= 33 and above</span>
    <span class="s3">if </span><span class="s1">p </span><span class="s4">&lt; </span><span class="s5">7</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s5">4</span>
    <span class="s3">if </span><span class="s1">p </span><span class="s4">&lt; </span><span class="s5">16</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s5">8</span>
    <span class="s1">machine </span><span class="s4">= </span><span class="s1">platform</span><span class="s4">.</span><span class="s1">machine</span><span class="s4">().</span><span class="s1">lower</span><span class="s4">()</span>
    <span class="s3">if </span><span class="s1">machine</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">((</span><span class="s6">'aarch64'</span><span class="s4">, </span><span class="s6">'alpha'</span><span class="s4">, </span><span class="s6">'arm64'</span><span class="s4">, </span><span class="s6">'loongarch'</span><span class="s4">, </span><span class="s6">'mips'</span><span class="s4">, </span><span class="s6">'power'</span><span class="s4">, </span><span class="s6">'ppc'</span><span class="s4">, </span><span class="s6">'riscv'</span><span class="s4">, </span><span class="s6">'s390x'</span><span class="s4">, </span><span class="s6">'sparc'</span><span class="s4">)):</span>
        <span class="s3">if </span><span class="s1">p </span><span class="s4">&lt;= </span><span class="s5">33</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s5">16</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">p </span><span class="s4">&lt; </span><span class="s5">19</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s5">10</span>
        <span class="s3">elif </span><span class="s1">p </span><span class="s4">&lt;= </span><span class="s5">33</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s5">16</span>
    <span class="s3">return </span><span class="s4">-</span><span class="s5">1</span>


<span class="s3">def </span><span class="s1">get_parameters</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">, </span><span class="s1">global_params</span><span class="s4">={}):</span>
    <span class="s1">params </span><span class="s4">= </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">global_params</span><span class="s4">)</span>
    <span class="s1">g_params </span><span class="s4">= </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">global_params</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">name</span><span class="s4">, </span><span class="s1">func </span><span class="s3">in </span><span class="s4">[(</span><span class="s6">'kind'</span><span class="s4">, </span><span class="s1">_kind_func</span><span class="s4">),</span>
                       <span class="s4">(</span><span class="s6">'selected_int_kind'</span><span class="s4">, </span><span class="s1">_selected_int_kind_func</span><span class="s4">),</span>
                       <span class="s4">(</span><span class="s6">'selected_real_kind'</span><span class="s4">, </span><span class="s1">_selected_real_kind_func</span><span class="s4">), ]:</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">g_params</span><span class="s4">:</span>
            <span class="s1">g_params</span><span class="s4">[</span><span class="s1">name</span><span class="s4">] = </span><span class="s1">func</span>
    <span class="s1">param_names </span><span class="s4">= []</span>
    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">get_sorted_names</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s6">'attrspec' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">] </span><span class="s3">and </span><span class="s6">'parameter' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">]:</span>
            <span class="s1">param_names</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)</span>
    <span class="s1">kind_re </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'\bkind\s*\(\s*(?P&lt;value&gt;.*)\s*\)'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
    <span class="s1">selected_int_kind_re </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
        <span class="s6">r'\bselected_int_kind\s*\(\s*(?P&lt;value&gt;.*)\s*\)'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
    <span class="s1">selected_kind_re </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
        <span class="s6">r'\bselected_(int|real)_kind\s*\(\s*(?P&lt;value&gt;.*)\s*\)'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">param_names</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s6">'=' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]:</span>
            <span class="s1">v </span><span class="s4">= </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'='</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">islogical</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]):</span>
                <span class="s1">v </span><span class="s4">= </span><span class="s1">v</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">()</span>
                <span class="s3">for </span><span class="s1">repl </span><span class="s3">in </span><span class="s4">[</span>
                    <span class="s4">(</span><span class="s6">'.false.'</span><span class="s4">, </span><span class="s6">'False'</span><span class="s4">),</span>
                    <span class="s4">(</span><span class="s6">'.true.'</span><span class="s4">, </span><span class="s6">'True'</span><span class="s4">),</span>
                    <span class="s0"># TODO: test .eq., .neq., etc replacements.</span>
                <span class="s4">]:</span>
                    <span class="s1">v </span><span class="s4">= </span><span class="s1">v</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(*</span><span class="s1">repl</span><span class="s4">)</span>

            <span class="s1">v </span><span class="s4">= </span><span class="s1">kind_re</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">(</span><span class="s6">r'kind(&quot;\1&quot;)'</span><span class="s4">, </span><span class="s1">v</span><span class="s4">)</span>
            <span class="s1">v </span><span class="s4">= </span><span class="s1">selected_int_kind_re</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">(</span><span class="s6">r'selected_int_kind(\1)'</span><span class="s4">, </span><span class="s1">v</span><span class="s4">)</span>

            <span class="s0"># We need to act according to the data.</span>
            <span class="s0"># The easy case is if the data has a kind-specifier,</span>
            <span class="s0"># then we may easily remove those specifiers.</span>
            <span class="s0"># However, it may be that the user uses other specifiers...(!)</span>
            <span class="s1">is_replaced </span><span class="s4">= </span><span class="s3">False</span>

            <span class="s3">if </span><span class="s6">'kindselector' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]:</span>
                <span class="s0"># Remove kind specifier (including those defined</span>
                <span class="s0"># by parameters)</span>
                <span class="s3">if </span><span class="s6">'kind' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'kindselector'</span><span class="s4">]:</span>
                    <span class="s1">orig_v_len </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">v</span><span class="s4">)</span>
                    <span class="s1">v </span><span class="s4">= </span><span class="s1">v</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s6">'_' </span><span class="s4">+ </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'kindselector'</span><span class="s4">][</span><span class="s6">'kind'</span><span class="s4">], </span><span class="s6">''</span><span class="s4">)</span>
                    <span class="s0"># Again, this will be true if even a single specifier</span>
                    <span class="s0"># has been replaced, see comment above.</span>
                    <span class="s1">is_replaced </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">v</span><span class="s4">) &lt; </span><span class="s1">orig_v_len</span>

            <span class="s3">if not </span><span class="s1">is_replaced</span><span class="s4">:</span>
                <span class="s3">if not </span><span class="s1">selected_kind_re</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">v</span><span class="s4">):</span>
                    <span class="s1">v_ </span><span class="s4">= </span><span class="s1">v</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'_'</span><span class="s4">)</span>
                    <span class="s0"># In case there are additive parameters</span>
                    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">v_</span><span class="s4">) &gt; </span><span class="s5">1</span><span class="s4">: </span>
                        <span class="s1">v </span><span class="s4">= </span><span class="s6">''</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">v_</span><span class="s4">[:-</span><span class="s5">1</span><span class="s4">]).</span><span class="s1">lower</span><span class="s4">().</span><span class="s1">replace</span><span class="s4">(</span><span class="s1">v_</span><span class="s4">[-</span><span class="s5">1</span><span class="s4">].</span><span class="s1">lower</span><span class="s4">(), </span><span class="s6">''</span><span class="s4">)</span>

            <span class="s0"># Currently this will not work for complex numbers.</span>
            <span class="s0"># There is missing code for extracting a complex number,</span>
            <span class="s0"># which may be defined in either of these:</span>
            <span class="s0">#  a) (Re, Im)</span>
            <span class="s0">#  b) cmplx(Re, Im)</span>
            <span class="s0">#  c) dcmplx(Re, Im)</span>
            <span class="s0">#  d) cmplx(Re, Im, &lt;prec&gt;)</span>

            <span class="s3">if </span><span class="s1">isdouble</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]):</span>
                <span class="s1">tt </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">v</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">real16pattern</span><span class="s4">.</span><span class="s1">finditer</span><span class="s4">(</span><span class="s1">v</span><span class="s4">):</span>
                    <span class="s1">tt</span><span class="s4">[</span><span class="s1">m</span><span class="s4">.</span><span class="s1">start</span><span class="s4">():</span><span class="s1">m</span><span class="s4">.</span><span class="s1">end</span><span class="s4">()] = </span><span class="s1">list</span><span class="s4">(</span>
                        <span class="s1">v</span><span class="s4">[</span><span class="s1">m</span><span class="s4">.</span><span class="s1">start</span><span class="s4">():</span><span class="s1">m</span><span class="s4">.</span><span class="s1">end</span><span class="s4">()].</span><span class="s1">lower</span><span class="s4">().</span><span class="s1">replace</span><span class="s4">(</span><span class="s6">'d'</span><span class="s4">, </span><span class="s6">'e'</span><span class="s4">))</span>
                <span class="s1">v </span><span class="s4">= </span><span class="s6">''</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">tt</span><span class="s4">)</span>

            <span class="s3">elif </span><span class="s1">iscomplex</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]):</span>
                <span class="s1">outmess</span><span class="s4">(</span><span class="s6">f'get_parameters[TODO]: '</span>
                        <span class="s6">f'implement evaluation of complex expression </span><span class="s3">{</span><span class="s1">v</span><span class="s3">}\n</span><span class="s6">'</span><span class="s4">)</span>

            <span class="s1">dimspec </span><span class="s4">= ([</span><span class="s1">s</span><span class="s4">.</span><span class="s1">removeprefix</span><span class="s4">(</span><span class="s6">'dimension'</span><span class="s4">).</span><span class="s1">strip</span><span class="s4">()</span>
                        <span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">]</span>
                       <span class="s3">if </span><span class="s1">s</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s6">'dimension'</span><span class="s4">)] </span><span class="s3">or </span><span class="s4">[</span><span class="s3">None</span><span class="s4">])[</span><span class="s5">0</span><span class="s4">]</span>

            <span class="s0"># Handle _dp for gh-6624</span>
            <span class="s0"># Also fixes gh-20460</span>
            <span class="s3">if </span><span class="s1">real16pattern</span><span class="s4">.</span><span class="s1">search</span><span class="s4">(</span><span class="s1">v</span><span class="s4">):</span>
                <span class="s1">v </span><span class="s4">= </span><span class="s5">8</span>
            <span class="s3">elif </span><span class="s1">real8pattern</span><span class="s4">.</span><span class="s1">search</span><span class="s4">(</span><span class="s1">v</span><span class="s4">):</span>
                <span class="s1">v </span><span class="s4">= </span><span class="s5">4</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">params</span><span class="s4">[</span><span class="s1">n</span><span class="s4">] = </span><span class="s1">param_eval</span><span class="s4">(</span><span class="s1">v</span><span class="s4">, </span><span class="s1">g_params</span><span class="s4">, </span><span class="s1">params</span><span class="s4">, </span><span class="s1">dimspec</span><span class="s4">=</span><span class="s1">dimspec</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">msg</span><span class="s4">:</span>
                <span class="s1">params</span><span class="s4">[</span><span class="s1">n</span><span class="s4">] = </span><span class="s1">v</span>
                <span class="s1">outmess</span><span class="s4">(</span><span class="s6">f'get_parameters: got &quot;</span><span class="s3">{</span><span class="s1">msg</span><span class="s3">}</span><span class="s6">&quot; on </span><span class="s3">{</span><span class="s1">n</span><span class="s3">!r}\n</span><span class="s6">'</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">isstring</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]) </span><span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">params</span><span class="s4">[</span><span class="s1">n</span><span class="s4">], </span><span class="s1">int</span><span class="s4">):</span>
                <span class="s1">params</span><span class="s4">[</span><span class="s1">n</span><span class="s4">] = </span><span class="s1">chr</span><span class="s4">(</span><span class="s1">params</span><span class="s4">[</span><span class="s1">n</span><span class="s4">])</span>
            <span class="s1">nl </span><span class="s4">= </span><span class="s1">n</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s1">nl </span><span class="s4">!= </span><span class="s1">n</span><span class="s4">:</span>
                <span class="s1">params</span><span class="s4">[</span><span class="s1">nl</span><span class="s4">] = </span><span class="s1">params</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">print</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">])</span>
            <span class="s1">outmess</span><span class="s4">(</span><span class="s6">f'get_parameters:parameter </span><span class="s3">{</span><span class="s1">n</span><span class="s3">!r} </span><span class="s6">does not have value?!</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">params</span>


<span class="s3">def </span><span class="s1">_eval_length</span><span class="s4">(</span><span class="s1">length</span><span class="s4">, </span><span class="s1">params</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">length </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'(:)'</span><span class="s4">, </span><span class="s6">'(*)'</span><span class="s4">, </span><span class="s6">'*'</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s6">'(*)'</span>
    <span class="s3">return </span><span class="s1">_eval_scalar</span><span class="s4">(</span><span class="s1">length</span><span class="s4">, </span><span class="s1">params</span><span class="s4">)</span>


<span class="s1">_is_kind_number </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'\d+_'</span><span class="s4">).</span><span class="s1">match</span>


<span class="s3">def </span><span class="s1">_eval_scalar</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">params</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">_is_kind_number</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
        <span class="s1">value </span><span class="s4">= </span><span class="s1">value</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'_'</span><span class="s4">)[</span><span class="s5">0</span><span class="s4">]</span>
    <span class="s3">try</span><span class="s4">:</span>
        <span class="s0"># TODO: use symbolic from PR #19805</span>
        <span class="s1">value </span><span class="s4">= </span><span class="s1">eval</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, {}, </span><span class="s1">params</span><span class="s4">)</span>
        <span class="s1">value </span><span class="s4">= (</span><span class="s1">repr </span><span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">str</span><span class="s4">) </span><span class="s3">else </span><span class="s1">str</span><span class="s4">)(</span><span class="s1">value</span><span class="s4">)</span>
    <span class="s3">except </span><span class="s4">(</span><span class="s1">NameError</span><span class="s4">, </span><span class="s1">SyntaxError</span><span class="s4">, </span><span class="s1">TypeError</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">value</span>
    <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">msg</span><span class="s4">:</span>
        <span class="s1">errmess</span><span class="s4">(</span><span class="s6">'&quot;%s&quot; in evaluating %r '</span>
                <span class="s6">'(available names: %s)</span><span class="s3">\n</span><span class="s6">'</span>
                <span class="s4">% (</span><span class="s1">msg</span><span class="s4">, </span><span class="s1">value</span><span class="s4">, </span><span class="s1">list</span><span class="s4">(</span><span class="s1">params</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">())))</span>
    <span class="s3">return </span><span class="s1">value</span>


<span class="s3">def </span><span class="s1">analyzevars</span><span class="s4">(</span><span class="s1">block</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Sets correct dimension information for each variable/parameter 
    &quot;&quot;&quot;</span>

    <span class="s3">global </span><span class="s1">f90modulevars</span>

    <span class="s1">setmesstext</span><span class="s4">(</span><span class="s1">block</span><span class="s4">)</span>
    <span class="s1">implicitrules</span><span class="s4">, </span><span class="s1">attrrules </span><span class="s4">= </span><span class="s1">buildimplicitrules</span><span class="s4">(</span><span class="s1">block</span><span class="s4">)</span>
    <span class="s1">vars </span><span class="s4">= </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">])</span>
    <span class="s3">if </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'block'</span><span class="s4">] == </span><span class="s6">'function' </span><span class="s3">and </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">] </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">:</span>
        <span class="s1">vars</span><span class="s4">[</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">]] = {}</span>
    <span class="s3">if </span><span class="s6">'' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">]:</span>
        <span class="s3">del </span><span class="s1">vars</span><span class="s4">[</span><span class="s6">''</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s6">'attrspec' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s6">''</span><span class="s4">]:</span>
            <span class="s1">gen </span><span class="s4">= </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s6">''</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">]</span>
            <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">set</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">) | </span><span class="s1">set</span><span class="s4">(</span><span class="s1">b</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">] </span><span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'body'</span><span class="s4">]):</span>
                <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'public'</span><span class="s4">, </span><span class="s6">'private'</span><span class="s4">]:</span>
                    <span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">gen</span><span class="s4">:</span>
                        <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">] = </span><span class="s1">setattrspec</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">n</span><span class="s4">, {}), </span><span class="s1">k</span><span class="s4">)</span>
    <span class="s1">svars </span><span class="s4">= []</span>
    <span class="s1">args </span><span class="s4">= </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'args'</span><span class="s4">]</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args</span><span class="s4">:</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">]</span>
            <span class="s1">svars</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">KeyError</span><span class="s4">:</span>
            <span class="s3">pass</span>
    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
        <span class="s3">if </span><span class="s1">n </span><span class="s3">not in </span><span class="s1">args</span><span class="s4">:</span>
            <span class="s1">svars</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)</span>

    <span class="s1">params </span><span class="s4">= </span><span class="s1">get_parameters</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">, </span><span class="s1">get_useparameters</span><span class="s4">(</span><span class="s1">block</span><span class="s4">))</span>
    <span class="s0"># At this point, params are read and interpreted, but</span>
    <span class="s0"># the params used to define vars are not yet parsed</span>
    <span class="s1">dep_matches </span><span class="s4">= {}</span>
    <span class="s1">name_match </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'[A-Za-z][\w$]*'</span><span class="s4">).</span><span class="s1">match</span>
    <span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
        <span class="s1">m </span><span class="s4">= </span><span class="s1">name_match</span><span class="s4">(</span><span class="s1">v</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">m</span><span class="s4">:</span>
            <span class="s1">n </span><span class="s4">= </span><span class="s1">v</span><span class="s4">[</span><span class="s1">m</span><span class="s4">.</span><span class="s1">start</span><span class="s4">():</span><span class="s1">m</span><span class="s4">.</span><span class="s1">end</span><span class="s4">()]</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">dep_matches</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]</span>
            <span class="s3">except </span><span class="s1">KeyError</span><span class="s4">:</span>
                <span class="s1">dep_matches</span><span class="s4">[</span><span class="s1">n</span><span class="s4">] = </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'.*\b%s\b' </span><span class="s4">% (</span><span class="s1">v</span><span class="s4">), </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">).</span><span class="s1">match</span>
    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">svars</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">n</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">attrrules</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
            <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">] = </span><span class="s1">setattrspec</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">], </span><span class="s1">attrrules</span><span class="s4">[</span><span class="s1">n</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]])</span>
        <span class="s3">if </span><span class="s6">'typespec' </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]:</span>
            <span class="s3">if not</span><span class="s4">(</span><span class="s6">'attrspec' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">] </span><span class="s3">and </span><span class="s6">'external' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">]):</span>
                <span class="s3">if </span><span class="s1">implicitrules</span><span class="s4">:</span>
                    <span class="s1">ln0 </span><span class="s4">= </span><span class="s1">n</span><span class="s4">[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">lower</span><span class="s4">()</span>
                    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">implicitrules</span><span class="s4">[</span><span class="s1">ln0</span><span class="s4">].</span><span class="s1">keys</span><span class="s4">()):</span>
                        <span class="s3">if </span><span class="s1">k </span><span class="s4">== </span><span class="s6">'typespec' </span><span class="s3">and </span><span class="s1">implicitrules</span><span class="s4">[</span><span class="s1">ln0</span><span class="s4">][</span><span class="s1">k</span><span class="s4">] == </span><span class="s6">'undefined'</span><span class="s4">:</span>
                            <span class="s3">continue</span>
                        <span class="s3">if </span><span class="s1">k </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]:</span>
                            <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s1">k</span><span class="s4">] = </span><span class="s1">implicitrules</span><span class="s4">[</span><span class="s1">ln0</span><span class="s4">][</span><span class="s1">k</span><span class="s4">]</span>
                        <span class="s3">elif </span><span class="s1">k </span><span class="s4">== </span><span class="s6">'attrspec'</span><span class="s4">:</span>
                            <span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">implicitrules</span><span class="s4">[</span><span class="s1">ln0</span><span class="s4">][</span><span class="s1">k</span><span class="s4">]:</span>
                                <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">] = </span><span class="s1">setattrspec</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">], </span><span class="s1">l</span><span class="s4">)</span>
                <span class="s3">elif </span><span class="s1">n </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'args'</span><span class="s4">]:</span>
                    <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'analyzevars: typespec of variable %s is not defined in routine %s.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span>
                        <span class="s1">repr</span><span class="s4">(</span><span class="s1">n</span><span class="s4">), </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">]))</span>
        <span class="s3">if </span><span class="s6">'charselector' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]:</span>
            <span class="s3">if </span><span class="s6">'len' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'charselector'</span><span class="s4">]:</span>
                <span class="s1">l </span><span class="s4">= </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'charselector'</span><span class="s4">][</span><span class="s6">'len'</span><span class="s4">]</span>
                <span class="s3">try</span><span class="s4">:</span>
                    <span class="s1">l </span><span class="s4">= </span><span class="s1">str</span><span class="s4">(</span><span class="s1">eval</span><span class="s4">(</span><span class="s1">l</span><span class="s4">, {}, </span><span class="s1">params</span><span class="s4">))</span>
                <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
                    <span class="s3">pass</span>
                <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'charselector'</span><span class="s4">][</span><span class="s6">'len'</span><span class="s4">] = </span><span class="s1">l</span>

        <span class="s3">if </span><span class="s6">'kindselector' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]:</span>
            <span class="s3">if </span><span class="s6">'kind' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'kindselector'</span><span class="s4">]:</span>
                <span class="s1">l </span><span class="s4">= </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'kindselector'</span><span class="s4">][</span><span class="s6">'kind'</span><span class="s4">]</span>
                <span class="s3">try</span><span class="s4">:</span>
                    <span class="s1">l </span><span class="s4">= </span><span class="s1">str</span><span class="s4">(</span><span class="s1">eval</span><span class="s4">(</span><span class="s1">l</span><span class="s4">, {}, </span><span class="s1">params</span><span class="s4">))</span>
                <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
                    <span class="s3">pass</span>
                <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'kindselector'</span><span class="s4">][</span><span class="s6">'kind'</span><span class="s4">] = </span><span class="s1">l</span>

        <span class="s1">dimension_exprs </span><span class="s4">= {}</span>
        <span class="s3">if </span><span class="s6">'attrspec' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]:</span>
            <span class="s1">attr </span><span class="s4">= </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">]</span>
            <span class="s1">attr</span><span class="s4">.</span><span class="s1">reverse</span><span class="s4">()</span>
            <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">] = []</span>
            <span class="s1">dim</span><span class="s4">, </span><span class="s1">intent</span><span class="s4">, </span><span class="s1">depend</span><span class="s4">, </span><span class="s1">check</span><span class="s4">, </span><span class="s1">note </span><span class="s4">= </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span>
            <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">attr</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">a</span><span class="s4">[:</span><span class="s5">9</span><span class="s4">] == </span><span class="s6">'dimension'</span><span class="s4">:</span>
                    <span class="s1">dim </span><span class="s4">= (</span><span class="s1">a</span><span class="s4">[</span><span class="s5">9</span><span class="s4">:].</span><span class="s1">strip</span><span class="s4">())[</span><span class="s5">1</span><span class="s4">:-</span><span class="s5">1</span><span class="s4">]</span>
                <span class="s3">elif </span><span class="s1">a</span><span class="s4">[:</span><span class="s5">6</span><span class="s4">] == </span><span class="s6">'intent'</span><span class="s4">:</span>
                    <span class="s1">intent </span><span class="s4">= (</span><span class="s1">a</span><span class="s4">[</span><span class="s5">6</span><span class="s4">:].</span><span class="s1">strip</span><span class="s4">())[</span><span class="s5">1</span><span class="s4">:-</span><span class="s5">1</span><span class="s4">]</span>
                <span class="s3">elif </span><span class="s1">a</span><span class="s4">[:</span><span class="s5">6</span><span class="s4">] == </span><span class="s6">'depend'</span><span class="s4">:</span>
                    <span class="s1">depend </span><span class="s4">= (</span><span class="s1">a</span><span class="s4">[</span><span class="s5">6</span><span class="s4">:].</span><span class="s1">strip</span><span class="s4">())[</span><span class="s5">1</span><span class="s4">:-</span><span class="s5">1</span><span class="s4">]</span>
                <span class="s3">elif </span><span class="s1">a</span><span class="s4">[:</span><span class="s5">5</span><span class="s4">] == </span><span class="s6">'check'</span><span class="s4">:</span>
                    <span class="s1">check </span><span class="s4">= (</span><span class="s1">a</span><span class="s4">[</span><span class="s5">5</span><span class="s4">:].</span><span class="s1">strip</span><span class="s4">())[</span><span class="s5">1</span><span class="s4">:-</span><span class="s5">1</span><span class="s4">]</span>
                <span class="s3">elif </span><span class="s1">a</span><span class="s4">[:</span><span class="s5">4</span><span class="s4">] == </span><span class="s6">'note'</span><span class="s4">:</span>
                    <span class="s1">note </span><span class="s4">= (</span><span class="s1">a</span><span class="s4">[</span><span class="s5">4</span><span class="s4">:].</span><span class="s1">strip</span><span class="s4">())[</span><span class="s5">1</span><span class="s4">:-</span><span class="s5">1</span><span class="s4">]</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">] = </span><span class="s1">setattrspec</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">], </span><span class="s1">a</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">intent</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s6">'intent' </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]:</span>
                        <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'intent'</span><span class="s4">] = []</span>
                    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s4">[</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">intent</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@,@'</span><span class="s4">)]:</span>
                        <span class="s0"># Remove spaces so that 'in out' becomes 'inout'</span>
                        <span class="s1">tmp </span><span class="s4">= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s6">' '</span><span class="s4">, </span><span class="s6">''</span><span class="s4">)</span>
                        <span class="s3">if </span><span class="s1">tmp </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'intent'</span><span class="s4">]:</span>
                            <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'intent'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">tmp</span><span class="s4">)</span>
                    <span class="s1">intent </span><span class="s4">= </span><span class="s3">None</span>
                <span class="s3">if </span><span class="s1">note</span><span class="s4">:</span>
                    <span class="s1">note </span><span class="s4">= </span><span class="s1">note</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s6">'</span><span class="s3">\\</span><span class="s6">n</span><span class="s3">\\</span><span class="s6">n'</span><span class="s4">, </span><span class="s6">'</span><span class="s3">\n\n</span><span class="s6">'</span><span class="s4">)</span>
                    <span class="s1">note </span><span class="s4">= </span><span class="s1">note</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s6">'</span><span class="s3">\\</span><span class="s6">n '</span><span class="s4">, </span><span class="s6">'</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s6">'note' </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]:</span>
                        <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'note'</span><span class="s4">] = [</span><span class="s1">note</span><span class="s4">]</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'note'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">note</span><span class="s4">)</span>
                    <span class="s1">note </span><span class="s4">= </span><span class="s3">None</span>
                <span class="s3">if </span><span class="s1">depend </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s6">'depend' </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]:</span>
                        <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'depend'</span><span class="s4">] = []</span>
                    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">rmbadname</span><span class="s4">([</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">depend</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@,@'</span><span class="s4">)]):</span>
                        <span class="s3">if </span><span class="s1">c </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'depend'</span><span class="s4">]:</span>
                            <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'depend'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
                    <span class="s1">depend </span><span class="s4">= </span><span class="s3">None</span>
                <span class="s3">if </span><span class="s1">check </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s6">'check' </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]:</span>
                        <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'check'</span><span class="s4">] = []</span>
                    <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s4">[</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">check</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@,@'</span><span class="s4">)]:</span>
                        <span class="s3">if </span><span class="s1">c </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'check'</span><span class="s4">]:</span>
                            <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'check'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">c</span><span class="s4">)</span>
                    <span class="s1">check </span><span class="s4">= </span><span class="s3">None</span>
            <span class="s3">if </span><span class="s1">dim </span><span class="s3">and </span><span class="s6">'dimension' </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]:</span>
                <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'dimension'</span><span class="s4">] = []</span>
                <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">rmbadname</span><span class="s4">(</span>
                        <span class="s4">[</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">dim</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@,@'</span><span class="s4">)]</span>
                <span class="s4">):</span>
                    <span class="s0"># d is the expression inside the dimension declaration</span>
                    <span class="s0"># Evaluate `d` with respect to params</span>
                    <span class="s3">try</span><span class="s4">:</span>
                        <span class="s0"># the dimension for this variable depends on a</span>
                        <span class="s0"># previously defined parameter</span>
                        <span class="s1">d </span><span class="s4">= </span><span class="s1">param_parse</span><span class="s4">(</span><span class="s1">d</span><span class="s4">, </span><span class="s1">params</span><span class="s4">)</span>
                    <span class="s3">except </span><span class="s4">(</span><span class="s1">ValueError</span><span class="s4">, </span><span class="s1">IndexError</span><span class="s4">, </span><span class="s1">KeyError</span><span class="s4">):</span>
                        <span class="s1">outmess</span><span class="s4">(</span>
                            <span class="s6">'analyzevars: could not parse dimension for '</span>
                            <span class="s6">f'variable </span><span class="s3">{</span><span class="s1">d</span><span class="s3">!r}\n</span><span class="s6">'</span>
                        <span class="s4">)</span>

                    <span class="s1">dim_char </span><span class="s4">= </span><span class="s6">':' </span><span class="s3">if </span><span class="s1">d </span><span class="s4">== </span><span class="s6">':' </span><span class="s3">else </span><span class="s6">'*'</span>
                    <span class="s3">if </span><span class="s1">d </span><span class="s4">== </span><span class="s1">dim_char</span><span class="s4">:</span>
                        <span class="s1">dl </span><span class="s4">= [</span><span class="s1">dim_char</span><span class="s4">]</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">dl </span><span class="s4">= </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">d</span><span class="s4">, </span><span class="s6">':'</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@:@'</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">dl</span><span class="s4">) == </span><span class="s5">2 </span><span class="s3">and </span><span class="s6">'*' </span><span class="s3">in </span><span class="s1">dl</span><span class="s4">:  </span><span class="s0"># e.g. dimension(5:*)</span>
                        <span class="s1">dl </span><span class="s4">= [</span><span class="s6">'*'</span><span class="s4">]</span>
                        <span class="s1">d </span><span class="s4">= </span><span class="s6">'*'</span>
                    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">dl</span><span class="s4">) == </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">dl</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] != </span><span class="s1">dim_char</span><span class="s4">:</span>
                        <span class="s1">dl </span><span class="s4">= [</span><span class="s6">'1'</span><span class="s4">, </span><span class="s1">dl</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]]</span>
                    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">dl</span><span class="s4">) == </span><span class="s5">2</span><span class="s4">:</span>
                        <span class="s1">d1</span><span class="s4">, </span><span class="s1">d2 </span><span class="s4">= </span><span class="s1">map</span><span class="s4">(</span><span class="s1">symbolic</span><span class="s4">.</span><span class="s1">Expr</span><span class="s4">.</span><span class="s1">parse</span><span class="s4">, </span><span class="s1">dl</span><span class="s4">)</span>
                        <span class="s1">dsize </span><span class="s4">= </span><span class="s1">d2 </span><span class="s4">- </span><span class="s1">d1 </span><span class="s4">+ </span><span class="s5">1</span>
                        <span class="s1">d </span><span class="s4">= </span><span class="s1">dsize</span><span class="s4">.</span><span class="s1">tostring</span><span class="s4">(</span><span class="s1">language</span><span class="s4">=</span><span class="s1">symbolic</span><span class="s4">.</span><span class="s1">Language</span><span class="s4">.</span><span class="s1">C</span><span class="s4">)</span>
                        <span class="s0"># find variables v that define d as a linear</span>
                        <span class="s0"># function, `d == a * v + b`, and store</span>
                        <span class="s0"># coefficients a and b for further analysis.</span>
                        <span class="s1">solver_and_deps </span><span class="s4">= {}</span>
                        <span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">]:</span>
                            <span class="s1">s </span><span class="s4">= </span><span class="s1">symbolic</span><span class="s4">.</span><span class="s1">as_symbol</span><span class="s4">(</span><span class="s1">v</span><span class="s4">)</span>
                            <span class="s3">if </span><span class="s1">dsize</span><span class="s4">.</span><span class="s1">contains</span><span class="s4">(</span><span class="s1">s</span><span class="s4">):</span>
                                <span class="s3">try</span><span class="s4">:</span>
                                    <span class="s1">a</span><span class="s4">, </span><span class="s1">b </span><span class="s4">= </span><span class="s1">dsize</span><span class="s4">.</span><span class="s1">linear_solve</span><span class="s4">(</span><span class="s1">s</span><span class="s4">)</span>

                                    <span class="s3">def </span><span class="s1">solve_v</span><span class="s4">(</span><span class="s1">s</span><span class="s4">, </span><span class="s1">a</span><span class="s4">=</span><span class="s1">a</span><span class="s4">, </span><span class="s1">b</span><span class="s4">=</span><span class="s1">b</span><span class="s4">):</span>
                                        <span class="s3">return </span><span class="s4">(</span><span class="s1">s </span><span class="s4">- </span><span class="s1">b</span><span class="s4">) / </span><span class="s1">a</span>

                                    <span class="s1">all_symbols </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">a</span><span class="s4">.</span><span class="s1">symbols</span><span class="s4">())</span>
                                    <span class="s1">all_symbols</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">b</span><span class="s4">.</span><span class="s1">symbols</span><span class="s4">())</span>
                                <span class="s3">except </span><span class="s1">RuntimeError </span><span class="s3">as </span><span class="s1">msg</span><span class="s4">:</span>
                                    <span class="s0"># d is not a linear function of v,</span>
                                    <span class="s0"># however, if v can be determined</span>
                                    <span class="s0"># from d using other means,</span>
                                    <span class="s0"># implement the corresponding</span>
                                    <span class="s0"># solve_v function here.</span>
                                    <span class="s1">solve_v </span><span class="s4">= </span><span class="s3">None</span>
                                    <span class="s1">all_symbols </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">dsize</span><span class="s4">.</span><span class="s1">symbols</span><span class="s4">())</span>
                                <span class="s1">v_deps </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span>
                                    <span class="s1">s</span><span class="s4">.</span><span class="s1">data </span><span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">all_symbols</span>
                                    <span class="s3">if </span><span class="s1">s</span><span class="s4">.</span><span class="s1">data </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">)</span>
                                <span class="s1">solver_and_deps</span><span class="s4">[</span><span class="s1">v</span><span class="s4">] = </span><span class="s1">solve_v</span><span class="s4">, </span><span class="s1">list</span><span class="s4">(</span><span class="s1">v_deps</span><span class="s4">)</span>
                        <span class="s0"># Note that dsize may contain symbols that are</span>
                        <span class="s0"># not defined in block['vars']. Here we assume</span>
                        <span class="s0"># these correspond to Fortran/C intrinsic</span>
                        <span class="s0"># functions or that are defined by other</span>
                        <span class="s0"># means. We'll let the compiler validate the</span>
                        <span class="s0"># definiteness of such symbols.</span>
                        <span class="s1">dimension_exprs</span><span class="s4">[</span><span class="s1">d</span><span class="s4">] = </span><span class="s1">solver_and_deps</span>
                    <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'dimension'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">d</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s6">'check' </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">] </span><span class="s3">and </span><span class="s6">'args' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and </span><span class="s1">n </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'args'</span><span class="s4">]:</span>
            <span class="s0"># n is an argument that has no checks defined. Here we</span>
            <span class="s0"># generate some consistency checks for n, and when n is an</span>
            <span class="s0"># array, generate checks for its dimensions and construct</span>
            <span class="s0"># initialization expressions.</span>
            <span class="s1">n_deps </span><span class="s4">= </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">].</span><span class="s1">get</span><span class="s4">(</span><span class="s6">'depend'</span><span class="s4">, [])</span>
            <span class="s1">n_checks </span><span class="s4">= []</span>
            <span class="s1">n_is_input </span><span class="s4">= </span><span class="s1">l_or</span><span class="s4">(</span><span class="s1">isintent_in</span><span class="s4">, </span><span class="s1">isintent_inout</span><span class="s4">,</span>
                              <span class="s1">isintent_inplace</span><span class="s4">)(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">])</span>
            <span class="s3">if </span><span class="s1">isarray</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]):  </span><span class="s0"># n is array</span>
                <span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">d </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'dimension'</span><span class="s4">]):</span>
                    <span class="s1">coeffs_and_deps </span><span class="s4">= </span><span class="s1">dimension_exprs</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">d</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">coeffs_and_deps </span><span class="s3">is None</span><span class="s4">:</span>
                        <span class="s0"># d is `:` or `*` or a constant expression</span>
                        <span class="s3">pass</span>
                    <span class="s3">elif </span><span class="s1">n_is_input</span><span class="s4">:</span>
                        <span class="s0"># n is an input array argument and its shape</span>
                        <span class="s0"># may define variables used in dimension</span>
                        <span class="s0"># specifications.</span>
                        <span class="s3">for </span><span class="s1">v</span><span class="s4">, (</span><span class="s1">solver</span><span class="s4">, </span><span class="s1">deps</span><span class="s4">) </span><span class="s3">in </span><span class="s1">coeffs_and_deps</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
                            <span class="s3">def </span><span class="s1">compute_deps</span><span class="s4">(</span><span class="s1">v</span><span class="s4">, </span><span class="s1">deps</span><span class="s4">):</span>
                                <span class="s3">for </span><span class="s1">v1 </span><span class="s3">in </span><span class="s1">coeffs_and_deps</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">v</span><span class="s4">, [</span><span class="s3">None</span><span class="s4">, []])[</span><span class="s5">1</span><span class="s4">]:</span>
                                    <span class="s3">if </span><span class="s1">v1 </span><span class="s3">not in </span><span class="s1">deps</span><span class="s4">:</span>
                                        <span class="s1">deps</span><span class="s4">.</span><span class="s1">add</span><span class="s4">(</span><span class="s1">v1</span><span class="s4">)</span>
                                        <span class="s1">compute_deps</span><span class="s4">(</span><span class="s1">v1</span><span class="s4">, </span><span class="s1">deps</span><span class="s4">)</span>
                            <span class="s1">all_deps </span><span class="s4">= </span><span class="s1">set</span><span class="s4">()</span>
                            <span class="s1">compute_deps</span><span class="s4">(</span><span class="s1">v</span><span class="s4">, </span><span class="s1">all_deps</span><span class="s4">)</span>
                            <span class="s3">if </span><span class="s4">(</span><span class="s1">v </span><span class="s3">in </span><span class="s1">n_deps</span>
                                 <span class="s3">or </span><span class="s6">'=' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">]</span>
                                 <span class="s3">or </span><span class="s6">'depend' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">]):</span>
                                <span class="s0"># Skip a variable that</span>
                                <span class="s0"># - n depends on</span>
                                <span class="s0"># - has user-defined initialization expression</span>
                                <span class="s0"># - has user-defined dependencies</span>
                                <span class="s3">continue</span>
                            <span class="s3">if </span><span class="s1">solver </span><span class="s3">is not None and </span><span class="s1">v </span><span class="s3">not in </span><span class="s1">all_deps</span><span class="s4">:</span>
                                <span class="s0"># v can be solved from d, hence, we</span>
                                <span class="s0"># make it an optional argument with</span>
                                <span class="s0"># initialization expression:</span>
                                <span class="s1">is_required </span><span class="s4">= </span><span class="s3">False</span>
                                <span class="s1">init </span><span class="s4">= </span><span class="s1">solver</span><span class="s4">(</span><span class="s1">symbolic</span><span class="s4">.</span><span class="s1">as_symbol</span><span class="s4">(</span>
                                    <span class="s6">f'shape(</span><span class="s3">{</span><span class="s1">n</span><span class="s3">}</span><span class="s6">, </span><span class="s3">{</span><span class="s1">i</span><span class="s3">}</span><span class="s6">)'</span><span class="s4">))</span>
                                <span class="s1">init </span><span class="s4">= </span><span class="s1">init</span><span class="s4">.</span><span class="s1">tostring</span><span class="s4">(</span>
                                    <span class="s1">language</span><span class="s4">=</span><span class="s1">symbolic</span><span class="s4">.</span><span class="s1">Language</span><span class="s4">.</span><span class="s1">C</span><span class="s4">)</span>
                                <span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">][</span><span class="s6">'='</span><span class="s4">] = </span><span class="s1">init</span>
                                <span class="s0"># n needs to be initialized before v. So,</span>
                                <span class="s0"># making v dependent on n and on any</span>
                                <span class="s0"># variables in solver or d.</span>
                                <span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">][</span><span class="s6">'depend'</span><span class="s4">] = [</span><span class="s1">n</span><span class="s4">] + </span><span class="s1">deps</span>
                                <span class="s3">if </span><span class="s6">'check' </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">]:</span>
                                    <span class="s0"># add check only when no</span>
                                    <span class="s0"># user-specified checks exist</span>
                                    <span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">][</span><span class="s6">'check'</span><span class="s4">] = [</span>
                                        <span class="s6">f'shape(</span><span class="s3">{</span><span class="s1">n</span><span class="s3">}</span><span class="s6">, </span><span class="s3">{</span><span class="s1">i</span><span class="s3">}</span><span class="s6">) == </span><span class="s3">{</span><span class="s1">d</span><span class="s3">}</span><span class="s6">'</span><span class="s4">]</span>
                            <span class="s3">else</span><span class="s4">:</span>
                                <span class="s0"># d is a non-linear function on v,</span>
                                <span class="s0"># hence, v must be a required input</span>
                                <span class="s0"># argument that n will depend on</span>
                                <span class="s1">is_required </span><span class="s4">= </span><span class="s3">True</span>
                                <span class="s3">if </span><span class="s6">'intent' </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">]:</span>
                                    <span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">][</span><span class="s6">'intent'</span><span class="s4">] = []</span>
                                <span class="s3">if </span><span class="s6">'in' </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">][</span><span class="s6">'intent'</span><span class="s4">]:</span>
                                    <span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">][</span><span class="s6">'intent'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s6">'in'</span><span class="s4">)</span>
                                <span class="s0"># v needs to be initialized before n</span>
                                <span class="s1">n_deps</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">v</span><span class="s4">)</span>
                                <span class="s1">n_checks</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span>
                                    <span class="s6">f'shape(</span><span class="s3">{</span><span class="s1">n</span><span class="s3">}</span><span class="s6">, </span><span class="s3">{</span><span class="s1">i</span><span class="s3">}</span><span class="s6">) == </span><span class="s3">{</span><span class="s1">d</span><span class="s3">}</span><span class="s6">'</span><span class="s4">)</span>
                            <span class="s1">v_attr </span><span class="s4">= </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">].</span><span class="s1">get</span><span class="s4">(</span><span class="s6">'attrspec'</span><span class="s4">, [])</span>
                            <span class="s3">if not </span><span class="s4">(</span><span class="s6">'optional' </span><span class="s3">in </span><span class="s1">v_attr</span>
                                    <span class="s3">or </span><span class="s6">'required' </span><span class="s3">in </span><span class="s1">v_attr</span><span class="s4">):</span>
                                <span class="s1">v_attr</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span>
                                    <span class="s6">'required' </span><span class="s3">if </span><span class="s1">is_required </span><span class="s3">else </span><span class="s6">'optional'</span><span class="s4">)</span>
                            <span class="s3">if </span><span class="s1">v_attr</span><span class="s4">:</span>
                                <span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">] = </span><span class="s1">v_attr</span>
                    <span class="s3">if </span><span class="s1">coeffs_and_deps </span><span class="s3">is not None</span><span class="s4">:</span>
                        <span class="s0"># extend v dependencies with ones specified in attrspec</span>
                        <span class="s3">for </span><span class="s1">v</span><span class="s4">, (</span><span class="s1">solver</span><span class="s4">, </span><span class="s1">deps</span><span class="s4">) </span><span class="s3">in </span><span class="s1">coeffs_and_deps</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
                            <span class="s1">v_deps </span><span class="s4">= </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">].</span><span class="s1">get</span><span class="s4">(</span><span class="s6">'depend'</span><span class="s4">, [])</span>
                            <span class="s3">for </span><span class="s1">aa </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">].</span><span class="s1">get</span><span class="s4">(</span><span class="s6">'attrspec'</span><span class="s4">, []):</span>
                                <span class="s3">if </span><span class="s1">aa</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s6">'depend'</span><span class="s4">):</span>
                                    <span class="s1">aa </span><span class="s4">= </span><span class="s6">''</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">aa</span><span class="s4">.</span><span class="s1">split</span><span class="s4">())</span>
                                    <span class="s1">v_deps</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">aa</span><span class="s4">[</span><span class="s5">7</span><span class="s4">:-</span><span class="s5">1</span><span class="s4">].</span><span class="s1">split</span><span class="s4">(</span><span class="s6">','</span><span class="s4">))</span>
                            <span class="s3">if </span><span class="s1">v_deps</span><span class="s4">:</span>
                                <span class="s1">vars</span><span class="s4">[</span><span class="s1">v</span><span class="s4">][</span><span class="s6">'depend'</span><span class="s4">] = </span><span class="s1">list</span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s1">v_deps</span><span class="s4">))</span>
                            <span class="s3">if </span><span class="s1">n </span><span class="s3">not in </span><span class="s1">v_deps</span><span class="s4">:</span>
                                <span class="s1">n_deps</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">v</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">isstring</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]):</span>
                <span class="s3">if </span><span class="s6">'charselector' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]:</span>
                    <span class="s3">if </span><span class="s6">'*' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'charselector'</span><span class="s4">]:</span>
                        <span class="s1">length </span><span class="s4">= </span><span class="s1">_eval_length</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'charselector'</span><span class="s4">][</span><span class="s6">'*'</span><span class="s4">],</span>
                                              <span class="s1">params</span><span class="s4">)</span>
                        <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'charselector'</span><span class="s4">][</span><span class="s6">'*'</span><span class="s4">] = </span><span class="s1">length</span>
                    <span class="s3">elif </span><span class="s6">'len' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'charselector'</span><span class="s4">]:</span>
                        <span class="s1">length </span><span class="s4">= </span><span class="s1">_eval_length</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'charselector'</span><span class="s4">][</span><span class="s6">'len'</span><span class="s4">],</span>
                                              <span class="s1">params</span><span class="s4">)</span>
                        <span class="s3">del </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'charselector'</span><span class="s4">][</span><span class="s6">'len'</span><span class="s4">]</span>
                        <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'charselector'</span><span class="s4">][</span><span class="s6">'*'</span><span class="s4">] = </span><span class="s1">length</span>
            <span class="s3">if </span><span class="s1">n_checks</span><span class="s4">:</span>
                <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'check'</span><span class="s4">] = </span><span class="s1">n_checks</span>
            <span class="s3">if </span><span class="s1">n_deps</span><span class="s4">:</span>
                <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'depend'</span><span class="s4">] = </span><span class="s1">list</span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s1">n_deps</span><span class="s4">))</span>

        <span class="s3">if </span><span class="s6">'=' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]:</span>
            <span class="s3">if </span><span class="s6">'attrspec' </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]:</span>
                <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">] = []</span>
            <span class="s3">if </span><span class="s4">(</span><span class="s6">'optional' </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">]) </span><span class="s3">and </span><span class="s1">\</span>
               <span class="s4">(</span><span class="s6">'required' </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">]):</span>
                <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s6">'optional'</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s6">'depend' </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]:</span>
                <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'depend'</span><span class="s4">] = []</span>
                <span class="s3">for </span><span class="s1">v</span><span class="s4">, </span><span class="s1">m </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">dep_matches</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()):</span>
                    <span class="s3">if </span><span class="s1">m</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'='</span><span class="s4">]):</span>
                        <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'depend'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">v</span><span class="s4">)</span>
                <span class="s3">if not </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'depend'</span><span class="s4">]:</span>
                    <span class="s3">del </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'depend'</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">isscalar</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]):</span>
                <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'='</span><span class="s4">] = </span><span class="s1">_eval_scalar</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'='</span><span class="s4">], </span><span class="s1">params</span><span class="s4">)</span>

    <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
        <span class="s3">if </span><span class="s1">n </span><span class="s4">== </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">]:  </span><span class="s0"># n is block name</span>
            <span class="s3">if </span><span class="s6">'note' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]:</span>
                <span class="s1">block</span><span class="s4">[</span><span class="s6">'note'</span><span class="s4">] = </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'note'</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'block'</span><span class="s4">] == </span><span class="s6">'function'</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s6">'result' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'result'</span><span class="s4">] </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">:</span>
                    <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">] = </span><span class="s1">appenddecl</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">], </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'result'</span><span class="s4">]])</span>
                <span class="s3">if </span><span class="s6">'prefix' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
                    <span class="s1">pr </span><span class="s4">= </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'prefix'</span><span class="s4">]</span>
                    <span class="s1">pr1 </span><span class="s4">= </span><span class="s1">pr</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s6">'pure'</span><span class="s4">, </span><span class="s6">''</span><span class="s4">)</span>
                    <span class="s1">ispure </span><span class="s4">= (</span><span class="s3">not </span><span class="s1">pr </span><span class="s4">== </span><span class="s1">pr1</span><span class="s4">)</span>
                    <span class="s1">pr </span><span class="s4">= </span><span class="s1">pr1</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s6">'recursive'</span><span class="s4">, </span><span class="s6">''</span><span class="s4">)</span>
                    <span class="s1">isrec </span><span class="s4">= (</span><span class="s3">not </span><span class="s1">pr </span><span class="s4">== </span><span class="s1">pr1</span><span class="s4">)</span>
                    <span class="s1">m </span><span class="s4">= </span><span class="s1">typespattern</span><span class="s4">[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">match</span><span class="s4">(</span><span class="s1">pr</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">m</span><span class="s4">:</span>
                        <span class="s1">typespec</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">, </span><span class="s1">edecl </span><span class="s4">= </span><span class="s1">cracktypespec0</span><span class="s4">(</span>
                            <span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'this'</span><span class="s4">), </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">))</span>
                        <span class="s1">kindselect</span><span class="s4">, </span><span class="s1">charselect</span><span class="s4">, </span><span class="s1">typename </span><span class="s4">= </span><span class="s1">cracktypespec</span><span class="s4">(</span>
                            <span class="s1">typespec</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">)</span>
                        <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'typespec'</span><span class="s4">] = </span><span class="s1">typespec</span>
                        <span class="s3">try</span><span class="s4">:</span>
                            <span class="s3">if </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'result'</span><span class="s4">]:</span>
                                <span class="s1">vars</span><span class="s4">[</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'result'</span><span class="s4">]][</span><span class="s6">'typespec'</span><span class="s4">] = </span><span class="s1">typespec</span>
                        <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
                            <span class="s3">pass</span>
                        <span class="s3">if </span><span class="s1">kindselect</span><span class="s4">:</span>
                            <span class="s3">if </span><span class="s6">'kind' </span><span class="s3">in </span><span class="s1">kindselect</span><span class="s4">:</span>
                                <span class="s3">try</span><span class="s4">:</span>
                                    <span class="s1">kindselect</span><span class="s4">[</span><span class="s6">'kind'</span><span class="s4">] = </span><span class="s1">eval</span><span class="s4">(</span>
                                        <span class="s1">kindselect</span><span class="s4">[</span><span class="s6">'kind'</span><span class="s4">], {}, </span><span class="s1">params</span><span class="s4">)</span>
                                <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
                                    <span class="s3">pass</span>
                            <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'kindselector'</span><span class="s4">] = </span><span class="s1">kindselect</span>
                        <span class="s3">if </span><span class="s1">charselect</span><span class="s4">:</span>
                            <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'charselector'</span><span class="s4">] = </span><span class="s1">charselect</span>
                        <span class="s3">if </span><span class="s1">typename</span><span class="s4">:</span>
                            <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">][</span><span class="s6">'typename'</span><span class="s4">] = </span><span class="s1">typename</span>
                        <span class="s3">if </span><span class="s1">ispure</span><span class="s4">:</span>
                            <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">] = </span><span class="s1">setattrspec</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">], </span><span class="s6">'pure'</span><span class="s4">)</span>
                        <span class="s3">if </span><span class="s1">isrec</span><span class="s4">:</span>
                            <span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">] = </span><span class="s1">setattrspec</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">], </span><span class="s6">'recursive'</span><span class="s4">)</span>
                    <span class="s3">else</span><span class="s4">:</span>
                        <span class="s1">outmess</span><span class="s4">(</span>
                            <span class="s6">'analyzevars: prefix (%s) were not used</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'prefix'</span><span class="s4">]))</span>
    <span class="s3">if not </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'block'</span><span class="s4">] </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'module'</span><span class="s4">, </span><span class="s6">'pythonmodule'</span><span class="s4">, </span><span class="s6">'python module'</span><span class="s4">, </span><span class="s6">'block data'</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s6">'commonvars' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
            <span class="s1">neededvars </span><span class="s4">= </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'args'</span><span class="s4">] + </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'commonvars'</span><span class="s4">])</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">neededvars </span><span class="s4">= </span><span class="s1">copy</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'args'</span><span class="s4">])</span>
        <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
            <span class="s3">if </span><span class="s1">l_or</span><span class="s4">(</span><span class="s1">isintent_callback</span><span class="s4">, </span><span class="s1">isintent_aux</span><span class="s4">)(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]):</span>
                <span class="s1">neededvars</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s6">'entry' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
            <span class="s1">neededvars</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">list</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'entry'</span><span class="s4">].</span><span class="s1">keys</span><span class="s4">()))</span>
            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'entry'</span><span class="s4">].</span><span class="s1">keys</span><span class="s4">()):</span>
                <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'entry'</span><span class="s4">][</span><span class="s1">k</span><span class="s4">]:</span>
                    <span class="s3">if </span><span class="s1">n </span><span class="s3">not in </span><span class="s1">neededvars</span><span class="s4">:</span>
                        <span class="s1">neededvars</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'block'</span><span class="s4">] == </span><span class="s6">'function'</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s6">'result' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
                <span class="s1">neededvars</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'result'</span><span class="s4">])</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">neededvars</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">])</span>
        <span class="s3">if </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'block'</span><span class="s4">] </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'subroutine'</span><span class="s4">, </span><span class="s6">'function'</span><span class="s4">]:</span>
            <span class="s1">name </span><span class="s4">= </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">in </span><span class="s1">vars </span><span class="s3">and </span><span class="s6">'intent' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">name</span><span class="s4">]:</span>
                <span class="s1">block</span><span class="s4">[</span><span class="s6">'intent'</span><span class="s4">] = </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">name</span><span class="s4">][</span><span class="s6">'intent'</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'block'</span><span class="s4">] == </span><span class="s6">'type'</span><span class="s4">:</span>
            <span class="s1">neededvars</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">list</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()))</span>
        <span class="s3">for </span><span class="s1">n </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
            <span class="s3">if </span><span class="s1">n </span><span class="s3">not in </span><span class="s1">neededvars</span><span class="s4">:</span>
                <span class="s3">del </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">vars</span>


<span class="s1">analyzeargs_re_1 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'\A[a-z]+[\w$]*\Z'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">param_eval</span><span class="s4">(</span><span class="s1">v</span><span class="s4">, </span><span class="s1">g_params</span><span class="s4">, </span><span class="s1">params</span><span class="s4">, </span><span class="s1">dimspec</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Creates a dictionary of indices and values for each parameter in a 
    parameter array to be evaluated later. 
 
    WARNING: It is not possible to initialize multidimensional array 
    parameters e.g. dimension(-3:1, 4, 3:5) at this point. This is because in 
    Fortran initialization through array constructor requires the RESHAPE 
    intrinsic function. Since the right-hand side of the parameter declaration 
    is not executed in f2py, but rather at the compiled c/fortran extension, 
    later, it is not possible to execute a reshape of a parameter array. 
    One issue remains: if the user wants to access the array parameter from 
    python, we should either 
    1) allow them to access the parameter array using python standard indexing 
       (which is often incompatible with the original fortran indexing) 
    2) allow the parameter array to be accessed in python as a dictionary with 
       fortran indices as keys 
    We are choosing 2 for now. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">dimspec </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">p </span><span class="s4">= </span><span class="s1">eval</span><span class="s4">(</span><span class="s1">v</span><span class="s4">, </span><span class="s1">g_params</span><span class="s4">, </span><span class="s1">params</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">msg</span><span class="s4">:</span>
            <span class="s1">p </span><span class="s4">= </span><span class="s1">v</span>
            <span class="s1">outmess</span><span class="s4">(</span><span class="s6">f'param_eval: got &quot;</span><span class="s3">{</span><span class="s1">msg</span><span class="s3">}</span><span class="s6">&quot; on </span><span class="s3">{</span><span class="s1">v</span><span class="s3">!r}\n</span><span class="s6">'</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">p</span>

    <span class="s0"># This is an array parameter.</span>
    <span class="s0"># First, we parse the dimension information</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">dimspec</span><span class="s4">) &lt; </span><span class="s5">2 </span><span class="s3">or </span><span class="s1">dimspec</span><span class="s4">[::</span><span class="s1">len</span><span class="s4">(</span><span class="s1">dimspec</span><span class="s4">)-</span><span class="s5">1</span><span class="s4">] != </span><span class="s6">&quot;()&quot;</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s6">f'param_eval: dimension </span><span class="s3">{</span><span class="s1">dimspec</span><span class="s3">} </span><span class="s6">can</span><span class="s3">\'</span><span class="s6">t be parsed'</span><span class="s4">)</span>
    <span class="s1">dimrange </span><span class="s4">= </span><span class="s1">dimspec</span><span class="s4">[</span><span class="s5">1</span><span class="s4">:-</span><span class="s5">1</span><span class="s4">].</span><span class="s1">split</span><span class="s4">(</span><span class="s6">','</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">dimrange</span><span class="s4">) == </span><span class="s5">1</span><span class="s4">:</span>
        <span class="s0"># e.g. dimension(2) or dimension(-1:1)</span>
        <span class="s1">dimrange </span><span class="s4">= </span><span class="s1">dimrange</span><span class="s4">[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">split</span><span class="s4">(</span><span class="s6">':'</span><span class="s4">)</span>
        <span class="s0"># now, dimrange is a list of 1 or 2 elements</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">dimrange</span><span class="s4">) == </span><span class="s5">1</span><span class="s4">:</span>
            <span class="s1">bound </span><span class="s4">= </span><span class="s1">param_parse</span><span class="s4">(</span><span class="s1">dimrange</span><span class="s4">[</span><span class="s5">0</span><span class="s4">], </span><span class="s1">params</span><span class="s4">)</span>
            <span class="s1">dimrange </span><span class="s4">= </span><span class="s1">range</span><span class="s4">(</span><span class="s5">1</span><span class="s4">, </span><span class="s1">int</span><span class="s4">(</span><span class="s1">bound</span><span class="s4">)+</span><span class="s5">1</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">lbound </span><span class="s4">= </span><span class="s1">param_parse</span><span class="s4">(</span><span class="s1">dimrange</span><span class="s4">[</span><span class="s5">0</span><span class="s4">], </span><span class="s1">params</span><span class="s4">)</span>
            <span class="s1">ubound </span><span class="s4">= </span><span class="s1">param_parse</span><span class="s4">(</span><span class="s1">dimrange</span><span class="s4">[</span><span class="s5">1</span><span class="s4">], </span><span class="s1">params</span><span class="s4">)</span>
            <span class="s1">dimrange </span><span class="s4">= </span><span class="s1">range</span><span class="s4">(</span><span class="s1">int</span><span class="s4">(</span><span class="s1">lbound</span><span class="s4">), </span><span class="s1">int</span><span class="s4">(</span><span class="s1">ubound</span><span class="s4">)+</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s6">f'param_eval: multidimensional array parameters '</span>
                         <span class="s6">'{dimspec} not supported'</span><span class="s4">)</span>

    <span class="s0"># Parse parameter value</span>
    <span class="s1">v </span><span class="s4">= (</span><span class="s1">v</span><span class="s4">[</span><span class="s5">2</span><span class="s4">:-</span><span class="s5">2</span><span class="s4">] </span><span class="s3">if </span><span class="s1">v</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s6">'(/'</span><span class="s4">) </span><span class="s3">else </span><span class="s1">v</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">','</span><span class="s4">)</span>
    <span class="s1">v_eval </span><span class="s4">= []</span>
    <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">v</span><span class="s4">:</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">item </span><span class="s4">= </span><span class="s1">eval</span><span class="s4">(</span><span class="s1">item</span><span class="s4">, </span><span class="s1">g_params</span><span class="s4">, </span><span class="s1">params</span><span class="s4">)</span>
        <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">msg</span><span class="s4">:</span>
            <span class="s1">outmess</span><span class="s4">(</span><span class="s6">f'param_eval: got &quot;</span><span class="s3">{</span><span class="s1">msg</span><span class="s3">}</span><span class="s6">&quot; on </span><span class="s3">{</span><span class="s1">item</span><span class="s3">!r}\n</span><span class="s6">'</span><span class="s4">)</span>
        <span class="s1">v_eval</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">item</span><span class="s4">)</span>

    <span class="s1">p </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">zip</span><span class="s4">(</span><span class="s1">dimrange</span><span class="s4">, </span><span class="s1">v_eval</span><span class="s4">))</span>

    <span class="s3">return </span><span class="s1">p</span>


<span class="s3">def </span><span class="s1">param_parse</span><span class="s4">(</span><span class="s1">d</span><span class="s4">, </span><span class="s1">params</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Recursively parse array dimensions. 
 
    Parses the declaration of an array variable or parameter 
    `dimension` keyword, and is called recursively if the 
    dimension for this array is a previously defined parameter 
    (found in `params`). 
 
    Parameters 
    ---------- 
    d : str 
        Fortran expression describing the dimension of an array. 
    params : dict 
        Previously parsed parameters declared in the Fortran source file. 
 
    Returns 
    ------- 
    out : str 
        Parsed dimension expression. 
 
    Examples 
    -------- 
 
    * If the line being analyzed is 
 
      `integer, parameter, dimension(2) :: pa = (/ 3, 5 /)` 
 
      then `d = 2` and we return immediately, with 
 
    &gt;&gt;&gt; d = '2' 
    &gt;&gt;&gt; param_parse(d, params) 
    2 
 
    * If the line being analyzed is 
 
      `integer, parameter, dimension(pa) :: pb = (/1, 2, 3/)` 
 
      then `d = 'pa'`; since `pa` is a previously parsed parameter, 
      and `pa = 3`, we call `param_parse` recursively, to obtain 
 
    &gt;&gt;&gt; d = 'pa' 
    &gt;&gt;&gt; params = {'pa': 3} 
    &gt;&gt;&gt; param_parse(d, params) 
    3 
 
    * If the line being analyzed is 
 
      `integer, parameter, dimension(pa(1)) :: pb = (/1, 2, 3/)` 
 
      then `d = 'pa(1)'`; since `pa` is a previously parsed parameter, 
      and `pa(1) = 3`, we call `param_parse` recursively, to obtain 
 
    &gt;&gt;&gt; d = 'pa(1)' 
    &gt;&gt;&gt; params = dict(pa={1: 3, 2: 5}) 
    &gt;&gt;&gt; param_parse(d, params) 
    3 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s6">&quot;(&quot; </span><span class="s3">in </span><span class="s1">d</span><span class="s4">:</span>
        <span class="s0"># this dimension expression is an array</span>
        <span class="s1">dname </span><span class="s4">= </span><span class="s1">d</span><span class="s4">[:</span><span class="s1">d</span><span class="s4">.</span><span class="s1">find</span><span class="s4">(</span><span class="s6">&quot;(&quot;</span><span class="s4">)]</span>
        <span class="s1">ddims </span><span class="s4">= </span><span class="s1">d</span><span class="s4">[</span><span class="s1">d</span><span class="s4">.</span><span class="s1">find</span><span class="s4">(</span><span class="s6">&quot;(&quot;</span><span class="s4">)+</span><span class="s5">1</span><span class="s4">:</span><span class="s1">d</span><span class="s4">.</span><span class="s1">rfind</span><span class="s4">(</span><span class="s6">&quot;)&quot;</span><span class="s4">)]</span>
        <span class="s0"># this dimension expression is also a parameter;</span>
        <span class="s0"># parse it recursively</span>
        <span class="s1">index </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">param_parse</span><span class="s4">(</span><span class="s1">ddims</span><span class="s4">, </span><span class="s1">params</span><span class="s4">))</span>
        <span class="s3">return </span><span class="s1">str</span><span class="s4">(</span><span class="s1">params</span><span class="s4">[</span><span class="s1">dname</span><span class="s4">][</span><span class="s1">index</span><span class="s4">])</span>
    <span class="s3">elif </span><span class="s1">d </span><span class="s3">in </span><span class="s1">params</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">str</span><span class="s4">(</span><span class="s1">params</span><span class="s4">[</span><span class="s1">d</span><span class="s4">])</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">params</span><span class="s4">:</span>
            <span class="s1">re_1 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
                <span class="s6">r'(?P&lt;before&gt;.*?)\b' </span><span class="s4">+ </span><span class="s1">p </span><span class="s4">+ </span><span class="s6">r'\b(?P&lt;after&gt;.*)'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span>
            <span class="s4">)</span>
            <span class="s1">m </span><span class="s4">= </span><span class="s1">re_1</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">d</span><span class="s4">)</span>
            <span class="s3">while </span><span class="s1">m</span><span class="s4">:</span>
                <span class="s1">d </span><span class="s4">= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'before'</span><span class="s4">) + </span><span class="s1">\</span>
                    <span class="s1">str</span><span class="s4">(</span><span class="s1">params</span><span class="s4">[</span><span class="s1">p</span><span class="s4">]) + </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'after'</span><span class="s4">)</span>
                <span class="s1">m </span><span class="s4">= </span><span class="s1">re_1</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">d</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">d</span>


<span class="s3">def </span><span class="s1">expr2name</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">block</span><span class="s4">, </span><span class="s1">args</span><span class="s4">=[]):</span>
    <span class="s1">orig_a </span><span class="s4">= </span><span class="s1">a</span>
    <span class="s1">a_is_expr </span><span class="s4">= </span><span class="s3">not </span><span class="s1">analyzeargs_re_1</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">a_is_expr</span><span class="s4">:  </span><span class="s0"># `a` is an expression</span>
        <span class="s1">implicitrules</span><span class="s4">, </span><span class="s1">attrrules </span><span class="s4">= </span><span class="s1">buildimplicitrules</span><span class="s4">(</span><span class="s1">block</span><span class="s4">)</span>
        <span class="s1">at </span><span class="s4">= </span><span class="s1">determineexprtype</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">], </span><span class="s1">implicitrules</span><span class="s4">)</span>
        <span class="s1">na </span><span class="s4">= </span><span class="s6">'e_'</span>
        <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">a</span><span class="s4">:</span>
            <span class="s1">c </span><span class="s4">= </span><span class="s1">c</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">()</span>
            <span class="s3">if </span><span class="s1">c </span><span class="s3">not in </span><span class="s1">string</span><span class="s4">.</span><span class="s1">ascii_lowercase </span><span class="s4">+ </span><span class="s1">string</span><span class="s4">.</span><span class="s1">digits</span><span class="s4">:</span>
                <span class="s1">c </span><span class="s4">= </span><span class="s6">'_'</span>
            <span class="s1">na </span><span class="s4">= </span><span class="s1">na </span><span class="s4">+ </span><span class="s1">c</span>
        <span class="s3">if </span><span class="s1">na</span><span class="s4">[-</span><span class="s5">1</span><span class="s4">] == </span><span class="s6">'_'</span><span class="s4">:</span>
            <span class="s1">na </span><span class="s4">= </span><span class="s1">na </span><span class="s4">+ </span><span class="s6">'e'</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">na </span><span class="s4">= </span><span class="s1">na </span><span class="s4">+ </span><span class="s6">'_e'</span>
        <span class="s1">a </span><span class="s4">= </span><span class="s1">na</span>
        <span class="s3">while </span><span class="s1">a </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">] </span><span class="s3">or </span><span class="s1">a </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'args'</span><span class="s4">]:</span>
            <span class="s1">a </span><span class="s4">= </span><span class="s1">a </span><span class="s4">+ </span><span class="s6">'r'</span>
    <span class="s3">if </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args</span><span class="s4">:</span>
        <span class="s1">k </span><span class="s4">= </span><span class="s5">1</span>
        <span class="s3">while </span><span class="s1">a </span><span class="s4">+ </span><span class="s1">str</span><span class="s4">(</span><span class="s1">k</span><span class="s4">) </span><span class="s3">in </span><span class="s1">args</span><span class="s4">:</span>
            <span class="s1">k </span><span class="s4">= </span><span class="s1">k </span><span class="s4">+ </span><span class="s5">1</span>
        <span class="s1">a </span><span class="s4">= </span><span class="s1">a </span><span class="s4">+ </span><span class="s1">str</span><span class="s4">(</span><span class="s1">k</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">a_is_expr</span><span class="s4">:</span>
        <span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">a</span><span class="s4">] = </span><span class="s1">at</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">a </span><span class="s3">not in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">]:</span>
            <span class="s3">if </span><span class="s1">orig_a </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">]:</span>
                <span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">a</span><span class="s4">] = </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">orig_a</span><span class="s4">]</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">a</span><span class="s4">] = {}</span>
        <span class="s3">if </span><span class="s6">'externals' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and </span><span class="s1">orig_a </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'externals'</span><span class="s4">] + </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'interfaced'</span><span class="s4">]:</span>
            <span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">a</span><span class="s4">] = </span><span class="s1">setattrspec</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">a</span><span class="s4">], </span><span class="s6">'external'</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">a</span>


<span class="s3">def </span><span class="s1">analyzeargs</span><span class="s4">(</span><span class="s1">block</span><span class="s4">):</span>
    <span class="s1">setmesstext</span><span class="s4">(</span><span class="s1">block</span><span class="s4">)</span>
    <span class="s1">implicitrules</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">buildimplicitrules</span><span class="s4">(</span><span class="s1">block</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s6">'args' </span><span class="s3">not in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s1">block</span><span class="s4">[</span><span class="s6">'args'</span><span class="s4">] = []</span>
    <span class="s1">args </span><span class="s4">= []</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'args'</span><span class="s4">]:</span>
        <span class="s1">a </span><span class="s4">= </span><span class="s1">expr2name</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">block</span><span class="s4">, </span><span class="s1">args</span><span class="s4">)</span>
        <span class="s1">args</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
    <span class="s1">block</span><span class="s4">[</span><span class="s6">'args'</span><span class="s4">] = </span><span class="s1">args</span>
    <span class="s3">if </span><span class="s6">'entry' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">args1 </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'entry'</span><span class="s4">].</span><span class="s1">items</span><span class="s4">()):</span>
            <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args1</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">a </span><span class="s3">not in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">]:</span>
                    <span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">a</span><span class="s4">] = {}</span>

    <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'body'</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">] </span><span class="s3">in </span><span class="s1">args</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s6">'externals' </span><span class="s3">not in </span><span class="s1">block</span><span class="s4">:</span>
                <span class="s1">block</span><span class="s4">[</span><span class="s6">'externals'</span><span class="s4">] = []</span>
            <span class="s3">if </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">] </span><span class="s3">not in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'externals'</span><span class="s4">]:</span>
                <span class="s1">block</span><span class="s4">[</span><span class="s6">'externals'</span><span class="s4">].</span><span class="s1">append</span><span class="s4">(</span><span class="s1">b</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">])</span>
    <span class="s3">if </span><span class="s6">'result' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'result'</span><span class="s4">] </span><span class="s3">not in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">]:</span>
        <span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">][</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'result'</span><span class="s4">]] = {}</span>
    <span class="s3">return </span><span class="s1">block</span>

<span class="s1">determineexprtype_re_1 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'\A\(.+?,.+?\)\Z'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
<span class="s1">determineexprtype_re_2 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'\A[+-]?\d+(_(?P&lt;name&gt;\w+)|)\Z'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
<span class="s1">determineexprtype_re_3 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span>
    <span class="s6">r'\A[+-]?[\d.]+[-\d+de.]*(_(?P&lt;name&gt;\w+)|)\Z'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
<span class="s1">determineexprtype_re_4 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'\A\(.*\)\Z'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>
<span class="s1">determineexprtype_re_5 </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s6">r'\A(?P&lt;name&gt;\w+)\s*\(.*?\)\s*\Z'</span><span class="s4">, </span><span class="s1">re</span><span class="s4">.</span><span class="s1">I</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_ensure_exprdict</span><span class="s4">(</span><span class="s1">r</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">r</span><span class="s4">, </span><span class="s1">int</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">{</span><span class="s6">'typespec'</span><span class="s4">: </span><span class="s6">'integer'</span><span class="s4">}</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">r</span><span class="s4">, </span><span class="s1">float</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">{</span><span class="s6">'typespec'</span><span class="s4">: </span><span class="s6">'real'</span><span class="s4">}</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">r</span><span class="s4">, </span><span class="s1">complex</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">{</span><span class="s6">'typespec'</span><span class="s4">: </span><span class="s6">'complex'</span><span class="s4">}</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">r</span><span class="s4">, </span><span class="s1">dict</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">r</span>
    <span class="s3">raise </span><span class="s1">AssertionError</span><span class="s4">(</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">r</span><span class="s4">))</span>


<span class="s3">def </span><span class="s1">determineexprtype</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">, </span><span class="s1">vars</span><span class="s4">, </span><span class="s1">rules</span><span class="s4">={}):</span>
    <span class="s3">if </span><span class="s1">expr </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">_ensure_exprdict</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">expr</span><span class="s4">])</span>
    <span class="s1">expr </span><span class="s4">= </span><span class="s1">expr</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">()</span>
    <span class="s3">if </span><span class="s1">determineexprtype_re_1</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">{</span><span class="s6">'typespec'</span><span class="s4">: </span><span class="s6">'complex'</span><span class="s4">}</span>
    <span class="s1">m </span><span class="s4">= </span><span class="s1">determineexprtype_re_2</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">m</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s6">'name' </span><span class="s3">in </span><span class="s1">m</span><span class="s4">.</span><span class="s1">groupdict</span><span class="s4">() </span><span class="s3">and </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'name'</span><span class="s4">):</span>
            <span class="s1">outmess</span><span class="s4">(</span>
                <span class="s6">'determineexprtype: selected kind types not supported (%s)</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">))</span>
        <span class="s3">return </span><span class="s4">{</span><span class="s6">'typespec'</span><span class="s4">: </span><span class="s6">'integer'</span><span class="s4">}</span>
    <span class="s1">m </span><span class="s4">= </span><span class="s1">determineexprtype_re_3</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">m</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s6">'name' </span><span class="s3">in </span><span class="s1">m</span><span class="s4">.</span><span class="s1">groupdict</span><span class="s4">() </span><span class="s3">and </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'name'</span><span class="s4">):</span>
            <span class="s1">outmess</span><span class="s4">(</span>
                <span class="s6">'determineexprtype: selected kind types not supported (%s)</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">))</span>
        <span class="s3">return </span><span class="s4">{</span><span class="s6">'typespec'</span><span class="s4">: </span><span class="s6">'real'</span><span class="s4">}</span>
    <span class="s3">for </span><span class="s1">op </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'+'</span><span class="s4">, </span><span class="s6">'-'</span><span class="s4">, </span><span class="s6">'*'</span><span class="s4">, </span><span class="s6">'/'</span><span class="s4">]:</span>
        <span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s4">[</span><span class="s1">x</span><span class="s4">.</span><span class="s1">strip</span><span class="s4">() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">markoutercomma</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">, </span><span class="s1">comma</span><span class="s4">=</span><span class="s1">op</span><span class="s4">).</span><span class="s1">split</span><span class="s4">(</span><span class="s6">'@' </span><span class="s4">+ </span><span class="s1">op </span><span class="s4">+ </span><span class="s6">'@'</span><span class="s4">)]:</span>
            <span class="s3">if </span><span class="s1">e </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">_ensure_exprdict</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">e</span><span class="s4">])</span>
    <span class="s1">t </span><span class="s4">= {}</span>
    <span class="s3">if </span><span class="s1">determineexprtype_re_4</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">):  </span><span class="s0"># in parenthesis</span>
        <span class="s1">t </span><span class="s4">= </span><span class="s1">determineexprtype</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">[</span><span class="s5">1</span><span class="s4">:-</span><span class="s5">1</span><span class="s4">], </span><span class="s1">vars</span><span class="s4">, </span><span class="s1">rules</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">m </span><span class="s4">= </span><span class="s1">determineexprtype_re_5</span><span class="s4">.</span><span class="s1">match</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">m</span><span class="s4">:</span>
            <span class="s1">rn </span><span class="s4">= </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'name'</span><span class="s4">)</span>
            <span class="s1">t </span><span class="s4">= </span><span class="s1">determineexprtype</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s6">'name'</span><span class="s4">), </span><span class="s1">vars</span><span class="s4">, </span><span class="s1">rules</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">t </span><span class="s3">and </span><span class="s6">'attrspec' </span><span class="s3">in </span><span class="s1">t</span><span class="s4">:</span>
                <span class="s3">del </span><span class="s1">t</span><span class="s4">[</span><span class="s6">'attrspec'</span><span class="s4">]</span>
            <span class="s3">if not </span><span class="s1">t</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">rn</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] </span><span class="s3">in </span><span class="s1">rules</span><span class="s4">:</span>
                    <span class="s3">return </span><span class="s1">_ensure_exprdict</span><span class="s4">(</span><span class="s1">rules</span><span class="s4">[</span><span class="s1">rn</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]])</span>
    <span class="s3">if </span><span class="s1">expr</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] </span><span class="s3">in </span><span class="s6">'</span><span class="s3">\'</span><span class="s6">&quot;'</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">{</span><span class="s6">'typespec'</span><span class="s4">: </span><span class="s6">'character'</span><span class="s4">, </span><span class="s6">'charselector'</span><span class="s4">: {</span><span class="s6">'*'</span><span class="s4">: </span><span class="s6">'*'</span><span class="s4">}}</span>
    <span class="s3">if not </span><span class="s1">t</span><span class="s4">:</span>
        <span class="s1">outmess</span><span class="s4">(</span>
            <span class="s6">'determineexprtype: could not determine expressions (%s) type.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">expr</span><span class="s4">)))</span>
    <span class="s3">return </span><span class="s1">t</span>

<span class="s0">######</span>


<span class="s3">def </span><span class="s1">crack2fortrangen</span><span class="s4">(</span><span class="s1">block</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">=</span><span class="s6">'</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">, </span><span class="s1">as_interface</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s3">global </span><span class="s1">skipfuncs</span><span class="s4">, </span><span class="s1">onlyfuncs</span>

    <span class="s1">setmesstext</span><span class="s4">(</span><span class="s1">block</span><span class="s4">)</span>
    <span class="s1">ret </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">block</span><span class="s4">, </span><span class="s1">list</span><span class="s4">):</span>
        <span class="s3">for </span><span class="s1">g </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">g </span><span class="s3">and </span><span class="s1">g</span><span class="s4">[</span><span class="s6">'block'</span><span class="s4">] </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'function'</span><span class="s4">, </span><span class="s6">'subroutine'</span><span class="s4">]:</span>
                <span class="s3">if </span><span class="s1">g</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">] </span><span class="s3">in </span><span class="s1">skipfuncs</span><span class="s4">:</span>
                    <span class="s3">continue</span>
                <span class="s3">if </span><span class="s1">onlyfuncs </span><span class="s3">and </span><span class="s1">g</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">] </span><span class="s3">not in </span><span class="s1">onlyfuncs</span><span class="s4">:</span>
                    <span class="s3">continue</span>
            <span class="s1">ret </span><span class="s4">= </span><span class="s1">ret </span><span class="s4">+ </span><span class="s1">crack2fortrangen</span><span class="s4">(</span><span class="s1">g</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">, </span><span class="s1">as_interface</span><span class="s4">=</span><span class="s1">as_interface</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">ret</span>
    <span class="s1">prefix </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s1">name </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s1">args </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s1">blocktype </span><span class="s4">= </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'block'</span><span class="s4">]</span>
    <span class="s3">if </span><span class="s1">blocktype </span><span class="s4">== </span><span class="s6">'program'</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s6">''</span>
    <span class="s1">argsl </span><span class="s4">= []</span>
    <span class="s3">if </span><span class="s6">'name' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s1">name </span><span class="s4">= </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">]</span>
    <span class="s3">if </span><span class="s6">'args' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s1">vars </span><span class="s4">= </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">]</span>
        <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'args'</span><span class="s4">]:</span>
            <span class="s1">a </span><span class="s4">= </span><span class="s1">expr2name</span><span class="s4">(</span><span class="s1">a</span><span class="s4">, </span><span class="s1">block</span><span class="s4">, </span><span class="s1">argsl</span><span class="s4">)</span>
            <span class="s3">if not </span><span class="s1">isintent_callback</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">]):</span>
                <span class="s1">argsl</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'block'</span><span class="s4">] == </span><span class="s6">'function' </span><span class="s3">or </span><span class="s1">argsl</span><span class="s4">:</span>
            <span class="s1">args </span><span class="s4">= </span><span class="s6">'(%s)' </span><span class="s4">% </span><span class="s6">','</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">argsl</span><span class="s4">)</span>
    <span class="s1">f2pyenhancements </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s3">if </span><span class="s6">'f2pyenhancements' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'f2pyenhancements'</span><span class="s4">].</span><span class="s1">keys</span><span class="s4">()):</span>
            <span class="s1">f2pyenhancements </span><span class="s4">= </span><span class="s6">'%s%s%s %s' </span><span class="s4">% (</span>
                <span class="s1">f2pyenhancements</span><span class="s4">, </span><span class="s1">tab </span><span class="s4">+ </span><span class="s1">tabchar</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'f2pyenhancements'</span><span class="s4">][</span><span class="s1">k</span><span class="s4">])</span>
    <span class="s1">intent_lst </span><span class="s4">= </span><span class="s1">block</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s6">'intent'</span><span class="s4">, [])[:]</span>
    <span class="s3">if </span><span class="s1">blocktype </span><span class="s4">== </span><span class="s6">'function' </span><span class="s3">and </span><span class="s6">'callback' </span><span class="s3">in </span><span class="s1">intent_lst</span><span class="s4">:</span>
        <span class="s1">intent_lst</span><span class="s4">.</span><span class="s1">remove</span><span class="s4">(</span><span class="s6">'callback'</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">intent_lst</span><span class="s4">:</span>
        <span class="s1">f2pyenhancements </span><span class="s4">= </span><span class="s6">'%s%sintent(%s) %s' </span><span class="s4">%</span><span class="s1">\</span>
                           <span class="s4">(</span><span class="s1">f2pyenhancements</span><span class="s4">, </span><span class="s1">tab </span><span class="s4">+ </span><span class="s1">tabchar</span><span class="s4">,</span>
                            <span class="s6">','</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">intent_lst</span><span class="s4">), </span><span class="s1">name</span><span class="s4">)</span>
    <span class="s1">use </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s3">if </span><span class="s6">'use' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s1">use </span><span class="s4">= </span><span class="s1">use2fortran</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'use'</span><span class="s4">], </span><span class="s1">tab </span><span class="s4">+ </span><span class="s1">tabchar</span><span class="s4">)</span>
    <span class="s1">common </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s3">if </span><span class="s6">'common' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s1">common </span><span class="s4">= </span><span class="s1">common2fortran</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'common'</span><span class="s4">], </span><span class="s1">tab </span><span class="s4">+ </span><span class="s1">tabchar</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">name </span><span class="s4">== </span><span class="s6">'unknown_interface'</span><span class="s4">:</span>
        <span class="s1">name </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s1">result </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s3">if </span><span class="s6">'result' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s6">' result (%s)' </span><span class="s4">% </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'result'</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'result'</span><span class="s4">] </span><span class="s3">not in </span><span class="s1">argsl</span><span class="s4">:</span>
            <span class="s1">argsl</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'result'</span><span class="s4">])</span>
    <span class="s1">body </span><span class="s4">= </span><span class="s1">crack2fortrangen</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'body'</span><span class="s4">], </span><span class="s1">tab </span><span class="s4">+ </span><span class="s1">tabchar</span><span class="s4">, </span><span class="s1">as_interface</span><span class="s4">=</span><span class="s1">as_interface</span><span class="s4">)</span>
    <span class="s1">vars </span><span class="s4">= </span><span class="s1">vars2fortran</span><span class="s4">(</span>
        <span class="s1">block</span><span class="s4">, </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">], </span><span class="s1">argsl</span><span class="s4">, </span><span class="s1">tab </span><span class="s4">+ </span><span class="s1">tabchar</span><span class="s4">, </span><span class="s1">as_interface</span><span class="s4">=</span><span class="s1">as_interface</span><span class="s4">)</span>
    <span class="s1">mess </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s3">if </span><span class="s6">'from' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and not </span><span class="s1">as_interface</span><span class="s4">:</span>
        <span class="s1">mess </span><span class="s4">= </span><span class="s6">'! in %s' </span><span class="s4">% </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'from'</span><span class="s4">]</span>
    <span class="s3">if </span><span class="s6">'entry' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s1">entry_stmts </span><span class="s4">= </span><span class="s6">''</span>
        <span class="s3">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">i </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'entry'</span><span class="s4">].</span><span class="s1">items</span><span class="s4">()):</span>
            <span class="s1">entry_stmts </span><span class="s4">= </span><span class="s6">'%s%sentry %s(%s)' </span><span class="s1">\</span>
                          <span class="s4">% (</span><span class="s1">entry_stmts</span><span class="s4">, </span><span class="s1">tab </span><span class="s4">+ </span><span class="s1">tabchar</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s6">','</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">i</span><span class="s4">))</span>
        <span class="s1">body </span><span class="s4">= </span><span class="s1">body </span><span class="s4">+ </span><span class="s1">entry_stmts</span>
    <span class="s3">if </span><span class="s1">blocktype </span><span class="s4">== </span><span class="s6">'block data' </span><span class="s3">and </span><span class="s1">name </span><span class="s4">== </span><span class="s6">'_BLOCK_DATA_'</span><span class="s4">:</span>
        <span class="s1">name </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s1">ret </span><span class="s4">= </span><span class="s6">'%s%s%s %s%s%s %s%s%s%s%s%s%send %s %s' </span><span class="s4">% (</span>
        <span class="s1">tab</span><span class="s4">, </span><span class="s1">prefix</span><span class="s4">, </span><span class="s1">blocktype</span><span class="s4">, </span><span class="s1">name</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">result</span><span class="s4">, </span><span class="s1">mess</span><span class="s4">, </span><span class="s1">f2pyenhancements</span><span class="s4">, </span><span class="s1">use</span><span class="s4">, </span><span class="s1">vars</span><span class="s4">, </span><span class="s1">common</span><span class="s4">, </span><span class="s1">body</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">, </span><span class="s1">blocktype</span><span class="s4">, </span><span class="s1">name</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">common2fortran</span><span class="s4">(</span><span class="s1">common</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">=</span><span class="s6">''</span><span class="s4">):</span>
    <span class="s1">ret </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">common</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
        <span class="s3">if </span><span class="s1">k </span><span class="s4">== </span><span class="s6">'_BLNK_'</span><span class="s4">:</span>
            <span class="s1">ret </span><span class="s4">= </span><span class="s6">'%s%scommon %s' </span><span class="s4">% (</span><span class="s1">ret</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">, </span><span class="s6">','</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">common</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]))</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">ret </span><span class="s4">= </span><span class="s6">'%s%scommon /%s/ %s' </span><span class="s4">% (</span><span class="s1">ret</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s6">','</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">common</span><span class="s4">[</span><span class="s1">k</span><span class="s4">]))</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">use2fortran</span><span class="s4">(</span><span class="s1">use</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">=</span><span class="s6">''</span><span class="s4">):</span>
    <span class="s1">ret </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">use</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
        <span class="s1">ret </span><span class="s4">= </span><span class="s6">'%s%suse %s,' </span><span class="s4">% (</span><span class="s1">ret</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">, </span><span class="s1">m</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">use</span><span class="s4">[</span><span class="s1">m</span><span class="s4">] == {}:</span>
            <span class="s3">if </span><span class="s1">ret </span><span class="s3">and </span><span class="s1">ret</span><span class="s4">[-</span><span class="s5">1</span><span class="s4">] == </span><span class="s6">','</span><span class="s4">:</span>
                <span class="s1">ret </span><span class="s4">= </span><span class="s1">ret</span><span class="s4">[:-</span><span class="s5">1</span><span class="s4">]</span>
            <span class="s3">continue</span>
        <span class="s3">if </span><span class="s6">'only' </span><span class="s3">in </span><span class="s1">use</span><span class="s4">[</span><span class="s1">m</span><span class="s4">] </span><span class="s3">and </span><span class="s1">use</span><span class="s4">[</span><span class="s1">m</span><span class="s4">][</span><span class="s6">'only'</span><span class="s4">]:</span>
            <span class="s1">ret </span><span class="s4">= </span><span class="s6">'%s only:' </span><span class="s4">% (</span><span class="s1">ret</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s6">'map' </span><span class="s3">in </span><span class="s1">use</span><span class="s4">[</span><span class="s1">m</span><span class="s4">] </span><span class="s3">and </span><span class="s1">use</span><span class="s4">[</span><span class="s1">m</span><span class="s4">][</span><span class="s6">'map'</span><span class="s4">]:</span>
            <span class="s1">c </span><span class="s4">= </span><span class="s6">' '</span>
            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">use</span><span class="s4">[</span><span class="s1">m</span><span class="s4">][</span><span class="s6">'map'</span><span class="s4">].</span><span class="s1">keys</span><span class="s4">()):</span>
                <span class="s3">if </span><span class="s1">k </span><span class="s4">== </span><span class="s1">use</span><span class="s4">[</span><span class="s1">m</span><span class="s4">][</span><span class="s6">'map'</span><span class="s4">][</span><span class="s1">k</span><span class="s4">]:</span>
                    <span class="s1">ret </span><span class="s4">= </span><span class="s6">'%s%s%s' </span><span class="s4">% (</span><span class="s1">ret</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
                    <span class="s1">c </span><span class="s4">= </span><span class="s6">','</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">ret </span><span class="s4">= </span><span class="s6">'%s%s%s=&gt;%s' </span><span class="s4">% (</span><span class="s1">ret</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">use</span><span class="s4">[</span><span class="s1">m</span><span class="s4">][</span><span class="s6">'map'</span><span class="s4">][</span><span class="s1">k</span><span class="s4">])</span>
                    <span class="s1">c </span><span class="s4">= </span><span class="s6">','</span>
        <span class="s3">if </span><span class="s1">ret </span><span class="s3">and </span><span class="s1">ret</span><span class="s4">[-</span><span class="s5">1</span><span class="s4">] == </span><span class="s6">','</span><span class="s4">:</span>
            <span class="s1">ret </span><span class="s4">= </span><span class="s1">ret</span><span class="s4">[:-</span><span class="s5">1</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">true_intent_list</span><span class="s4">(</span><span class="s1">var</span><span class="s4">):</span>
    <span class="s1">lst </span><span class="s4">= </span><span class="s1">var</span><span class="s4">[</span><span class="s6">'intent'</span><span class="s4">]</span>
    <span class="s1">ret </span><span class="s4">= []</span>
    <span class="s3">for </span><span class="s1">intent </span><span class="s3">in </span><span class="s1">lst</span><span class="s4">:</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">f </span><span class="s4">= </span><span class="s1">globals</span><span class="s4">()[</span><span class="s6">'isintent_%s' </span><span class="s4">% </span><span class="s1">intent</span><span class="s4">]</span>
        <span class="s3">except </span><span class="s1">KeyError</span><span class="s4">:</span>
            <span class="s3">pass</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">f</span><span class="s4">(</span><span class="s1">var</span><span class="s4">):</span>
                <span class="s1">ret</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">intent</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">vars2fortran</span><span class="s4">(</span><span class="s1">block</span><span class="s4">, </span><span class="s1">vars</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">=</span><span class="s6">''</span><span class="s4">, </span><span class="s1">as_interface</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s1">setmesstext</span><span class="s4">(</span><span class="s1">block</span><span class="s4">)</span>
    <span class="s1">ret </span><span class="s4">= </span><span class="s6">''</span>
    <span class="s1">nout </span><span class="s4">= []</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">a </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'vars'</span><span class="s4">]:</span>
            <span class="s1">nout</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s6">'commonvars' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'commonvars'</span><span class="s4">]:</span>
            <span class="s3">if </span><span class="s1">a </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">a </span><span class="s3">not in </span><span class="s1">nout</span><span class="s4">:</span>
                    <span class="s1">nout</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">errmess</span><span class="s4">(</span>
                    <span class="s6">'vars2fortran: Confused?!: &quot;%s&quot; is not defined in vars.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">a</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s6">'varnames' </span><span class="s3">in </span><span class="s1">block</span><span class="s4">:</span>
        <span class="s1">nout</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">block</span><span class="s4">[</span><span class="s6">'varnames'</span><span class="s4">])</span>
    <span class="s3">if not </span><span class="s1">as_interface</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">.</span><span class="s1">keys</span><span class="s4">()):</span>
            <span class="s3">if </span><span class="s1">a </span><span class="s3">not in </span><span class="s1">nout</span><span class="s4">:</span>
                <span class="s1">nout</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">nout</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s6">'depend' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">]:</span>
            <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">][</span><span class="s6">'depend'</span><span class="s4">]:</span>
                <span class="s3">if </span><span class="s1">d </span><span class="s3">in </span><span class="s1">vars </span><span class="s3">and </span><span class="s6">'depend' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">d</span><span class="s4">] </span><span class="s3">and </span><span class="s1">a </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">d</span><span class="s4">][</span><span class="s6">'depend'</span><span class="s4">]:</span>
                    <span class="s1">errmess</span><span class="s4">(</span>
                        <span class="s6">'vars2fortran: Warning: cross-dependence between variables &quot;%s&quot; and &quot;%s&quot;</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% (</span><span class="s1">a</span><span class="s4">, </span><span class="s1">d</span><span class="s4">))</span>
        <span class="s3">if </span><span class="s6">'externals' </span><span class="s3">in </span><span class="s1">block </span><span class="s3">and </span><span class="s1">a </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'externals'</span><span class="s4">]:</span>
            <span class="s3">if </span><span class="s1">isintent_callback</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">]):</span>
                <span class="s1">ret </span><span class="s4">= </span><span class="s6">'%s%sintent(callback) %s' </span><span class="s4">% (</span><span class="s1">ret</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">, </span><span class="s1">a</span><span class="s4">)</span>
            <span class="s1">ret </span><span class="s4">= </span><span class="s6">'%s%sexternal %s' </span><span class="s4">% (</span><span class="s1">ret</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">, </span><span class="s1">a</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">isoptional</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">]):</span>
                <span class="s1">ret </span><span class="s4">= </span><span class="s6">'%s%soptional %s' </span><span class="s4">% (</span><span class="s1">ret</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">, </span><span class="s1">a</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">a </span><span class="s3">in </span><span class="s1">vars </span><span class="s3">and </span><span class="s6">'typespec' </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">]:</span>
                <span class="s3">continue</span>
            <span class="s1">cont </span><span class="s4">= </span><span class="s5">1</span>
            <span class="s3">for </span><span class="s1">b </span><span class="s3">in </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'body'</span><span class="s4">]:</span>
                <span class="s3">if </span><span class="s1">a </span><span class="s4">== </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">] </span><span class="s3">and </span><span class="s1">b</span><span class="s4">[</span><span class="s6">'block'</span><span class="s4">] == </span><span class="s6">'function'</span><span class="s4">:</span>
                    <span class="s1">cont </span><span class="s4">= </span><span class="s5">0</span>
                    <span class="s3">break</span>
            <span class="s3">if </span><span class="s1">cont</span><span class="s4">:</span>
                <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">a </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">:</span>
            <span class="s1">show</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">)</span>
            <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'vars2fortran: No definition for argument &quot;%s&quot;.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">a</span><span class="s4">)</span>
            <span class="s3">continue</span>
        <span class="s3">if </span><span class="s1">a </span><span class="s4">== </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'name'</span><span class="s4">]:</span>
            <span class="s3">if </span><span class="s1">block</span><span class="s4">[</span><span class="s6">'block'</span><span class="s4">] != </span><span class="s6">'function' </span><span class="s3">or </span><span class="s1">block</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s6">'result'</span><span class="s4">):</span>
                <span class="s0"># 1) skip declaring a variable that name matches with</span>
                <span class="s0">#    subroutine name</span>
                <span class="s0"># 2) skip declaring function when its type is</span>
                <span class="s0">#    declared via `result` construction</span>
                <span class="s3">continue</span>
        <span class="s3">if </span><span class="s6">'typespec' </span><span class="s3">not in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">]:</span>
            <span class="s3">if </span><span class="s6">'attrspec' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">] </span><span class="s3">and </span><span class="s6">'external' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">]:</span>
                <span class="s3">if </span><span class="s1">a </span><span class="s3">in </span><span class="s1">args</span><span class="s4">:</span>
                    <span class="s1">ret </span><span class="s4">= </span><span class="s6">'%s%sexternal %s' </span><span class="s4">% (</span><span class="s1">ret</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">, </span><span class="s1">a</span><span class="s4">)</span>
                <span class="s3">continue</span>
            <span class="s1">show</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">])</span>
            <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'vars2fortran: No typespec for argument &quot;%s&quot;.</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">a</span><span class="s4">)</span>
            <span class="s3">continue</span>
        <span class="s1">vardef </span><span class="s4">= </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">][</span><span class="s6">'typespec'</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">vardef </span><span class="s4">== </span><span class="s6">'type' </span><span class="s3">and </span><span class="s6">'typename' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">]:</span>
            <span class="s1">vardef </span><span class="s4">= </span><span class="s6">'%s(%s)' </span><span class="s4">% (</span><span class="s1">vardef</span><span class="s4">, </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">][</span><span class="s6">'typename'</span><span class="s4">])</span>
        <span class="s1">selector </span><span class="s4">= {}</span>
        <span class="s3">if </span><span class="s6">'kindselector' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">]:</span>
            <span class="s1">selector </span><span class="s4">= </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">][</span><span class="s6">'kindselector'</span><span class="s4">]</span>
        <span class="s3">elif </span><span class="s6">'charselector' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">]:</span>
            <span class="s1">selector </span><span class="s4">= </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">][</span><span class="s6">'charselector'</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s6">'*' </span><span class="s3">in </span><span class="s1">selector</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">selector</span><span class="s4">[</span><span class="s6">'*'</span><span class="s4">] </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'*'</span><span class="s4">, </span><span class="s6">':'</span><span class="s4">]:</span>
                <span class="s1">vardef </span><span class="s4">= </span><span class="s6">'%s*(%s)' </span><span class="s4">% (</span><span class="s1">vardef</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">[</span><span class="s6">'*'</span><span class="s4">])</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">vardef </span><span class="s4">= </span><span class="s6">'%s*%s' </span><span class="s4">% (</span><span class="s1">vardef</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">[</span><span class="s6">'*'</span><span class="s4">])</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s6">'len' </span><span class="s3">in </span><span class="s1">selector</span><span class="s4">:</span>
                <span class="s1">vardef </span><span class="s4">= </span><span class="s6">'%s(len=%s' </span><span class="s4">% (</span><span class="s1">vardef</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">[</span><span class="s6">'len'</span><span class="s4">])</span>
                <span class="s3">if </span><span class="s6">'kind' </span><span class="s3">in </span><span class="s1">selector</span><span class="s4">:</span>
                    <span class="s1">vardef </span><span class="s4">= </span><span class="s6">'%s,kind=%s)' </span><span class="s4">% (</span><span class="s1">vardef</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">[</span><span class="s6">'kind'</span><span class="s4">])</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">vardef </span><span class="s4">= </span><span class="s6">'%s)' </span><span class="s4">% (</span><span class="s1">vardef</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s6">'kind' </span><span class="s3">in </span><span class="s1">selector</span><span class="s4">:</span>
                <span class="s1">vardef </span><span class="s4">= </span><span class="s6">'%s(kind=%s)' </span><span class="s4">% (</span><span class="s1">vardef</span><span class="s4">, </span><span class="s1">selector</span><span class="s4">[</span><span class="s6">'kind'</span><span class="s4">])</span>
        <span class="s1">c </span><span class="s4">= </span><span class="s6">' '</span>
        <span class="s3">if </span><span class="s6">'attrspec' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">]:</span>
            <span class="s1">attr </span><span class="s4">= [</span><span class="s1">l </span><span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">][</span><span class="s6">'attrspec'</span><span class="s4">]</span>
                    <span class="s3">if </span><span class="s1">l </span><span class="s3">not in </span><span class="s4">[</span><span class="s6">'external'</span><span class="s4">]]</span>
            <span class="s3">if </span><span class="s1">as_interface </span><span class="s3">and </span><span class="s6">'intent(in)' </span><span class="s3">in </span><span class="s1">attr </span><span class="s3">and </span><span class="s6">'intent(out)' </span><span class="s3">in </span><span class="s1">attr</span><span class="s4">:</span>
                <span class="s0"># In Fortran, intent(in, out) are conflicting while</span>
                <span class="s0"># intent(in, out) can be specified only via</span>
                <span class="s0"># `!f2py intent(out) ..`.</span>
                <span class="s0"># So, for the Fortran interface, we'll drop</span>
                <span class="s0"># intent(out) to resolve the conflict.</span>
                <span class="s1">attr</span><span class="s4">.</span><span class="s1">remove</span><span class="s4">(</span><span class="s6">'intent(out)'</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">attr</span><span class="s4">:</span>
                <span class="s1">vardef </span><span class="s4">= </span><span class="s6">'%s, %s' </span><span class="s4">% (</span><span class="s1">vardef</span><span class="s4">, </span><span class="s6">','</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">))</span>
                <span class="s1">c </span><span class="s4">= </span><span class="s6">','</span>
        <span class="s3">if </span><span class="s6">'dimension' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">]:</span>
            <span class="s1">vardef </span><span class="s4">= </span><span class="s6">'%s%sdimension(%s)' </span><span class="s4">% (</span>
                <span class="s1">vardef</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s6">','</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">][</span><span class="s6">'dimension'</span><span class="s4">]))</span>
            <span class="s1">c </span><span class="s4">= </span><span class="s6">','</span>
        <span class="s3">if </span><span class="s6">'intent' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">]:</span>
            <span class="s1">lst </span><span class="s4">= </span><span class="s1">true_intent_list</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">])</span>
            <span class="s3">if </span><span class="s1">lst</span><span class="s4">:</span>
                <span class="s1">vardef </span><span class="s4">= </span><span class="s6">'%s%sintent(%s)' </span><span class="s4">% (</span><span class="s1">vardef</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s6">','</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">lst</span><span class="s4">))</span>
            <span class="s1">c </span><span class="s4">= </span><span class="s6">','</span>
        <span class="s3">if </span><span class="s6">'check' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">]:</span>
            <span class="s1">vardef </span><span class="s4">= </span><span class="s6">'%s%scheck(%s)' </span><span class="s4">% (</span><span class="s1">vardef</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s6">','</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">][</span><span class="s6">'check'</span><span class="s4">]))</span>
            <span class="s1">c </span><span class="s4">= </span><span class="s6">','</span>
        <span class="s3">if </span><span class="s6">'depend' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">]:</span>
            <span class="s1">vardef </span><span class="s4">= </span><span class="s6">'%s%sdepend(%s)' </span><span class="s4">% (</span>
                <span class="s1">vardef</span><span class="s4">, </span><span class="s1">c</span><span class="s4">, </span><span class="s6">','</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">][</span><span class="s6">'depend'</span><span class="s4">]))</span>
            <span class="s1">c </span><span class="s4">= </span><span class="s6">','</span>
        <span class="s3">if </span><span class="s6">'=' </span><span class="s3">in </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">]:</span>
            <span class="s1">v </span><span class="s4">= </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">][</span><span class="s6">'='</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">vars</span><span class="s4">[</span><span class="s1">a</span><span class="s4">][</span><span class="s6">'typespec'</span><span class="s4">] </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'complex'</span><span class="s4">, </span><span class="s6">'double complex'</span><span class="s4">]:</span>
                <span class="s3">try</span><span class="s4">:</span>
                    <span class="s1">v </span><span class="s4">= </span><span class="s1">eval</span><span class="s4">(</span><span class="s1">v</span><span class="s4">)</span>
                    <span class="s1">v </span><span class="s4">= </span><span class="s6">'(%s,%s)' </span><span class="s4">% (</span><span class="s1">v</span><span class="s4">.</span><span class="s1">real</span><span class="s4">, </span><span class="s1">v</span><span class="s4">.</span><span class="s1">imag</span><span class="s4">)</span>
                <span class="s3">except </span><span class="s1">Exception</span><span class="s4">:</span>
                    <span class="s3">pass</span>
            <span class="s1">vardef </span><span class="s4">= </span><span class="s6">'%s :: %s=%s' </span><span class="s4">% (</span><span class="s1">vardef</span><span class="s4">, </span><span class="s1">a</span><span class="s4">, </span><span class="s1">v</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">vardef </span><span class="s4">= </span><span class="s6">'%s :: %s' </span><span class="s4">% (</span><span class="s1">vardef</span><span class="s4">, </span><span class="s1">a</span><span class="s4">)</span>
        <span class="s1">ret </span><span class="s4">= </span><span class="s6">'%s%s%s' </span><span class="s4">% (</span><span class="s1">ret</span><span class="s4">, </span><span class="s1">tab</span><span class="s4">, </span><span class="s1">vardef</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">ret</span>
<span class="s0">######</span>


<span class="s0"># We expose post_processing_hooks as global variable so that</span>
<span class="s0"># user-libraries could register their own hooks to f2py.</span>
<span class="s1">post_processing_hooks </span><span class="s4">= []</span>


<span class="s3">def </span><span class="s1">crackfortran</span><span class="s4">(</span><span class="s1">files</span><span class="s4">):</span>
    <span class="s3">global </span><span class="s1">usermodules</span><span class="s4">, </span><span class="s1">post_processing_hooks</span>

    <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'Reading fortran codes...</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">, </span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">readfortrancode</span><span class="s4">(</span><span class="s1">files</span><span class="s4">, </span><span class="s1">crackline</span><span class="s4">)</span>
    <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'Post-processing...</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">, </span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">usermodules </span><span class="s4">= []</span>
    <span class="s1">postlist </span><span class="s4">= </span><span class="s1">postcrack</span><span class="s4">(</span><span class="s1">grouplist</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>
    <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'Applying post-processing hooks...</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">, </span><span class="s5">0</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">hook </span><span class="s3">in </span><span class="s1">post_processing_hooks</span><span class="s4">:</span>
        <span class="s1">outmess</span><span class="s4">(</span><span class="s6">f'  </span><span class="s3">{</span><span class="s1">hook</span><span class="s4">.</span><span class="s1">__name__</span><span class="s3">}\n</span><span class="s6">'</span><span class="s4">, </span><span class="s5">0</span><span class="s4">)</span>
        <span class="s1">postlist </span><span class="s4">= </span><span class="s1">traverse</span><span class="s4">(</span><span class="s1">postlist</span><span class="s4">, </span><span class="s1">hook</span><span class="s4">)</span>
    <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'Post-processing (stage 2)...</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">, </span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">postlist </span><span class="s4">= </span><span class="s1">postcrack2</span><span class="s4">(</span><span class="s1">postlist</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">usermodules </span><span class="s4">+ </span><span class="s1">postlist</span>


<span class="s3">def </span><span class="s1">crack2fortran</span><span class="s4">(</span><span class="s1">block</span><span class="s4">):</span>
    <span class="s3">global </span><span class="s1">f2py_version</span>

    <span class="s1">pyf </span><span class="s4">= </span><span class="s1">crack2fortrangen</span><span class="s4">(</span><span class="s1">block</span><span class="s4">) + </span><span class="s6">'</span><span class="s3">\n</span><span class="s6">'</span>
    <span class="s1">header </span><span class="s4">= </span><span class="s6">&quot;&quot;&quot;!    -*- f90 -*- 
! Note: the context of this file is case sensitive. 
&quot;&quot;&quot;</span>
    <span class="s1">footer </span><span class="s4">= </span><span class="s6">&quot;&quot;&quot; 
! This file was auto-generated with f2py (version:%s). 
! See: 
! https://web.archive.org/web/20140822061353/http://cens.ioc.ee/projects/f2py2e 
&quot;&quot;&quot; </span><span class="s4">% (</span><span class="s1">f2py_version</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">header </span><span class="s4">+ </span><span class="s1">pyf </span><span class="s4">+ </span><span class="s1">footer</span>


<span class="s3">def </span><span class="s1">_is_visit_pair</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s4">(</span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">)</span>
            <span class="s3">and </span><span class="s1">len</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">) == </span><span class="s5">2</span>
            <span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">[</span><span class="s5">0</span><span class="s4">], (</span><span class="s1">int</span><span class="s4">, </span><span class="s1">str</span><span class="s4">)))</span>


<span class="s3">def </span><span class="s1">traverse</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">visit</span><span class="s4">, </span><span class="s1">parents</span><span class="s4">=[], </span><span class="s1">result</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
    <span class="s2">'''Traverse f2py data structure with the following visit function: 
 
    def visit(item, parents, result, *args, **kwargs): 
        &quot;&quot;&quot; 
 
        parents is a list of key-&quot;f2py data structure&quot; pairs from which 
        items are taken from. 
 
        result is a f2py data structure that is filled with the 
        return value of the visit function. 
 
        item is 2-tuple (index, value) if parents[-1][1] is a list 
        item is 2-tuple (key, value) if parents[-1][1] is a dict 
 
        The return value of visit must be None, or of the same kind as 
        item, that is, if parents[-1] is a list, the return value must 
        be 2-tuple (new_index, new_value), or if parents[-1] is a 
        dict, the return value must be 2-tuple (new_key, new_value). 
 
        If new_index or new_value is None, the return value of visit 
        is ignored, that is, it will not be added to the result. 
 
        If the return value is None, the content of obj will be 
        traversed, otherwise not. 
        &quot;&quot;&quot; 
    '''</span>

    <span class="s3">if </span><span class="s1">_is_visit_pair</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">obj</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] == </span><span class="s6">'parent_block'</span><span class="s4">:</span>
            <span class="s0"># avoid infinite recursion</span>
            <span class="s3">return </span><span class="s1">obj</span>
        <span class="s1">new_result </span><span class="s4">= </span><span class="s1">visit</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">parents</span><span class="s4">, </span><span class="s1">result</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">new_result </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">_is_visit_pair</span><span class="s4">(</span><span class="s1">new_result</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">new_result</span>
        <span class="s1">parent </span><span class="s4">= </span><span class="s1">obj</span>
        <span class="s1">result_key</span><span class="s4">, </span><span class="s1">obj </span><span class="s4">= </span><span class="s1">obj</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">parent </span><span class="s4">= (</span><span class="s3">None</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">)</span>
        <span class="s1">result_key </span><span class="s4">= </span><span class="s3">None</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">list</span><span class="s4">):</span>
        <span class="s1">new_result </span><span class="s4">= []</span>
        <span class="s3">for </span><span class="s1">index</span><span class="s4">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">):</span>
            <span class="s1">new_index</span><span class="s4">, </span><span class="s1">new_item </span><span class="s4">= </span><span class="s1">traverse</span><span class="s4">((</span><span class="s1">index</span><span class="s4">, </span><span class="s1">value</span><span class="s4">), </span><span class="s1">visit</span><span class="s4">,</span>
                                           <span class="s1">parents</span><span class="s4">=</span><span class="s1">parents </span><span class="s4">+ [</span><span class="s1">parent</span><span class="s4">],</span>
                                           <span class="s1">result</span><span class="s4">=</span><span class="s1">result</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">new_index </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">new_result</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">new_item</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">obj</span><span class="s4">, </span><span class="s1">dict</span><span class="s4">):</span>
        <span class="s1">new_result </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">()</span>
        <span class="s3">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">obj</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
            <span class="s1">new_key</span><span class="s4">, </span><span class="s1">new_value </span><span class="s4">= </span><span class="s1">traverse</span><span class="s4">((</span><span class="s1">key</span><span class="s4">, </span><span class="s1">value</span><span class="s4">), </span><span class="s1">visit</span><span class="s4">,</span>
                                          <span class="s1">parents</span><span class="s4">=</span><span class="s1">parents </span><span class="s4">+ [</span><span class="s1">parent</span><span class="s4">],</span>
                                          <span class="s1">result</span><span class="s4">=</span><span class="s1">result</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">new_key </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">new_result</span><span class="s4">[</span><span class="s1">new_key</span><span class="s4">] = </span><span class="s1">new_value</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">new_result </span><span class="s4">= </span><span class="s1">obj</span>

    <span class="s3">if </span><span class="s1">result_key </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">new_result</span>
    <span class="s3">return </span><span class="s1">result_key</span><span class="s4">, </span><span class="s1">new_result</span>


<span class="s3">def </span><span class="s1">character_backward_compatibility_hook</span><span class="s4">(</span><span class="s1">item</span><span class="s4">, </span><span class="s1">parents</span><span class="s4">, </span><span class="s1">result</span><span class="s4">,</span>
                                          <span class="s4">*</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Previously, Fortran character was incorrectly treated as 
    character*1. This hook fixes the usage of the corresponding 
    variables in `check`, `dimension`, `=`, and `callstatement` 
    expressions. 
 
    The usage of `char*` in `callprotoargument` expression can be left 
    unchanged because C `character` is C typedef of `char`, although, 
    new implementations should use `character*` in the corresponding 
    expressions. 
 
    See https://github.com/numpy/numpy/pull/19388 for more information. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">parent_key</span><span class="s4">, </span><span class="s1">parent_value </span><span class="s4">= </span><span class="s1">parents</span><span class="s4">[-</span><span class="s5">1</span><span class="s4">]</span>
    <span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s4">= </span><span class="s1">item</span>

    <span class="s3">def </span><span class="s1">fix_usage</span><span class="s4">(</span><span class="s1">varname</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s1">value </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">(</span><span class="s6">r'[*]\s*\b' </span><span class="s4">+ </span><span class="s1">varname </span><span class="s4">+ </span><span class="s6">r'\b'</span><span class="s4">, </span><span class="s1">varname</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>
        <span class="s1">value </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">(</span><span class="s6">r'\b' </span><span class="s4">+ </span><span class="s1">varname </span><span class="s4">+ </span><span class="s6">r'\b\s*[\[]\s*0\s*[\]]'</span><span class="s4">,</span>
                       <span class="s1">varname</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">value</span>

    <span class="s3">if </span><span class="s1">parent_key </span><span class="s3">in </span><span class="s4">[</span><span class="s6">'dimension'</span><span class="s4">, </span><span class="s6">'check'</span><span class="s4">]:</span>
        <span class="s3">assert </span><span class="s1">parents</span><span class="s4">[-</span><span class="s5">3</span><span class="s4">][</span><span class="s5">0</span><span class="s4">] == </span><span class="s6">'vars'</span>
        <span class="s1">vars_dict </span><span class="s4">= </span><span class="s1">parents</span><span class="s4">[-</span><span class="s5">3</span><span class="s4">][</span><span class="s5">1</span><span class="s4">]</span>
    <span class="s3">elif </span><span class="s1">key </span><span class="s4">== </span><span class="s6">'='</span><span class="s4">:</span>
        <span class="s3">assert </span><span class="s1">parents</span><span class="s4">[-</span><span class="s5">2</span><span class="s4">][</span><span class="s5">0</span><span class="s4">] == </span><span class="s6">'vars'</span>
        <span class="s1">vars_dict </span><span class="s4">= </span><span class="s1">parents</span><span class="s4">[-</span><span class="s5">2</span><span class="s4">][</span><span class="s5">1</span><span class="s4">]</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">vars_dict </span><span class="s4">= </span><span class="s3">None</span>

    <span class="s1">new_value </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s3">if </span><span class="s1">vars_dict </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">new_value </span><span class="s4">= </span><span class="s1">value</span>
        <span class="s3">for </span><span class="s1">varname</span><span class="s4">, </span><span class="s1">vd </span><span class="s3">in </span><span class="s1">vars_dict</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
            <span class="s3">if </span><span class="s1">ischaracter</span><span class="s4">(</span><span class="s1">vd</span><span class="s4">):</span>
                <span class="s1">new_value </span><span class="s4">= </span><span class="s1">fix_usage</span><span class="s4">(</span><span class="s1">varname</span><span class="s4">, </span><span class="s1">new_value</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">key </span><span class="s4">== </span><span class="s6">'callstatement'</span><span class="s4">:</span>
        <span class="s1">vars_dict </span><span class="s4">= </span><span class="s1">parents</span><span class="s4">[-</span><span class="s5">2</span><span class="s4">][</span><span class="s5">1</span><span class="s4">][</span><span class="s6">'vars'</span><span class="s4">]</span>
        <span class="s1">new_value </span><span class="s4">= </span><span class="s1">value</span>
        <span class="s3">for </span><span class="s1">varname</span><span class="s4">, </span><span class="s1">vd </span><span class="s3">in </span><span class="s1">vars_dict</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
            <span class="s3">if </span><span class="s1">ischaracter</span><span class="s4">(</span><span class="s1">vd</span><span class="s4">):</span>
                <span class="s0"># replace all occurrences of `&lt;varname&gt;` with</span>
                <span class="s0"># `&amp;&lt;varname&gt;` in argument passing</span>
                <span class="s1">new_value </span><span class="s4">= </span><span class="s1">re</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">(</span>
                    <span class="s6">r'(?&lt;![&amp;])\b' </span><span class="s4">+ </span><span class="s1">varname </span><span class="s4">+ </span><span class="s6">r'\b'</span><span class="s4">, </span><span class="s6">'&amp;' </span><span class="s4">+ </span><span class="s1">varname</span><span class="s4">, </span><span class="s1">new_value</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">new_value </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">new_value </span><span class="s4">!= </span><span class="s1">value</span><span class="s4">:</span>
            <span class="s0"># We report the replacements here so that downstream</span>
            <span class="s0"># software could update their source codes</span>
            <span class="s0"># accordingly. However, such updates are recommended only</span>
            <span class="s0"># when BC with numpy 1.21 or older is not required.</span>
            <span class="s1">outmess</span><span class="s4">(</span><span class="s6">f'character_bc_hook[</span><span class="s3">{</span><span class="s1">parent_key</span><span class="s3">}</span><span class="s6">.</span><span class="s3">{</span><span class="s1">key</span><span class="s3">}</span><span class="s6">]:'</span>
                    <span class="s6">f' replaced `</span><span class="s3">{</span><span class="s1">value</span><span class="s3">}</span><span class="s6">` -&gt; `</span><span class="s3">{</span><span class="s1">new_value</span><span class="s3">}</span><span class="s6">`</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">, </span><span class="s5">1</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s1">key</span><span class="s4">, </span><span class="s1">new_value</span><span class="s4">)</span>


<span class="s1">post_processing_hooks</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">character_backward_compatibility_hook</span><span class="s4">)</span>


<span class="s3">if </span><span class="s1">__name__ </span><span class="s4">== </span><span class="s6">&quot;__main__&quot;</span><span class="s4">:</span>
    <span class="s1">files </span><span class="s4">= []</span>
    <span class="s1">funcs </span><span class="s4">= []</span>
    <span class="s1">f </span><span class="s4">= </span><span class="s5">1</span>
    <span class="s1">f2 </span><span class="s4">= </span><span class="s5">0</span>
    <span class="s1">f3 </span><span class="s4">= </span><span class="s5">0</span>
    <span class="s1">showblocklist </span><span class="s4">= </span><span class="s5">0</span>
    <span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">sys</span><span class="s4">.</span><span class="s1">argv</span><span class="s4">[</span><span class="s5">1</span><span class="s4">:]:</span>
        <span class="s3">if </span><span class="s1">l </span><span class="s4">== </span><span class="s6">''</span><span class="s4">:</span>
            <span class="s3">pass</span>
        <span class="s3">elif </span><span class="s1">l</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] == </span><span class="s6">':'</span><span class="s4">:</span>
            <span class="s1">f </span><span class="s4">= </span><span class="s5">0</span>
        <span class="s3">elif </span><span class="s1">l </span><span class="s4">== </span><span class="s6">'-quiet'</span><span class="s4">:</span>
            <span class="s1">quiet </span><span class="s4">= </span><span class="s5">1</span>
            <span class="s1">verbose </span><span class="s4">= </span><span class="s5">0</span>
        <span class="s3">elif </span><span class="s1">l </span><span class="s4">== </span><span class="s6">'-verbose'</span><span class="s4">:</span>
            <span class="s1">verbose </span><span class="s4">= </span><span class="s5">2</span>
            <span class="s1">quiet </span><span class="s4">= </span><span class="s5">0</span>
        <span class="s3">elif </span><span class="s1">l </span><span class="s4">== </span><span class="s6">'-fix'</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">strictf77</span><span class="s4">:</span>
                <span class="s1">outmess</span><span class="s4">(</span>
                    <span class="s6">'Use option -f90 before -fix if Fortran 90 code is in fix form.</span><span class="s3">\n</span><span class="s6">'</span><span class="s4">, </span><span class="s5">0</span><span class="s4">)</span>
            <span class="s1">skipemptyends </span><span class="s4">= </span><span class="s5">1</span>
            <span class="s1">sourcecodeform </span><span class="s4">= </span><span class="s6">'fix'</span>
        <span class="s3">elif </span><span class="s1">l </span><span class="s4">== </span><span class="s6">'-skipemptyends'</span><span class="s4">:</span>
            <span class="s1">skipemptyends </span><span class="s4">= </span><span class="s5">1</span>
        <span class="s3">elif </span><span class="s1">l </span><span class="s4">== </span><span class="s6">'--ignore-contains'</span><span class="s4">:</span>
            <span class="s1">ignorecontains </span><span class="s4">= </span><span class="s5">1</span>
        <span class="s3">elif </span><span class="s1">l </span><span class="s4">== </span><span class="s6">'-f77'</span><span class="s4">:</span>
            <span class="s1">strictf77 </span><span class="s4">= </span><span class="s5">1</span>
            <span class="s1">sourcecodeform </span><span class="s4">= </span><span class="s6">'fix'</span>
        <span class="s3">elif </span><span class="s1">l </span><span class="s4">== </span><span class="s6">'-f90'</span><span class="s4">:</span>
            <span class="s1">strictf77 </span><span class="s4">= </span><span class="s5">0</span>
            <span class="s1">sourcecodeform </span><span class="s4">= </span><span class="s6">'free'</span>
            <span class="s1">skipemptyends </span><span class="s4">= </span><span class="s5">1</span>
        <span class="s3">elif </span><span class="s1">l </span><span class="s4">== </span><span class="s6">'-h'</span><span class="s4">:</span>
            <span class="s1">f2 </span><span class="s4">= </span><span class="s5">1</span>
        <span class="s3">elif </span><span class="s1">l </span><span class="s4">== </span><span class="s6">'-show'</span><span class="s4">:</span>
            <span class="s1">showblocklist </span><span class="s4">= </span><span class="s5">1</span>
        <span class="s3">elif </span><span class="s1">l </span><span class="s4">== </span><span class="s6">'-m'</span><span class="s4">:</span>
            <span class="s1">f3 </span><span class="s4">= </span><span class="s5">1</span>
        <span class="s3">elif </span><span class="s1">l</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] == </span><span class="s6">'-'</span><span class="s4">:</span>
            <span class="s1">errmess</span><span class="s4">(</span><span class="s6">'Unknown option %s</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">l</span><span class="s4">))</span>
        <span class="s3">elif </span><span class="s1">f2</span><span class="s4">:</span>
            <span class="s1">f2 </span><span class="s4">= </span><span class="s5">0</span>
            <span class="s1">pyffilename </span><span class="s4">= </span><span class="s1">l</span>
        <span class="s3">elif </span><span class="s1">f3</span><span class="s4">:</span>
            <span class="s1">f3 </span><span class="s4">= </span><span class="s5">0</span>
            <span class="s1">f77modulename </span><span class="s4">= </span><span class="s1">l</span>
        <span class="s3">elif </span><span class="s1">f</span><span class="s4">:</span>
            <span class="s3">try</span><span class="s4">:</span>
                <span class="s1">open</span><span class="s4">(</span><span class="s1">l</span><span class="s4">).</span><span class="s1">close</span><span class="s4">()</span>
                <span class="s1">files</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">l</span><span class="s4">)</span>
            <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">detail</span><span class="s4">:</span>
                <span class="s1">errmess</span><span class="s4">(</span><span class="s6">f'OSError: </span><span class="s3">{</span><span class="s1">detail</span><span class="s3">!s}\n</span><span class="s6">'</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">funcs</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">l</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">strictf77 </span><span class="s3">and </span><span class="s1">f77modulename </span><span class="s3">and not </span><span class="s1">skipemptyends</span><span class="s4">:</span>
        <span class="s1">outmess</span><span class="s4">(</span><span class="s6">&quot;&quot;&quot;</span><span class="s3">\ 
  </span><span class="s6">Warning: You have specified module name for non Fortran 77 code that 
  should not need one (expect if you are scanning F90 code for non 
  module blocks but then you should use flag -skipemptyends and also 
  be sure that the files do not contain programs without program 
  statement). 
&quot;&quot;&quot;</span><span class="s4">, </span><span class="s5">0</span><span class="s4">)</span>

    <span class="s1">postlist </span><span class="s4">= </span><span class="s1">crackfortran</span><span class="s4">(</span><span class="s1">files</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">pyffilename</span><span class="s4">:</span>
        <span class="s1">outmess</span><span class="s4">(</span><span class="s6">'Writing fortran code to file %s</span><span class="s3">\n</span><span class="s6">' </span><span class="s4">% </span><span class="s1">repr</span><span class="s4">(</span><span class="s1">pyffilename</span><span class="s4">), </span><span class="s5">0</span><span class="s4">)</span>
        <span class="s1">pyf </span><span class="s4">= </span><span class="s1">crack2fortran</span><span class="s4">(</span><span class="s1">postlist</span><span class="s4">)</span>
        <span class="s3">with </span><span class="s1">open</span><span class="s4">(</span><span class="s1">pyffilename</span><span class="s4">, </span><span class="s6">'w'</span><span class="s4">) </span><span class="s3">as </span><span class="s1">f</span><span class="s4">:</span>
            <span class="s1">f</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s1">pyf</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">showblocklist</span><span class="s4">:</span>
        <span class="s1">show</span><span class="s4">(</span><span class="s1">postlist</span><span class="s4">)</span>
</pre>
</body>
</html>