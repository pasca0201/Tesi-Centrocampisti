<html>
<head>
<title>_decomp.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #2aacb8;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_decomp.py</font>
</center></td></tr></table>
<pre><span class="s0">#</span>
<span class="s0"># Author: Pearu Peterson, March 2002</span>
<span class="s0">#</span>
<span class="s0"># additions by Travis Oliphant, March 2002</span>
<span class="s0"># additions by Eric Jones,      June 2002</span>
<span class="s0"># additions by Johannes Loehnert, June 2006</span>
<span class="s0"># additions by Bart Vandereycken, June 2006</span>
<span class="s0"># additions by Andrew D Straw, May 2007</span>
<span class="s0"># additions by Tiziano Zito, November 2008</span>
<span class="s0">#</span>
<span class="s0"># April 2010: Functions for LU, QR, SVD, Schur, and Cholesky decompositions</span>
<span class="s0"># were moved to their own files. Still in this file are functions for</span>
<span class="s0"># eigenstuff and for the Hessenberg form.</span>

<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">'eig'</span><span class="s2">, </span><span class="s3">'eigvals'</span><span class="s2">, </span><span class="s3">'eigh'</span><span class="s2">, </span><span class="s3">'eigvalsh'</span><span class="s2">,</span>
           <span class="s3">'eig_banded'</span><span class="s2">, </span><span class="s3">'eigvals_banded'</span><span class="s2">,</span>
           <span class="s3">'eigh_tridiagonal'</span><span class="s2">, </span><span class="s3">'eigvalsh_tridiagonal'</span><span class="s2">, </span><span class="s3">'hessenberg'</span><span class="s2">, </span><span class="s3">'cdf2rdf'</span><span class="s2">]</span>

<span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>
<span class="s4">from </span><span class="s1">numpy </span><span class="s4">import </span><span class="s2">(</span><span class="s1">array</span><span class="s2">, </span><span class="s1">isfinite</span><span class="s2">, </span><span class="s1">inexact</span><span class="s2">, </span><span class="s1">nonzero</span><span class="s2">, </span><span class="s1">iscomplexobj</span><span class="s2">,</span>
                   <span class="s1">flatnonzero</span><span class="s2">, </span><span class="s1">conj</span><span class="s2">, </span><span class="s1">asarray</span><span class="s2">, </span><span class="s1">argsort</span><span class="s2">, </span><span class="s1">empty</span><span class="s2">,</span>
                   <span class="s1">iscomplex</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">, </span><span class="s1">einsum</span><span class="s2">, </span><span class="s1">eye</span><span class="s2">, </span><span class="s1">inf</span><span class="s2">)</span>
<span class="s0"># Local imports</span>
<span class="s4">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">_lib</span><span class="s2">.</span><span class="s1">_util </span><span class="s4">import </span><span class="s1">_asarray_validated</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_misc </span><span class="s4">import </span><span class="s1">LinAlgError</span><span class="s2">, </span><span class="s1">_datacopied</span><span class="s2">, </span><span class="s1">norm</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">lapack </span><span class="s4">import </span><span class="s1">get_lapack_funcs</span><span class="s2">, </span><span class="s1">_compute_lwork</span>


<span class="s1">_I </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s5">1j</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">'F'</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">_make_complex_eigvecs</span><span class="s2">(</span><span class="s1">w</span><span class="s2">, </span><span class="s1">vin</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Produce complex-valued eigenvectors from LAPACK DGGEV real-valued output 
    &quot;&quot;&quot;</span>
    <span class="s0"># - see LAPACK man page DGGEV at ALPHAI</span>
    <span class="s1">v </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">vin</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">m </span><span class="s2">= (</span><span class="s1">w</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">)</span>
    <span class="s1">m</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">] |= (</span><span class="s1">w</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:] &lt; </span><span class="s5">0</span><span class="s2">)  </span><span class="s0"># workaround for LAPACK bug, cf. ticket #709</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">flatnonzero</span><span class="s2">(</span><span class="s1">m</span><span class="s2">):</span>
        <span class="s1">v</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">[:, </span><span class="s1">i</span><span class="s2">] = </span><span class="s1">vin</span><span class="s2">[:, </span><span class="s1">i</span><span class="s2">+</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s1">conj</span><span class="s2">(</span><span class="s1">v</span><span class="s2">[:, </span><span class="s1">i</span><span class="s2">], </span><span class="s1">v</span><span class="s2">[:, </span><span class="s1">i</span><span class="s2">+</span><span class="s5">1</span><span class="s2">])</span>
    <span class="s4">return </span><span class="s1">v</span>


<span class="s4">def </span><span class="s1">_make_eigvals</span><span class="s2">(</span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">homogeneous_eigvals</span><span class="s2">):</span>
    <span class="s4">if </span><span class="s1">homogeneous_eigvals</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">beta </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">vstack</span><span class="s2">((</span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones_like</span><span class="s2">(</span><span class="s1">alpha</span><span class="s2">)))</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">vstack</span><span class="s2">((</span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">))</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">beta </span><span class="s4">is None</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">alpha</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">w </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">alpha</span><span class="s2">)</span>
            <span class="s1">alpha_zero </span><span class="s2">= (</span><span class="s1">alpha </span><span class="s2">== </span><span class="s5">0</span><span class="s2">)</span>
            <span class="s1">beta_zero </span><span class="s2">= (</span><span class="s1">beta </span><span class="s2">== </span><span class="s5">0</span><span class="s2">)</span>
            <span class="s1">beta_nonzero </span><span class="s2">= ~</span><span class="s1">beta_zero</span>
            <span class="s1">w</span><span class="s2">[</span><span class="s1">beta_nonzero</span><span class="s2">] = </span><span class="s1">alpha</span><span class="s2">[</span><span class="s1">beta_nonzero</span><span class="s2">]/</span><span class="s1">beta</span><span class="s2">[</span><span class="s1">beta_nonzero</span><span class="s2">]</span>
            <span class="s0"># Use np.inf for complex values too since</span>
            <span class="s0"># 1/np.inf = 0, i.e., it correctly behaves as projective</span>
            <span class="s0"># infinity.</span>
            <span class="s1">w</span><span class="s2">[~</span><span class="s1">alpha_zero </span><span class="s2">&amp; </span><span class="s1">beta_zero</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span>
            <span class="s4">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">alpha</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">== </span><span class="s5">0</span><span class="s2">):</span>
                <span class="s1">w</span><span class="s2">[</span><span class="s1">alpha_zero </span><span class="s2">&amp; </span><span class="s1">beta_zero</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">w</span><span class="s2">[</span><span class="s1">alpha_zero </span><span class="s2">&amp; </span><span class="s1">beta_zero</span><span class="s2">] = </span><span class="s1">complex</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">w</span>


<span class="s4">def </span><span class="s1">_geneig</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">overwrite_a</span><span class="s2">, </span><span class="s1">overwrite_b</span><span class="s2">,</span>
            <span class="s1">homogeneous_eigvals</span><span class="s2">):</span>
    <span class="s1">ggev</span><span class="s2">, = </span><span class="s1">get_lapack_funcs</span><span class="s2">((</span><span class="s3">'ggev'</span><span class="s2">,), (</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">))</span>
    <span class="s1">cvl</span><span class="s2">, </span><span class="s1">cvr </span><span class="s2">= </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">ggev</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">lwork</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s1">lwork </span><span class="s2">= </span><span class="s1">res</span><span class="s2">[-</span><span class="s5">2</span><span class="s2">][</span><span class="s5">0</span><span class="s2">].</span><span class="s1">real</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">int_</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">ggev</span><span class="s2">.</span><span class="s1">typecode </span><span class="s4">in </span><span class="s3">'cz'</span><span class="s2">:</span>
        <span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vr</span><span class="s2">, </span><span class="s1">work</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">ggev</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">cvl</span><span class="s2">, </span><span class="s1">cvr</span><span class="s2">, </span><span class="s1">lwork</span><span class="s2">,</span>
                                               <span class="s1">overwrite_a</span><span class="s2">, </span><span class="s1">overwrite_b</span><span class="s2">)</span>
        <span class="s1">w </span><span class="s2">= </span><span class="s1">_make_eigvals</span><span class="s2">(</span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">homogeneous_eigvals</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">alphar</span><span class="s2">, </span><span class="s1">alphai</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vr</span><span class="s2">, </span><span class="s1">work</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">ggev</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">cvl</span><span class="s2">, </span><span class="s1">cvr</span><span class="s2">,</span>
                                                        <span class="s1">lwork</span><span class="s2">, </span><span class="s1">overwrite_a</span><span class="s2">,</span>
                                                        <span class="s1">overwrite_b</span><span class="s2">)</span>
        <span class="s1">alpha </span><span class="s2">= </span><span class="s1">alphar </span><span class="s2">+ </span><span class="s1">_I </span><span class="s2">* </span><span class="s1">alphai</span>
        <span class="s1">w </span><span class="s2">= </span><span class="s1">_make_eigvals</span><span class="s2">(</span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">homogeneous_eigvals</span><span class="s2">)</span>
    <span class="s1">_check_info</span><span class="s2">(</span><span class="s1">info</span><span class="s2">, </span><span class="s3">'generalized eig algorithm (ggev)'</span><span class="s2">)</span>

    <span class="s1">only_real </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">w</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">== </span><span class="s5">0.0</span><span class="s2">)</span>
    <span class="s4">if not </span><span class="s2">(</span><span class="s1">ggev</span><span class="s2">.</span><span class="s1">typecode </span><span class="s4">in </span><span class="s3">'cz' </span><span class="s4">or </span><span class="s1">only_real</span><span class="s2">):</span>
        <span class="s1">t </span><span class="s2">= </span><span class="s1">w</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span>
        <span class="s4">if </span><span class="s1">left</span><span class="s2">:</span>
            <span class="s1">vl </span><span class="s2">= </span><span class="s1">_make_complex_eigvecs</span><span class="s2">(</span><span class="s1">w</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">t</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">right</span><span class="s2">:</span>
            <span class="s1">vr </span><span class="s2">= </span><span class="s1">_make_complex_eigvecs</span><span class="s2">(</span><span class="s1">w</span><span class="s2">, </span><span class="s1">vr</span><span class="s2">, </span><span class="s1">t</span><span class="s2">)</span>

    <span class="s0"># the eigenvectors returned by the lapack function are NOT normalized</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">vr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]):</span>
        <span class="s4">if </span><span class="s1">right</span><span class="s2">:</span>
            <span class="s1">vr</span><span class="s2">[:, </span><span class="s1">i</span><span class="s2">] /= </span><span class="s1">norm</span><span class="s2">(</span><span class="s1">vr</span><span class="s2">[:, </span><span class="s1">i</span><span class="s2">])</span>
        <span class="s4">if </span><span class="s1">left</span><span class="s2">:</span>
            <span class="s1">vl</span><span class="s2">[:, </span><span class="s1">i</span><span class="s2">] /= </span><span class="s1">norm</span><span class="s2">(</span><span class="s1">vl</span><span class="s2">[:, </span><span class="s1">i</span><span class="s2">])</span>

    <span class="s4">if not </span><span class="s2">(</span><span class="s1">left </span><span class="s4">or </span><span class="s1">right</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">w</span>
    <span class="s4">if </span><span class="s1">left</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">right</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">w</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vr</span>
        <span class="s4">return </span><span class="s1">w</span><span class="s2">, </span><span class="s1">vl</span>
    <span class="s4">return </span><span class="s1">w</span><span class="s2">, </span><span class="s1">vr</span>


<span class="s4">def </span><span class="s1">eig</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">left</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">right</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">overwrite_a</span><span class="s2">=</span><span class="s4">False</span><span class="s2">,</span>
        <span class="s1">overwrite_b</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">homogeneous_eigvals</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Solve an ordinary or generalized eigenvalue problem of a square matrix. 
 
    Find eigenvalues w and right or left eigenvectors of a general matrix:: 
 
        a   vr[:,i] = w[i]        b   vr[:,i] 
        a.H vl[:,i] = w[i].conj() b.H vl[:,i] 
 
    where ``.H`` is the Hermitian conjugation. 
 
    Parameters 
    ---------- 
    a : (M, M) array_like 
        A complex or real matrix whose eigenvalues and eigenvectors 
        will be computed. 
    b : (M, M) array_like, optional 
        Right-hand side matrix in a generalized eigenvalue problem. 
        Default is None, identity matrix is assumed. 
    left : bool, optional 
        Whether to calculate and return left eigenvectors.  Default is False. 
    right : bool, optional 
        Whether to calculate and return right eigenvectors.  Default is True. 
    overwrite_a : bool, optional 
        Whether to overwrite `a`; may improve performance.  Default is False. 
    overwrite_b : bool, optional 
        Whether to overwrite `b`; may improve performance.  Default is False. 
    check_finite : bool, optional 
        Whether to check that the input matrices contain only finite numbers. 
        Disabling may give a performance gain, but may result in problems 
        (crashes, non-termination) if the inputs do contain infinities or NaNs. 
    homogeneous_eigvals : bool, optional 
        If True, return the eigenvalues in homogeneous coordinates. 
        In this case ``w`` is a (2, M) array so that:: 
 
            w[1,i] a vr[:,i] = w[0,i] b vr[:,i] 
 
        Default is False. 
 
    Returns 
    ------- 
    w : (M,) or (2, M) double or complex ndarray 
        The eigenvalues, each repeated according to its 
        multiplicity. The shape is (M,) unless 
        ``homogeneous_eigvals=True``. 
    vl : (M, M) double or complex ndarray 
        The left eigenvector corresponding to the eigenvalue 
        ``w[i]`` is the column ``vl[:,i]``. Only returned if ``left=True``. 
        The left eigenvector is not normalized. 
    vr : (M, M) double or complex ndarray 
        The normalized right eigenvector corresponding to the eigenvalue 
        ``w[i]`` is the column ``vr[:,i]``.  Only returned if ``right=True``. 
 
    Raises 
    ------ 
    LinAlgError 
        If eigenvalue computation does not converge. 
 
    See Also 
    -------- 
    eigvals : eigenvalues of general arrays 
    eigh : Eigenvalues and right eigenvectors for symmetric/Hermitian arrays. 
    eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian 
        band matrices 
    eigh_tridiagonal : eigenvalues and right eiegenvectors for 
        symmetric/Hermitian tridiagonal matrices 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import linalg 
    &gt;&gt;&gt; a = np.array([[0., -1.], [1., 0.]]) 
    &gt;&gt;&gt; linalg.eigvals(a) 
    array([0.+1.j, 0.-1.j]) 
 
    &gt;&gt;&gt; b = np.array([[0., 1.], [1., 1.]]) 
    &gt;&gt;&gt; linalg.eigvals(a, b) 
    array([ 1.+0.j, -1.+0.j]) 
 
    &gt;&gt;&gt; a = np.array([[3., 0., 0.], [0., 8., 0.], [0., 0., 7.]]) 
    &gt;&gt;&gt; linalg.eigvals(a, homogeneous_eigvals=True) 
    array([[3.+0.j, 8.+0.j, 7.+0.j], 
           [1.+0.j, 1.+0.j, 1.+0.j]]) 
 
    &gt;&gt;&gt; a = np.array([[0., -1.], [1., 0.]]) 
    &gt;&gt;&gt; linalg.eigvals(a) == linalg.eig(a)[0] 
    array([ True,  True]) 
    &gt;&gt;&gt; linalg.eig(a, left=True, right=False)[1] # normalized left eigenvector 
    array([[-0.70710678+0.j        , -0.70710678-0.j        ], 
           [-0.        +0.70710678j, -0.        -0.70710678j]]) 
    &gt;&gt;&gt; linalg.eig(a, left=False, right=True)[1] # normalized right eigenvector 
    array([[0.70710678+0.j        , 0.70710678-0.j        ], 
           [0.        -0.70710678j, 0.        +0.70710678j]]) 
 
 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a1 </span><span class="s2">= </span><span class="s1">_asarray_validated</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s1">check_finite</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) != </span><span class="s5">2 </span><span class="s4">or </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] != </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'expected square matrix'</span><span class="s2">)</span>

    <span class="s0"># accommodate square empty matrices</span>
    <span class="s4">if </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">w_n</span><span class="s2">, </span><span class="s1">vr_n </span><span class="s2">= </span><span class="s1">eig</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">eye</span><span class="s2">(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">a1</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">))</span>
        <span class="s1">w </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=(</span><span class="s5">0</span><span class="s2">,), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">w_n</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">w </span><span class="s2">= </span><span class="s1">_make_eigvals</span><span class="s2">(</span><span class="s1">w</span><span class="s2">, </span><span class="s4">None</span><span class="s2">, </span><span class="s1">homogeneous_eigvals</span><span class="s2">)</span>
        <span class="s1">vl </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">vr_n</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">vr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">vr_n</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s2">(</span><span class="s1">left </span><span class="s4">or </span><span class="s1">right</span><span class="s2">):</span>
            <span class="s4">return </span><span class="s1">w</span>
        <span class="s4">if </span><span class="s1">left</span><span class="s2">:</span>
            <span class="s4">if </span><span class="s1">right</span><span class="s2">:</span>
                <span class="s4">return </span><span class="s1">w</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vr</span>
            <span class="s4">return </span><span class="s1">w</span><span class="s2">, </span><span class="s1">vl</span>
        <span class="s4">return </span><span class="s1">w</span><span class="s2">, </span><span class="s1">vr</span>

    <span class="s1">overwrite_a </span><span class="s2">= </span><span class="s1">overwrite_a </span><span class="s4">or </span><span class="s2">(</span><span class="s1">_datacopied</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">a</span><span class="s2">))</span>
    <span class="s4">if </span><span class="s1">b </span><span class="s4">is not None</span><span class="s2">:</span>
        <span class="s1">b1 </span><span class="s2">= </span><span class="s1">_asarray_validated</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s1">check_finite</span><span class="s2">)</span>
        <span class="s1">overwrite_b </span><span class="s2">= </span><span class="s1">overwrite_b </span><span class="s4">or </span><span class="s1">_datacopied</span><span class="s2">(</span><span class="s1">b1</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">b1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) != </span><span class="s5">2 </span><span class="s4">or </span><span class="s1">b1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] != </span><span class="s1">b1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'expected square matrix'</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">b1</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'a and b must have the same shape'</span><span class="s2">)</span>
        <span class="s4">return </span><span class="s1">_geneig</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">, </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">overwrite_a</span><span class="s2">, </span><span class="s1">overwrite_b</span><span class="s2">,</span>
                       <span class="s1">homogeneous_eigvals</span><span class="s2">)</span>

    <span class="s1">geev</span><span class="s2">, </span><span class="s1">geev_lwork </span><span class="s2">= </span><span class="s1">get_lapack_funcs</span><span class="s2">((</span><span class="s3">'geev'</span><span class="s2">, </span><span class="s3">'geev_lwork'</span><span class="s2">), (</span><span class="s1">a1</span><span class="s2">,))</span>
    <span class="s1">compute_vl</span><span class="s2">, </span><span class="s1">compute_vr </span><span class="s2">= </span><span class="s1">left</span><span class="s2">, </span><span class="s1">right</span>

    <span class="s1">lwork </span><span class="s2">= </span><span class="s1">_compute_lwork</span><span class="s2">(</span><span class="s1">geev_lwork</span><span class="s2">, </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">],</span>
                           <span class="s1">compute_vl</span><span class="s2">=</span><span class="s1">compute_vl</span><span class="s2">,</span>
                           <span class="s1">compute_vr</span><span class="s2">=</span><span class="s1">compute_vr</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">geev</span><span class="s2">.</span><span class="s1">typecode </span><span class="s4">in </span><span class="s3">'cz'</span><span class="s2">:</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vr</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">geev</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">lwork</span><span class="s2">=</span><span class="s1">lwork</span><span class="s2">,</span>
                               <span class="s1">compute_vl</span><span class="s2">=</span><span class="s1">compute_vl</span><span class="s2">,</span>
                               <span class="s1">compute_vr</span><span class="s2">=</span><span class="s1">compute_vr</span><span class="s2">,</span>
                               <span class="s1">overwrite_a</span><span class="s2">=</span><span class="s1">overwrite_a</span><span class="s2">)</span>
        <span class="s1">w </span><span class="s2">= </span><span class="s1">_make_eigvals</span><span class="s2">(</span><span class="s1">w</span><span class="s2">, </span><span class="s4">None</span><span class="s2">, </span><span class="s1">homogeneous_eigvals</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">wr</span><span class="s2">, </span><span class="s1">wi</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vr</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">geev</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">lwork</span><span class="s2">=</span><span class="s1">lwork</span><span class="s2">,</span>
                                    <span class="s1">compute_vl</span><span class="s2">=</span><span class="s1">compute_vl</span><span class="s2">,</span>
                                    <span class="s1">compute_vr</span><span class="s2">=</span><span class="s1">compute_vr</span><span class="s2">,</span>
                                    <span class="s1">overwrite_a</span><span class="s2">=</span><span class="s1">overwrite_a</span><span class="s2">)</span>
        <span class="s1">w </span><span class="s2">= </span><span class="s1">wr </span><span class="s2">+ </span><span class="s1">_I </span><span class="s2">* </span><span class="s1">wi</span>
        <span class="s1">w </span><span class="s2">= </span><span class="s1">_make_eigvals</span><span class="s2">(</span><span class="s1">w</span><span class="s2">, </span><span class="s4">None</span><span class="s2">, </span><span class="s1">homogeneous_eigvals</span><span class="s2">)</span>

    <span class="s1">_check_info</span><span class="s2">(</span><span class="s1">info</span><span class="s2">, </span><span class="s3">'eig algorithm (geev)'</span><span class="s2">,</span>
                <span class="s1">positive</span><span class="s2">=</span><span class="s3">'did not converge (only eigenvalues '</span>
                         <span class="s3">'with order &gt;= %d have converged)'</span><span class="s2">)</span>

    <span class="s1">only_real </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">w</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">== </span><span class="s5">0.0</span><span class="s2">)</span>
    <span class="s4">if not </span><span class="s2">(</span><span class="s1">geev</span><span class="s2">.</span><span class="s1">typecode </span><span class="s4">in </span><span class="s3">'cz' </span><span class="s4">or </span><span class="s1">only_real</span><span class="s2">):</span>
        <span class="s1">t </span><span class="s2">= </span><span class="s1">w</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span>
        <span class="s4">if </span><span class="s1">left</span><span class="s2">:</span>
            <span class="s1">vl </span><span class="s2">= </span><span class="s1">_make_complex_eigvecs</span><span class="s2">(</span><span class="s1">w</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">t</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">right</span><span class="s2">:</span>
            <span class="s1">vr </span><span class="s2">= </span><span class="s1">_make_complex_eigvecs</span><span class="s2">(</span><span class="s1">w</span><span class="s2">, </span><span class="s1">vr</span><span class="s2">, </span><span class="s1">t</span><span class="s2">)</span>
    <span class="s4">if not </span><span class="s2">(</span><span class="s1">left </span><span class="s4">or </span><span class="s1">right</span><span class="s2">):</span>
        <span class="s4">return </span><span class="s1">w</span>
    <span class="s4">if </span><span class="s1">left</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">right</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">w</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vr</span>
        <span class="s4">return </span><span class="s1">w</span><span class="s2">, </span><span class="s1">vl</span>
    <span class="s4">return </span><span class="s1">w</span><span class="s2">, </span><span class="s1">vr</span>


<span class="s4">def </span><span class="s1">eigh</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, *, </span><span class="s1">lower</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">eigvals_only</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">overwrite_a</span><span class="s2">=</span><span class="s4">False</span><span class="s2">,</span>
         <span class="s1">overwrite_b</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">type</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">subset_by_index</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
         <span class="s1">subset_by_value</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">driver</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Solve a standard or generalized eigenvalue problem for a complex 
    Hermitian or real symmetric matrix. 
 
    Find eigenvalues array ``w`` and optionally eigenvectors array ``v`` of 
    array ``a``, where ``b`` is positive definite such that for every 
    eigenvalue λ (i-th entry of w) and its eigenvector ``vi`` (i-th column of 
    ``v``) satisfies:: 
 
                      a @ vi = λ * b @ vi 
        vi.conj().T @ a @ vi = λ 
        vi.conj().T @ b @ vi = 1 
 
    In the standard problem, ``b`` is assumed to be the identity matrix. 
 
    Parameters 
    ---------- 
    a : (M, M) array_like 
        A complex Hermitian or real symmetric matrix whose eigenvalues and 
        eigenvectors will be computed. 
    b : (M, M) array_like, optional 
        A complex Hermitian or real symmetric definite positive matrix in. 
        If omitted, identity matrix is assumed. 
    lower : bool, optional 
        Whether the pertinent array data is taken from the lower or upper 
        triangle of ``a`` and, if applicable, ``b``. (Default: lower) 
    eigvals_only : bool, optional 
        Whether to calculate only eigenvalues and no eigenvectors. 
        (Default: both are calculated) 
    subset_by_index : iterable, optional 
        If provided, this two-element iterable defines the start and the end 
        indices of the desired eigenvalues (ascending order and 0-indexed). 
        To return only the second smallest to fifth smallest eigenvalues, 
        ``[1, 4]`` is used. ``[n-3, n-1]`` returns the largest three. Only 
        available with &quot;evr&quot;, &quot;evx&quot;, and &quot;gvx&quot; drivers. The entries are 
        directly converted to integers via ``int()``. 
    subset_by_value : iterable, optional 
        If provided, this two-element iterable defines the half-open interval 
        ``(a, b]`` that, if any, only the eigenvalues between these values 
        are returned. Only available with &quot;evr&quot;, &quot;evx&quot;, and &quot;gvx&quot; drivers. Use 
        ``np.inf`` for the unconstrained ends. 
    driver : str, optional 
        Defines which LAPACK driver should be used. Valid options are &quot;ev&quot;, 
        &quot;evd&quot;, &quot;evr&quot;, &quot;evx&quot; for standard problems and &quot;gv&quot;, &quot;gvd&quot;, &quot;gvx&quot; for 
        generalized (where b is not None) problems. See the Notes section. 
        The default for standard problems is &quot;evr&quot;. For generalized problems, 
        &quot;gvd&quot; is used for full set, and &quot;gvx&quot; for subset requested cases. 
    type : int, optional 
        For the generalized problems, this keyword specifies the problem type 
        to be solved for ``w`` and ``v`` (only takes 1, 2, 3 as possible 
        inputs):: 
 
            1 =&gt;     a @ v = w @ b @ v 
            2 =&gt; a @ b @ v = w @ v 
            3 =&gt; b @ a @ v = w @ v 
 
        This keyword is ignored for standard problems. 
    overwrite_a : bool, optional 
        Whether to overwrite data in ``a`` (may improve performance). Default 
        is False. 
    overwrite_b : bool, optional 
        Whether to overwrite data in ``b`` (may improve performance). Default 
        is False. 
    check_finite : bool, optional 
        Whether to check that the input matrices contain only finite numbers. 
        Disabling may give a performance gain, but may result in problems 
        (crashes, non-termination) if the inputs do contain infinities or NaNs. 
 
    Returns 
    ------- 
    w : (N,) ndarray 
        The N (N&lt;=M) selected eigenvalues, in ascending order, each 
        repeated according to its multiplicity. 
    v : (M, N) ndarray 
        The normalized eigenvector corresponding to the eigenvalue ``w[i]`` is 
        the column ``v[:,i]``. Only returned if ``eigvals_only=False``. 
 
    Raises 
    ------ 
    LinAlgError 
        If eigenvalue computation does not converge, an error occurred, or 
        b matrix is not definite positive. Note that if input matrices are 
        not symmetric or Hermitian, no error will be reported but results will 
        be wrong. 
 
    See Also 
    -------- 
    eigvalsh : eigenvalues of symmetric or Hermitian arrays 
    eig : eigenvalues and right eigenvectors for non-symmetric arrays 
    eigh_tridiagonal : eigenvalues and right eiegenvectors for 
        symmetric/Hermitian tridiagonal matrices 
 
    Notes 
    ----- 
    This function does not check the input array for being Hermitian/symmetric 
    in order to allow for representing arrays with only their upper/lower 
    triangular parts. Also, note that even though not taken into account, 
    finiteness check applies to the whole array and unaffected by &quot;lower&quot; 
    keyword. 
 
    This function uses LAPACK drivers for computations in all possible keyword 
    combinations, prefixed with ``sy`` if arrays are real and ``he`` if 
    complex, e.g., a float array with &quot;evr&quot; driver is solved via 
    &quot;syevr&quot;, complex arrays with &quot;gvx&quot; driver problem is solved via &quot;hegvx&quot; 
    etc. 
 
    As a brief summary, the slowest and the most robust driver is the 
    classical ``&lt;sy/he&gt;ev`` which uses symmetric QR. ``&lt;sy/he&gt;evr`` is seen as 
    the optimal choice for the most general cases. However, there are certain 
    occasions that ``&lt;sy/he&gt;evd`` computes faster at the expense of more 
    memory usage. ``&lt;sy/he&gt;evx``, while still being faster than ``&lt;sy/he&gt;ev``, 
    often performs worse than the rest except when very few eigenvalues are 
    requested for large arrays though there is still no performance guarantee. 
 
    Note that the underlying LAPACK algorithms are different depending on whether 
    `eigvals_only` is True or False --- thus the eigenvalues may differ 
    depending on whether eigenvectors are requested or not. The difference is 
    generally of the order of machine epsilon times the largest eigenvalue, 
    so is likely only visible for zero or nearly zero eigenvalues. 
 
    For the generalized problem, normalization with respect to the given 
    type argument:: 
 
            type 1 and 3 :      v.conj().T @ a @ v = w 
            type 2       : inv(v).conj().T @ a @ inv(v) = w 
 
            type 1 or 2  :      v.conj().T @ b @ v  = I 
            type 3       : v.conj().T @ inv(b) @ v  = I 
 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.linalg import eigh 
    &gt;&gt;&gt; A = np.array([[6, 3, 1, 5], [3, 0, 5, 1], [1, 5, 6, 2], [5, 1, 2, 2]]) 
    &gt;&gt;&gt; w, v = eigh(A) 
    &gt;&gt;&gt; np.allclose(A @ v - v @ np.diag(w), np.zeros((4, 4))) 
    True 
 
    Request only the eigenvalues 
 
    &gt;&gt;&gt; w = eigh(A, eigvals_only=True) 
 
    Request eigenvalues that are less than 10. 
 
    &gt;&gt;&gt; A = np.array([[34, -4, -10, -7, 2], 
    ...               [-4, 7, 2, 12, 0], 
    ...               [-10, 2, 44, 2, -19], 
    ...               [-7, 12, 2, 79, -34], 
    ...               [2, 0, -19, -34, 29]]) 
    &gt;&gt;&gt; eigh(A, eigvals_only=True, subset_by_value=[-np.inf, 10]) 
    array([6.69199443e-07, 9.11938152e+00]) 
 
    Request the second smallest eigenvalue and its eigenvector 
 
    &gt;&gt;&gt; w, v = eigh(A, subset_by_index=[1, 1]) 
    &gt;&gt;&gt; w 
    array([9.11938152]) 
    &gt;&gt;&gt; v.shape  # only a single column is returned 
    (5, 1) 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># set lower</span>
    <span class="s1">uplo </span><span class="s2">= </span><span class="s3">'L' </span><span class="s4">if </span><span class="s1">lower </span><span class="s4">else </span><span class="s3">'U'</span>
    <span class="s0"># Set job for Fortran routines</span>
    <span class="s1">_job </span><span class="s2">= </span><span class="s3">'N' </span><span class="s4">if </span><span class="s1">eigvals_only </span><span class="s4">else </span><span class="s3">'V'</span>

    <span class="s1">drv_str </span><span class="s2">= [</span><span class="s4">None</span><span class="s2">, </span><span class="s3">&quot;ev&quot;</span><span class="s2">, </span><span class="s3">&quot;evd&quot;</span><span class="s2">, </span><span class="s3">&quot;evr&quot;</span><span class="s2">, </span><span class="s3">&quot;evx&quot;</span><span class="s2">, </span><span class="s3">&quot;gv&quot;</span><span class="s2">, </span><span class="s3">&quot;gvd&quot;</span><span class="s2">, </span><span class="s3">&quot;gvx&quot;</span><span class="s2">]</span>
    <span class="s4">if </span><span class="s1">driver </span><span class="s4">not in </span><span class="s1">drv_str</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'&quot;{}&quot; is unknown. Possible values are &quot;None&quot;, &quot;{}&quot;.'</span>
                         <span class="s3">''</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">driver</span><span class="s2">, </span><span class="s3">'&quot;, &quot;'</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">drv_str</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:])))</span>

    <span class="s1">a1 </span><span class="s2">= </span><span class="s1">_asarray_validated</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s1">check_finite</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) != </span><span class="s5">2 </span><span class="s4">or </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] != </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'expected square &quot;a&quot; matrix'</span><span class="s2">)</span>

    <span class="s0"># accommodate square empty matrices</span>
    <span class="s4">if </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">w_n</span><span class="s2">, </span><span class="s1">v_n </span><span class="s2">= </span><span class="s1">eigh</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">eye</span><span class="s2">(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">a1</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">))</span>

        <span class="s1">w </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=(</span><span class="s5">0</span><span class="s2">,), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">w_n</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">v </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">v_n</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">eigvals_only</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">w</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">w</span><span class="s2">, </span><span class="s1">v</span>

    <span class="s1">overwrite_a </span><span class="s2">= </span><span class="s1">overwrite_a </span><span class="s4">or </span><span class="s2">(</span><span class="s1">_datacopied</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">a</span><span class="s2">))</span>
    <span class="s1">cplx </span><span class="s2">= </span><span class="s4">True if </span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">) </span><span class="s4">else False</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
    <span class="s1">drv_args </span><span class="s2">= {</span><span class="s3">'overwrite_a'</span><span class="s2">: </span><span class="s1">overwrite_a</span><span class="s2">}</span>

    <span class="s4">if </span><span class="s1">b </span><span class="s4">is not None</span><span class="s2">:</span>
        <span class="s1">b1 </span><span class="s2">= </span><span class="s1">_asarray_validated</span><span class="s2">(</span><span class="s1">b</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s1">check_finite</span><span class="s2">)</span>
        <span class="s1">overwrite_b </span><span class="s2">= </span><span class="s1">overwrite_b </span><span class="s4">or </span><span class="s1">_datacopied</span><span class="s2">(</span><span class="s1">b1</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">b1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) != </span><span class="s5">2 </span><span class="s4">or </span><span class="s1">b1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] != </span><span class="s1">b1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'expected square &quot;b&quot; matrix'</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">b1</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f&quot;wrong b dimensions </span><span class="s4">{</span><span class="s1">b1</span><span class="s2">.</span><span class="s1">shape</span><span class="s4">}</span><span class="s3">, should be </span><span class="s4">{</span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s4">}</span><span class="s3">&quot;</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">type </span><span class="s4">not in </span><span class="s2">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">]:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'&quot;type&quot; keyword only accepts 1, 2, and 3.'</span><span class="s2">)</span>

        <span class="s1">cplx </span><span class="s2">= </span><span class="s4">True if </span><span class="s1">iscomplexobj</span><span class="s2">(</span><span class="s1">b1</span><span class="s2">) </span><span class="s4">else </span><span class="s2">(</span><span class="s1">cplx </span><span class="s4">or False</span><span class="s2">)</span>
        <span class="s1">drv_args</span><span class="s2">.</span><span class="s1">update</span><span class="s2">({</span><span class="s3">'overwrite_b'</span><span class="s2">: </span><span class="s1">overwrite_b</span><span class="s2">, </span><span class="s3">'itype'</span><span class="s2">: </span><span class="s1">type</span><span class="s2">})</span>

    <span class="s1">subset </span><span class="s2">= (</span><span class="s1">subset_by_index </span><span class="s4">is not None</span><span class="s2">) </span><span class="s4">or </span><span class="s2">(</span><span class="s1">subset_by_value </span><span class="s4">is not None</span><span class="s2">)</span>

    <span class="s0"># Both subsets can't be given</span>
    <span class="s4">if </span><span class="s1">subset_by_index </span><span class="s4">and </span><span class="s1">subset_by_value</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'Either index or value subset can be requested.'</span><span class="s2">)</span>

    <span class="s0"># Check indices if given</span>
    <span class="s4">if </span><span class="s1">subset_by_index</span><span class="s2">:</span>
        <span class="s1">lo</span><span class="s2">, </span><span class="s1">hi </span><span class="s2">= (</span><span class="s1">int</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) </span><span class="s4">for </span><span class="s1">x </span><span class="s4">in </span><span class="s1">subset_by_index</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">&lt;= </span><span class="s1">lo </span><span class="s2">&lt;= </span><span class="s1">hi </span><span class="s2">&lt; </span><span class="s1">n</span><span class="s2">):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'Requested eigenvalue indices are not valid. '</span>
                             <span class="s3">f'Valid range is [0, </span><span class="s4">{</span><span class="s1">n</span><span class="s2">-</span><span class="s5">1</span><span class="s4">}</span><span class="s3">] and start &lt;= end, but '</span>
                             <span class="s3">f'start=</span><span class="s4">{</span><span class="s1">lo</span><span class="s4">}</span><span class="s3">, end=</span><span class="s4">{</span><span class="s1">hi</span><span class="s4">} </span><span class="s3">is given'</span><span class="s2">)</span>
        <span class="s0"># fortran is 1-indexed</span>
        <span class="s1">drv_args</span><span class="s2">.</span><span class="s1">update</span><span class="s2">({</span><span class="s3">'range'</span><span class="s2">: </span><span class="s3">'I'</span><span class="s2">, </span><span class="s3">'il'</span><span class="s2">: </span><span class="s1">lo </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">, </span><span class="s3">'iu'</span><span class="s2">: </span><span class="s1">hi </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">})</span>

    <span class="s4">if </span><span class="s1">subset_by_value</span><span class="s2">:</span>
        <span class="s1">lo</span><span class="s2">, </span><span class="s1">hi </span><span class="s2">= </span><span class="s1">subset_by_value</span>
        <span class="s4">if not </span><span class="s2">(-</span><span class="s1">inf </span><span class="s2">&lt;= </span><span class="s1">lo </span><span class="s2">&lt; </span><span class="s1">hi </span><span class="s2">&lt;= </span><span class="s1">inf</span><span class="s2">):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'Requested eigenvalue bounds are not valid. '</span>
                             <span class="s3">'Valid range is (-inf, inf) and low &lt; high, but '</span>
                             <span class="s3">f'low=</span><span class="s4">{</span><span class="s1">lo</span><span class="s4">}</span><span class="s3">, high=</span><span class="s4">{</span><span class="s1">hi</span><span class="s4">} </span><span class="s3">is given'</span><span class="s2">)</span>

        <span class="s1">drv_args</span><span class="s2">.</span><span class="s1">update</span><span class="s2">({</span><span class="s3">'range'</span><span class="s2">: </span><span class="s3">'V'</span><span class="s2">, </span><span class="s3">'vl'</span><span class="s2">: </span><span class="s1">lo</span><span class="s2">, </span><span class="s3">'vu'</span><span class="s2">: </span><span class="s1">hi</span><span class="s2">})</span>

    <span class="s0"># fix prefix for lapack routines</span>
    <span class="s1">pfx </span><span class="s2">= </span><span class="s3">'he' </span><span class="s4">if </span><span class="s1">cplx </span><span class="s4">else </span><span class="s3">'sy'</span>

    <span class="s0"># decide on the driver if not given</span>
    <span class="s0"># first early exit on incompatible choice</span>
    <span class="s4">if </span><span class="s1">driver</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">b </span><span class="s4">is None and </span><span class="s2">(</span><span class="s1">driver </span><span class="s4">in </span><span class="s2">[</span><span class="s3">&quot;gv&quot;</span><span class="s2">, </span><span class="s3">&quot;gvd&quot;</span><span class="s2">, </span><span class="s3">&quot;gvx&quot;</span><span class="s2">]):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'</span><span class="s4">{</span><span class="s1">driver</span><span class="s4">} </span><span class="s3">requires input b array to be supplied '</span>
                             <span class="s3">'for generalized eigenvalue problems.'</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s1">b </span><span class="s4">is not None</span><span class="s2">) </span><span class="s4">and </span><span class="s2">(</span><span class="s1">driver </span><span class="s4">in </span><span class="s2">[</span><span class="s3">'ev'</span><span class="s2">, </span><span class="s3">'evd'</span><span class="s2">, </span><span class="s3">'evr'</span><span class="s2">, </span><span class="s3">'evx'</span><span class="s2">]):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'&quot;</span><span class="s4">{</span><span class="s1">driver</span><span class="s4">}</span><span class="s3">&quot; does not accept input b array '</span>
                             <span class="s3">'for standard eigenvalue problems.'</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">subset </span><span class="s4">and </span><span class="s2">(</span><span class="s1">driver </span><span class="s4">in </span><span class="s2">[</span><span class="s3">&quot;ev&quot;</span><span class="s2">, </span><span class="s3">&quot;evd&quot;</span><span class="s2">, </span><span class="s3">&quot;gv&quot;</span><span class="s2">, </span><span class="s3">&quot;gvd&quot;</span><span class="s2">]):</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'&quot;</span><span class="s4">{</span><span class="s1">driver</span><span class="s4">}</span><span class="s3">&quot; cannot compute subsets of eigenvalues'</span><span class="s2">)</span>

    <span class="s0"># Default driver is evr and gvd</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">driver </span><span class="s2">= </span><span class="s3">&quot;evr&quot; </span><span class="s4">if </span><span class="s1">b </span><span class="s4">is None else </span><span class="s2">(</span><span class="s3">&quot;gvx&quot; </span><span class="s4">if </span><span class="s1">subset </span><span class="s4">else </span><span class="s3">&quot;gvd&quot;</span><span class="s2">)</span>

    <span class="s1">lwork_spec </span><span class="s2">= {</span>
                  <span class="s3">'syevd'</span><span class="s2">: [</span><span class="s3">'lwork'</span><span class="s2">, </span><span class="s3">'liwork'</span><span class="s2">],</span>
                  <span class="s3">'syevr'</span><span class="s2">: [</span><span class="s3">'lwork'</span><span class="s2">, </span><span class="s3">'liwork'</span><span class="s2">],</span>
                  <span class="s3">'heevd'</span><span class="s2">: [</span><span class="s3">'lwork'</span><span class="s2">, </span><span class="s3">'liwork'</span><span class="s2">, </span><span class="s3">'lrwork'</span><span class="s2">],</span>
                  <span class="s3">'heevr'</span><span class="s2">: [</span><span class="s3">'lwork'</span><span class="s2">, </span><span class="s3">'lrwork'</span><span class="s2">, </span><span class="s3">'liwork'</span><span class="s2">],</span>
                  <span class="s2">}</span>

    <span class="s4">if </span><span class="s1">b </span><span class="s4">is None</span><span class="s2">:  </span><span class="s0"># Standard problem</span>
        <span class="s1">drv</span><span class="s2">, </span><span class="s1">drvlw </span><span class="s2">= </span><span class="s1">get_lapack_funcs</span><span class="s2">((</span><span class="s1">pfx </span><span class="s2">+ </span><span class="s1">driver</span><span class="s2">, </span><span class="s1">pfx</span><span class="s2">+</span><span class="s1">driver</span><span class="s2">+</span><span class="s3">'_lwork'</span><span class="s2">),</span>
                                      <span class="s2">[</span><span class="s1">a1</span><span class="s2">])</span>
        <span class="s1">clw_args </span><span class="s2">= {</span><span class="s3">'n'</span><span class="s2">: </span><span class="s1">n</span><span class="s2">, </span><span class="s3">'lower'</span><span class="s2">: </span><span class="s1">lower</span><span class="s2">}</span>
        <span class="s4">if </span><span class="s1">driver </span><span class="s2">== </span><span class="s3">'evd'</span><span class="s2">:</span>
            <span class="s1">clw_args</span><span class="s2">.</span><span class="s1">update</span><span class="s2">({</span><span class="s3">'compute_v'</span><span class="s2">: </span><span class="s5">0 </span><span class="s4">if </span><span class="s1">_job </span><span class="s2">== </span><span class="s3">&quot;N&quot; </span><span class="s4">else </span><span class="s5">1</span><span class="s2">})</span>

        <span class="s1">lw </span><span class="s2">= </span><span class="s1">_compute_lwork</span><span class="s2">(</span><span class="s1">drvlw</span><span class="s2">, **</span><span class="s1">clw_args</span><span class="s2">)</span>
        <span class="s0"># Multiple lwork vars</span>
        <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">lw</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
            <span class="s1">lwork_args </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">lwork_spec</span><span class="s2">[</span><span class="s1">pfx</span><span class="s2">+</span><span class="s1">driver</span><span class="s2">], </span><span class="s1">lw</span><span class="s2">))</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">lwork_args </span><span class="s2">= {</span><span class="s3">'lwork'</span><span class="s2">: </span><span class="s1">lw</span><span class="s2">}</span>

        <span class="s1">drv_args</span><span class="s2">.</span><span class="s1">update</span><span class="s2">({</span><span class="s3">'lower'</span><span class="s2">: </span><span class="s1">lower</span><span class="s2">, </span><span class="s3">'compute_v'</span><span class="s2">: </span><span class="s5">0 </span><span class="s4">if </span><span class="s1">_job </span><span class="s2">== </span><span class="s3">&quot;N&quot; </span><span class="s4">else </span><span class="s5">1</span><span class="s2">})</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, *</span><span class="s1">other_args</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">drv</span><span class="s2">(</span><span class="s1">a</span><span class="s2">=</span><span class="s1">a1</span><span class="s2">, **</span><span class="s1">drv_args</span><span class="s2">, **</span><span class="s1">lwork_args</span><span class="s2">)</span>

    <span class="s4">else</span><span class="s2">:  </span><span class="s0"># Generalized problem</span>
        <span class="s0"># 'gvd' doesn't have lwork query</span>
        <span class="s4">if </span><span class="s1">driver </span><span class="s2">== </span><span class="s3">&quot;gvd&quot;</span><span class="s2">:</span>
            <span class="s1">drv </span><span class="s2">= </span><span class="s1">get_lapack_funcs</span><span class="s2">(</span><span class="s1">pfx </span><span class="s2">+ </span><span class="s3">&quot;gvd&quot;</span><span class="s2">, [</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">])</span>
            <span class="s1">lwork_args </span><span class="s2">= {}</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">drv</span><span class="s2">, </span><span class="s1">drvlw </span><span class="s2">= </span><span class="s1">get_lapack_funcs</span><span class="s2">((</span><span class="s1">pfx </span><span class="s2">+ </span><span class="s1">driver</span><span class="s2">, </span><span class="s1">pfx</span><span class="s2">+</span><span class="s1">driver</span><span class="s2">+</span><span class="s3">'_lwork'</span><span class="s2">),</span>
                                          <span class="s2">[</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">b1</span><span class="s2">])</span>
            <span class="s0"># generalized drivers use uplo instead of lower</span>
            <span class="s1">lw </span><span class="s2">= </span><span class="s1">_compute_lwork</span><span class="s2">(</span><span class="s1">drvlw</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">uplo</span><span class="s2">=</span><span class="s1">uplo</span><span class="s2">)</span>
            <span class="s1">lwork_args </span><span class="s2">= {</span><span class="s3">'lwork'</span><span class="s2">: </span><span class="s1">lw</span><span class="s2">}</span>

        <span class="s1">drv_args</span><span class="s2">.</span><span class="s1">update</span><span class="s2">({</span><span class="s3">'uplo'</span><span class="s2">: </span><span class="s1">uplo</span><span class="s2">, </span><span class="s3">'jobz'</span><span class="s2">: </span><span class="s1">_job</span><span class="s2">})</span>

        <span class="s1">w</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, *</span><span class="s1">other_args</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">drv</span><span class="s2">(</span><span class="s1">a</span><span class="s2">=</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">b</span><span class="s2">=</span><span class="s1">b1</span><span class="s2">, **</span><span class="s1">drv_args</span><span class="s2">, **</span><span class="s1">lwork_args</span><span class="s2">)</span>

    <span class="s0"># m is always the first extra argument</span>
    <span class="s1">w </span><span class="s2">= </span><span class="s1">w</span><span class="s2">[:</span><span class="s1">other_args</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]] </span><span class="s4">if </span><span class="s1">subset </span><span class="s4">else </span><span class="s1">w</span>
    <span class="s1">v </span><span class="s2">= </span><span class="s1">v</span><span class="s2">[:, :</span><span class="s1">other_args</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]] </span><span class="s4">if </span><span class="s2">(</span><span class="s1">subset </span><span class="s4">and not </span><span class="s1">eigvals_only</span><span class="s2">) </span><span class="s4">else </span><span class="s1">v</span>

    <span class="s0"># Check if we had a  successful exit</span>
    <span class="s4">if </span><span class="s1">info </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">eigvals_only</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">w</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">w</span><span class="s2">, </span><span class="s1">v</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">info </span><span class="s2">&lt; -</span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">LinAlgError</span><span class="s2">(</span><span class="s3">f'Illegal value in argument </span><span class="s4">{</span><span class="s2">-</span><span class="s1">info</span><span class="s4">} </span><span class="s3">of internal '</span>
                              <span class="s3">f'</span><span class="s4">{</span><span class="s1">drv</span><span class="s2">.</span><span class="s1">typecode </span><span class="s2">+ </span><span class="s1">pfx </span><span class="s2">+ </span><span class="s1">driver</span><span class="s4">}</span><span class="s3">'</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s1">info </span><span class="s2">&gt; </span><span class="s1">n</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">LinAlgError</span><span class="s2">(</span><span class="s3">f'The leading minor of order </span><span class="s4">{</span><span class="s1">info</span><span class="s2">-</span><span class="s1">n</span><span class="s4">} </span><span class="s3">of B is not '</span>
                              <span class="s3">'positive definite. The factorization of B '</span>
                              <span class="s3">'could not be completed and no eigenvalues '</span>
                              <span class="s3">'or eigenvectors were computed.'</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">drv_err </span><span class="s2">= {</span><span class="s3">'ev'</span><span class="s2">: </span><span class="s3">'The algorithm failed to converge; {} '</span>
                             <span class="s3">'off-diagonal elements of an intermediate '</span>
                             <span class="s3">'tridiagonal form did not converge to zero.'</span><span class="s2">,</span>
                       <span class="s3">'evx'</span><span class="s2">: </span><span class="s3">'{} eigenvectors failed to converge.'</span><span class="s2">,</span>
                       <span class="s3">'evd'</span><span class="s2">: </span><span class="s3">'The algorithm failed to compute an eigenvalue '</span>
                              <span class="s3">'while working on the submatrix lying in rows '</span>
                              <span class="s3">'and columns {0}/{1} through mod({0},{1}).'</span><span class="s2">,</span>
                       <span class="s3">'evr'</span><span class="s2">: </span><span class="s3">'Internal Error.'</span>
                       <span class="s2">}</span>
            <span class="s4">if </span><span class="s1">driver </span><span class="s4">in </span><span class="s2">[</span><span class="s3">'ev'</span><span class="s2">, </span><span class="s3">'gv'</span><span class="s2">]:</span>
                <span class="s1">msg </span><span class="s2">= </span><span class="s1">drv_err</span><span class="s2">[</span><span class="s3">'ev'</span><span class="s2">].</span><span class="s1">format</span><span class="s2">(</span><span class="s1">info</span><span class="s2">)</span>
            <span class="s4">elif </span><span class="s1">driver </span><span class="s4">in </span><span class="s2">[</span><span class="s3">'evx'</span><span class="s2">, </span><span class="s3">'gvx'</span><span class="s2">]:</span>
                <span class="s1">msg </span><span class="s2">= </span><span class="s1">drv_err</span><span class="s2">[</span><span class="s3">'evx'</span><span class="s2">].</span><span class="s1">format</span><span class="s2">(</span><span class="s1">info</span><span class="s2">)</span>
            <span class="s4">elif </span><span class="s1">driver </span><span class="s4">in </span><span class="s2">[</span><span class="s3">'evd'</span><span class="s2">, </span><span class="s3">'gvd'</span><span class="s2">]:</span>
                <span class="s4">if </span><span class="s1">eigvals_only</span><span class="s2">:</span>
                    <span class="s1">msg </span><span class="s2">= </span><span class="s1">drv_err</span><span class="s2">[</span><span class="s3">'ev'</span><span class="s2">].</span><span class="s1">format</span><span class="s2">(</span><span class="s1">info</span><span class="s2">)</span>
                <span class="s4">else</span><span class="s2">:</span>
                    <span class="s1">msg </span><span class="s2">= </span><span class="s1">drv_err</span><span class="s2">[</span><span class="s3">'evd'</span><span class="s2">].</span><span class="s1">format</span><span class="s2">(</span><span class="s1">info</span><span class="s2">, </span><span class="s1">n</span><span class="s2">+</span><span class="s5">1</span><span class="s2">)</span>
            <span class="s4">else</span><span class="s2">:</span>
                <span class="s1">msg </span><span class="s2">= </span><span class="s1">drv_err</span><span class="s2">[</span><span class="s3">'evr'</span><span class="s2">]</span>

            <span class="s4">raise </span><span class="s1">LinAlgError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>


<span class="s1">_conv_dict </span><span class="s2">= {</span><span class="s5">0</span><span class="s2">: </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">: </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">: </span><span class="s5">2</span><span class="s2">,</span>
              <span class="s3">'all'</span><span class="s2">: </span><span class="s5">0</span><span class="s2">, </span><span class="s3">'value'</span><span class="s2">: </span><span class="s5">1</span><span class="s2">, </span><span class="s3">'index'</span><span class="s2">: </span><span class="s5">2</span><span class="s2">,</span>
              <span class="s3">'a'</span><span class="s2">: </span><span class="s5">0</span><span class="s2">, </span><span class="s3">'v'</span><span class="s2">: </span><span class="s5">1</span><span class="s2">, </span><span class="s3">'i'</span><span class="s2">: </span><span class="s5">2</span><span class="s2">}</span>


<span class="s4">def </span><span class="s1">_check_select</span><span class="s2">(</span><span class="s1">select</span><span class="s2">, </span><span class="s1">select_range</span><span class="s2">, </span><span class="s1">max_ev</span><span class="s2">, </span><span class="s1">max_len</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Check that select is valid, convert to Fortran style.&quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">select</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
        <span class="s1">select </span><span class="s2">= </span><span class="s1">select</span><span class="s2">.</span><span class="s1">lower</span><span class="s2">()</span>
    <span class="s4">try</span><span class="s2">:</span>
        <span class="s1">select </span><span class="s2">= </span><span class="s1">_conv_dict</span><span class="s2">[</span><span class="s1">select</span><span class="s2">]</span>
    <span class="s4">except </span><span class="s1">KeyError </span><span class="s4">as </span><span class="s1">e</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'invalid argument for select'</span><span class="s2">) </span><span class="s4">from </span><span class="s1">e</span>
    <span class="s1">vl</span><span class="s2">, </span><span class="s1">vu </span><span class="s2">= </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">1.</span>
    <span class="s1">il </span><span class="s2">= </span><span class="s1">iu </span><span class="s2">= </span><span class="s5">1</span>
    <span class="s4">if </span><span class="s1">select </span><span class="s2">!= </span><span class="s5">0</span><span class="s2">:  </span><span class="s0"># (non-all)</span>
        <span class="s1">sr </span><span class="s2">= </span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">select_range</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">sr</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">1 </span><span class="s4">or </span><span class="s1">sr</span><span class="s2">.</span><span class="s1">size </span><span class="s2">!= </span><span class="s5">2 </span><span class="s4">or </span><span class="s1">sr</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] &lt; </span><span class="s1">sr</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'select_range must be a 2-element array-like '</span>
                             <span class="s3">'in nondecreasing order'</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">select </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:  </span><span class="s0"># (value)</span>
            <span class="s1">vl</span><span class="s2">, </span><span class="s1">vu </span><span class="s2">= </span><span class="s1">sr</span>
            <span class="s4">if </span><span class="s1">max_ev </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s1">max_ev </span><span class="s2">= </span><span class="s1">max_len</span>
        <span class="s4">else</span><span class="s2">:  </span><span class="s0"># 2 (index)</span>
            <span class="s4">if </span><span class="s1">sr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">.</span><span class="s1">lower</span><span class="s2">() </span><span class="s4">not in </span><span class="s3">'hilqp'</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s3">f'when using select=&quot;i&quot;, select_range must '</span>
                    <span class="s3">f'contain integers, got dtype </span><span class="s4">{</span><span class="s1">sr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s4">} </span><span class="s3">(</span><span class="s4">{</span><span class="s1">sr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s4">}</span><span class="s3">)'</span>
                <span class="s2">)</span>
            <span class="s0"># translate Python (0 ... N-1) into Fortran (1 ... N) with + 1</span>
            <span class="s1">il</span><span class="s2">, </span><span class="s1">iu </span><span class="s2">= </span><span class="s1">sr </span><span class="s2">+ </span><span class="s5">1</span>
            <span class="s4">if </span><span class="s1">min</span><span class="s2">(</span><span class="s1">il</span><span class="s2">, </span><span class="s1">iu</span><span class="s2">) &lt; </span><span class="s5">1 </span><span class="s4">or </span><span class="s1">max</span><span class="s2">(</span><span class="s1">il</span><span class="s2">, </span><span class="s1">iu</span><span class="s2">) &gt; </span><span class="s1">max_len</span><span class="s2">:</span>
                <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'select_range out of bounds'</span><span class="s2">)</span>
            <span class="s1">max_ev </span><span class="s2">= </span><span class="s1">iu </span><span class="s2">- </span><span class="s1">il </span><span class="s2">+ </span><span class="s5">1</span>
    <span class="s4">return </span><span class="s1">select</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vu</span><span class="s2">, </span><span class="s1">il</span><span class="s2">, </span><span class="s1">iu</span><span class="s2">, </span><span class="s1">max_ev</span>


<span class="s4">def </span><span class="s1">eig_banded</span><span class="s2">(</span><span class="s1">a_band</span><span class="s2">, </span><span class="s1">lower</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">eigvals_only</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">overwrite_a_band</span><span class="s2">=</span><span class="s4">False</span><span class="s2">,</span>
               <span class="s1">select</span><span class="s2">=</span><span class="s3">'a'</span><span class="s2">, </span><span class="s1">select_range</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">max_ev</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s4">True</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Solve real symmetric or complex Hermitian band matrix eigenvalue problem. 
 
    Find eigenvalues w and optionally right eigenvectors v of a:: 
 
        a v[:,i] = w[i] v[:,i] 
        v.H v    = identity 
 
    The matrix a is stored in a_band either in lower diagonal or upper 
    diagonal ordered form: 
 
        a_band[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j) 
        a_band[    i - j, j] == a[i,j]        (if lower form; i &gt;= j) 
 
    where u is the number of bands above the diagonal. 
 
    Example of a_band (shape of a is (6,6), u=2):: 
 
        upper form: 
        *   *   a02 a13 a24 a35 
        *   a01 a12 a23 a34 a45 
        a00 a11 a22 a33 a44 a55 
 
        lower form: 
        a00 a11 a22 a33 a44 a55 
        a10 a21 a32 a43 a54 * 
        a20 a31 a42 a53 *   * 
 
    Cells marked with * are not used. 
 
    Parameters 
    ---------- 
    a_band : (u+1, M) array_like 
        The bands of the M by M matrix a. 
    lower : bool, optional 
        Is the matrix in the lower form. (Default is upper form) 
    eigvals_only : bool, optional 
        Compute only the eigenvalues and no eigenvectors. 
        (Default: calculate also eigenvectors) 
    overwrite_a_band : bool, optional 
        Discard data in a_band (may enhance performance) 
    select : {'a', 'v', 'i'}, optional 
        Which eigenvalues to calculate 
 
        ======  ======================================== 
        select  calculated 
        ======  ======================================== 
        'a'     All eigenvalues 
        'v'     Eigenvalues in the interval (min, max] 
        'i'     Eigenvalues with indices min &lt;= i &lt;= max 
        ======  ======================================== 
    select_range : (min, max), optional 
        Range of selected eigenvalues 
    max_ev : int, optional 
        For select=='v', maximum number of eigenvalues expected. 
        For other values of select, has no meaning. 
 
        In doubt, leave this parameter untouched. 
 
    check_finite : bool, optional 
        Whether to check that the input matrix contains only finite numbers. 
        Disabling may give a performance gain, but may result in problems 
        (crashes, non-termination) if the inputs do contain infinities or NaNs. 
 
    Returns 
    ------- 
    w : (M,) ndarray 
        The eigenvalues, in ascending order, each repeated according to its 
        multiplicity. 
    v : (M, M) float or complex ndarray 
        The normalized eigenvector corresponding to the eigenvalue w[i] is 
        the column v[:,i]. Only returned if ``eigvals_only=False``. 
 
    Raises 
    ------ 
    LinAlgError 
        If eigenvalue computation does not converge. 
 
    See Also 
    -------- 
    eigvals_banded : eigenvalues for symmetric/Hermitian band matrices 
    eig : eigenvalues and right eigenvectors of general arrays. 
    eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays 
    eigh_tridiagonal : eigenvalues and right eigenvectors for 
        symmetric/Hermitian tridiagonal matrices 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.linalg import eig_banded 
    &gt;&gt;&gt; A = np.array([[1, 5, 2, 0], [5, 2, 5, 2], [2, 5, 3, 5], [0, 2, 5, 4]]) 
    &gt;&gt;&gt; Ab = np.array([[1, 2, 3, 4], [5, 5, 5, 0], [2, 2, 0, 0]]) 
    &gt;&gt;&gt; w, v = eig_banded(Ab, lower=True) 
    &gt;&gt;&gt; np.allclose(A @ v - v @ np.diag(w), np.zeros((4, 4))) 
    True 
    &gt;&gt;&gt; w = eig_banded(Ab, lower=True, eigvals_only=True) 
    &gt;&gt;&gt; w 
    array([-4.26200532, -2.22987175,  3.95222349, 12.53965359]) 
 
    Request only the eigenvalues between ``[-3, 4]`` 
 
    &gt;&gt;&gt; w, v = eig_banded(Ab, lower=True, select='v', select_range=[-3, 4]) 
    &gt;&gt;&gt; w 
    array([-2.22987175,  3.95222349]) 
 
    &quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">eigvals_only </span><span class="s4">or </span><span class="s1">overwrite_a_band</span><span class="s2">:</span>
        <span class="s1">a1 </span><span class="s2">= </span><span class="s1">_asarray_validated</span><span class="s2">(</span><span class="s1">a_band</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s1">check_finite</span><span class="s2">)</span>
        <span class="s1">overwrite_a_band </span><span class="s2">= </span><span class="s1">overwrite_a_band </span><span class="s4">or </span><span class="s2">(</span><span class="s1">_datacopied</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">a_band</span><span class="s2">))</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">a1 </span><span class="s2">= </span><span class="s1">array</span><span class="s2">(</span><span class="s1">a_band</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">issubclass</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">, </span><span class="s1">inexact</span><span class="s2">) </span><span class="s4">and not </span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">).</span><span class="s1">all</span><span class="s2">():</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;array must not contain infs or NaNs&quot;</span><span class="s2">)</span>
        <span class="s1">overwrite_a_band </span><span class="s2">= </span><span class="s5">1</span>

    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) != </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'expected a 2-D array'</span><span class="s2">)</span>

    <span class="s0"># accommodate square empty matrices</span>
    <span class="s4">if </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">w_n</span><span class="s2">, </span><span class="s1">v_n </span><span class="s2">= </span><span class="s1">eig_banded</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">], [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">a1</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">))</span>

        <span class="s1">w </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=(</span><span class="s5">0</span><span class="s2">,), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">w_n</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">v </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">v_n</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">eigvals_only</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">w</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">w</span><span class="s2">, </span><span class="s1">v</span>

    <span class="s1">select</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vu</span><span class="s2">, </span><span class="s1">il</span><span class="s2">, </span><span class="s1">iu</span><span class="s2">, </span><span class="s1">max_ev </span><span class="s2">= </span><span class="s1">_check_select</span><span class="s2">(</span>
        <span class="s1">select</span><span class="s2">, </span><span class="s1">select_range</span><span class="s2">, </span><span class="s1">max_ev</span><span class="s2">, </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">])</span>

    <span class="s4">del </span><span class="s1">select_range</span>
    <span class="s4">if </span><span class="s1">select </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char </span><span class="s4">in </span><span class="s3">'GFD'</span><span class="s2">:</span>
            <span class="s0"># FIXME: implement this somewhen, for now go with builtin values</span>
            <span class="s0"># FIXME: calc optimal lwork by calling ?hbevd(lwork=-1)</span>
            <span class="s0">#        or by using calc_lwork.f ???</span>
            <span class="s0"># lwork = calc_lwork.hbevd(bevd.typecode, a1.shape[0], lower)</span>
            <span class="s1">internal_name </span><span class="s2">= </span><span class="s3">'hbevd'</span>
        <span class="s4">else</span><span class="s2">:  </span><span class="s0"># a1.dtype.char in 'fd':</span>
            <span class="s0"># FIXME: implement this somewhen, for now go with builtin values</span>
            <span class="s0">#         see above</span>
            <span class="s0"># lwork = calc_lwork.sbevd(bevd.typecode, a1.shape[0], lower)</span>
            <span class="s1">internal_name </span><span class="s2">= </span><span class="s3">'sbevd'</span>
        <span class="s1">bevd</span><span class="s2">, = </span><span class="s1">get_lapack_funcs</span><span class="s2">((</span><span class="s1">internal_name</span><span class="s2">,), (</span><span class="s1">a1</span><span class="s2">,))</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">bevd</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">compute_v</span><span class="s2">=</span><span class="s4">not </span><span class="s1">eigvals_only</span><span class="s2">,</span>
                          <span class="s1">lower</span><span class="s2">=</span><span class="s1">lower</span><span class="s2">, </span><span class="s1">overwrite_ab</span><span class="s2">=</span><span class="s1">overwrite_a_band</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:  </span><span class="s0"># select in [1, 2]</span>
        <span class="s4">if </span><span class="s1">eigvals_only</span><span class="s2">:</span>
            <span class="s1">max_ev </span><span class="s2">= </span><span class="s5">1</span>
        <span class="s0"># calculate optimal abstol for dsbevx (see manpage)</span>
        <span class="s4">if </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char </span><span class="s4">in </span><span class="s3">'fF'</span><span class="s2">:  </span><span class="s0"># single precision</span>
            <span class="s1">lamch</span><span class="s2">, = </span><span class="s1">get_lapack_funcs</span><span class="s2">((</span><span class="s3">'lamch'</span><span class="s2">,), (</span><span class="s1">array</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">'f'</span><span class="s2">),))</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">lamch</span><span class="s2">, = </span><span class="s1">get_lapack_funcs</span><span class="s2">((</span><span class="s3">'lamch'</span><span class="s2">,), (</span><span class="s1">array</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">'d'</span><span class="s2">),))</span>
        <span class="s1">abstol </span><span class="s2">= </span><span class="s5">2 </span><span class="s2">* </span><span class="s1">lamch</span><span class="s2">(</span><span class="s3">'s'</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char </span><span class="s4">in </span><span class="s3">'GFD'</span><span class="s2">:</span>
            <span class="s1">internal_name </span><span class="s2">= </span><span class="s3">'hbevx'</span>
        <span class="s4">else</span><span class="s2">:  </span><span class="s0"># a1.dtype.char in 'gfd'</span>
            <span class="s1">internal_name </span><span class="s2">= </span><span class="s3">'sbevx'</span>
        <span class="s1">bevx</span><span class="s2">, = </span><span class="s1">get_lapack_funcs</span><span class="s2">((</span><span class="s1">internal_name</span><span class="s2">,), (</span><span class="s1">a1</span><span class="s2">,))</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">ifail</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">bevx</span><span class="s2">(</span>
            <span class="s1">a1</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vu</span><span class="s2">, </span><span class="s1">il</span><span class="s2">, </span><span class="s1">iu</span><span class="s2">, </span><span class="s1">compute_v</span><span class="s2">=</span><span class="s4">not </span><span class="s1">eigvals_only</span><span class="s2">, </span><span class="s1">mmax</span><span class="s2">=</span><span class="s1">max_ev</span><span class="s2">,</span>
            <span class="s1">range</span><span class="s2">=</span><span class="s1">select</span><span class="s2">, </span><span class="s1">lower</span><span class="s2">=</span><span class="s1">lower</span><span class="s2">, </span><span class="s1">overwrite_ab</span><span class="s2">=</span><span class="s1">overwrite_a_band</span><span class="s2">,</span>
            <span class="s1">abstol</span><span class="s2">=</span><span class="s1">abstol</span><span class="s2">)</span>
        <span class="s0"># crop off w and v</span>
        <span class="s1">w </span><span class="s2">= </span><span class="s1">w</span><span class="s2">[:</span><span class="s1">m</span><span class="s2">]</span>
        <span class="s4">if not </span><span class="s1">eigvals_only</span><span class="s2">:</span>
            <span class="s1">v </span><span class="s2">= </span><span class="s1">v</span><span class="s2">[:, :</span><span class="s1">m</span><span class="s2">]</span>
    <span class="s1">_check_info</span><span class="s2">(</span><span class="s1">info</span><span class="s2">, </span><span class="s1">internal_name</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">eigvals_only</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">w</span>
    <span class="s4">return </span><span class="s1">w</span><span class="s2">, </span><span class="s1">v</span>


<span class="s4">def </span><span class="s1">eigvals</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">overwrite_a</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s4">True</span><span class="s2">,</span>
            <span class="s1">homogeneous_eigvals</span><span class="s2">=</span><span class="s4">False</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Compute eigenvalues from an ordinary or generalized eigenvalue problem. 
 
    Find eigenvalues of a general matrix:: 
 
        a   vr[:,i] = w[i]        b   vr[:,i] 
 
    Parameters 
    ---------- 
    a : (M, M) array_like 
        A complex or real matrix whose eigenvalues and eigenvectors 
        will be computed. 
    b : (M, M) array_like, optional 
        Right-hand side matrix in a generalized eigenvalue problem. 
        If omitted, identity matrix is assumed. 
    overwrite_a : bool, optional 
        Whether to overwrite data in a (may improve performance) 
    check_finite : bool, optional 
        Whether to check that the input matrices contain only finite numbers. 
        Disabling may give a performance gain, but may result in problems 
        (crashes, non-termination) if the inputs do contain infinities 
        or NaNs. 
    homogeneous_eigvals : bool, optional 
        If True, return the eigenvalues in homogeneous coordinates. 
        In this case ``w`` is a (2, M) array so that:: 
 
            w[1,i] a vr[:,i] = w[0,i] b vr[:,i] 
 
        Default is False. 
 
    Returns 
    ------- 
    w : (M,) or (2, M) double or complex ndarray 
        The eigenvalues, each repeated according to its multiplicity 
        but not in any specific order. The shape is (M,) unless 
        ``homogeneous_eigvals=True``. 
 
    Raises 
    ------ 
    LinAlgError 
        If eigenvalue computation does not converge 
 
    See Also 
    -------- 
    eig : eigenvalues and right eigenvectors of general arrays. 
    eigvalsh : eigenvalues of symmetric or Hermitian arrays 
    eigvals_banded : eigenvalues for symmetric/Hermitian band matrices 
    eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal 
        matrices 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import linalg 
    &gt;&gt;&gt; a = np.array([[0., -1.], [1., 0.]]) 
    &gt;&gt;&gt; linalg.eigvals(a) 
    array([0.+1.j, 0.-1.j]) 
 
    &gt;&gt;&gt; b = np.array([[0., 1.], [1., 1.]]) 
    &gt;&gt;&gt; linalg.eigvals(a, b) 
    array([ 1.+0.j, -1.+0.j]) 
 
    &gt;&gt;&gt; a = np.array([[3., 0., 0.], [0., 8., 0.], [0., 0., 7.]]) 
    &gt;&gt;&gt; linalg.eigvals(a, homogeneous_eigvals=True) 
    array([[3.+0.j, 8.+0.j, 7.+0.j], 
           [1.+0.j, 1.+0.j, 1.+0.j]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">eig</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">=</span><span class="s1">b</span><span class="s2">, </span><span class="s1">left</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">right</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">overwrite_a</span><span class="s2">=</span><span class="s1">overwrite_a</span><span class="s2">,</span>
               <span class="s1">check_finite</span><span class="s2">=</span><span class="s1">check_finite</span><span class="s2">,</span>
               <span class="s1">homogeneous_eigvals</span><span class="s2">=</span><span class="s1">homogeneous_eigvals</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">eigvalsh</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, *, </span><span class="s1">lower</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">overwrite_a</span><span class="s2">=</span><span class="s4">False</span><span class="s2">,</span>
             <span class="s1">overwrite_b</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">type</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">subset_by_index</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
             <span class="s1">subset_by_value</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">driver</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Solves a standard or generalized eigenvalue problem for a complex 
    Hermitian or real symmetric matrix. 
 
    Find eigenvalues array ``w`` of array ``a``, where ``b`` is positive 
    definite such that for every eigenvalue λ (i-th entry of w) and its 
    eigenvector vi (i-th column of v) satisfies:: 
 
                      a @ vi = λ * b @ vi 
        vi.conj().T @ a @ vi = λ 
        vi.conj().T @ b @ vi = 1 
 
    In the standard problem, b is assumed to be the identity matrix. 
 
    Parameters 
    ---------- 
    a : (M, M) array_like 
        A complex Hermitian or real symmetric matrix whose eigenvalues will 
        be computed. 
    b : (M, M) array_like, optional 
        A complex Hermitian or real symmetric definite positive matrix in. 
        If omitted, identity matrix is assumed. 
    lower : bool, optional 
        Whether the pertinent array data is taken from the lower or upper 
        triangle of ``a`` and, if applicable, ``b``. (Default: lower) 
    overwrite_a : bool, optional 
        Whether to overwrite data in ``a`` (may improve performance). Default 
        is False. 
    overwrite_b : bool, optional 
        Whether to overwrite data in ``b`` (may improve performance). Default 
        is False. 
    type : int, optional 
        For the generalized problems, this keyword specifies the problem type 
        to be solved for ``w`` and ``v`` (only takes 1, 2, 3 as possible 
        inputs):: 
 
            1 =&gt;     a @ v = w @ b @ v 
            2 =&gt; a @ b @ v = w @ v 
            3 =&gt; b @ a @ v = w @ v 
 
        This keyword is ignored for standard problems. 
    check_finite : bool, optional 
        Whether to check that the input matrices contain only finite numbers. 
        Disabling may give a performance gain, but may result in problems 
        (crashes, non-termination) if the inputs do contain infinities or NaNs. 
    subset_by_index : iterable, optional 
        If provided, this two-element iterable defines the start and the end 
        indices of the desired eigenvalues (ascending order and 0-indexed). 
        To return only the second smallest to fifth smallest eigenvalues, 
        ``[1, 4]`` is used. ``[n-3, n-1]`` returns the largest three. Only 
        available with &quot;evr&quot;, &quot;evx&quot;, and &quot;gvx&quot; drivers. The entries are 
        directly converted to integers via ``int()``. 
    subset_by_value : iterable, optional 
        If provided, this two-element iterable defines the half-open interval 
        ``(a, b]`` that, if any, only the eigenvalues between these values 
        are returned. Only available with &quot;evr&quot;, &quot;evx&quot;, and &quot;gvx&quot; drivers. Use 
        ``np.inf`` for the unconstrained ends. 
    driver : str, optional 
        Defines which LAPACK driver should be used. Valid options are &quot;ev&quot;, 
        &quot;evd&quot;, &quot;evr&quot;, &quot;evx&quot; for standard problems and &quot;gv&quot;, &quot;gvd&quot;, &quot;gvx&quot; for 
        generalized (where b is not None) problems. See the Notes section of 
        `scipy.linalg.eigh`. 
 
    Returns 
    ------- 
    w : (N,) ndarray 
        The N (N&lt;=M) selected eigenvalues, in ascending order, each 
        repeated according to its multiplicity. 
 
    Raises 
    ------ 
    LinAlgError 
        If eigenvalue computation does not converge, an error occurred, or 
        b matrix is not definite positive. Note that if input matrices are 
        not symmetric or Hermitian, no error will be reported but results will 
        be wrong. 
 
    See Also 
    -------- 
    eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays 
    eigvals : eigenvalues of general arrays 
    eigvals_banded : eigenvalues for symmetric/Hermitian band matrices 
    eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal 
        matrices 
 
    Notes 
    ----- 
    This function does not check the input array for being Hermitian/symmetric 
    in order to allow for representing arrays with only their upper/lower 
    triangular parts. 
 
    This function serves as a one-liner shorthand for `scipy.linalg.eigh` with 
    the option ``eigvals_only=True`` to get the eigenvalues and not the 
    eigenvectors. Here it is kept as a legacy convenience. It might be 
    beneficial to use the main function to have full control and to be a bit 
    more pythonic. 
 
    Examples 
    -------- 
    For more examples see `scipy.linalg.eigh`. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.linalg import eigvalsh 
    &gt;&gt;&gt; A = np.array([[6, 3, 1, 5], [3, 0, 5, 1], [1, 5, 6, 2], [5, 1, 2, 2]]) 
    &gt;&gt;&gt; w = eigvalsh(A) 
    &gt;&gt;&gt; w 
    array([-3.74637491, -0.76263923,  6.08502336, 12.42399079]) 
 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">eigh</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">=</span><span class="s1">b</span><span class="s2">, </span><span class="s1">lower</span><span class="s2">=</span><span class="s1">lower</span><span class="s2">, </span><span class="s1">eigvals_only</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">overwrite_a</span><span class="s2">=</span><span class="s1">overwrite_a</span><span class="s2">,</span>
                <span class="s1">overwrite_b</span><span class="s2">=</span><span class="s1">overwrite_b</span><span class="s2">, </span><span class="s1">type</span><span class="s2">=</span><span class="s1">type</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s1">check_finite</span><span class="s2">,</span>
                <span class="s1">subset_by_index</span><span class="s2">=</span><span class="s1">subset_by_index</span><span class="s2">, </span><span class="s1">subset_by_value</span><span class="s2">=</span><span class="s1">subset_by_value</span><span class="s2">,</span>
                <span class="s1">driver</span><span class="s2">=</span><span class="s1">driver</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">eigvals_banded</span><span class="s2">(</span><span class="s1">a_band</span><span class="s2">, </span><span class="s1">lower</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">overwrite_a_band</span><span class="s2">=</span><span class="s4">False</span><span class="s2">,</span>
                   <span class="s1">select</span><span class="s2">=</span><span class="s3">'a'</span><span class="s2">, </span><span class="s1">select_range</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s4">True</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Solve real symmetric or complex Hermitian band matrix eigenvalue problem. 
 
    Find eigenvalues w of a:: 
 
        a v[:,i] = w[i] v[:,i] 
        v.H v    = identity 
 
    The matrix a is stored in a_band either in lower diagonal or upper 
    diagonal ordered form: 
 
        a_band[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j) 
        a_band[    i - j, j] == a[i,j]        (if lower form; i &gt;= j) 
 
    where u is the number of bands above the diagonal. 
 
    Example of a_band (shape of a is (6,6), u=2):: 
 
        upper form: 
        *   *   a02 a13 a24 a35 
        *   a01 a12 a23 a34 a45 
        a00 a11 a22 a33 a44 a55 
 
        lower form: 
        a00 a11 a22 a33 a44 a55 
        a10 a21 a32 a43 a54 * 
        a20 a31 a42 a53 *   * 
 
    Cells marked with * are not used. 
 
    Parameters 
    ---------- 
    a_band : (u+1, M) array_like 
        The bands of the M by M matrix a. 
    lower : bool, optional 
        Is the matrix in the lower form. (Default is upper form) 
    overwrite_a_band : bool, optional 
        Discard data in a_band (may enhance performance) 
    select : {'a', 'v', 'i'}, optional 
        Which eigenvalues to calculate 
 
        ======  ======================================== 
        select  calculated 
        ======  ======================================== 
        'a'     All eigenvalues 
        'v'     Eigenvalues in the interval (min, max] 
        'i'     Eigenvalues with indices min &lt;= i &lt;= max 
        ======  ======================================== 
    select_range : (min, max), optional 
        Range of selected eigenvalues 
    check_finite : bool, optional 
        Whether to check that the input matrix contains only finite numbers. 
        Disabling may give a performance gain, but may result in problems 
        (crashes, non-termination) if the inputs do contain infinities or NaNs. 
 
    Returns 
    ------- 
    w : (M,) ndarray 
        The eigenvalues, in ascending order, each repeated according to its 
        multiplicity. 
 
    Raises 
    ------ 
    LinAlgError 
        If eigenvalue computation does not converge. 
 
    See Also 
    -------- 
    eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian 
        band matrices 
    eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal 
        matrices 
    eigvals : eigenvalues of general arrays 
    eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays 
    eig : eigenvalues and right eigenvectors for non-symmetric arrays 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.linalg import eigvals_banded 
    &gt;&gt;&gt; A = np.array([[1, 5, 2, 0], [5, 2, 5, 2], [2, 5, 3, 5], [0, 2, 5, 4]]) 
    &gt;&gt;&gt; Ab = np.array([[1, 2, 3, 4], [5, 5, 5, 0], [2, 2, 0, 0]]) 
    &gt;&gt;&gt; w = eigvals_banded(Ab, lower=True) 
    &gt;&gt;&gt; w 
    array([-4.26200532, -2.22987175,  3.95222349, 12.53965359]) 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">eig_banded</span><span class="s2">(</span><span class="s1">a_band</span><span class="s2">, </span><span class="s1">lower</span><span class="s2">=</span><span class="s1">lower</span><span class="s2">, </span><span class="s1">eigvals_only</span><span class="s2">=</span><span class="s5">1</span><span class="s2">,</span>
                      <span class="s1">overwrite_a_band</span><span class="s2">=</span><span class="s1">overwrite_a_band</span><span class="s2">, </span><span class="s1">select</span><span class="s2">=</span><span class="s1">select</span><span class="s2">,</span>
                      <span class="s1">select_range</span><span class="s2">=</span><span class="s1">select_range</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s1">check_finite</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">eigvalsh_tridiagonal</span><span class="s2">(</span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">select</span><span class="s2">=</span><span class="s3">'a'</span><span class="s2">, </span><span class="s1">select_range</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                         <span class="s1">check_finite</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s5">0.</span><span class="s2">, </span><span class="s1">lapack_driver</span><span class="s2">=</span><span class="s3">'auto'</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Solve eigenvalue problem for a real symmetric tridiagonal matrix. 
 
    Find eigenvalues `w` of ``a``:: 
 
        a v[:,i] = w[i] v[:,i] 
        v.H v    = identity 
 
    For a real symmetric matrix ``a`` with diagonal elements `d` and 
    off-diagonal elements `e`. 
 
    Parameters 
    ---------- 
    d : ndarray, shape (ndim,) 
        The diagonal elements of the array. 
    e : ndarray, shape (ndim-1,) 
        The off-diagonal elements of the array. 
    select : {'a', 'v', 'i'}, optional 
        Which eigenvalues to calculate 
 
        ======  ======================================== 
        select  calculated 
        ======  ======================================== 
        'a'     All eigenvalues 
        'v'     Eigenvalues in the interval (min, max] 
        'i'     Eigenvalues with indices min &lt;= i &lt;= max 
        ======  ======================================== 
    select_range : (min, max), optional 
        Range of selected eigenvalues 
    check_finite : bool, optional 
        Whether to check that the input matrix contains only finite numbers. 
        Disabling may give a performance gain, but may result in problems 
        (crashes, non-termination) if the inputs do contain infinities or NaNs. 
    tol : float 
        The absolute tolerance to which each eigenvalue is required 
        (only used when ``lapack_driver='stebz'``). 
        An eigenvalue (or cluster) is considered to have converged if it 
        lies in an interval of this width. If &lt;= 0. (default), 
        the value ``eps*|a|`` is used where eps is the machine precision, 
        and ``|a|`` is the 1-norm of the matrix ``a``. 
    lapack_driver : str 
        LAPACK function to use, can be 'auto', 'stemr', 'stebz',  'sterf', 
        or 'stev'. When 'auto' (default), it will use 'stemr' if ``select='a'`` 
        and 'stebz' otherwise. 'sterf' and 'stev' can only be used when 
        ``select='a'``. 
 
    Returns 
    ------- 
    w : (M,) ndarray 
        The eigenvalues, in ascending order, each repeated according to its 
        multiplicity. 
 
    Raises 
    ------ 
    LinAlgError 
        If eigenvalue computation does not converge. 
 
    See Also 
    -------- 
    eigh_tridiagonal : eigenvalues and right eiegenvectors for 
        symmetric/Hermitian tridiagonal matrices 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.linalg import eigvalsh_tridiagonal, eigvalsh 
    &gt;&gt;&gt; d = 3*np.ones(4) 
    &gt;&gt;&gt; e = -1*np.ones(3) 
    &gt;&gt;&gt; w = eigvalsh_tridiagonal(d, e) 
    &gt;&gt;&gt; A = np.diag(d) + np.diag(e, k=1) + np.diag(e, k=-1) 
    &gt;&gt;&gt; w2 = eigvalsh(A)  # Verify with other eigenvalue routines 
    &gt;&gt;&gt; np.allclose(w - w2, np.zeros(4)) 
    True 
    &quot;&quot;&quot;</span>
    <span class="s4">return </span><span class="s1">eigh_tridiagonal</span><span class="s2">(</span>
        <span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">eigvals_only</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">select</span><span class="s2">=</span><span class="s1">select</span><span class="s2">, </span><span class="s1">select_range</span><span class="s2">=</span><span class="s1">select_range</span><span class="s2">,</span>
        <span class="s1">check_finite</span><span class="s2">=</span><span class="s1">check_finite</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s1">tol</span><span class="s2">, </span><span class="s1">lapack_driver</span><span class="s2">=</span><span class="s1">lapack_driver</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">eigh_tridiagonal</span><span class="s2">(</span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">eigvals_only</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">select</span><span class="s2">=</span><span class="s3">'a'</span><span class="s2">, </span><span class="s1">select_range</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                     <span class="s1">check_finite</span><span class="s2">=</span><span class="s4">True</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s5">0.</span><span class="s2">, </span><span class="s1">lapack_driver</span><span class="s2">=</span><span class="s3">'auto'</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Solve eigenvalue problem for a real symmetric tridiagonal matrix. 
 
    Find eigenvalues `w` and optionally right eigenvectors `v` of ``a``:: 
 
        a v[:,i] = w[i] v[:,i] 
        v.H v    = identity 
 
    For a real symmetric matrix ``a`` with diagonal elements `d` and 
    off-diagonal elements `e`. 
 
    Parameters 
    ---------- 
    d : ndarray, shape (ndim,) 
        The diagonal elements of the array. 
    e : ndarray, shape (ndim-1,) 
        The off-diagonal elements of the array. 
    eigvals_only : bool, optional 
        Compute only the eigenvalues and no eigenvectors. 
        (Default: calculate also eigenvectors) 
    select : {'a', 'v', 'i'}, optional 
        Which eigenvalues to calculate 
 
        ======  ======================================== 
        select  calculated 
        ======  ======================================== 
        'a'     All eigenvalues 
        'v'     Eigenvalues in the interval (min, max] 
        'i'     Eigenvalues with indices min &lt;= i &lt;= max 
        ======  ======================================== 
    select_range : (min, max), optional 
        Range of selected eigenvalues 
    check_finite : bool, optional 
        Whether to check that the input matrix contains only finite numbers. 
        Disabling may give a performance gain, but may result in problems 
        (crashes, non-termination) if the inputs do contain infinities or NaNs. 
    tol : float 
        The absolute tolerance to which each eigenvalue is required 
        (only used when 'stebz' is the `lapack_driver`). 
        An eigenvalue (or cluster) is considered to have converged if it 
        lies in an interval of this width. If &lt;= 0. (default), 
        the value ``eps*|a|`` is used where eps is the machine precision, 
        and ``|a|`` is the 1-norm of the matrix ``a``. 
    lapack_driver : str 
        LAPACK function to use, can be 'auto', 'stemr', 'stebz', 'sterf', 
        or 'stev'. When 'auto' (default), it will use 'stemr' if ``select='a'`` 
        and 'stebz' otherwise. When 'stebz' is used to find the eigenvalues and 
        ``eigvals_only=False``, then a second LAPACK call (to ``?STEIN``) is 
        used to find the corresponding eigenvectors. 'sterf' can only be 
        used when ``eigvals_only=True`` and ``select='a'``. 'stev' can only 
        be used when ``select='a'``. 
 
    Returns 
    ------- 
    w : (M,) ndarray 
        The eigenvalues, in ascending order, each repeated according to its 
        multiplicity. 
    v : (M, M) ndarray 
        The normalized eigenvector corresponding to the eigenvalue ``w[i]`` is 
        the column ``v[:,i]``. Only returned if ``eigvals_only=False``. 
 
    Raises 
    ------ 
    LinAlgError 
        If eigenvalue computation does not converge. 
 
    See Also 
    -------- 
    eigvalsh_tridiagonal : eigenvalues of symmetric/Hermitian tridiagonal 
        matrices 
    eig : eigenvalues and right eigenvectors for non-symmetric arrays 
    eigh : eigenvalues and right eigenvectors for symmetric/Hermitian arrays 
    eig_banded : eigenvalues and right eigenvectors for symmetric/Hermitian 
        band matrices 
 
    Notes 
    ----- 
    This function makes use of LAPACK ``S/DSTEMR`` routines. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.linalg import eigh_tridiagonal 
    &gt;&gt;&gt; d = 3*np.ones(4) 
    &gt;&gt;&gt; e = -1*np.ones(3) 
    &gt;&gt;&gt; w, v = eigh_tridiagonal(d, e) 
    &gt;&gt;&gt; A = np.diag(d) + np.diag(e, k=1) + np.diag(e, k=-1) 
    &gt;&gt;&gt; np.allclose(A @ v - v @ np.diag(w), np.zeros((4, 4))) 
    True 
    &quot;&quot;&quot;</span>
    <span class="s1">d </span><span class="s2">= </span><span class="s1">_asarray_validated</span><span class="s2">(</span><span class="s1">d</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s1">check_finite</span><span class="s2">)</span>
    <span class="s1">e </span><span class="s2">= </span><span class="s1">_asarray_validated</span><span class="s2">(</span><span class="s1">e</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s1">check_finite</span><span class="s2">)</span>
    <span class="s4">for </span><span class="s1">check </span><span class="s4">in </span><span class="s2">(</span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">check</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'expected a 1-D array'</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">check</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char </span><span class="s4">in </span><span class="s3">'GFD'</span><span class="s2">:  </span><span class="s0"># complex</span>
            <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">'Only real arrays currently supported'</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">d</span><span class="s2">.</span><span class="s1">size </span><span class="s2">!= </span><span class="s1">e</span><span class="s2">.</span><span class="s1">size </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'd (</span><span class="s4">{</span><span class="s1">d</span><span class="s2">.</span><span class="s1">size</span><span class="s4">}</span><span class="s3">) must have one more element than e (</span><span class="s4">{</span><span class="s1">e</span><span class="s2">.</span><span class="s1">size</span><span class="s4">}</span><span class="s3">)'</span><span class="s2">)</span>
    <span class="s1">select</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vu</span><span class="s2">, </span><span class="s1">il</span><span class="s2">, </span><span class="s1">iu</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_check_select</span><span class="s2">(</span>
        <span class="s1">select</span><span class="s2">, </span><span class="s1">select_range</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">d</span><span class="s2">.</span><span class="s1">size</span><span class="s2">)</span>
    <span class="s4">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">lapack_driver</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
        <span class="s4">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s3">'lapack_driver must be str'</span><span class="s2">)</span>
    <span class="s1">drivers </span><span class="s2">= (</span><span class="s3">'auto'</span><span class="s2">, </span><span class="s3">'stemr'</span><span class="s2">, </span><span class="s3">'sterf'</span><span class="s2">, </span><span class="s3">'stebz'</span><span class="s2">, </span><span class="s3">'stev'</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">lapack_driver </span><span class="s4">not in </span><span class="s1">drivers</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">f'lapack_driver must be one of </span><span class="s4">{</span><span class="s1">drivers</span><span class="s4">}</span><span class="s3">, '</span>
                         <span class="s3">f'got </span><span class="s4">{</span><span class="s1">lapack_driver</span><span class="s4">}</span><span class="s3">'</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">lapack_driver </span><span class="s2">== </span><span class="s3">'auto'</span><span class="s2">:</span>
        <span class="s1">lapack_driver </span><span class="s2">= </span><span class="s3">'stemr' </span><span class="s4">if </span><span class="s1">select </span><span class="s2">== </span><span class="s5">0 </span><span class="s4">else </span><span class="s3">'stebz'</span>

    <span class="s0"># Quick exit for 1x1 case</span>
    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">d</span><span class="s2">) == </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">select </span><span class="s2">== </span><span class="s5">1 </span><span class="s4">and </span><span class="s2">(</span><span class="s4">not </span><span class="s2">(</span><span class="s1">vl </span><span class="s2">&lt; </span><span class="s1">d</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] &lt;= </span><span class="s1">vu</span><span class="s2">)):  </span><span class="s0"># request by value</span>
            <span class="s1">w </span><span class="s2">= </span><span class="s1">array</span><span class="s2">([])</span>
            <span class="s1">v </span><span class="s2">= </span><span class="s1">empty</span><span class="s2">([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">d</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s4">else</span><span class="s2">:  </span><span class="s0"># all and request by index</span>
            <span class="s1">w </span><span class="s2">= </span><span class="s1">array</span><span class="s2">([</span><span class="s1">d</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">d</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">v </span><span class="s2">= </span><span class="s1">array</span><span class="s2">([[</span><span class="s5">1.</span><span class="s2">]], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">d</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s4">if </span><span class="s1">eigvals_only</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">w</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">w</span><span class="s2">, </span><span class="s1">v</span>

    <span class="s1">func</span><span class="s2">, = </span><span class="s1">get_lapack_funcs</span><span class="s2">((</span><span class="s1">lapack_driver</span><span class="s2">,), (</span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">))</span>
    <span class="s1">compute_v </span><span class="s2">= </span><span class="s4">not </span><span class="s1">eigvals_only</span>
    <span class="s4">if </span><span class="s1">lapack_driver </span><span class="s2">== </span><span class="s3">'sterf'</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">select </span><span class="s2">!= </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'sterf can only be used when select == &quot;a&quot;'</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">eigvals_only</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'sterf can only be used when eigvals_only is '</span>
                             <span class="s3">'True'</span><span class="s2">)</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">)</span>
        <span class="s1">m </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">w</span><span class="s2">)</span>
    <span class="s4">elif </span><span class="s1">lapack_driver </span><span class="s2">== </span><span class="s3">'stev'</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">select </span><span class="s2">!= </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'stev can only be used when select == &quot;a&quot;'</span><span class="s2">)</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">compute_v</span><span class="s2">=</span><span class="s1">compute_v</span><span class="s2">)</span>
        <span class="s1">m </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">w</span><span class="s2">)</span>
    <span class="s4">elif </span><span class="s1">lapack_driver </span><span class="s2">== </span><span class="s3">'stebz'</span><span class="s2">:</span>
        <span class="s1">tol </span><span class="s2">= </span><span class="s1">float</span><span class="s2">(</span><span class="s1">tol</span><span class="s2">)</span>
        <span class="s1">internal_name </span><span class="s2">= </span><span class="s3">'stebz'</span>
        <span class="s1">stebz</span><span class="s2">, = </span><span class="s1">get_lapack_funcs</span><span class="s2">((</span><span class="s1">internal_name</span><span class="s2">,), (</span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">))</span>
        <span class="s0"># If getting eigenvectors, needs to be block-ordered (B) instead of</span>
        <span class="s0"># matrix-ordered (E), and we will reorder later</span>
        <span class="s1">order </span><span class="s2">= </span><span class="s3">'E' </span><span class="s4">if </span><span class="s1">eigvals_only </span><span class="s4">else </span><span class="s3">'B'</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">iblock</span><span class="s2">, </span><span class="s1">isplit</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">stebz</span><span class="s2">(</span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">select</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vu</span><span class="s2">, </span><span class="s1">il</span><span class="s2">, </span><span class="s1">iu</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">,</span>
                                           <span class="s1">order</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:   </span><span class="s0"># 'stemr'</span>
        <span class="s0"># ?STEMR annoyingly requires size N instead of N-1</span>
        <span class="s1">e_ </span><span class="s2">= </span><span class="s1">empty</span><span class="s2">(</span><span class="s1">e</span><span class="s2">.</span><span class="s1">size</span><span class="s2">+</span><span class="s5">1</span><span class="s2">, </span><span class="s1">e</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">e_</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">] = </span><span class="s1">e</span>
        <span class="s1">stemr_lwork</span><span class="s2">, = </span><span class="s1">get_lapack_funcs</span><span class="s2">((</span><span class="s3">'stemr_lwork'</span><span class="s2">,), (</span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">))</span>
        <span class="s1">lwork</span><span class="s2">, </span><span class="s1">liwork</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">stemr_lwork</span><span class="s2">(</span><span class="s1">d</span><span class="s2">, </span><span class="s1">e_</span><span class="s2">, </span><span class="s1">select</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vu</span><span class="s2">, </span><span class="s1">il</span><span class="s2">, </span><span class="s1">iu</span><span class="s2">,</span>
                                          <span class="s1">compute_v</span><span class="s2">=</span><span class="s1">compute_v</span><span class="s2">)</span>
        <span class="s1">_check_info</span><span class="s2">(</span><span class="s1">info</span><span class="s2">, </span><span class="s3">'stemr_lwork'</span><span class="s2">)</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">d</span><span class="s2">, </span><span class="s1">e_</span><span class="s2">, </span><span class="s1">select</span><span class="s2">, </span><span class="s1">vl</span><span class="s2">, </span><span class="s1">vu</span><span class="s2">, </span><span class="s1">il</span><span class="s2">, </span><span class="s1">iu</span><span class="s2">,</span>
                             <span class="s1">compute_v</span><span class="s2">=</span><span class="s1">compute_v</span><span class="s2">, </span><span class="s1">lwork</span><span class="s2">=</span><span class="s1">lwork</span><span class="s2">, </span><span class="s1">liwork</span><span class="s2">=</span><span class="s1">liwork</span><span class="s2">)</span>
    <span class="s1">_check_info</span><span class="s2">(</span><span class="s1">info</span><span class="s2">, </span><span class="s1">lapack_driver </span><span class="s2">+ </span><span class="s3">' (eigh_tridiagonal)'</span><span class="s2">)</span>
    <span class="s1">w </span><span class="s2">= </span><span class="s1">w</span><span class="s2">[:</span><span class="s1">m</span><span class="s2">]</span>
    <span class="s4">if </span><span class="s1">eigvals_only</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">w</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s0"># Do we still need to compute the eigenvalues?</span>
        <span class="s4">if </span><span class="s1">lapack_driver </span><span class="s2">== </span><span class="s3">'stebz'</span><span class="s2">:</span>
            <span class="s1">func</span><span class="s2">, = </span><span class="s1">get_lapack_funcs</span><span class="s2">((</span><span class="s3">'stein'</span><span class="s2">,), (</span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">))</span>
            <span class="s1">v</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">iblock</span><span class="s2">, </span><span class="s1">isplit</span><span class="s2">)</span>
            <span class="s1">_check_info</span><span class="s2">(</span><span class="s1">info</span><span class="s2">, </span><span class="s3">'stein (eigh_tridiagonal)'</span><span class="s2">,</span>
                        <span class="s1">positive</span><span class="s2">=</span><span class="s3">'%d eigenvectors failed to converge'</span><span class="s2">)</span>
            <span class="s0"># Convert block-order to matrix-order</span>
            <span class="s1">order </span><span class="s2">= </span><span class="s1">argsort</span><span class="s2">(</span><span class="s1">w</span><span class="s2">)</span>
            <span class="s1">w</span><span class="s2">, </span><span class="s1">v </span><span class="s2">= </span><span class="s1">w</span><span class="s2">[</span><span class="s1">order</span><span class="s2">], </span><span class="s1">v</span><span class="s2">[:, </span><span class="s1">order</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">v </span><span class="s2">= </span><span class="s1">v</span><span class="s2">[:, :</span><span class="s1">m</span><span class="s2">]</span>
        <span class="s4">return </span><span class="s1">w</span><span class="s2">, </span><span class="s1">v</span>


<span class="s4">def </span><span class="s1">_check_info</span><span class="s2">(</span><span class="s1">info</span><span class="s2">, </span><span class="s1">driver</span><span class="s2">, </span><span class="s1">positive</span><span class="s2">=</span><span class="s3">'did not converge (LAPACK info=%d)'</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Check info return value.&quot;&quot;&quot;</span>
    <span class="s4">if </span><span class="s1">info </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'illegal value in argument %d of internal %s'</span>
                         <span class="s2">% (-</span><span class="s1">info</span><span class="s2">, </span><span class="s1">driver</span><span class="s2">))</span>
    <span class="s4">if </span><span class="s1">info </span><span class="s2">&gt; </span><span class="s5">0 </span><span class="s4">and </span><span class="s1">positive</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">LinAlgError</span><span class="s2">((</span><span class="s3">&quot;%s &quot; </span><span class="s2">+ </span><span class="s1">positive</span><span class="s2">) % (</span><span class="s1">driver</span><span class="s2">, </span><span class="s1">info</span><span class="s2">,))</span>


<span class="s4">def </span><span class="s1">hessenberg</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">calc_q</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">overwrite_a</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s4">True</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Compute Hessenberg form of a matrix. 
 
    The Hessenberg decomposition is:: 
 
        A = Q H Q^H 
 
    where `Q` is unitary/orthogonal and `H` has only zero elements below 
    the first sub-diagonal. 
 
    Parameters 
    ---------- 
    a : (M, M) array_like 
        Matrix to bring into Hessenberg form. 
    calc_q : bool, optional 
        Whether to compute the transformation matrix.  Default is False. 
    overwrite_a : bool, optional 
        Whether to overwrite `a`; may improve performance. 
        Default is False. 
    check_finite : bool, optional 
        Whether to check that the input matrix contains only finite numbers. 
        Disabling may give a performance gain, but may result in problems 
        (crashes, non-termination) if the inputs do contain infinities or NaNs. 
 
    Returns 
    ------- 
    H : (M, M) ndarray 
        Hessenberg form of `a`. 
    Q : (M, M) ndarray 
        Unitary/orthogonal similarity transformation matrix ``A = Q H Q^H``. 
        Only returned if ``calc_q=True``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.linalg import hessenberg 
    &gt;&gt;&gt; A = np.array([[2, 5, 8, 7], [5, 2, 2, 8], [7, 5, 6, 6], [5, 4, 4, 8]]) 
    &gt;&gt;&gt; H, Q = hessenberg(A, calc_q=True) 
    &gt;&gt;&gt; H 
    array([[  2.        , -11.65843866,   1.42005301,   0.25349066], 
           [ -9.94987437,  14.53535354,  -5.31022304,   2.43081618], 
           [  0.        ,  -1.83299243,   0.38969961,  -0.51527034], 
           [  0.        ,   0.        ,  -3.83189513,   1.07494686]]) 
    &gt;&gt;&gt; np.allclose(Q @ H @ Q.conj().T - A, np.zeros((4, 4))) 
    True 
    &quot;&quot;&quot;</span>
    <span class="s1">a1 </span><span class="s2">= </span><span class="s1">_asarray_validated</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">check_finite</span><span class="s2">=</span><span class="s1">check_finite</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) != </span><span class="s5">2 </span><span class="s4">or </span><span class="s2">(</span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] != </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]):</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'expected square matrix'</span><span class="s2">)</span>
    <span class="s1">overwrite_a </span><span class="s2">= </span><span class="s1">overwrite_a </span><span class="s4">or </span><span class="s2">(</span><span class="s1">_datacopied</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">a</span><span class="s2">))</span>

    <span class="s4">if </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s1">h3 </span><span class="s2">= </span><span class="s1">hessenberg</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">eye</span><span class="s2">(</span><span class="s5">3</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">a1</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">))</span>
        <span class="s1">h </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">h3</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s4">if not </span><span class="s1">calc_q</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">h</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">h3</span><span class="s2">, </span><span class="s1">q3 </span><span class="s2">= </span><span class="s1">hessenberg</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">eye</span><span class="s2">(</span><span class="s5">3</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">a1</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">), </span><span class="s1">calc_q</span><span class="s2">=</span><span class="s4">True</span><span class="s2">)</span>
            <span class="s1">q </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">q3</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">h </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">h3</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s4">return </span><span class="s1">h</span><span class="s2">, </span><span class="s1">q</span>

    <span class="s0"># if 2x2 or smaller: already in Hessenberg</span>
    <span class="s4">if </span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] &lt;= </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">calc_q</span><span class="s2">:</span>
            <span class="s4">return </span><span class="s1">a1</span><span class="s2">, </span><span class="s1">eye</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>
        <span class="s4">return </span><span class="s1">a1</span>

    <span class="s1">gehrd</span><span class="s2">, </span><span class="s1">gebal</span><span class="s2">, </span><span class="s1">gehrd_lwork </span><span class="s2">= </span><span class="s1">get_lapack_funcs</span><span class="s2">((</span><span class="s3">'gehrd'</span><span class="s2">, </span><span class="s3">'gebal'</span><span class="s2">,</span>
                                                  <span class="s3">'gehrd_lwork'</span><span class="s2">), (</span><span class="s1">a1</span><span class="s2">,))</span>
    <span class="s1">ba</span><span class="s2">, </span><span class="s1">lo</span><span class="s2">, </span><span class="s1">hi</span><span class="s2">, </span><span class="s1">pivscale</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">gebal</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">, </span><span class="s1">permute</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">overwrite_a</span><span class="s2">=</span><span class="s1">overwrite_a</span><span class="s2">)</span>
    <span class="s1">_check_info</span><span class="s2">(</span><span class="s1">info</span><span class="s2">, </span><span class="s3">'gebal (hessenberg)'</span><span class="s2">, </span><span class="s1">positive</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">a1</span><span class="s2">)</span>

    <span class="s1">lwork </span><span class="s2">= </span><span class="s1">_compute_lwork</span><span class="s2">(</span><span class="s1">gehrd_lwork</span><span class="s2">, </span><span class="s1">ba</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">lo</span><span class="s2">=</span><span class="s1">lo</span><span class="s2">, </span><span class="s1">hi</span><span class="s2">=</span><span class="s1">hi</span><span class="s2">)</span>

    <span class="s1">hq</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">gehrd</span><span class="s2">(</span><span class="s1">ba</span><span class="s2">, </span><span class="s1">lo</span><span class="s2">=</span><span class="s1">lo</span><span class="s2">, </span><span class="s1">hi</span><span class="s2">=</span><span class="s1">hi</span><span class="s2">, </span><span class="s1">lwork</span><span class="s2">=</span><span class="s1">lwork</span><span class="s2">, </span><span class="s1">overwrite_a</span><span class="s2">=</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s1">_check_info</span><span class="s2">(</span><span class="s1">info</span><span class="s2">, </span><span class="s3">'gehrd (hessenberg)'</span><span class="s2">, </span><span class="s1">positive</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>
    <span class="s1">h </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">triu</span><span class="s2">(</span><span class="s1">hq</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s4">if not </span><span class="s1">calc_q</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s1">h</span>

    <span class="s0"># use orghr/unghr to compute q</span>
    <span class="s1">orghr</span><span class="s2">, </span><span class="s1">orghr_lwork </span><span class="s2">= </span><span class="s1">get_lapack_funcs</span><span class="s2">((</span><span class="s3">'orghr'</span><span class="s2">, </span><span class="s3">'orghr_lwork'</span><span class="s2">), (</span><span class="s1">a1</span><span class="s2">,))</span>
    <span class="s1">lwork </span><span class="s2">= </span><span class="s1">_compute_lwork</span><span class="s2">(</span><span class="s1">orghr_lwork</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">lo</span><span class="s2">=</span><span class="s1">lo</span><span class="s2">, </span><span class="s1">hi</span><span class="s2">=</span><span class="s1">hi</span><span class="s2">)</span>

    <span class="s1">q</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">orghr</span><span class="s2">(</span><span class="s1">a</span><span class="s2">=</span><span class="s1">hq</span><span class="s2">, </span><span class="s1">tau</span><span class="s2">=</span><span class="s1">tau</span><span class="s2">, </span><span class="s1">lo</span><span class="s2">=</span><span class="s1">lo</span><span class="s2">, </span><span class="s1">hi</span><span class="s2">=</span><span class="s1">hi</span><span class="s2">, </span><span class="s1">lwork</span><span class="s2">=</span><span class="s1">lwork</span><span class="s2">, </span><span class="s1">overwrite_a</span><span class="s2">=</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s1">_check_info</span><span class="s2">(</span><span class="s1">info</span><span class="s2">, </span><span class="s3">'orghr (hessenberg)'</span><span class="s2">, </span><span class="s1">positive</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">h</span><span class="s2">, </span><span class="s1">q</span>


<span class="s4">def </span><span class="s1">cdf2rdf</span><span class="s2">(</span><span class="s1">w</span><span class="s2">, </span><span class="s1">v</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Converts complex eigenvalues ``w`` and eigenvectors ``v`` to real 
    eigenvalues in a block diagonal form ``wr`` and the associated real 
    eigenvectors ``vr``, such that:: 
 
        vr @ wr = X @ vr 
 
    continues to hold, where ``X`` is the original array for which ``w`` and 
    ``v`` are the eigenvalues and eigenvectors. 
 
    .. versionadded:: 1.1.0 
 
    Parameters 
    ---------- 
    w : (..., M) array_like 
        Complex or real eigenvalues, an array or stack of arrays 
 
        Conjugate pairs must not be interleaved, else the wrong result 
        will be produced. So ``[1+1j, 1, 1-1j]`` will give a correct result, 
        but ``[1+1j, 2+1j, 1-1j, 2-1j]`` will not. 
 
    v : (..., M, M) array_like 
        Complex or real eigenvectors, a square array or stack of square arrays. 
 
    Returns 
    ------- 
    wr : (..., M, M) ndarray 
        Real diagonal block form of eigenvalues 
    vr : (..., M, M) ndarray 
        Real eigenvectors associated with ``wr`` 
 
    See Also 
    -------- 
    eig : Eigenvalues and right eigenvectors for non-symmetric arrays 
    rsf2csf : Convert real Schur form to complex Schur form 
 
    Notes 
    ----- 
    ``w``, ``v`` must be the eigenstructure for some *real* matrix ``X``. 
    For example, obtained by ``w, v = scipy.linalg.eig(X)`` or 
    ``w, v = numpy.linalg.eig(X)`` in which case ``X`` can also represent 
    stacked arrays. 
 
    .. versionadded:: 1.1.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; X = np.array([[1, 2, 3], [0, 4, 5], [0, -5, 4]]) 
    &gt;&gt;&gt; X 
    array([[ 1,  2,  3], 
           [ 0,  4,  5], 
           [ 0, -5,  4]]) 
 
    &gt;&gt;&gt; from scipy import linalg 
    &gt;&gt;&gt; w, v = linalg.eig(X) 
    &gt;&gt;&gt; w 
    array([ 1.+0.j,  4.+5.j,  4.-5.j]) 
    &gt;&gt;&gt; v 
    array([[ 1.00000+0.j     , -0.01906-0.40016j, -0.01906+0.40016j], 
           [ 0.00000+0.j     ,  0.00000-0.64788j,  0.00000+0.64788j], 
           [ 0.00000+0.j     ,  0.64788+0.j     ,  0.64788-0.j     ]]) 
 
    &gt;&gt;&gt; wr, vr = linalg.cdf2rdf(w, v) 
    &gt;&gt;&gt; wr 
    array([[ 1.,  0.,  0.], 
           [ 0.,  4.,  5.], 
           [ 0., -5.,  4.]]) 
    &gt;&gt;&gt; vr 
    array([[ 1.     ,  0.40016, -0.01906], 
           [ 0.     ,  0.64788,  0.     ], 
           [ 0.     ,  0.     ,  0.64788]]) 
 
    &gt;&gt;&gt; vr @ wr 
    array([[ 1.     ,  1.69593,  1.9246 ], 
           [ 0.     ,  2.59153,  3.23942], 
           [ 0.     , -3.23942,  2.59153]]) 
    &gt;&gt;&gt; X @ vr 
    array([[ 1.     ,  1.69593,  1.9246 ], 
           [ 0.     ,  2.59153,  3.23942], 
           [ 0.     , -3.23942,  2.59153]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">w</span><span class="s2">, </span><span class="s1">v </span><span class="s2">= </span><span class="s1">_asarray_validated</span><span class="s2">(</span><span class="s1">w</span><span class="s2">), </span><span class="s1">_asarray_validated</span><span class="s2">(</span><span class="s1">v</span><span class="s2">)</span>

    <span class="s0"># check dimensions</span>
    <span class="s4">if </span><span class="s1">w</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&lt; </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'expected w to be at least 1D'</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">v</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&lt; </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'expected v to be at least 2D'</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">v</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s1">w</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'expected eigenvectors array to have exactly one '</span>
                         <span class="s3">'dimension more than eigenvalues array'</span><span class="s2">)</span>

    <span class="s0"># check shapes</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">w</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span>
    <span class="s1">M </span><span class="s2">= </span><span class="s1">w</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">]</span>
    <span class="s4">if </span><span class="s1">v</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">2</span><span class="s2">] != </span><span class="s1">v</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'expected v to be a square matrix or stacked square '</span>
                         <span class="s3">'matrices: v.shape[-2] = v.shape[-1]'</span><span class="s2">)</span>
    <span class="s4">if </span><span class="s1">v</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] != </span><span class="s1">n</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'expected the same number of eigenvalues as '</span>
                         <span class="s3">'eigenvectors'</span><span class="s2">)</span>

    <span class="s0"># get indices for each first pair of complex eigenvalues</span>
    <span class="s1">complex_mask </span><span class="s2">= </span><span class="s1">iscomplex</span><span class="s2">(</span><span class="s1">w</span><span class="s2">)</span>
    <span class="s1">n_complex </span><span class="s2">= </span><span class="s1">complex_mask</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=-</span><span class="s5">1</span><span class="s2">)</span>

    <span class="s0"># check if all complex eigenvalues have conjugate pairs</span>
    <span class="s4">if not </span><span class="s2">(</span><span class="s1">n_complex </span><span class="s2">% </span><span class="s5">2 </span><span class="s2">== </span><span class="s5">0</span><span class="s2">).</span><span class="s1">all</span><span class="s2">():</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'expected complex-conjugate pairs of eigenvalues'</span><span class="s2">)</span>

    <span class="s0"># find complex indices</span>
    <span class="s1">idx </span><span class="s2">= </span><span class="s1">nonzero</span><span class="s2">(</span><span class="s1">complex_mask</span><span class="s2">)</span>
    <span class="s1">idx_stack </span><span class="s2">= </span><span class="s1">idx</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">]</span>
    <span class="s1">idx_elem </span><span class="s2">= </span><span class="s1">idx</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span>

    <span class="s0"># filter them to conjugate indices, assuming pairs are not interleaved</span>
    <span class="s1">j </span><span class="s2">= </span><span class="s1">idx_elem</span><span class="s2">[</span><span class="s5">0</span><span class="s2">::</span><span class="s5">2</span><span class="s2">]</span>
    <span class="s1">k </span><span class="s2">= </span><span class="s1">idx_elem</span><span class="s2">[</span><span class="s5">1</span><span class="s2">::</span><span class="s5">2</span><span class="s2">]</span>
    <span class="s1">stack_ind </span><span class="s2">= ()</span>
    <span class="s4">for </span><span class="s1">i </span><span class="s4">in </span><span class="s1">idx_stack</span><span class="s2">:</span>
        <span class="s0"># should never happen, assuming nonzero orders by the last axis</span>
        <span class="s4">assert </span><span class="s2">(</span><span class="s1">i</span><span class="s2">[</span><span class="s5">0</span><span class="s2">::</span><span class="s5">2</span><span class="s2">] == </span><span class="s1">i</span><span class="s2">[</span><span class="s5">1</span><span class="s2">::</span><span class="s5">2</span><span class="s2">]).</span><span class="s1">all</span><span class="s2">(), </span><span class="s1">\</span>
                <span class="s3">&quot;Conjugate pair spanned different arrays!&quot;</span>
        <span class="s1">stack_ind </span><span class="s2">+= (</span><span class="s1">i</span><span class="s2">[</span><span class="s5">0</span><span class="s2">::</span><span class="s5">2</span><span class="s2">],)</span>

    <span class="s0"># all eigenvalues to diagonal form</span>
    <span class="s1">wr </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">M </span><span class="s2">+ (</span><span class="s1">n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">w</span><span class="s2">.</span><span class="s1">real</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
    <span class="s1">di </span><span class="s2">= </span><span class="s1">range</span><span class="s2">(</span><span class="s1">n</span><span class="s2">)</span>
    <span class="s1">wr</span><span class="s2">[..., </span><span class="s1">di</span><span class="s2">, </span><span class="s1">di</span><span class="s2">] = </span><span class="s1">w</span><span class="s2">.</span><span class="s1">real</span>

    <span class="s0"># complex eigenvalues to real block diagonal form</span>
    <span class="s1">wr</span><span class="s2">[</span><span class="s1">stack_ind </span><span class="s2">+ (</span><span class="s1">j</span><span class="s2">, </span><span class="s1">k</span><span class="s2">)] = </span><span class="s1">w</span><span class="s2">[</span><span class="s1">stack_ind </span><span class="s2">+ (</span><span class="s1">j</span><span class="s2">,)].</span><span class="s1">imag</span>
    <span class="s1">wr</span><span class="s2">[</span><span class="s1">stack_ind </span><span class="s2">+ (</span><span class="s1">k</span><span class="s2">, </span><span class="s1">j</span><span class="s2">)] = </span><span class="s1">w</span><span class="s2">[</span><span class="s1">stack_ind </span><span class="s2">+ (</span><span class="s1">k</span><span class="s2">,)].</span><span class="s1">imag</span>

    <span class="s0"># compute real eigenvectors associated with real block diagonal eigenvalues</span>
    <span class="s1">u </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">M </span><span class="s2">+ (</span><span class="s1">n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">cdouble</span><span class="s2">)</span>
    <span class="s1">u</span><span class="s2">[..., </span><span class="s1">di</span><span class="s2">, </span><span class="s1">di</span><span class="s2">] = </span><span class="s5">1.0</span>
    <span class="s1">u</span><span class="s2">[</span><span class="s1">stack_ind </span><span class="s2">+ (</span><span class="s1">j</span><span class="s2">, </span><span class="s1">j</span><span class="s2">)] = </span><span class="s5">0.5j</span>
    <span class="s1">u</span><span class="s2">[</span><span class="s1">stack_ind </span><span class="s2">+ (</span><span class="s1">j</span><span class="s2">, </span><span class="s1">k</span><span class="s2">)] = </span><span class="s5">0.5</span>
    <span class="s1">u</span><span class="s2">[</span><span class="s1">stack_ind </span><span class="s2">+ (</span><span class="s1">k</span><span class="s2">, </span><span class="s1">j</span><span class="s2">)] = -</span><span class="s5">0.5j</span>
    <span class="s1">u</span><span class="s2">[</span><span class="s1">stack_ind </span><span class="s2">+ (</span><span class="s1">k</span><span class="s2">, </span><span class="s1">k</span><span class="s2">)] = </span><span class="s5">0.5</span>

    <span class="s0"># multiply matrices v and u (equivalent to v @ u)</span>
    <span class="s1">vr </span><span class="s2">= </span><span class="s1">einsum</span><span class="s2">(</span><span class="s3">'...ij,...jk-&gt;...ik'</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">u</span><span class="s2">).</span><span class="s1">real</span>

    <span class="s4">return </span><span class="s1">wr</span><span class="s2">, </span><span class="s1">vr</span>
</pre>
</body>
</html>