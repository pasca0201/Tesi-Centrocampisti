<html>
<head>
<title>_robust_covariance.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_robust_covariance.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Robust location and covariance estimators. 
 
Here are implemented estimators that are resistant to outliers. 
 
&quot;&quot;&quot;</span>

<span class="s2"># Author: Virgile Fritsch &lt;virgile.fritsch@inria.fr&gt;</span>
<span class="s2">#</span>
<span class="s2"># License: BSD 3 clause</span>

<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">from </span><span class="s1">numbers </span><span class="s3">import </span><span class="s1">Integral</span><span class="s4">, </span><span class="s1">Real</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">linalg</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">stats </span><span class="s3">import </span><span class="s1">chi2</span>

<span class="s3">from </span><span class="s4">..</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_fit_context</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils </span><span class="s3">import </span><span class="s1">check_array</span><span class="s4">, </span><span class="s1">check_random_state</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_param_validation </span><span class="s3">import </span><span class="s1">Interval</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">extmath </span><span class="s3">import </span><span class="s1">fast_logdet</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_empirical_covariance </span><span class="s3">import </span><span class="s1">EmpiricalCovariance</span><span class="s4">, </span><span class="s1">empirical_covariance</span>


<span class="s2"># Minimum Covariance Determinant</span>
<span class="s2">#   Implementing of an algorithm by Rousseeuw &amp; Van Driessen described in</span>
<span class="s2">#   (A Fast Algorithm for the Minimum Covariance Determinant Estimator,</span>
<span class="s2">#   1999, American Statistical Association and the American Society</span>
<span class="s2">#   for Quality, TECHNOMETRICS)</span>
<span class="s2"># XXX Is this really a public function? It's not listed in the docs or</span>
<span class="s2"># exported by sklearn.covariance. Deprecate?</span>
<span class="s3">def </span><span class="s1">c_step</span><span class="s4">(</span>
    <span class="s1">X</span><span class="s4">,</span>
    <span class="s1">n_support</span><span class="s4">,</span>
    <span class="s1">remaining_iterations</span><span class="s4">=</span><span class="s5">30</span><span class="s4">,</span>
    <span class="s1">initial_estimates</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">verbose</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s1">cov_computation_method</span><span class="s4">=</span><span class="s1">empirical_covariance</span><span class="s4">,</span>
    <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;C_step procedure described in [Rouseeuw1984]_ aiming at computing MCD. 
 
    Parameters 
    ---------- 
    X : array-like of shape (n_samples, n_features) 
        Data set in which we look for the n_support observations whose 
        scatter matrix has minimum determinant. 
 
    n_support : int 
        Number of observations to compute the robust estimates of location 
        and covariance from. This parameter must be greater than 
        `n_samples / 2`. 
 
    remaining_iterations : int, default=30 
        Number of iterations to perform. 
        According to [Rouseeuw1999]_, two iterations are sufficient to get 
        close to the minimum, and we never need more than 30 to reach 
        convergence. 
 
    initial_estimates : tuple of shape (2,), default=None 
        Initial estimates of location and shape from which to run the c_step 
        procedure: 
        - initial_estimates[0]: an initial location estimate 
        - initial_estimates[1]: an initial covariance estimate 
 
    verbose : bool, default=False 
        Verbose mode. 
 
    cov_computation_method : callable, \ 
            default=:func:`sklearn.covariance.empirical_covariance` 
        The function which will be used to compute the covariance. 
        Must return array of shape (n_features, n_features). 
 
    random_state : int, RandomState instance or None, default=None 
        Determines the pseudo random number generator for shuffling the data. 
        Pass an int for reproducible results across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    Returns 
    ------- 
    location : ndarray of shape (n_features,) 
        Robust location estimates. 
 
    covariance : ndarray of shape (n_features, n_features) 
        Robust covariance estimates. 
 
    support : ndarray of shape (n_samples,) 
        A mask for the `n_support` observations whose scatter matrix has 
        minimum determinant. 
 
    References 
    ---------- 
    .. [Rouseeuw1999] A Fast Algorithm for the Minimum Covariance Determinant 
        Estimator, 1999, American Statistical Association and the American 
        Society for Quality, TECHNOMETRICS 
    &quot;&quot;&quot;</span>
    <span class="s1">X </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">random_state </span><span class="s4">= </span><span class="s1">check_random_state</span><span class="s4">(</span><span class="s1">random_state</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">_c_step</span><span class="s4">(</span>
        <span class="s1">X</span><span class="s4">,</span>
        <span class="s1">n_support</span><span class="s4">,</span>
        <span class="s1">remaining_iterations</span><span class="s4">=</span><span class="s1">remaining_iterations</span><span class="s4">,</span>
        <span class="s1">initial_estimates</span><span class="s4">=</span><span class="s1">initial_estimates</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">,</span>
        <span class="s1">cov_computation_method</span><span class="s4">=</span><span class="s1">cov_computation_method</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">_c_step</span><span class="s4">(</span>
    <span class="s1">X</span><span class="s4">,</span>
    <span class="s1">n_support</span><span class="s4">,</span>
    <span class="s1">random_state</span><span class="s4">,</span>
    <span class="s1">remaining_iterations</span><span class="s4">=</span><span class="s5">30</span><span class="s4">,</span>
    <span class="s1">initial_estimates</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">verbose</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s1">cov_computation_method</span><span class="s4">=</span><span class="s1">empirical_covariance</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_features </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s1">dist </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span>

    <span class="s2"># Initialisation</span>
    <span class="s1">support </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">bool</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">initial_estimates </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s2"># compute initial robust estimates from a random subset</span>
        <span class="s1">support</span><span class="s4">[</span><span class="s1">random_state</span><span class="s4">.</span><span class="s1">permutation</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">)[:</span><span class="s1">n_support</span><span class="s4">]] = </span><span class="s3">True</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s2"># get initial robust estimates from the function parameters</span>
        <span class="s1">location </span><span class="s4">= </span><span class="s1">initial_estimates</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
        <span class="s1">covariance </span><span class="s4">= </span><span class="s1">initial_estimates</span><span class="s4">[</span><span class="s5">1</span><span class="s4">]</span>
        <span class="s2"># run a special iteration for that case (to get an initial support)</span>
        <span class="s1">precision </span><span class="s4">= </span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">pinvh</span><span class="s4">(</span><span class="s1">covariance</span><span class="s4">)</span>
        <span class="s1">X_centered </span><span class="s4">= </span><span class="s1">X </span><span class="s4">- </span><span class="s1">location</span>
        <span class="s1">dist </span><span class="s4">= (</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">X_centered</span><span class="s4">, </span><span class="s1">precision</span><span class="s4">) * </span><span class="s1">X_centered</span><span class="s4">).</span><span class="s1">sum</span><span class="s4">(</span><span class="s5">1</span><span class="s4">)</span>
        <span class="s2"># compute new estimates</span>
        <span class="s1">support</span><span class="s4">[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">argsort</span><span class="s4">(</span><span class="s1">dist</span><span class="s4">)[:</span><span class="s1">n_support</span><span class="s4">]] = </span><span class="s3">True</span>

    <span class="s1">X_support </span><span class="s4">= </span><span class="s1">X</span><span class="s4">[</span><span class="s1">support</span><span class="s4">]</span>
    <span class="s1">location </span><span class="s4">= </span><span class="s1">X_support</span><span class="s4">.</span><span class="s1">mean</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>
    <span class="s1">covariance </span><span class="s4">= </span><span class="s1">cov_computation_method</span><span class="s4">(</span><span class="s1">X_support</span><span class="s4">)</span>

    <span class="s2"># Iterative procedure for Minimum Covariance Determinant computation</span>
    <span class="s1">det </span><span class="s4">= </span><span class="s1">fast_logdet</span><span class="s4">(</span><span class="s1">covariance</span><span class="s4">)</span>
    <span class="s2"># If the data already has singular covariance, calculate the precision,</span>
    <span class="s2"># as the loop below will not be entered.</span>
    <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isinf</span><span class="s4">(</span><span class="s1">det</span><span class="s4">):</span>
        <span class="s1">precision </span><span class="s4">= </span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">pinvh</span><span class="s4">(</span><span class="s1">covariance</span><span class="s4">)</span>

    <span class="s1">previous_det </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span>
    <span class="s3">while </span><span class="s1">det </span><span class="s4">&lt; </span><span class="s1">previous_det </span><span class="s3">and </span><span class="s1">remaining_iterations </span><span class="s4">&gt; </span><span class="s5">0 </span><span class="s3">and not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isinf</span><span class="s4">(</span><span class="s1">det</span><span class="s4">):</span>
        <span class="s2"># save old estimates values</span>
        <span class="s1">previous_location </span><span class="s4">= </span><span class="s1">location</span>
        <span class="s1">previous_covariance </span><span class="s4">= </span><span class="s1">covariance</span>
        <span class="s1">previous_det </span><span class="s4">= </span><span class="s1">det</span>
        <span class="s1">previous_support </span><span class="s4">= </span><span class="s1">support</span>
        <span class="s2"># compute a new support from the full data set mahalanobis distances</span>
        <span class="s1">precision </span><span class="s4">= </span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">pinvh</span><span class="s4">(</span><span class="s1">covariance</span><span class="s4">)</span>
        <span class="s1">X_centered </span><span class="s4">= </span><span class="s1">X </span><span class="s4">- </span><span class="s1">location</span>
        <span class="s1">dist </span><span class="s4">= (</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">X_centered</span><span class="s4">, </span><span class="s1">precision</span><span class="s4">) * </span><span class="s1">X_centered</span><span class="s4">).</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)</span>
        <span class="s2"># compute new estimates</span>
        <span class="s1">support </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">bool</span><span class="s4">)</span>
        <span class="s1">support</span><span class="s4">[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">argsort</span><span class="s4">(</span><span class="s1">dist</span><span class="s4">)[:</span><span class="s1">n_support</span><span class="s4">]] = </span><span class="s3">True</span>
        <span class="s1">X_support </span><span class="s4">= </span><span class="s1">X</span><span class="s4">[</span><span class="s1">support</span><span class="s4">]</span>
        <span class="s1">location </span><span class="s4">= </span><span class="s1">X_support</span><span class="s4">.</span><span class="s1">mean</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">0</span><span class="s4">)</span>
        <span class="s1">covariance </span><span class="s4">= </span><span class="s1">cov_computation_method</span><span class="s4">(</span><span class="s1">X_support</span><span class="s4">)</span>
        <span class="s1">det </span><span class="s4">= </span><span class="s1">fast_logdet</span><span class="s4">(</span><span class="s1">covariance</span><span class="s4">)</span>
        <span class="s2"># update remaining iterations for early stopping</span>
        <span class="s1">remaining_iterations </span><span class="s4">-= </span><span class="s5">1</span>

    <span class="s1">previous_dist </span><span class="s4">= </span><span class="s1">dist</span>
    <span class="s1">dist </span><span class="s4">= (</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">X </span><span class="s4">- </span><span class="s1">location</span><span class="s4">, </span><span class="s1">precision</span><span class="s4">) * (</span><span class="s1">X </span><span class="s4">- </span><span class="s1">location</span><span class="s4">)).</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s2"># Check if best fit already found (det =&gt; 0, logdet =&gt; -inf)</span>
    <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isinf</span><span class="s4">(</span><span class="s1">det</span><span class="s4">):</span>
        <span class="s1">results </span><span class="s4">= </span><span class="s1">location</span><span class="s4">, </span><span class="s1">covariance</span><span class="s4">, </span><span class="s1">det</span><span class="s4">, </span><span class="s1">support</span><span class="s4">, </span><span class="s1">dist</span>
    <span class="s2"># Check convergence</span>
    <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">allclose</span><span class="s4">(</span><span class="s1">det</span><span class="s4">, </span><span class="s1">previous_det</span><span class="s4">):</span>
        <span class="s2"># c_step procedure converged</span>
        <span class="s3">if </span><span class="s1">verbose</span><span class="s4">:</span>
            <span class="s1">print</span><span class="s4">(</span>
                <span class="s6">&quot;Optimal couple (location, covariance) found before&quot;</span>
                <span class="s6">&quot; ending iterations (%d left)&quot; </span><span class="s4">% (</span><span class="s1">remaining_iterations</span><span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s1">results </span><span class="s4">= </span><span class="s1">location</span><span class="s4">, </span><span class="s1">covariance</span><span class="s4">, </span><span class="s1">det</span><span class="s4">, </span><span class="s1">support</span><span class="s4">, </span><span class="s1">dist</span>
    <span class="s3">elif </span><span class="s1">det </span><span class="s4">&gt; </span><span class="s1">previous_det</span><span class="s4">:</span>
        <span class="s2"># determinant has increased (should not happen)</span>
        <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
            <span class="s6">&quot;Determinant has increased; this should not happen: &quot;</span>
            <span class="s6">&quot;log(det) &gt; log(previous_det) (%.15f &gt; %.15f). &quot;</span>
            <span class="s6">&quot;You may want to try with a higher value of &quot;</span>
            <span class="s6">&quot;support_fraction (current value: %.3f).&quot;</span>
            <span class="s4">% (</span><span class="s1">det</span><span class="s4">, </span><span class="s1">previous_det</span><span class="s4">, </span><span class="s1">n_support </span><span class="s4">/ </span><span class="s1">n_samples</span><span class="s4">),</span>
            <span class="s1">RuntimeWarning</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">results </span><span class="s4">= (</span>
            <span class="s1">previous_location</span><span class="s4">,</span>
            <span class="s1">previous_covariance</span><span class="s4">,</span>
            <span class="s1">previous_det</span><span class="s4">,</span>
            <span class="s1">previous_support</span><span class="s4">,</span>
            <span class="s1">previous_dist</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s2"># Check early stopping</span>
    <span class="s3">if </span><span class="s1">remaining_iterations </span><span class="s4">== </span><span class="s5">0</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">verbose</span><span class="s4">:</span>
            <span class="s1">print</span><span class="s4">(</span><span class="s6">&quot;Maximum number of iterations reached&quot;</span><span class="s4">)</span>
        <span class="s1">results </span><span class="s4">= </span><span class="s1">location</span><span class="s4">, </span><span class="s1">covariance</span><span class="s4">, </span><span class="s1">det</span><span class="s4">, </span><span class="s1">support</span><span class="s4">, </span><span class="s1">dist</span>

    <span class="s3">return </span><span class="s1">results</span>


<span class="s3">def </span><span class="s1">select_candidates</span><span class="s4">(</span>
    <span class="s1">X</span><span class="s4">,</span>
    <span class="s1">n_support</span><span class="s4">,</span>
    <span class="s1">n_trials</span><span class="s4">,</span>
    <span class="s1">select</span><span class="s4">=</span><span class="s5">1</span><span class="s4">,</span>
    <span class="s1">n_iter</span><span class="s4">=</span><span class="s5">30</span><span class="s4">,</span>
    <span class="s1">verbose</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s1">cov_computation_method</span><span class="s4">=</span><span class="s1">empirical_covariance</span><span class="s4">,</span>
    <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Finds the best pure subset of observations to compute MCD from it. 
 
    The purpose of this function is to find the best sets of n_support 
    observations with respect to a minimization of their covariance 
    matrix determinant. Equivalently, it removes n_samples-n_support 
    observations to construct what we call a pure data set (i.e. not 
    containing outliers). The list of the observations of the pure 
    data set is referred to as the `support`. 
 
    Starting from a random support, the pure data set is found by the 
    c_step procedure introduced by Rousseeuw and Van Driessen in 
    [RV]_. 
 
    Parameters 
    ---------- 
    X : array-like of shape (n_samples, n_features) 
        Data (sub)set in which we look for the n_support purest observations. 
 
    n_support : int 
        The number of samples the pure data set must contain. 
        This parameter must be in the range `[(n + p + 1)/2] &lt; n_support &lt; n`. 
 
    n_trials : int or tuple of shape (2,) 
        Number of different initial sets of observations from which to 
        run the algorithm. This parameter should be a strictly positive 
        integer. 
        Instead of giving a number of trials to perform, one can provide a 
        list of initial estimates that will be used to iteratively run 
        c_step procedures. In this case: 
        - n_trials[0]: array-like, shape (n_trials, n_features) 
          is the list of `n_trials` initial location estimates 
        - n_trials[1]: array-like, shape (n_trials, n_features, n_features) 
          is the list of `n_trials` initial covariances estimates 
 
    select : int, default=1 
        Number of best candidates results to return. This parameter must be 
        a strictly positive integer. 
 
    n_iter : int, default=30 
        Maximum number of iterations for the c_step procedure. 
        (2 is enough to be close to the final solution. &quot;Never&quot; exceeds 20). 
        This parameter must be a strictly positive integer. 
 
    verbose : bool, default=False 
        Control the output verbosity. 
 
    cov_computation_method : callable, \ 
            default=:func:`sklearn.covariance.empirical_covariance` 
        The function which will be used to compute the covariance. 
        Must return an array of shape (n_features, n_features). 
 
    random_state : int, RandomState instance or None, default=None 
        Determines the pseudo random number generator for shuffling the data. 
        Pass an int for reproducible results across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    See Also 
    --------- 
    c_step 
 
    Returns 
    ------- 
    best_locations : ndarray of shape (select, n_features) 
        The `select` location estimates computed from the `select` best 
        supports found in the data set (`X`). 
 
    best_covariances : ndarray of shape (select, n_features, n_features) 
        The `select` covariance estimates computed from the `select` 
        best supports found in the data set (`X`). 
 
    best_supports : ndarray of shape (select, n_samples) 
        The `select` best supports found in the data set (`X`). 
 
    References 
    ---------- 
    .. [RV] A Fast Algorithm for the Minimum Covariance Determinant 
        Estimator, 1999, American Statistical Association and the American 
        Society for Quality, TECHNOMETRICS 
    &quot;&quot;&quot;</span>
    <span class="s1">random_state </span><span class="s4">= </span><span class="s1">check_random_state</span><span class="s4">(</span><span class="s1">random_state</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">n_trials</span><span class="s4">, </span><span class="s1">Integral</span><span class="s4">):</span>
        <span class="s1">run_from_estimates </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">n_trials</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">):</span>
        <span class="s1">run_from_estimates </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s1">estimates_list </span><span class="s4">= </span><span class="s1">n_trials</span>
        <span class="s1">n_trials </span><span class="s4">= </span><span class="s1">estimates_list</span><span class="s4">[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span>
            <span class="s6">&quot;Invalid 'n_trials' parameter, expected tuple or  integer, got %s (%s)&quot;</span>
            <span class="s4">% (</span><span class="s1">n_trials</span><span class="s4">, </span><span class="s1">type</span><span class="s4">(</span><span class="s1">n_trials</span><span class="s4">))</span>
        <span class="s4">)</span>

    <span class="s2"># compute `n_trials` location and shape estimates candidates in the subset</span>
    <span class="s1">all_estimates </span><span class="s4">= []</span>
    <span class="s3">if not </span><span class="s1">run_from_estimates</span><span class="s4">:</span>
        <span class="s2"># perform `n_trials` computations from random initial supports</span>
        <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">n_trials</span><span class="s4">):</span>
            <span class="s1">all_estimates</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span>
                <span class="s1">_c_step</span><span class="s4">(</span>
                    <span class="s1">X</span><span class="s4">,</span>
                    <span class="s1">n_support</span><span class="s4">,</span>
                    <span class="s1">remaining_iterations</span><span class="s4">=</span><span class="s1">n_iter</span><span class="s4">,</span>
                    <span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">,</span>
                    <span class="s1">cov_computation_method</span><span class="s4">=</span><span class="s1">cov_computation_method</span><span class="s4">,</span>
                    <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
                <span class="s4">)</span>
            <span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s2"># perform computations from every given initial estimates</span>
        <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">n_trials</span><span class="s4">):</span>
            <span class="s1">initial_estimates </span><span class="s4">= (</span><span class="s1">estimates_list</span><span class="s4">[</span><span class="s5">0</span><span class="s4">][</span><span class="s1">j</span><span class="s4">], </span><span class="s1">estimates_list</span><span class="s4">[</span><span class="s5">1</span><span class="s4">][</span><span class="s1">j</span><span class="s4">])</span>
            <span class="s1">all_estimates</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span>
                <span class="s1">_c_step</span><span class="s4">(</span>
                    <span class="s1">X</span><span class="s4">,</span>
                    <span class="s1">n_support</span><span class="s4">,</span>
                    <span class="s1">remaining_iterations</span><span class="s4">=</span><span class="s1">n_iter</span><span class="s4">,</span>
                    <span class="s1">initial_estimates</span><span class="s4">=</span><span class="s1">initial_estimates</span><span class="s4">,</span>
                    <span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">,</span>
                    <span class="s1">cov_computation_method</span><span class="s4">=</span><span class="s1">cov_computation_method</span><span class="s4">,</span>
                    <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
                <span class="s4">)</span>
            <span class="s4">)</span>
    <span class="s1">all_locs_sub</span><span class="s4">, </span><span class="s1">all_covs_sub</span><span class="s4">, </span><span class="s1">all_dets_sub</span><span class="s4">, </span><span class="s1">all_supports_sub</span><span class="s4">, </span><span class="s1">all_ds_sub </span><span class="s4">= </span><span class="s1">zip</span><span class="s4">(</span>
        <span class="s4">*</span><span class="s1">all_estimates</span>
    <span class="s4">)</span>
    <span class="s2"># find the `n_best` best results among the `n_trials` ones</span>
    <span class="s1">index_best </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">argsort</span><span class="s4">(</span><span class="s1">all_dets_sub</span><span class="s4">)[:</span><span class="s1">select</span><span class="s4">]</span>
    <span class="s1">best_locations </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">all_locs_sub</span><span class="s4">)[</span><span class="s1">index_best</span><span class="s4">]</span>
    <span class="s1">best_covariances </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">all_covs_sub</span><span class="s4">)[</span><span class="s1">index_best</span><span class="s4">]</span>
    <span class="s1">best_supports </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">all_supports_sub</span><span class="s4">)[</span><span class="s1">index_best</span><span class="s4">]</span>
    <span class="s1">best_ds </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">all_ds_sub</span><span class="s4">)[</span><span class="s1">index_best</span><span class="s4">]</span>

    <span class="s3">return </span><span class="s1">best_locations</span><span class="s4">, </span><span class="s1">best_covariances</span><span class="s4">, </span><span class="s1">best_supports</span><span class="s4">, </span><span class="s1">best_ds</span>


<span class="s3">def </span><span class="s1">fast_mcd</span><span class="s4">(</span>
    <span class="s1">X</span><span class="s4">,</span>
    <span class="s1">support_fraction</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">cov_computation_method</span><span class="s4">=</span><span class="s1">empirical_covariance</span><span class="s4">,</span>
    <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Estimate the Minimum Covariance Determinant matrix. 
 
    Read more in the :ref:`User Guide &lt;robust_covariance&gt;`. 
 
    Parameters 
    ---------- 
    X : array-like of shape (n_samples, n_features) 
        The data matrix, with p features and n samples. 
 
    support_fraction : float, default=None 
        The proportion of points to be included in the support of the raw 
        MCD estimate. Default is `None`, which implies that the minimum 
        value of `support_fraction` will be used within the algorithm: 
        `(n_samples + n_features + 1) / 2 * n_samples`. This parameter must be 
        in the range (0, 1). 
 
    cov_computation_method : callable, \ 
            default=:func:`sklearn.covariance.empirical_covariance` 
        The function which will be used to compute the covariance. 
        Must return an array of shape (n_features, n_features). 
 
    random_state : int, RandomState instance or None, default=None 
        Determines the pseudo random number generator for shuffling the data. 
        Pass an int for reproducible results across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    Returns 
    ------- 
    location : ndarray of shape (n_features,) 
        Robust location of the data. 
 
    covariance : ndarray of shape (n_features, n_features) 
        Robust covariance of the features. 
 
    support : ndarray of shape (n_samples,), dtype=bool 
        A mask of the observations that have been used to compute 
        the robust location and covariance estimates of the data set. 
 
    Notes 
    ----- 
    The FastMCD algorithm has been introduced by Rousseuw and Van Driessen 
    in &quot;A Fast Algorithm for the Minimum Covariance Determinant Estimator, 
    1999, American Statistical Association and the American Society 
    for Quality, TECHNOMETRICS&quot;. 
    The principle is to compute robust estimates and random subsets before 
    pooling them into a larger subsets, and finally into the full data set. 
    Depending on the size of the initial sample, we have one, two or three 
    such computation levels. 
 
    Note that only raw estimates are returned. If one is interested in 
    the correction and reweighting steps described in [RouseeuwVan]_, 
    see the MinCovDet object. 
 
    References 
    ---------- 
 
    .. [RouseeuwVan] A Fast Algorithm for the Minimum Covariance 
        Determinant Estimator, 1999, American Statistical Association 
        and the American Society for Quality, TECHNOMETRICS 
 
    .. [Butler1993] R. W. Butler, P. L. Davies and M. Jhun, 
        Asymptotics For The Minimum Covariance Determinant Estimator, 
        The Annals of Statistics, 1993, Vol. 21, No. 3, 1385-1400 
    &quot;&quot;&quot;</span>
    <span class="s1">random_state </span><span class="s4">= </span><span class="s1">check_random_state</span><span class="s4">(</span><span class="s1">random_state</span><span class="s4">)</span>

    <span class="s1">X </span><span class="s4">= </span><span class="s1">check_array</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">ensure_min_samples</span><span class="s4">=</span><span class="s5">2</span><span class="s4">, </span><span class="s1">estimator</span><span class="s4">=</span><span class="s6">&quot;fast_mcd&quot;</span><span class="s4">)</span>
    <span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_features </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span>

    <span class="s2"># minimum breakdown value</span>
    <span class="s3">if </span><span class="s1">support_fraction </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">n_support </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ceil</span><span class="s4">(</span><span class="s5">0.5 </span><span class="s4">* (</span><span class="s1">n_samples </span><span class="s4">+ </span><span class="s1">n_features </span><span class="s4">+ </span><span class="s5">1</span><span class="s4">)))</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">n_support </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">support_fraction </span><span class="s4">* </span><span class="s1">n_samples</span><span class="s4">)</span>

    <span class="s2"># 1-dimensional case quick computation</span>
    <span class="s2"># (Rousseeuw, P. J. and Leroy, A. M. (2005) References, in Robust</span>
    <span class="s2">#  Regression and Outlier Detection, John Wiley &amp; Sons, chapter 4)</span>
    <span class="s3">if </span><span class="s1">n_features </span><span class="s4">== </span><span class="s5">1</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">n_support </span><span class="s4">&lt; </span><span class="s1">n_samples</span><span class="s4">:</span>
            <span class="s2"># find the sample shortest halves</span>
            <span class="s1">X_sorted </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sort</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">))</span>
            <span class="s1">diff </span><span class="s4">= </span><span class="s1">X_sorted</span><span class="s4">[</span><span class="s1">n_support</span><span class="s4">:] - </span><span class="s1">X_sorted</span><span class="s4">[: (</span><span class="s1">n_samples </span><span class="s4">- </span><span class="s1">n_support</span><span class="s4">)]</span>
            <span class="s1">halves_start </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">where</span><span class="s4">(</span><span class="s1">diff </span><span class="s4">== </span><span class="s1">np</span><span class="s4">.</span><span class="s1">min</span><span class="s4">(</span><span class="s1">diff</span><span class="s4">))[</span><span class="s5">0</span><span class="s4">]</span>
            <span class="s2"># take the middle points' mean to get the robust location estimate</span>
            <span class="s1">location </span><span class="s4">= (</span>
                <span class="s5">0.5</span>
                <span class="s4">* (</span><span class="s1">X_sorted</span><span class="s4">[</span><span class="s1">n_support </span><span class="s4">+ </span><span class="s1">halves_start</span><span class="s4">] + </span><span class="s1">X_sorted</span><span class="s4">[</span><span class="s1">halves_start</span><span class="s4">]).</span><span class="s1">mean</span><span class="s4">()</span>
            <span class="s4">)</span>
            <span class="s1">support </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">bool</span><span class="s4">)</span>
            <span class="s1">X_centered </span><span class="s4">= </span><span class="s1">X </span><span class="s4">- </span><span class="s1">location</span>
            <span class="s1">support</span><span class="s4">[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">argsort</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">X_centered</span><span class="s4">), </span><span class="s5">0</span><span class="s4">)[:</span><span class="s1">n_support</span><span class="s4">]] = </span><span class="s3">True</span>
            <span class="s1">covariance </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">([[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">var</span><span class="s4">(</span><span class="s1">X</span><span class="s4">[</span><span class="s1">support</span><span class="s4">])]])</span>
            <span class="s1">location </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">([</span><span class="s1">location</span><span class="s4">])</span>
            <span class="s2"># get precision matrix in an optimized way</span>
            <span class="s1">precision </span><span class="s4">= </span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">pinvh</span><span class="s4">(</span><span class="s1">covariance</span><span class="s4">)</span>
            <span class="s1">dist </span><span class="s4">= (</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">X_centered</span><span class="s4">, </span><span class="s1">precision</span><span class="s4">) * (</span><span class="s1">X_centered</span><span class="s4">)).</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">support </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">bool</span><span class="s4">)</span>
            <span class="s1">covariance </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">([[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">var</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)]])</span>
            <span class="s1">location </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">([</span><span class="s1">np</span><span class="s4">.</span><span class="s1">mean</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)])</span>
            <span class="s1">X_centered </span><span class="s4">= </span><span class="s1">X </span><span class="s4">- </span><span class="s1">location</span>
            <span class="s2"># get precision matrix in an optimized way</span>
            <span class="s1">precision </span><span class="s4">= </span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">pinvh</span><span class="s4">(</span><span class="s1">covariance</span><span class="s4">)</span>
            <span class="s1">dist </span><span class="s4">= (</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">X_centered</span><span class="s4">, </span><span class="s1">precision</span><span class="s4">) * (</span><span class="s1">X_centered</span><span class="s4">)).</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">1</span><span class="s4">)</span>
    <span class="s2"># Starting FastMCD algorithm for p-dimensional case</span>
    <span class="s3">if </span><span class="s4">(</span><span class="s1">n_samples </span><span class="s4">&gt; </span><span class="s5">500</span><span class="s4">) </span><span class="s3">and </span><span class="s4">(</span><span class="s1">n_features </span><span class="s4">&gt; </span><span class="s5">1</span><span class="s4">):</span>
        <span class="s2"># 1. Find candidate supports on subsets</span>
        <span class="s2"># a. split the set in subsets of size ~ 300</span>
        <span class="s1">n_subsets </span><span class="s4">= </span><span class="s1">n_samples </span><span class="s4">// </span><span class="s5">300</span>
        <span class="s1">n_samples_subsets </span><span class="s4">= </span><span class="s1">n_samples </span><span class="s4">// </span><span class="s1">n_subsets</span>
        <span class="s1">samples_shuffle </span><span class="s4">= </span><span class="s1">random_state</span><span class="s4">.</span><span class="s1">permutation</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">)</span>
        <span class="s1">h_subset </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ceil</span><span class="s4">(</span><span class="s1">n_samples_subsets </span><span class="s4">* (</span><span class="s1">n_support </span><span class="s4">/ </span><span class="s1">float</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">))))</span>
        <span class="s2"># b. perform a total of 500 trials</span>
        <span class="s1">n_trials_tot </span><span class="s4">= </span><span class="s5">500</span>
        <span class="s2"># c. select 10 best (location, covariance) for each subset</span>
        <span class="s1">n_best_sub </span><span class="s4">= </span><span class="s5">10</span>
        <span class="s1">n_trials </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s5">10</span><span class="s4">, </span><span class="s1">n_trials_tot </span><span class="s4">// </span><span class="s1">n_subsets</span><span class="s4">)</span>
        <span class="s1">n_best_tot </span><span class="s4">= </span><span class="s1">n_subsets </span><span class="s4">* </span><span class="s1">n_best_sub</span>
        <span class="s1">all_best_locations </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n_best_tot</span><span class="s4">, </span><span class="s1">n_features</span><span class="s4">))</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">all_best_covariances </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n_best_tot</span><span class="s4">, </span><span class="s1">n_features</span><span class="s4">, </span><span class="s1">n_features</span><span class="s4">))</span>
        <span class="s3">except </span><span class="s1">MemoryError</span><span class="s4">:</span>
            <span class="s2"># The above is too big. Let's try with something much small</span>
            <span class="s2"># (and less optimal)</span>
            <span class="s1">n_best_tot </span><span class="s4">= </span><span class="s5">10</span>
            <span class="s1">all_best_covariances </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">n_best_tot</span><span class="s4">, </span><span class="s1">n_features</span><span class="s4">, </span><span class="s1">n_features</span><span class="s4">))</span>
            <span class="s1">n_best_sub </span><span class="s4">= </span><span class="s5">2</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">n_subsets</span><span class="s4">):</span>
            <span class="s1">low_bound </span><span class="s4">= </span><span class="s1">i </span><span class="s4">* </span><span class="s1">n_samples_subsets</span>
            <span class="s1">high_bound </span><span class="s4">= </span><span class="s1">low_bound </span><span class="s4">+ </span><span class="s1">n_samples_subsets</span>
            <span class="s1">current_subset </span><span class="s4">= </span><span class="s1">X</span><span class="s4">[</span><span class="s1">samples_shuffle</span><span class="s4">[</span><span class="s1">low_bound</span><span class="s4">:</span><span class="s1">high_bound</span><span class="s4">]]</span>
            <span class="s1">best_locations_sub</span><span class="s4">, </span><span class="s1">best_covariances_sub</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">select_candidates</span><span class="s4">(</span>
                <span class="s1">current_subset</span><span class="s4">,</span>
                <span class="s1">h_subset</span><span class="s4">,</span>
                <span class="s1">n_trials</span><span class="s4">,</span>
                <span class="s1">select</span><span class="s4">=</span><span class="s1">n_best_sub</span><span class="s4">,</span>
                <span class="s1">n_iter</span><span class="s4">=</span><span class="s5">2</span><span class="s4">,</span>
                <span class="s1">cov_computation_method</span><span class="s4">=</span><span class="s1">cov_computation_method</span><span class="s4">,</span>
                <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s1">subset_slice </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s1">i </span><span class="s4">* </span><span class="s1">n_best_sub</span><span class="s4">, (</span><span class="s1">i </span><span class="s4">+ </span><span class="s5">1</span><span class="s4">) * </span><span class="s1">n_best_sub</span><span class="s4">)</span>
            <span class="s1">all_best_locations</span><span class="s4">[</span><span class="s1">subset_slice</span><span class="s4">] = </span><span class="s1">best_locations_sub</span>
            <span class="s1">all_best_covariances</span><span class="s4">[</span><span class="s1">subset_slice</span><span class="s4">] = </span><span class="s1">best_covariances_sub</span>
        <span class="s2"># 2. Pool the candidate supports into a merged set</span>
        <span class="s2"># (possibly the full dataset)</span>
        <span class="s1">n_samples_merged </span><span class="s4">= </span><span class="s1">min</span><span class="s4">(</span><span class="s5">1500</span><span class="s4">, </span><span class="s1">n_samples</span><span class="s4">)</span>
        <span class="s1">h_merged </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ceil</span><span class="s4">(</span><span class="s1">n_samples_merged </span><span class="s4">* (</span><span class="s1">n_support </span><span class="s4">/ </span><span class="s1">float</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">))))</span>
        <span class="s3">if </span><span class="s1">n_samples </span><span class="s4">&gt; </span><span class="s5">1500</span><span class="s4">:</span>
            <span class="s1">n_best_merged </span><span class="s4">= </span><span class="s5">10</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">n_best_merged </span><span class="s4">= </span><span class="s5">1</span>
        <span class="s2"># find the best couples (location, covariance) on the merged set</span>
        <span class="s1">selection </span><span class="s4">= </span><span class="s1">random_state</span><span class="s4">.</span><span class="s1">permutation</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">)[:</span><span class="s1">n_samples_merged</span><span class="s4">]</span>
        <span class="s1">locations_merged</span><span class="s4">, </span><span class="s1">covariances_merged</span><span class="s4">, </span><span class="s1">supports_merged</span><span class="s4">, </span><span class="s1">d </span><span class="s4">= </span><span class="s1">select_candidates</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">[</span><span class="s1">selection</span><span class="s4">],</span>
            <span class="s1">h_merged</span><span class="s4">,</span>
            <span class="s1">n_trials</span><span class="s4">=(</span><span class="s1">all_best_locations</span><span class="s4">, </span><span class="s1">all_best_covariances</span><span class="s4">),</span>
            <span class="s1">select</span><span class="s4">=</span><span class="s1">n_best_merged</span><span class="s4">,</span>
            <span class="s1">cov_computation_method</span><span class="s4">=</span><span class="s1">cov_computation_method</span><span class="s4">,</span>
            <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s2"># 3. Finally get the overall best (locations, covariance) couple</span>
        <span class="s3">if </span><span class="s1">n_samples </span><span class="s4">&lt; </span><span class="s5">1500</span><span class="s4">:</span>
            <span class="s2"># directly get the best couple (location, covariance)</span>
            <span class="s1">location </span><span class="s4">= </span><span class="s1">locations_merged</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
            <span class="s1">covariance </span><span class="s4">= </span><span class="s1">covariances_merged</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
            <span class="s1">support </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">bool</span><span class="s4">)</span>
            <span class="s1">dist </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">)</span>
            <span class="s1">support</span><span class="s4">[</span><span class="s1">selection</span><span class="s4">] = </span><span class="s1">supports_merged</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
            <span class="s1">dist</span><span class="s4">[</span><span class="s1">selection</span><span class="s4">] = </span><span class="s1">d</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s2"># select the best couple on the full dataset</span>
            <span class="s1">locations_full</span><span class="s4">, </span><span class="s1">covariances_full</span><span class="s4">, </span><span class="s1">supports_full</span><span class="s4">, </span><span class="s1">d </span><span class="s4">= </span><span class="s1">select_candidates</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">,</span>
                <span class="s1">n_support</span><span class="s4">,</span>
                <span class="s1">n_trials</span><span class="s4">=(</span><span class="s1">locations_merged</span><span class="s4">, </span><span class="s1">covariances_merged</span><span class="s4">),</span>
                <span class="s1">select</span><span class="s4">=</span><span class="s5">1</span><span class="s4">,</span>
                <span class="s1">cov_computation_method</span><span class="s4">=</span><span class="s1">cov_computation_method</span><span class="s4">,</span>
                <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s1">location </span><span class="s4">= </span><span class="s1">locations_full</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
            <span class="s1">covariance </span><span class="s4">= </span><span class="s1">covariances_full</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
            <span class="s1">support </span><span class="s4">= </span><span class="s1">supports_full</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
            <span class="s1">dist </span><span class="s4">= </span><span class="s1">d</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
    <span class="s3">elif </span><span class="s1">n_features </span><span class="s4">&gt; </span><span class="s5">1</span><span class="s4">:</span>
        <span class="s2"># 1. Find the 10 best couples (location, covariance)</span>
        <span class="s2"># considering two iterations</span>
        <span class="s1">n_trials </span><span class="s4">= </span><span class="s5">30</span>
        <span class="s1">n_best </span><span class="s4">= </span><span class="s5">10</span>
        <span class="s1">locations_best</span><span class="s4">, </span><span class="s1">covariances_best</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">select_candidates</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">n_support</span><span class="s4">,</span>
            <span class="s1">n_trials</span><span class="s4">=</span><span class="s1">n_trials</span><span class="s4">,</span>
            <span class="s1">select</span><span class="s4">=</span><span class="s1">n_best</span><span class="s4">,</span>
            <span class="s1">n_iter</span><span class="s4">=</span><span class="s5">2</span><span class="s4">,</span>
            <span class="s1">cov_computation_method</span><span class="s4">=</span><span class="s1">cov_computation_method</span><span class="s4">,</span>
            <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s2"># 2. Select the best couple on the full dataset amongst the 10</span>
        <span class="s1">locations_full</span><span class="s4">, </span><span class="s1">covariances_full</span><span class="s4">, </span><span class="s1">supports_full</span><span class="s4">, </span><span class="s1">d </span><span class="s4">= </span><span class="s1">select_candidates</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">n_support</span><span class="s4">,</span>
            <span class="s1">n_trials</span><span class="s4">=(</span><span class="s1">locations_best</span><span class="s4">, </span><span class="s1">covariances_best</span><span class="s4">),</span>
            <span class="s1">select</span><span class="s4">=</span><span class="s5">1</span><span class="s4">,</span>
            <span class="s1">cov_computation_method</span><span class="s4">=</span><span class="s1">cov_computation_method</span><span class="s4">,</span>
            <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">location </span><span class="s4">= </span><span class="s1">locations_full</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
        <span class="s1">covariance </span><span class="s4">= </span><span class="s1">covariances_full</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
        <span class="s1">support </span><span class="s4">= </span><span class="s1">supports_full</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
        <span class="s1">dist </span><span class="s4">= </span><span class="s1">d</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>

    <span class="s3">return </span><span class="s1">location</span><span class="s4">, </span><span class="s1">covariance</span><span class="s4">, </span><span class="s1">support</span><span class="s4">, </span><span class="s1">dist</span>


<span class="s3">class </span><span class="s1">MinCovDet</span><span class="s4">(</span><span class="s1">EmpiricalCovariance</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Minimum Covariance Determinant (MCD): robust estimator of covariance. 
 
    The Minimum Covariance Determinant covariance estimator is to be applied 
    on Gaussian-distributed data, but could still be relevant on data 
    drawn from a unimodal, symmetric distribution. It is not meant to be used 
    with multi-modal data (the algorithm used to fit a MinCovDet object is 
    likely to fail in such a case). 
    One should consider projection pursuit methods to deal with multi-modal 
    datasets. 
 
    Read more in the :ref:`User Guide &lt;robust_covariance&gt;`. 
 
    Parameters 
    ---------- 
    store_precision : bool, default=True 
        Specify if the estimated precision is stored. 
 
    assume_centered : bool, default=False 
        If True, the support of the robust location and the covariance 
        estimates is computed, and a covariance estimate is recomputed from 
        it, without centering the data. 
        Useful to work with data whose mean is significantly equal to 
        zero but is not exactly zero. 
        If False, the robust location and covariance are directly computed 
        with the FastMCD algorithm without additional treatment. 
 
    support_fraction : float, default=None 
        The proportion of points to be included in the support of the raw 
        MCD estimate. Default is None, which implies that the minimum 
        value of support_fraction will be used within the algorithm: 
        `(n_samples + n_features + 1) / 2 * n_samples`. The parameter must be 
        in the range (0, 1]. 
 
    random_state : int, RandomState instance or None, default=None 
        Determines the pseudo random number generator for shuffling the data. 
        Pass an int for reproducible results across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    Attributes 
    ---------- 
    raw_location_ : ndarray of shape (n_features,) 
        The raw robust estimated location before correction and re-weighting. 
 
    raw_covariance_ : ndarray of shape (n_features, n_features) 
        The raw robust estimated covariance before correction and re-weighting. 
 
    raw_support_ : ndarray of shape (n_samples,) 
        A mask of the observations that have been used to compute 
        the raw robust estimates of location and shape, before correction 
        and re-weighting. 
 
    location_ : ndarray of shape (n_features,) 
        Estimated robust location. 
 
    covariance_ : ndarray of shape (n_features, n_features) 
        Estimated robust covariance matrix. 
 
    precision_ : ndarray of shape (n_features, n_features) 
        Estimated pseudo inverse matrix. 
        (stored only if store_precision is True) 
 
    support_ : ndarray of shape (n_samples,) 
        A mask of the observations that have been used to compute 
        the robust estimates of location and shape. 
 
    dist_ : ndarray of shape (n_samples,) 
        Mahalanobis distances of the training set (on which :meth:`fit` is 
        called) observations. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    EllipticEnvelope : An object for detecting outliers in 
        a Gaussian distributed dataset. 
    EmpiricalCovariance : Maximum likelihood covariance estimator. 
    GraphicalLasso : Sparse inverse covariance estimation 
        with an l1-penalized estimator. 
    GraphicalLassoCV : Sparse inverse covariance with cross-validated 
        choice of the l1 penalty. 
    LedoitWolf : LedoitWolf Estimator. 
    OAS : Oracle Approximating Shrinkage Estimator. 
    ShrunkCovariance : Covariance estimator with shrinkage. 
 
    References 
    ---------- 
 
    .. [Rouseeuw1984] P. J. Rousseeuw. Least median of squares regression. 
        J. Am Stat Ass, 79:871, 1984. 
    .. [Rousseeuw] A Fast Algorithm for the Minimum Covariance Determinant 
        Estimator, 1999, American Statistical Association and the American 
        Society for Quality, TECHNOMETRICS 
    .. [ButlerDavies] R. W. Butler, P. L. Davies and M. Jhun, 
        Asymptotics For The Minimum Covariance Determinant Estimator, 
        The Annals of Statistics, 1993, Vol. 21, No. 3, 1385-1400 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.covariance import MinCovDet 
    &gt;&gt;&gt; from sklearn.datasets import make_gaussian_quantiles 
    &gt;&gt;&gt; real_cov = np.array([[.8, .3], 
    ...                      [.3, .4]]) 
    &gt;&gt;&gt; rng = np.random.RandomState(0) 
    &gt;&gt;&gt; X = rng.multivariate_normal(mean=[0, 0], 
    ...                                   cov=real_cov, 
    ...                                   size=500) 
    &gt;&gt;&gt; cov = MinCovDet(random_state=0).fit(X) 
    &gt;&gt;&gt; cov.covariance_ 
    array([[0.7411..., 0.2535...], 
           [0.2535..., 0.3053...]]) 
    &gt;&gt;&gt; cov.location_ 
    array([0.0813... , 0.0427...]) 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
        <span class="s4">**</span><span class="s1">EmpiricalCovariance</span><span class="s4">.</span><span class="s1">_parameter_constraints</span><span class="s4">,</span>
        <span class="s6">&quot;support_fraction&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s6">&quot;right&quot;</span><span class="s4">), </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s6">&quot;random_state&quot;</span><span class="s4">: [</span><span class="s6">&quot;random_state&quot;</span><span class="s4">],</span>
    <span class="s4">}</span>
    <span class="s1">_nonrobust_covariance </span><span class="s4">= </span><span class="s1">staticmethod</span><span class="s4">(</span><span class="s1">empirical_covariance</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">store_precision</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">assume_centered</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">support_fraction</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">store_precision </span><span class="s4">= </span><span class="s1">store_precision</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">assume_centered </span><span class="s4">= </span><span class="s1">assume_centered</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">support_fraction </span><span class="s4">= </span><span class="s1">support_fraction</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">random_state </span><span class="s4">= </span><span class="s1">random_state</span>

    <span class="s4">@</span><span class="s1">_fit_context</span><span class="s4">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Fit a Minimum Covariance Determinant with the FastMCD algorithm. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Training data, where `n_samples` is the number of samples 
            and `n_features` is the number of features. 
 
        y : Ignored 
            Not used, present for API consistency by convention. 
 
        Returns 
        ------- 
        self : object 
            Returns the instance itself. 
        &quot;&quot;&quot;</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">ensure_min_samples</span><span class="s4">=</span><span class="s5">2</span><span class="s4">, </span><span class="s1">estimator</span><span class="s4">=</span><span class="s6">&quot;MinCovDet&quot;</span><span class="s4">)</span>
        <span class="s1">random_state </span><span class="s4">= </span><span class="s1">check_random_state</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">random_state</span><span class="s4">)</span>
        <span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_features </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span>
        <span class="s2"># check that the empirical covariance is full rank</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">svdvals</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">X</span><span class="s4">)) &gt; </span><span class="s5">1e-8</span><span class="s4">).</span><span class="s1">sum</span><span class="s4">() != </span><span class="s1">n_features</span><span class="s4">:</span>
            <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                <span class="s6">&quot;The covariance matrix associated to your dataset is not full rank&quot;</span>
            <span class="s4">)</span>
        <span class="s2"># compute and store raw estimates</span>
        <span class="s1">raw_location</span><span class="s4">, </span><span class="s1">raw_covariance</span><span class="s4">, </span><span class="s1">raw_support</span><span class="s4">, </span><span class="s1">raw_dist </span><span class="s4">= </span><span class="s1">fast_mcd</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">support_fraction</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">support_fraction</span><span class="s4">,</span>
            <span class="s1">cov_computation_method</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_nonrobust_covariance</span><span class="s4">,</span>
            <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">assume_centered</span><span class="s4">:</span>
            <span class="s1">raw_location </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_features</span><span class="s4">)</span>
            <span class="s1">raw_covariance </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_nonrobust_covariance</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">[</span><span class="s1">raw_support</span><span class="s4">], </span><span class="s1">assume_centered</span><span class="s4">=</span><span class="s3">True</span>
            <span class="s4">)</span>
            <span class="s2"># get precision matrix in an optimized way</span>
            <span class="s1">precision </span><span class="s4">= </span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">pinvh</span><span class="s4">(</span><span class="s1">raw_covariance</span><span class="s4">)</span>
            <span class="s1">raw_dist </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">precision</span><span class="s4">) * </span><span class="s1">X</span><span class="s4">, </span><span class="s5">1</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">raw_location_ </span><span class="s4">= </span><span class="s1">raw_location</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">raw_covariance_ </span><span class="s4">= </span><span class="s1">raw_covariance</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">raw_support_ </span><span class="s4">= </span><span class="s1">raw_support</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">location_ </span><span class="s4">= </span><span class="s1">raw_location</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">support_ </span><span class="s4">= </span><span class="s1">raw_support</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">dist_ </span><span class="s4">= </span><span class="s1">raw_dist</span>
        <span class="s2"># obtain consistency at normal models</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">correct_covariance</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s2"># re-weight estimator</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">reweight_covariance</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">correct_covariance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Apply a correction to raw Minimum Covariance Determinant estimates. 
 
        Correction using the empirical correction factor suggested 
        by Rousseeuw and Van Driessen in [RVD]_. 
 
        Parameters 
        ---------- 
        data : array-like of shape (n_samples, n_features) 
            The data matrix, with p features and n samples. 
            The data set must be the one which was used to compute 
            the raw estimates. 
 
        Returns 
        ------- 
        covariance_corrected : ndarray of shape (n_features, n_features) 
            Corrected robust covariance estimate. 
 
        References 
        ---------- 
 
        .. [RVD] A Fast Algorithm for the Minimum Covariance 
            Determinant Estimator, 1999, American Statistical Association 
            and the American Society for Quality, TECHNOMETRICS 
        &quot;&quot;&quot;</span>

        <span class="s2"># Check that the covariance of the support data is not equal to 0.</span>
        <span class="s2"># Otherwise self.dist_ = 0 and thus correction = 0.</span>
        <span class="s1">n_samples </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">dist_</span><span class="s4">)</span>
        <span class="s1">n_support </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">support_</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">n_support </span><span class="s4">&lt; </span><span class="s1">n_samples </span><span class="s3">and </span><span class="s1">np</span><span class="s4">.</span><span class="s1">allclose</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">raw_covariance_</span><span class="s4">, </span><span class="s5">0</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s6">&quot;The covariance matrix of the support data &quot;</span>
                <span class="s6">&quot;is equal to 0, try to increase support_fraction&quot;</span>
            <span class="s4">)</span>
        <span class="s1">correction </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">median</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">dist_</span><span class="s4">) / </span><span class="s1">chi2</span><span class="s4">(</span><span class="s1">data</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">1</span><span class="s4">]).</span><span class="s1">isf</span><span class="s4">(</span><span class="s5">0.5</span><span class="s4">)</span>
        <span class="s1">covariance_corrected </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">raw_covariance_ </span><span class="s4">* </span><span class="s1">correction</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">dist_ </span><span class="s4">/= </span><span class="s1">correction</span>
        <span class="s3">return </span><span class="s1">covariance_corrected</span>

    <span class="s3">def </span><span class="s1">reweight_covariance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">data</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Re-weight raw Minimum Covariance Determinant estimates. 
 
        Re-weight observations using Rousseeuw's method (equivalent to 
        deleting outlying observations from the data set before 
        computing location and covariance estimates) described 
        in [RVDriessen]_. 
 
        Parameters 
        ---------- 
        data : array-like of shape (n_samples, n_features) 
            The data matrix, with p features and n samples. 
            The data set must be the one which was used to compute 
            the raw estimates. 
 
        Returns 
        ------- 
        location_reweighted : ndarray of shape (n_features,) 
            Re-weighted robust location estimate. 
 
        covariance_reweighted : ndarray of shape (n_features, n_features) 
            Re-weighted robust covariance estimate. 
 
        support_reweighted : ndarray of shape (n_samples,), dtype=bool 
            A mask of the observations that have been used to compute 
            the re-weighted robust location and covariance estimates. 
 
        References 
        ---------- 
 
        .. [RVDriessen] A Fast Algorithm for the Minimum Covariance 
            Determinant Estimator, 1999, American Statistical Association 
            and the American Society for Quality, TECHNOMETRICS 
        &quot;&quot;&quot;</span>
        <span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_features </span><span class="s4">= </span><span class="s1">data</span><span class="s4">.</span><span class="s1">shape</span>
        <span class="s1">mask </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dist_ </span><span class="s4">&lt; </span><span class="s1">chi2</span><span class="s4">(</span><span class="s1">n_features</span><span class="s4">).</span><span class="s1">isf</span><span class="s4">(</span><span class="s5">0.025</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">assume_centered</span><span class="s4">:</span>
            <span class="s1">location_reweighted </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_features</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">location_reweighted </span><span class="s4">= </span><span class="s1">data</span><span class="s4">[</span><span class="s1">mask</span><span class="s4">].</span><span class="s1">mean</span><span class="s4">(</span><span class="s5">0</span><span class="s4">)</span>
        <span class="s1">covariance_reweighted </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_nonrobust_covariance</span><span class="s4">(</span>
            <span class="s1">data</span><span class="s4">[</span><span class="s1">mask</span><span class="s4">], </span><span class="s1">assume_centered</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">assume_centered</span>
        <span class="s4">)</span>
        <span class="s1">support_reweighted </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">bool</span><span class="s4">)</span>
        <span class="s1">support_reweighted</span><span class="s4">[</span><span class="s1">mask</span><span class="s4">] = </span><span class="s3">True</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_set_covariance</span><span class="s4">(</span><span class="s1">covariance_reweighted</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">location_ </span><span class="s4">= </span><span class="s1">location_reweighted</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">support_ </span><span class="s4">= </span><span class="s1">support_reweighted</span>
        <span class="s1">X_centered </span><span class="s4">= </span><span class="s1">data </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">location_</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">dist_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">X_centered</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">get_precision</span><span class="s4">()) * </span><span class="s1">X_centered</span><span class="s4">, </span><span class="s5">1</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">location_reweighted</span><span class="s4">, </span><span class="s1">covariance_reweighted</span><span class="s4">, </span><span class="s1">support_reweighted</span>
</pre>
</body>
</html>