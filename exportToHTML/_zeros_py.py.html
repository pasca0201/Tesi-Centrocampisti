<html>
<head>
<title>_zeros_py.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #2aacb8;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_zeros_py.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">namedtuple</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">from </span><span class="s2">. </span><span class="s0">import </span><span class="s1">_zeros</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_optimize </span><span class="s0">import </span><span class="s1">OptimizeResult</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>


<span class="s1">_iter </span><span class="s2">= </span><span class="s3">100</span>
<span class="s1">_xtol </span><span class="s2">= </span><span class="s3">2e-12</span>
<span class="s1">_rtol </span><span class="s2">= </span><span class="s3">4 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">float</span><span class="s2">).</span><span class="s1">eps</span>

<span class="s1">__all__ </span><span class="s2">= [</span><span class="s4">'newton'</span><span class="s2">, </span><span class="s4">'bisect'</span><span class="s2">, </span><span class="s4">'ridder'</span><span class="s2">, </span><span class="s4">'brentq'</span><span class="s2">, </span><span class="s4">'brenth'</span><span class="s2">, </span><span class="s4">'toms748'</span><span class="s2">,</span>
           <span class="s4">'RootResults'</span><span class="s2">]</span>

<span class="s5"># Must agree with CONVERGED, SIGNERR, CONVERR, ...  in zeros.h</span>
<span class="s1">_ECONVERGED </span><span class="s2">= </span><span class="s3">0</span>
<span class="s1">_ESIGNERR </span><span class="s2">= -</span><span class="s3">1  </span><span class="s5"># used in _chandrupatla</span>
<span class="s1">_ECONVERR </span><span class="s2">= -</span><span class="s3">2</span>
<span class="s1">_EVALUEERR </span><span class="s2">= -</span><span class="s3">3</span>
<span class="s1">_ECALLBACK </span><span class="s2">= -</span><span class="s3">4</span>
<span class="s1">_EINPROGRESS </span><span class="s2">= </span><span class="s3">1</span>

<span class="s1">CONVERGED </span><span class="s2">= </span><span class="s4">'converged'</span>
<span class="s1">SIGNERR </span><span class="s2">= </span><span class="s4">'sign error'</span>
<span class="s1">CONVERR </span><span class="s2">= </span><span class="s4">'convergence error'</span>
<span class="s1">VALUEERR </span><span class="s2">= </span><span class="s4">'value error'</span>
<span class="s1">INPROGRESS </span><span class="s2">= </span><span class="s4">'No error'</span>


<span class="s1">flag_map </span><span class="s2">= {</span><span class="s1">_ECONVERGED</span><span class="s2">: </span><span class="s1">CONVERGED</span><span class="s2">, </span><span class="s1">_ESIGNERR</span><span class="s2">: </span><span class="s1">SIGNERR</span><span class="s2">, </span><span class="s1">_ECONVERR</span><span class="s2">: </span><span class="s1">CONVERR</span><span class="s2">,</span>
            <span class="s1">_EVALUEERR</span><span class="s2">: </span><span class="s1">VALUEERR</span><span class="s2">, </span><span class="s1">_EINPROGRESS</span><span class="s2">: </span><span class="s1">INPROGRESS</span><span class="s2">}</span>


<span class="s0">class </span><span class="s1">RootResults</span><span class="s2">(</span><span class="s1">OptimizeResult</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Represents the root finding result. 
 
    Attributes 
    ---------- 
    root : float 
        Estimated root location. 
    iterations : int 
        Number of iterations needed to find the root. 
    function_calls : int 
        Number of times the function was called. 
    converged : bool 
        True if the routine converged. 
    flag : str 
        Description of the cause of termination. 
    method : str 
        Root finding method used. 
 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">root</span><span class="s2">, </span><span class="s1">iterations</span><span class="s2">, </span><span class="s1">function_calls</span><span class="s2">, </span><span class="s1">flag</span><span class="s2">, </span><span class="s1">method</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">root </span><span class="s2">= </span><span class="s1">root</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">iterations </span><span class="s2">= </span><span class="s1">iterations</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">function_calls </span><span class="s2">= </span><span class="s1">function_calls</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">converged </span><span class="s2">= </span><span class="s1">flag </span><span class="s2">== </span><span class="s1">_ECONVERGED</span>
        <span class="s0">if </span><span class="s1">flag </span><span class="s0">in </span><span class="s1">flag_map</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">flag </span><span class="s2">= </span><span class="s1">flag_map</span><span class="s2">[</span><span class="s1">flag</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">flag </span><span class="s2">= </span><span class="s1">flag</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">method </span><span class="s2">= </span><span class="s1">method</span>


<span class="s0">def </span><span class="s1">results_c</span><span class="s2">(</span><span class="s1">full_output</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">method</span><span class="s2">):</span>
    <span class="s0">if </span><span class="s1">full_output</span><span class="s2">:</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">funcalls</span><span class="s2">, </span><span class="s1">iterations</span><span class="s2">, </span><span class="s1">flag </span><span class="s2">= </span><span class="s1">r</span>
        <span class="s1">results </span><span class="s2">= </span><span class="s1">RootResults</span><span class="s2">(</span><span class="s1">root</span><span class="s2">=</span><span class="s1">x</span><span class="s2">,</span>
                              <span class="s1">iterations</span><span class="s2">=</span><span class="s1">iterations</span><span class="s2">,</span>
                              <span class="s1">function_calls</span><span class="s2">=</span><span class="s1">funcalls</span><span class="s2">,</span>
                              <span class="s1">flag</span><span class="s2">=</span><span class="s1">flag</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s1">method</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">results</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">r</span>


<span class="s0">def </span><span class="s1">_results_select</span><span class="s2">(</span><span class="s1">full_output</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">method</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Select from a tuple of (root, funccalls, iterations, flag)&quot;&quot;&quot;</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">funcalls</span><span class="s2">, </span><span class="s1">iterations</span><span class="s2">, </span><span class="s1">flag </span><span class="s2">= </span><span class="s1">r</span>
    <span class="s0">if </span><span class="s1">full_output</span><span class="s2">:</span>
        <span class="s1">results </span><span class="s2">= </span><span class="s1">RootResults</span><span class="s2">(</span><span class="s1">root</span><span class="s2">=</span><span class="s1">x</span><span class="s2">,</span>
                              <span class="s1">iterations</span><span class="s2">=</span><span class="s1">iterations</span><span class="s2">,</span>
                              <span class="s1">function_calls</span><span class="s2">=</span><span class="s1">funcalls</span><span class="s2">,</span>
                              <span class="s1">flag</span><span class="s2">=</span><span class="s1">flag</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s1">method</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">results</span>
    <span class="s0">return </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">_wrap_nan_raise</span><span class="s2">(</span><span class="s1">f</span><span class="s2">):</span>

    <span class="s0">def </span><span class="s1">f_raise</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">):</span>
        <span class="s1">fx </span><span class="s2">= </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s1">f_raise</span><span class="s2">.</span><span class="s1">_function_calls </span><span class="s2">+= </span><span class="s3">1</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">fx</span><span class="s2">):</span>
            <span class="s1">msg </span><span class="s2">= (</span><span class="s4">f'The function value at x=</span><span class="s0">{</span><span class="s1">x</span><span class="s0">} </span><span class="s4">is NaN; '</span>
                   <span class="s4">'solver cannot continue.'</span><span class="s2">)</span>
            <span class="s1">err </span><span class="s2">= </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
            <span class="s1">err</span><span class="s2">.</span><span class="s1">_x </span><span class="s2">= </span><span class="s1">x</span>
            <span class="s1">err</span><span class="s2">.</span><span class="s1">_function_calls </span><span class="s2">= </span><span class="s1">f_raise</span><span class="s2">.</span><span class="s1">_function_calls</span>
            <span class="s0">raise </span><span class="s1">err</span>
        <span class="s0">return </span><span class="s1">fx</span>

    <span class="s1">f_raise</span><span class="s2">.</span><span class="s1">_function_calls </span><span class="s2">= </span><span class="s3">0</span>
    <span class="s0">return </span><span class="s1">f_raise</span>


<span class="s0">def </span><span class="s1">newton</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">tol</span><span class="s2">=</span><span class="s3">1.48e-8</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s3">50</span><span class="s2">,</span>
           <span class="s1">fprime2</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s3">0.0</span><span class="s2">,</span>
           <span class="s1">full_output</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Find a root of a real or complex function using the Newton-Raphson 
    (or secant or Halley's) method. 
 
    Find a root of the scalar-valued function `func` given a nearby scalar 
    starting point `x0`. 
    The Newton-Raphson method is used if the derivative `fprime` of `func` 
    is provided, otherwise the secant method is used. If the second order 
    derivative `fprime2` of `func` is also provided, then Halley's method is 
    used. 
 
    If `x0` is a sequence with more than one item, `newton` returns an array: 
    the roots of the function from each (scalar) starting point in `x0`. 
    In this case, `func` must be vectorized to return a sequence or array of 
    the same shape as its first argument. If `fprime` (`fprime2`) is given, 
    then its return must also have the same shape: each element is the first 
    (second) derivative of `func` with respect to its only variable evaluated 
    at each element of its first argument. 
 
    `newton` is for finding roots of a scalar-valued functions of a single 
    variable. For problems involving several variables, see `root`. 
 
    Parameters 
    ---------- 
    func : callable 
        The function whose root is wanted. It must be a function of a 
        single variable of the form ``f(x,a,b,c...)``, where ``a,b,c...`` 
        are extra arguments that can be passed in the `args` parameter. 
    x0 : float, sequence, or ndarray 
        An initial estimate of the root that should be somewhere near the 
        actual root. If not scalar, then `func` must be vectorized and return 
        a sequence or array of the same shape as its first argument. 
    fprime : callable, optional 
        The derivative of the function when available and convenient. If it 
        is None (default), then the secant method is used. 
    args : tuple, optional 
        Extra arguments to be used in the function call. 
    tol : float, optional 
        The allowable error of the root's value. If `func` is complex-valued, 
        a larger `tol` is recommended as both the real and imaginary parts 
        of `x` contribute to ``|x - x0|``. 
    maxiter : int, optional 
        Maximum number of iterations. 
    fprime2 : callable, optional 
        The second order derivative of the function when available and 
        convenient. If it is None (default), then the normal Newton-Raphson 
        or the secant method is used. If it is not None, then Halley's method 
        is used. 
    x1 : float, optional 
        Another estimate of the root that should be somewhere near the 
        actual root. Used if `fprime` is not provided. 
    rtol : float, optional 
        Tolerance (relative) for termination. 
    full_output : bool, optional 
        If `full_output` is False (default), the root is returned. 
        If True and `x0` is scalar, the return value is ``(x, r)``, where ``x`` 
        is the root and ``r`` is a `RootResults` object. 
        If True and `x0` is non-scalar, the return value is ``(x, converged, 
        zero_der)`` (see Returns section for details). 
    disp : bool, optional 
        If True, raise a RuntimeError if the algorithm didn't converge, with 
        the error message containing the number of iterations and current 
        function value. Otherwise, the convergence status is recorded in a 
        `RootResults` return object. 
        Ignored if `x0` is not scalar. 
        *Note: this has little to do with displaying, however, 
        the `disp` keyword cannot be renamed for backwards compatibility.* 
 
    Returns 
    ------- 
    root : float, sequence, or ndarray 
        Estimated location where function is zero. 
    r : `RootResults`, optional 
        Present if ``full_output=True`` and `x0` is scalar. 
        Object containing information about the convergence. In particular, 
        ``r.converged`` is True if the routine converged. 
    converged : ndarray of bool, optional 
        Present if ``full_output=True`` and `x0` is non-scalar. 
        For vector functions, indicates which elements converged successfully. 
    zero_der : ndarray of bool, optional 
        Present if ``full_output=True`` and `x0` is non-scalar. 
        For vector functions, indicates which elements had a zero derivative. 
 
    See Also 
    -------- 
    root_scalar : interface to root solvers for scalar functions 
    root : interface to root solvers for multi-input, multi-output functions 
 
    Notes 
    ----- 
    The convergence rate of the Newton-Raphson method is quadratic, 
    the Halley method is cubic, and the secant method is 
    sub-quadratic. This means that if the function is well-behaved 
    the actual error in the estimated root after the nth iteration 
    is approximately the square (cube for Halley) of the error 
    after the (n-1)th step. However, the stopping criterion used 
    here is the step size and there is no guarantee that a root 
    has been found. Consequently, the result should be verified. 
    Safer algorithms are brentq, brenth, ridder, and bisect, 
    but they all require that the root first be bracketed in an 
    interval where the function changes sign. The brentq algorithm 
    is recommended for general use in one dimensional problems 
    when such an interval has been found. 
 
    When `newton` is used with arrays, it is best suited for the following 
    types of problems: 
 
    * The initial guesses, `x0`, are all relatively the same distance from 
      the roots. 
    * Some or all of the extra arguments, `args`, are also arrays so that a 
      class of similar problems can be solved together. 
    * The size of the initial guesses, `x0`, is larger than O(100) elements. 
      Otherwise, a naive loop may perform as well or better than a vector. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy import optimize 
 
    &gt;&gt;&gt; def f(x): 
    ...     return (x**3 - 1)  # only one real root at x = 1 
 
    ``fprime`` is not provided, use the secant method: 
 
    &gt;&gt;&gt; root = optimize.newton(f, 1.5) 
    &gt;&gt;&gt; root 
    1.0000000000000016 
    &gt;&gt;&gt; root = optimize.newton(f, 1.5, fprime2=lambda x: 6 * x) 
    &gt;&gt;&gt; root 
    1.0000000000000016 
 
    Only ``fprime`` is provided, use the Newton-Raphson method: 
 
    &gt;&gt;&gt; root = optimize.newton(f, 1.5, fprime=lambda x: 3 * x**2) 
    &gt;&gt;&gt; root 
    1.0 
 
    Both ``fprime2`` and ``fprime`` are provided, use Halley's method: 
 
    &gt;&gt;&gt; root = optimize.newton(f, 1.5, fprime=lambda x: 3 * x**2, 
    ...                        fprime2=lambda x: 6 * x) 
    &gt;&gt;&gt; root 
    1.0 
 
    When we want to find roots for a set of related starting values and/or 
    function parameters, we can provide both of those as an array of inputs: 
 
    &gt;&gt;&gt; f = lambda x, a: x**3 - a 
    &gt;&gt;&gt; fder = lambda x, a: 3 * x**2 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; x = rng.standard_normal(100) 
    &gt;&gt;&gt; a = np.arange(-50, 50) 
    &gt;&gt;&gt; vec_res = optimize.newton(f, x, fprime=fder, args=(a, ), maxiter=200) 
 
    The above is the equivalent of solving for each value in ``(x, a)`` 
    separately in a for-loop, just faster: 
 
    &gt;&gt;&gt; loop_res = [optimize.newton(f, x0, fprime=fder, args=(a0,), 
    ...                             maxiter=200) 
    ...             for x0, a0 in zip(x, a)] 
    &gt;&gt;&gt; np.allclose(vec_res, loop_res) 
    True 
 
    Plot the results found for all values of ``a``: 
 
    &gt;&gt;&gt; analytical_result = np.sign(a) * np.abs(a)**(1/3) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(a, analytical_result, 'o') 
    &gt;&gt;&gt; ax.plot(a, vec_res, '.') 
    &gt;&gt;&gt; ax.set_xlabel('$a$') 
    &gt;&gt;&gt; ax.set_ylabel('$x$ where $f(x, a)=0$') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">tol </span><span class="s2">&lt;= </span><span class="s3">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;tol too small (%g &lt;= 0)&quot; </span><span class="s2">% </span><span class="s1">tol</span><span class="s2">)</span>
    <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">maxiter </span><span class="s2">&lt; </span><span class="s3">1</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;maxiter must be greater than 0&quot;</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">size</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">) &gt; </span><span class="s3">1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">_array_newton</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">, </span><span class="s1">fprime2</span><span class="s2">,</span>
                             <span class="s1">full_output</span><span class="s2">)</span>

    <span class="s5"># Convert to float (don't use float(x0); this works also for complex x0)</span>
    <span class="s5"># Use np.asarray because we want x0 to be a numpy object, not a Python</span>
    <span class="s5"># object. e.g. np.complex(1+1j) &gt; 0 is possible, but (1 + 1j) &gt; 0 raises</span>
    <span class="s5"># a TypeError</span>
    <span class="s1">x0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">)[()] * </span><span class="s3">1.0</span>
    <span class="s1">p0 </span><span class="s2">= </span><span class="s1">x0</span>
    <span class="s1">funcalls </span><span class="s2">= </span><span class="s3">0</span>
    <span class="s0">if </span><span class="s1">fprime </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s5"># Newton-Raphson method</span>
        <span class="s1">method </span><span class="s2">= </span><span class="s4">&quot;newton&quot;</span>
        <span class="s0">for </span><span class="s1">itr </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">):</span>
            <span class="s5"># first evaluate fval</span>
            <span class="s1">fval </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">p0</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s1">funcalls </span><span class="s2">+= </span><span class="s3">1</span>
            <span class="s5"># If fval is 0, a root has been found, then terminate</span>
            <span class="s0">if </span><span class="s1">fval </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">_results_select</span><span class="s2">(</span>
                    <span class="s1">full_output</span><span class="s2">, (</span><span class="s1">p0</span><span class="s2">, </span><span class="s1">funcalls</span><span class="s2">, </span><span class="s1">itr</span><span class="s2">, </span><span class="s1">_ECONVERGED</span><span class="s2">), </span><span class="s1">method</span><span class="s2">)</span>
            <span class="s1">fder </span><span class="s2">= </span><span class="s1">fprime</span><span class="s2">(</span><span class="s1">p0</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s1">funcalls </span><span class="s2">+= </span><span class="s3">1</span>
            <span class="s0">if </span><span class="s1">fder </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
                <span class="s1">msg </span><span class="s2">= </span><span class="s4">&quot;Derivative was zero.&quot;</span>
                <span class="s0">if </span><span class="s1">disp</span><span class="s2">:</span>
                    <span class="s1">msg </span><span class="s2">+= (</span>
                        <span class="s4">&quot; Failed to converge after %d iterations, value is %s.&quot;</span>
                        <span class="s2">% (</span><span class="s1">itr </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">, </span><span class="s1">p0</span><span class="s2">))</span>
                    <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s3">2</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">_results_select</span><span class="s2">(</span>
                    <span class="s1">full_output</span><span class="s2">, (</span><span class="s1">p0</span><span class="s2">, </span><span class="s1">funcalls</span><span class="s2">, </span><span class="s1">itr </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">, </span><span class="s1">_ECONVERR</span><span class="s2">), </span><span class="s1">method</span><span class="s2">)</span>
            <span class="s1">newton_step </span><span class="s2">= </span><span class="s1">fval </span><span class="s2">/ </span><span class="s1">fder</span>
            <span class="s0">if </span><span class="s1">fprime2</span><span class="s2">:</span>
                <span class="s1">fder2 </span><span class="s2">= </span><span class="s1">fprime2</span><span class="s2">(</span><span class="s1">p0</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
                <span class="s1">funcalls </span><span class="s2">+= </span><span class="s3">1</span>
                <span class="s1">method </span><span class="s2">= </span><span class="s4">&quot;halley&quot;</span>
                <span class="s5"># Halley's method:</span>
                <span class="s5">#   newton_step /= (1.0 - 0.5 * newton_step * fder2 / fder)</span>
                <span class="s5"># Only do it if denominator stays close enough to 1</span>
                <span class="s5"># Rationale: If 1-adj &lt; 0, then Halley sends x in the</span>
                <span class="s5"># opposite direction to Newton. Doesn't happen if x is close</span>
                <span class="s5"># enough to root.</span>
                <span class="s1">adj </span><span class="s2">= </span><span class="s1">newton_step </span><span class="s2">* </span><span class="s1">fder2 </span><span class="s2">/ </span><span class="s1">fder </span><span class="s2">/ </span><span class="s3">2</span>
                <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">adj</span><span class="s2">) &lt; </span><span class="s3">1</span><span class="s2">:</span>
                    <span class="s1">newton_step </span><span class="s2">/= </span><span class="s3">1.0 </span><span class="s2">- </span><span class="s1">adj</span>
            <span class="s1">p </span><span class="s2">= </span><span class="s1">p0 </span><span class="s2">- </span><span class="s1">newton_step</span>
            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isclose</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">p0</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">tol</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">_results_select</span><span class="s2">(</span>
                    <span class="s1">full_output</span><span class="s2">, (</span><span class="s1">p</span><span class="s2">, </span><span class="s1">funcalls</span><span class="s2">, </span><span class="s1">itr </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">, </span><span class="s1">_ECONVERGED</span><span class="s2">), </span><span class="s1">method</span><span class="s2">)</span>
            <span class="s1">p0 </span><span class="s2">= </span><span class="s1">p</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s5"># Secant method</span>
        <span class="s1">method </span><span class="s2">= </span><span class="s4">&quot;secant&quot;</span>
        <span class="s0">if </span><span class="s1">x1 </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">x1 </span><span class="s2">== </span><span class="s1">x0</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;x1 and x0 must be different&quot;</span><span class="s2">)</span>
            <span class="s1">p1 </span><span class="s2">= </span><span class="s1">x1</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">eps </span><span class="s2">= </span><span class="s3">1e-4</span>
            <span class="s1">p1 </span><span class="s2">= </span><span class="s1">x0 </span><span class="s2">* (</span><span class="s3">1 </span><span class="s2">+ </span><span class="s1">eps</span><span class="s2">)</span>
            <span class="s1">p1 </span><span class="s2">+= (</span><span class="s1">eps </span><span class="s0">if </span><span class="s1">p1 </span><span class="s2">&gt;= </span><span class="s3">0 </span><span class="s0">else </span><span class="s2">-</span><span class="s1">eps</span><span class="s2">)</span>
        <span class="s1">q0 </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">p0</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s1">funcalls </span><span class="s2">+= </span><span class="s3">1</span>
        <span class="s1">q1 </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">p1</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s1">funcalls </span><span class="s2">+= </span><span class="s3">1</span>
        <span class="s0">if </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">q1</span><span class="s2">) &lt; </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">q0</span><span class="s2">):</span>
            <span class="s1">p0</span><span class="s2">, </span><span class="s1">p1</span><span class="s2">, </span><span class="s1">q0</span><span class="s2">, </span><span class="s1">q1 </span><span class="s2">= </span><span class="s1">p1</span><span class="s2">, </span><span class="s1">p0</span><span class="s2">, </span><span class="s1">q1</span><span class="s2">, </span><span class="s1">q0</span>
        <span class="s0">for </span><span class="s1">itr </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">q1 </span><span class="s2">== </span><span class="s1">q0</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">p1 </span><span class="s2">!= </span><span class="s1">p0</span><span class="s2">:</span>
                    <span class="s1">msg </span><span class="s2">= </span><span class="s4">&quot;Tolerance of %s reached.&quot; </span><span class="s2">% (</span><span class="s1">p1 </span><span class="s2">- </span><span class="s1">p0</span><span class="s2">)</span>
                    <span class="s0">if </span><span class="s1">disp</span><span class="s2">:</span>
                        <span class="s1">msg </span><span class="s2">+= (</span>
                            <span class="s4">&quot; Failed to converge after %d iterations, value is %s.&quot;</span>
                            <span class="s2">% (</span><span class="s1">itr </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">, </span><span class="s1">p1</span><span class="s2">))</span>
                        <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
                    <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s3">2</span><span class="s2">)</span>
                <span class="s1">p </span><span class="s2">= (</span><span class="s1">p1 </span><span class="s2">+ </span><span class="s1">p0</span><span class="s2">) / </span><span class="s3">2.0</span>
                <span class="s0">return </span><span class="s1">_results_select</span><span class="s2">(</span>
                    <span class="s1">full_output</span><span class="s2">, (</span><span class="s1">p</span><span class="s2">, </span><span class="s1">funcalls</span><span class="s2">, </span><span class="s1">itr </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">, </span><span class="s1">_ECONVERR</span><span class="s2">), </span><span class="s1">method</span><span class="s2">)</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">q1</span><span class="s2">) &gt; </span><span class="s1">abs</span><span class="s2">(</span><span class="s1">q0</span><span class="s2">):</span>
                    <span class="s1">p </span><span class="s2">= (-</span><span class="s1">q0 </span><span class="s2">/ </span><span class="s1">q1 </span><span class="s2">* </span><span class="s1">p1 </span><span class="s2">+ </span><span class="s1">p0</span><span class="s2">) / (</span><span class="s3">1 </span><span class="s2">- </span><span class="s1">q0 </span><span class="s2">/ </span><span class="s1">q1</span><span class="s2">)</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">p </span><span class="s2">= (-</span><span class="s1">q1 </span><span class="s2">/ </span><span class="s1">q0 </span><span class="s2">* </span><span class="s1">p0 </span><span class="s2">+ </span><span class="s1">p1</span><span class="s2">) / (</span><span class="s3">1 </span><span class="s2">- </span><span class="s1">q1 </span><span class="s2">/ </span><span class="s1">q0</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isclose</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">p1</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">tol</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">_results_select</span><span class="s2">(</span>
                    <span class="s1">full_output</span><span class="s2">, (</span><span class="s1">p</span><span class="s2">, </span><span class="s1">funcalls</span><span class="s2">, </span><span class="s1">itr </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">, </span><span class="s1">_ECONVERGED</span><span class="s2">), </span><span class="s1">method</span><span class="s2">)</span>
            <span class="s1">p0</span><span class="s2">, </span><span class="s1">q0 </span><span class="s2">= </span><span class="s1">p1</span><span class="s2">, </span><span class="s1">q1</span>
            <span class="s1">p1 </span><span class="s2">= </span><span class="s1">p</span>
            <span class="s1">q1 </span><span class="s2">= </span><span class="s1">func</span><span class="s2">(</span><span class="s1">p1</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
            <span class="s1">funcalls </span><span class="s2">+= </span><span class="s3">1</span>

    <span class="s0">if </span><span class="s1">disp</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= (</span><span class="s4">&quot;Failed to converge after %d iterations, value is %s.&quot;</span>
               <span class="s2">% (</span><span class="s1">itr </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">, </span><span class="s1">p</span><span class="s2">))</span>
        <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">_results_select</span><span class="s2">(</span><span class="s1">full_output</span><span class="s2">, (</span><span class="s1">p</span><span class="s2">, </span><span class="s1">funcalls</span><span class="s2">, </span><span class="s1">itr </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">, </span><span class="s1">_ECONVERR</span><span class="s2">), </span><span class="s1">method</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_array_newton</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">, </span><span class="s1">fprime2</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    A vectorized version of Newton, Halley, and secant methods for arrays. 
 
    Do not use this method directly. This method is called from `newton` 
    when ``np.size(x0) &gt; 1`` is ``True``. For docstring, see `newton`. 
    &quot;&quot;&quot;</span>
    <span class="s5"># Explicitly copy `x0` as `p` will be modified inplace, but the</span>
    <span class="s5"># user's array should not be altered.</span>
    <span class="s1">p </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

    <span class="s1">failures </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones_like</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
    <span class="s1">nz_der </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones_like</span><span class="s2">(</span><span class="s1">failures</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">fprime </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s5"># Newton-Raphson method</span>
        <span class="s0">for </span><span class="s1">iteration </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">):</span>
            <span class="s5"># first evaluate fval</span>
            <span class="s1">fval </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">func</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">))</span>
            <span class="s5"># If all fval are 0, all roots have been found, then terminate</span>
            <span class="s0">if not </span><span class="s1">fval</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
                <span class="s1">failures </span><span class="s2">= </span><span class="s1">fval</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">bool</span><span class="s2">)</span>
                <span class="s0">break</span>
            <span class="s1">fder </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">fprime</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">))</span>
            <span class="s1">nz_der </span><span class="s2">= (</span><span class="s1">fder </span><span class="s2">!= </span><span class="s3">0</span><span class="s2">)</span>
            <span class="s5"># stop iterating if all derivatives are zero</span>
            <span class="s0">if not </span><span class="s1">nz_der</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
                <span class="s0">break</span>
            <span class="s5"># Newton step</span>
            <span class="s1">dp </span><span class="s2">= </span><span class="s1">fval</span><span class="s2">[</span><span class="s1">nz_der</span><span class="s2">] / </span><span class="s1">fder</span><span class="s2">[</span><span class="s1">nz_der</span><span class="s2">]</span>
            <span class="s0">if </span><span class="s1">fprime2 </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">fder2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">fprime2</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">))</span>
                <span class="s1">dp </span><span class="s2">= </span><span class="s1">dp </span><span class="s2">/ (</span><span class="s3">1.0 </span><span class="s2">- </span><span class="s3">0.5 </span><span class="s2">* </span><span class="s1">dp </span><span class="s2">* </span><span class="s1">fder2</span><span class="s2">[</span><span class="s1">nz_der</span><span class="s2">] / </span><span class="s1">fder</span><span class="s2">[</span><span class="s1">nz_der</span><span class="s2">])</span>
            <span class="s5"># only update nonzero derivatives</span>
            <span class="s1">p </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">result_type</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">dp</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">))</span>
            <span class="s1">p</span><span class="s2">[</span><span class="s1">nz_der</span><span class="s2">] -= </span><span class="s1">dp</span>
            <span class="s1">failures</span><span class="s2">[</span><span class="s1">nz_der</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">dp</span><span class="s2">) &gt;= </span><span class="s1">tol  </span><span class="s5"># items not yet converged</span>
            <span class="s5"># stop iterating if there aren't any failures, not incl zero der</span>
            <span class="s0">if not </span><span class="s1">failures</span><span class="s2">[</span><span class="s1">nz_der</span><span class="s2">].</span><span class="s1">any</span><span class="s2">():</span>
                <span class="s0">break</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s5"># Secant method</span>
        <span class="s1">dx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">float</span><span class="s2">).</span><span class="s1">eps</span><span class="s2">**</span><span class="s3">0.33</span>
        <span class="s1">p1 </span><span class="s2">= </span><span class="s1">p </span><span class="s2">* (</span><span class="s3">1 </span><span class="s2">+ </span><span class="s1">dx</span><span class="s2">) + </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">(</span><span class="s1">p </span><span class="s2">&gt;= </span><span class="s3">0</span><span class="s2">, </span><span class="s1">dx</span><span class="s2">, -</span><span class="s1">dx</span><span class="s2">)</span>
        <span class="s1">q0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">func</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">))</span>
        <span class="s1">q1 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">func</span><span class="s2">(</span><span class="s1">p1</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">))</span>
        <span class="s1">active </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones_like</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">bool</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">iteration </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">):</span>
            <span class="s1">nz_der </span><span class="s2">= (</span><span class="s1">q1 </span><span class="s2">!= </span><span class="s1">q0</span><span class="s2">)</span>
            <span class="s5"># stop iterating if all derivatives are zero</span>
            <span class="s0">if not </span><span class="s1">nz_der</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
                <span class="s1">p </span><span class="s2">= (</span><span class="s1">p1 </span><span class="s2">+ </span><span class="s1">p</span><span class="s2">) / </span><span class="s3">2.0</span>
                <span class="s0">break</span>
            <span class="s5"># Secant Step</span>
            <span class="s1">dp </span><span class="s2">= (</span><span class="s1">q1 </span><span class="s2">* (</span><span class="s1">p1 </span><span class="s2">- </span><span class="s1">p</span><span class="s2">))[</span><span class="s1">nz_der</span><span class="s2">] / (</span><span class="s1">q1 </span><span class="s2">- </span><span class="s1">q0</span><span class="s2">)[</span><span class="s1">nz_der</span><span class="s2">]</span>
            <span class="s5"># only update nonzero derivatives</span>
            <span class="s1">p </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">result_type</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">p1</span><span class="s2">, </span><span class="s1">dp</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">))</span>
            <span class="s1">p</span><span class="s2">[</span><span class="s1">nz_der</span><span class="s2">] = </span><span class="s1">p1</span><span class="s2">[</span><span class="s1">nz_der</span><span class="s2">] - </span><span class="s1">dp</span>
            <span class="s1">active_zero_der </span><span class="s2">= ~</span><span class="s1">nz_der </span><span class="s2">&amp; </span><span class="s1">active</span>
            <span class="s1">p</span><span class="s2">[</span><span class="s1">active_zero_der</span><span class="s2">] = (</span><span class="s1">p1 </span><span class="s2">+ </span><span class="s1">p</span><span class="s2">)[</span><span class="s1">active_zero_der</span><span class="s2">] / </span><span class="s3">2.0</span>
            <span class="s1">active </span><span class="s2">&amp;= </span><span class="s1">nz_der  </span><span class="s5"># don't assign zero derivatives again</span>
            <span class="s1">failures</span><span class="s2">[</span><span class="s1">nz_der</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">dp</span><span class="s2">) &gt;= </span><span class="s1">tol  </span><span class="s5"># not yet converged</span>
            <span class="s5"># stop iterating if there aren't any failures, not incl zero der</span>
            <span class="s0">if not </span><span class="s1">failures</span><span class="s2">[</span><span class="s1">nz_der</span><span class="s2">].</span><span class="s1">any</span><span class="s2">():</span>
                <span class="s0">break</span>
            <span class="s1">p1</span><span class="s2">, </span><span class="s1">p </span><span class="s2">= </span><span class="s1">p</span><span class="s2">, </span><span class="s1">p1</span>
            <span class="s1">q0 </span><span class="s2">= </span><span class="s1">q1</span>
            <span class="s1">q1 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">func</span><span class="s2">(</span><span class="s1">p1</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">))</span>

    <span class="s1">zero_der </span><span class="s2">= ~</span><span class="s1">nz_der </span><span class="s2">&amp; </span><span class="s1">failures  </span><span class="s5"># don't include converged with zero-ders</span>
    <span class="s0">if </span><span class="s1">zero_der</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s5"># Secant warnings</span>
        <span class="s0">if </span><span class="s1">fprime </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">nonzero_dp </span><span class="s2">= (</span><span class="s1">p1 </span><span class="s2">!= </span><span class="s1">p</span><span class="s2">)</span>
            <span class="s5"># non-zero dp, but infinite newton step</span>
            <span class="s1">zero_der_nz_dp </span><span class="s2">= (</span><span class="s1">zero_der </span><span class="s2">&amp; </span><span class="s1">nonzero_dp</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">zero_der_nz_dp</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
                <span class="s1">rms </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span>
                    <span class="s1">sum</span><span class="s2">((</span><span class="s1">p1</span><span class="s2">[</span><span class="s1">zero_der_nz_dp</span><span class="s2">] - </span><span class="s1">p</span><span class="s2">[</span><span class="s1">zero_der_nz_dp</span><span class="s2">]) ** </span><span class="s3">2</span><span class="s2">)</span>
                <span class="s2">)</span>
                <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s4">f'RMS of </span><span class="s0">{</span><span class="s1">rms</span><span class="s0">:</span><span class="s4">g</span><span class="s0">} </span><span class="s4">reached'</span><span class="s2">, </span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s3">3</span><span class="s2">)</span>
        <span class="s5"># Newton or Halley warnings</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">all_or_some </span><span class="s2">= </span><span class="s4">'all' </span><span class="s0">if </span><span class="s1">zero_der</span><span class="s2">.</span><span class="s1">all</span><span class="s2">() </span><span class="s0">else </span><span class="s4">'some'</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s4">f'</span><span class="s0">{</span><span class="s1">all_or_some</span><span class="s0">:</span><span class="s4">s</span><span class="s0">} </span><span class="s4">derivatives were zero'</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s3">3</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">failures</span><span class="s2">.</span><span class="s1">any</span><span class="s2">():</span>
        <span class="s1">all_or_some </span><span class="s2">= </span><span class="s4">'all' </span><span class="s0">if </span><span class="s1">failures</span><span class="s2">.</span><span class="s1">all</span><span class="s2">() </span><span class="s0">else </span><span class="s4">'some'</span>
        <span class="s1">msg </span><span class="s2">= </span><span class="s4">f'</span><span class="s0">{</span><span class="s1">all_or_some</span><span class="s0">:</span><span class="s4">s</span><span class="s0">} </span><span class="s4">failed to converge after </span><span class="s0">{</span><span class="s1">maxiter</span><span class="s0">:</span><span class="s4">d</span><span class="s0">} </span><span class="s4">iterations'</span>
        <span class="s0">if </span><span class="s1">failures</span><span class="s2">.</span><span class="s1">all</span><span class="s2">():</span>
            <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s3">3</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">full_output</span><span class="s2">:</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">namedtuple</span><span class="s2">(</span><span class="s4">'result'</span><span class="s2">, (</span><span class="s4">'root'</span><span class="s2">, </span><span class="s4">'converged'</span><span class="s2">, </span><span class="s4">'zero_der'</span><span class="s2">))</span>
        <span class="s1">p </span><span class="s2">= </span><span class="s1">result</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, ~</span><span class="s1">failures</span><span class="s2">, </span><span class="s1">zero_der</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">p</span>


<span class="s0">def </span><span class="s1">bisect</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(),</span>
           <span class="s1">xtol</span><span class="s2">=</span><span class="s1">_xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">_rtol</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s1">_iter</span><span class="s2">,</span>
           <span class="s1">full_output</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Find root of a function within an interval using bisection. 
 
    Basic bisection routine to find a root of the function `f` between the 
    arguments `a` and `b`. `f(a)` and `f(b)` cannot have the same signs. 
    Slow but sure. 
 
    Parameters 
    ---------- 
    f : function 
        Python function returning a number.  `f` must be continuous, and 
        f(a) and f(b) must have opposite signs. 
    a : scalar 
        One end of the bracketing interval [a,b]. 
    b : scalar 
        The other end of the bracketing interval [a,b]. 
    xtol : number, optional 
        The computed root ``x0`` will satisfy ``np.allclose(x, x0, 
        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The 
        parameter must be positive. 
    rtol : number, optional 
        The computed root ``x0`` will satisfy ``np.allclose(x, x0, 
        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The 
        parameter cannot be smaller than its default value of 
        ``4*np.finfo(float).eps``. 
    maxiter : int, optional 
        If convergence is not achieved in `maxiter` iterations, an error is 
        raised. Must be &gt;= 0. 
    args : tuple, optional 
        Containing extra arguments for the function `f`. 
        `f` is called by ``apply(f, (x)+args)``. 
    full_output : bool, optional 
        If `full_output` is False, the root is returned. If `full_output` is 
        True, the return value is ``(x, r)``, where x is the root, and r is 
        a `RootResults` object. 
    disp : bool, optional 
        If True, raise RuntimeError if the algorithm didn't converge. 
        Otherwise, the convergence status is recorded in a `RootResults` 
        return object. 
 
    Returns 
    ------- 
    root : float 
        Root of `f` between `a` and `b`. 
    r : `RootResults` (present if ``full_output = True``) 
        Object containing information about the convergence. In particular, 
        ``r.converged`` is True if the routine converged. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; def f(x): 
    ...     return (x**2 - 1) 
 
    &gt;&gt;&gt; from scipy import optimize 
 
    &gt;&gt;&gt; root = optimize.bisect(f, 0, 2) 
    &gt;&gt;&gt; root 
    1.0 
 
    &gt;&gt;&gt; root = optimize.bisect(f, -2, 0) 
    &gt;&gt;&gt; root 
    -1.0 
 
    See Also 
    -------- 
    brentq, brenth, bisect, newton 
    fixed_point : scalar fixed-point finder 
    fsolve : n-dimensional root-finding 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
        <span class="s1">args </span><span class="s2">= (</span><span class="s1">args</span><span class="s2">,)</span>
    <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">xtol </span><span class="s2">&lt;= </span><span class="s3">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;xtol too small (%g &lt;= 0)&quot; </span><span class="s2">% </span><span class="s1">xtol</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">rtol </span><span class="s2">&lt; </span><span class="s1">_rtol</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">f&quot;rtol too small (</span><span class="s0">{</span><span class="s1">rtol</span><span class="s0">:</span><span class="s4">g</span><span class="s0">} </span><span class="s4">&lt; </span><span class="s0">{</span><span class="s1">_rtol</span><span class="s0">:</span><span class="s4">g</span><span class="s0">}</span><span class="s4">)&quot;</span><span class="s2">)</span>
    <span class="s1">f </span><span class="s2">= </span><span class="s1">_wrap_nan_raise</span><span class="s2">(</span><span class="s1">f</span><span class="s2">)</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">_zeros</span><span class="s2">.</span><span class="s1">_bisect</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">results_c</span><span class="s2">(</span><span class="s1">full_output</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s4">&quot;bisect&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">ridder</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(),</span>
           <span class="s1">xtol</span><span class="s2">=</span><span class="s1">_xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">_rtol</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s1">_iter</span><span class="s2">,</span>
           <span class="s1">full_output</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Find a root of a function in an interval using Ridder's method. 
 
    Parameters 
    ---------- 
    f : function 
        Python function returning a number. f must be continuous, and f(a) and 
        f(b) must have opposite signs. 
    a : scalar 
        One end of the bracketing interval [a,b]. 
    b : scalar 
        The other end of the bracketing interval [a,b]. 
    xtol : number, optional 
        The computed root ``x0`` will satisfy ``np.allclose(x, x0, 
        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The 
        parameter must be positive. 
    rtol : number, optional 
        The computed root ``x0`` will satisfy ``np.allclose(x, x0, 
        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The 
        parameter cannot be smaller than its default value of 
        ``4*np.finfo(float).eps``. 
    maxiter : int, optional 
        If convergence is not achieved in `maxiter` iterations, an error is 
        raised. Must be &gt;= 0. 
    args : tuple, optional 
        Containing extra arguments for the function `f`. 
        `f` is called by ``apply(f, (x)+args)``. 
    full_output : bool, optional 
        If `full_output` is False, the root is returned. If `full_output` is 
        True, the return value is ``(x, r)``, where `x` is the root, and `r` is 
        a `RootResults` object. 
    disp : bool, optional 
        If True, raise RuntimeError if the algorithm didn't converge. 
        Otherwise, the convergence status is recorded in any `RootResults` 
        return object. 
 
    Returns 
    ------- 
    root : float 
        Root of `f` between `a` and `b`. 
    r : `RootResults` (present if ``full_output = True``) 
        Object containing information about the convergence. 
        In particular, ``r.converged`` is True if the routine converged. 
 
    See Also 
    -------- 
    brentq, brenth, bisect, newton : 1-D root-finding 
    fixed_point : scalar fixed-point finder 
 
    Notes 
    ----- 
    Uses [Ridders1979]_ method to find a root of the function `f` between the 
    arguments `a` and `b`. Ridders' method is faster than bisection, but not 
    generally as fast as the Brent routines. [Ridders1979]_ provides the 
    classic description and source of the algorithm. A description can also be 
    found in any recent edition of Numerical Recipes. 
 
    The routine used here diverges slightly from standard presentations in 
    order to be a bit more careful of tolerance. 
 
    References 
    ---------- 
    .. [Ridders1979] 
       Ridders, C. F. J. &quot;A New Algorithm for Computing a 
       Single Root of a Real Continuous Function.&quot; 
       IEEE Trans. Circuits Systems 26, 979-980, 1979. 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; def f(x): 
    ...     return (x**2 - 1) 
 
    &gt;&gt;&gt; from scipy import optimize 
 
    &gt;&gt;&gt; root = optimize.ridder(f, 0, 2) 
    &gt;&gt;&gt; root 
    1.0 
 
    &gt;&gt;&gt; root = optimize.ridder(f, -2, 0) 
    &gt;&gt;&gt; root 
    -1.0 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
        <span class="s1">args </span><span class="s2">= (</span><span class="s1">args</span><span class="s2">,)</span>
    <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">xtol </span><span class="s2">&lt;= </span><span class="s3">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;xtol too small (%g &lt;= 0)&quot; </span><span class="s2">% </span><span class="s1">xtol</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">rtol </span><span class="s2">&lt; </span><span class="s1">_rtol</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">f&quot;rtol too small (</span><span class="s0">{</span><span class="s1">rtol</span><span class="s0">:</span><span class="s4">g</span><span class="s0">} </span><span class="s4">&lt; </span><span class="s0">{</span><span class="s1">_rtol</span><span class="s0">:</span><span class="s4">g</span><span class="s0">}</span><span class="s4">)&quot;</span><span class="s2">)</span>
    <span class="s1">f </span><span class="s2">= </span><span class="s1">_wrap_nan_raise</span><span class="s2">(</span><span class="s1">f</span><span class="s2">)</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">_zeros</span><span class="s2">.</span><span class="s1">_ridder</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">results_c</span><span class="s2">(</span><span class="s1">full_output</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s4">&quot;ridder&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">brentq</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(),</span>
           <span class="s1">xtol</span><span class="s2">=</span><span class="s1">_xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">_rtol</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s1">_iter</span><span class="s2">,</span>
           <span class="s1">full_output</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Find a root of a function in a bracketing interval using Brent's method. 
 
    Uses the classic Brent's method to find a root of the function `f` on 
    the sign changing interval [a , b]. Generally considered the best of the 
    rootfinding routines here. It is a safe version of the secant method that 
    uses inverse quadratic extrapolation. Brent's method combines root 
    bracketing, interval bisection, and inverse quadratic interpolation. It is 
    sometimes known as the van Wijngaarden-Dekker-Brent method. Brent (1973) 
    claims convergence is guaranteed for functions computable within [a,b]. 
 
    [Brent1973]_ provides the classic description of the algorithm. Another 
    description can be found in a recent edition of Numerical Recipes, including 
    [PressEtal1992]_. A third description is at 
    http://mathworld.wolfram.com/BrentsMethod.html. It should be easy to 
    understand the algorithm just by reading our code. Our code diverges a bit 
    from standard presentations: we choose a different formula for the 
    extrapolation step. 
 
    Parameters 
    ---------- 
    f : function 
        Python function returning a number. The function :math:`f` 
        must be continuous, and :math:`f(a)` and :math:`f(b)` must 
        have opposite signs. 
    a : scalar 
        One end of the bracketing interval :math:`[a, b]`. 
    b : scalar 
        The other end of the bracketing interval :math:`[a, b]`. 
    xtol : number, optional 
        The computed root ``x0`` will satisfy ``np.allclose(x, x0, 
        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The 
        parameter must be positive. For nice functions, Brent's 
        method will often satisfy the above condition with ``xtol/2`` 
        and ``rtol/2``. [Brent1973]_ 
    rtol : number, optional 
        The computed root ``x0`` will satisfy ``np.allclose(x, x0, 
        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The 
        parameter cannot be smaller than its default value of 
        ``4*np.finfo(float).eps``. For nice functions, Brent's 
        method will often satisfy the above condition with ``xtol/2`` 
        and ``rtol/2``. [Brent1973]_ 
    maxiter : int, optional 
        If convergence is not achieved in `maxiter` iterations, an error is 
        raised. Must be &gt;= 0. 
    args : tuple, optional 
        Containing extra arguments for the function `f`. 
        `f` is called by ``apply(f, (x)+args)``. 
    full_output : bool, optional 
        If `full_output` is False, the root is returned. If `full_output` is 
        True, the return value is ``(x, r)``, where `x` is the root, and `r` is 
        a `RootResults` object. 
    disp : bool, optional 
        If True, raise RuntimeError if the algorithm didn't converge. 
        Otherwise, the convergence status is recorded in any `RootResults` 
        return object. 
 
    Returns 
    ------- 
    root : float 
        Root of `f` between `a` and `b`. 
    r : `RootResults` (present if ``full_output = True``) 
        Object containing information about the convergence. In particular, 
        ``r.converged`` is True if the routine converged. 
 
    Notes 
    ----- 
    `f` must be continuous.  f(a) and f(b) must have opposite signs. 
 
    Related functions fall into several classes: 
 
    multivariate local optimizers 
      `fmin`, `fmin_powell`, `fmin_cg`, `fmin_bfgs`, `fmin_ncg` 
    nonlinear least squares minimizer 
      `leastsq` 
    constrained multivariate optimizers 
      `fmin_l_bfgs_b`, `fmin_tnc`, `fmin_cobyla` 
    global optimizers 
      `basinhopping`, `brute`, `differential_evolution` 
    local scalar minimizers 
      `fminbound`, `brent`, `golden`, `bracket` 
    N-D root-finding 
      `fsolve` 
    1-D root-finding 
      `brenth`, `ridder`, `bisect`, `newton` 
    scalar fixed-point finder 
      `fixed_point` 
 
    References 
    ---------- 
    .. [Brent1973] 
       Brent, R. P., 
       *Algorithms for Minimization Without Derivatives*. 
       Englewood Cliffs, NJ: Prentice-Hall, 1973. Ch. 3-4. 
 
    .. [PressEtal1992] 
       Press, W. H.; Flannery, B. P.; Teukolsky, S. A.; and Vetterling, W. T. 
       *Numerical Recipes in FORTRAN: The Art of Scientific Computing*, 2nd ed. 
       Cambridge, England: Cambridge University Press, pp. 352-355, 1992. 
       Section 9.3:  &quot;Van Wijngaarden-Dekker-Brent Method.&quot; 
 
    Examples 
    -------- 
    &gt;&gt;&gt; def f(x): 
    ...     return (x**2 - 1) 
 
    &gt;&gt;&gt; from scipy import optimize 
 
    &gt;&gt;&gt; root = optimize.brentq(f, -2, 0) 
    &gt;&gt;&gt; root 
    -1.0 
 
    &gt;&gt;&gt; root = optimize.brentq(f, 0, 2) 
    &gt;&gt;&gt; root 
    1.0 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
        <span class="s1">args </span><span class="s2">= (</span><span class="s1">args</span><span class="s2">,)</span>
    <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">xtol </span><span class="s2">&lt;= </span><span class="s3">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;xtol too small (%g &lt;= 0)&quot; </span><span class="s2">% </span><span class="s1">xtol</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">rtol </span><span class="s2">&lt; </span><span class="s1">_rtol</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">f&quot;rtol too small (</span><span class="s0">{</span><span class="s1">rtol</span><span class="s0">:</span><span class="s4">g</span><span class="s0">} </span><span class="s4">&lt; </span><span class="s0">{</span><span class="s1">_rtol</span><span class="s0">:</span><span class="s4">g</span><span class="s0">}</span><span class="s4">)&quot;</span><span class="s2">)</span>
    <span class="s1">f </span><span class="s2">= </span><span class="s1">_wrap_nan_raise</span><span class="s2">(</span><span class="s1">f</span><span class="s2">)</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">_zeros</span><span class="s2">.</span><span class="s1">_brentq</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">results_c</span><span class="s2">(</span><span class="s1">full_output</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s4">&quot;brentq&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">brenth</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(),</span>
           <span class="s1">xtol</span><span class="s2">=</span><span class="s1">_xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">_rtol</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s1">_iter</span><span class="s2">,</span>
           <span class="s1">full_output</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Find a root of a function in a bracketing interval using Brent's 
    method with hyperbolic extrapolation. 
 
    A variation on the classic Brent routine to find a root of the function f 
    between the arguments a and b that uses hyperbolic extrapolation instead of 
    inverse quadratic extrapolation. Bus &amp; Dekker (1975) guarantee convergence 
    for this method, claiming that the upper bound of function evaluations here 
    is 4 or 5 times that of bisection. 
    f(a) and f(b) cannot have the same signs. Generally, on a par with the 
    brent routine, but not as heavily tested. It is a safe version of the 
    secant method that uses hyperbolic extrapolation. 
    The version here is by Chuck Harris, and implements Algorithm M of 
    [BusAndDekker1975]_, where further details (convergence properties, 
    additional remarks and such) can be found 
 
    Parameters 
    ---------- 
    f : function 
        Python function returning a number. f must be continuous, and f(a) and 
        f(b) must have opposite signs. 
    a : scalar 
        One end of the bracketing interval [a,b]. 
    b : scalar 
        The other end of the bracketing interval [a,b]. 
    xtol : number, optional 
        The computed root ``x0`` will satisfy ``np.allclose(x, x0, 
        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The 
        parameter must be positive. As with `brentq`, for nice 
        functions the method will often satisfy the above condition 
        with ``xtol/2`` and ``rtol/2``. 
    rtol : number, optional 
        The computed root ``x0`` will satisfy ``np.allclose(x, x0, 
        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The 
        parameter cannot be smaller than its default value of 
        ``4*np.finfo(float).eps``. As with `brentq`, for nice functions 
        the method will often satisfy the above condition with 
        ``xtol/2`` and ``rtol/2``. 
    maxiter : int, optional 
        If convergence is not achieved in `maxiter` iterations, an error is 
        raised. Must be &gt;= 0. 
    args : tuple, optional 
        Containing extra arguments for the function `f`. 
        `f` is called by ``apply(f, (x)+args)``. 
    full_output : bool, optional 
        If `full_output` is False, the root is returned. If `full_output` is 
        True, the return value is ``(x, r)``, where `x` is the root, and `r` is 
        a `RootResults` object. 
    disp : bool, optional 
        If True, raise RuntimeError if the algorithm didn't converge. 
        Otherwise, the convergence status is recorded in any `RootResults` 
        return object. 
 
    Returns 
    ------- 
    root : float 
        Root of `f` between `a` and `b`. 
    r : `RootResults` (present if ``full_output = True``) 
        Object containing information about the convergence. In particular, 
        ``r.converged`` is True if the routine converged. 
 
    See Also 
    -------- 
    fmin, fmin_powell, fmin_cg, fmin_bfgs, fmin_ncg : multivariate local optimizers 
    leastsq : nonlinear least squares minimizer 
    fmin_l_bfgs_b, fmin_tnc, fmin_cobyla : constrained multivariate optimizers 
    basinhopping, differential_evolution, brute : global optimizers 
    fminbound, brent, golden, bracket : local scalar minimizers 
    fsolve : N-D root-finding 
    brentq, brenth, ridder, bisect, newton : 1-D root-finding 
    fixed_point : scalar fixed-point finder 
 
    References 
    ---------- 
    .. [BusAndDekker1975] 
       Bus, J. C. P., Dekker, T. J., 
       &quot;Two Efficient Algorithms with Guaranteed Convergence for Finding a Zero 
       of a Function&quot;, ACM Transactions on Mathematical Software, Vol. 1, Issue 
       4, Dec. 1975, pp. 330-345. Section 3: &quot;Algorithm M&quot;. 
       :doi:`10.1145/355656.355659` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; def f(x): 
    ...     return (x**2 - 1) 
 
    &gt;&gt;&gt; from scipy import optimize 
 
    &gt;&gt;&gt; root = optimize.brenth(f, -2, 0) 
    &gt;&gt;&gt; root 
    -1.0 
 
    &gt;&gt;&gt; root = optimize.brenth(f, 0, 2) 
    &gt;&gt;&gt; root 
    1.0 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
        <span class="s1">args </span><span class="s2">= (</span><span class="s1">args</span><span class="s2">,)</span>
    <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">xtol </span><span class="s2">&lt;= </span><span class="s3">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;xtol too small (%g &lt;= 0)&quot; </span><span class="s2">% </span><span class="s1">xtol</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">rtol </span><span class="s2">&lt; </span><span class="s1">_rtol</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">f&quot;rtol too small (</span><span class="s0">{</span><span class="s1">rtol</span><span class="s0">:</span><span class="s4">g</span><span class="s0">} </span><span class="s4">&lt; </span><span class="s0">{</span><span class="s1">_rtol</span><span class="s0">:</span><span class="s4">g</span><span class="s0">}</span><span class="s4">)&quot;</span><span class="s2">)</span>
    <span class="s1">f </span><span class="s2">= </span><span class="s1">_wrap_nan_raise</span><span class="s2">(</span><span class="s1">f</span><span class="s2">)</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">_zeros</span><span class="s2">.</span><span class="s1">_brenth</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">results_c</span><span class="s2">(</span><span class="s1">full_output</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s4">&quot;brenth&quot;</span><span class="s2">)</span>


<span class="s5">################################</span>
<span class="s5"># TOMS &quot;Algorithm 748: Enclosing Zeros of Continuous Functions&quot;, by</span>
<span class="s5">#  Alefeld, G. E. and Potra, F. A. and Shi, Yixun,</span>
<span class="s5">#  See [1]</span>


<span class="s0">def </span><span class="s1">_notclose</span><span class="s2">(</span><span class="s1">fs</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">_rtol</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">_xtol</span><span class="s2">):</span>
    <span class="s5"># Ensure not None, not 0, all finite, and not very close to each other</span>
    <span class="s1">notclosefvals </span><span class="s2">= (</span>
            <span class="s1">all</span><span class="s2">(</span><span class="s1">fs</span><span class="s2">) </span><span class="s0">and </span><span class="s1">all</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">fs</span><span class="s2">)) </span><span class="s0">and</span>
            <span class="s0">not </span><span class="s1">any</span><span class="s2">(</span><span class="s1">any</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isclose</span><span class="s2">(</span><span class="s1">_f</span><span class="s2">, </span><span class="s1">fs</span><span class="s2">[</span><span class="s1">i </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">:], </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">atol</span><span class="s2">))</span>
                    <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">_f </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">fs</span><span class="s2">[:-</span><span class="s3">1</span><span class="s2">])))</span>
    <span class="s0">return </span><span class="s1">notclosefvals</span>


<span class="s0">def </span><span class="s1">_secant</span><span class="s2">(</span><span class="s1">xvals</span><span class="s2">, </span><span class="s1">fvals</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Perform a secant step, taking a little care&quot;&quot;&quot;</span>
    <span class="s5"># Secant has many &quot;mathematically&quot; equivalent formulations</span>
    <span class="s5"># x2 = x0 - (x1 - x0)/(f1 - f0) * f0</span>
    <span class="s5">#    = x1 - (x1 - x0)/(f1 - f0) * f1</span>
    <span class="s5">#    = (-x1 * f0 + x0 * f1) / (f1 - f0)</span>
    <span class="s5">#    = (-f0 / f1 * x1 + x0) / (1 - f0 / f1)</span>
    <span class="s5">#    = (-f1 / f0 * x0 + x1) / (1 - f1 / f0)</span>
    <span class="s1">x0</span><span class="s2">, </span><span class="s1">x1 </span><span class="s2">= </span><span class="s1">xvals</span><span class="s2">[:</span><span class="s3">2</span><span class="s2">]</span>
    <span class="s1">f0</span><span class="s2">, </span><span class="s1">f1 </span><span class="s2">= </span><span class="s1">fvals</span><span class="s2">[:</span><span class="s3">2</span><span class="s2">]</span>
    <span class="s0">if </span><span class="s1">f0 </span><span class="s2">== </span><span class="s1">f1</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">) &gt; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">f0</span><span class="s2">):</span>
        <span class="s1">x2 </span><span class="s2">= (-</span><span class="s1">f0 </span><span class="s2">/ </span><span class="s1">f1 </span><span class="s2">* </span><span class="s1">x1 </span><span class="s2">+ </span><span class="s1">x0</span><span class="s2">) / (</span><span class="s3">1 </span><span class="s2">- </span><span class="s1">f0 </span><span class="s2">/ </span><span class="s1">f1</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">x2 </span><span class="s2">= (-</span><span class="s1">f1 </span><span class="s2">/ </span><span class="s1">f0 </span><span class="s2">* </span><span class="s1">x0 </span><span class="s2">+ </span><span class="s1">x1</span><span class="s2">) / (</span><span class="s3">1 </span><span class="s2">- </span><span class="s1">f1 </span><span class="s2">/ </span><span class="s1">f0</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">x2</span>


<span class="s0">def </span><span class="s1">_update_bracket</span><span class="s2">(</span><span class="s1">ab</span><span class="s2">, </span><span class="s1">fab</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Update a bracket given (c, fc), return the discarded endpoints.&quot;&quot;&quot;</span>
    <span class="s1">fa</span><span class="s2">, </span><span class="s1">fb </span><span class="s2">= </span><span class="s1">fab</span>
    <span class="s1">idx </span><span class="s2">= (</span><span class="s3">0 </span><span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sign</span><span class="s2">(</span><span class="s1">fa</span><span class="s2">) * </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sign</span><span class="s2">(</span><span class="s1">fc</span><span class="s2">) &gt; </span><span class="s3">0 </span><span class="s0">else </span><span class="s3">1</span><span class="s2">)</span>
    <span class="s1">rx</span><span class="s2">, </span><span class="s1">rfx </span><span class="s2">= </span><span class="s1">ab</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">], </span><span class="s1">fab</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">]</span>
    <span class="s1">fab</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">] = </span><span class="s1">fc</span>
    <span class="s1">ab</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">] = </span><span class="s1">c</span>
    <span class="s0">return </span><span class="s1">rx</span><span class="s2">, </span><span class="s1">rfx</span>


<span class="s0">def </span><span class="s1">_compute_divided_differences</span><span class="s2">(</span><span class="s1">xvals</span><span class="s2">, </span><span class="s1">fvals</span><span class="s2">, </span><span class="s1">N</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">full</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
                                 <span class="s1">forward</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Return a matrix of divided differences for the xvals, fvals pairs 
 
    DD[i, j] = f[x_{i-j}, ..., x_i] for 0 &lt;= j &lt;= i 
 
    If full is False, just return the main diagonal(or last row): 
      f[a], f[a, b] and f[a, b, c]. 
    If forward is False, return f[c], f[b, c], f[a, b, c].&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">full</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">forward</span><span class="s2">:</span>
            <span class="s1">xvals </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">xvals</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">xvals </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">xvals</span><span class="s2">)[::-</span><span class="s3">1</span><span class="s2">]</span>
        <span class="s1">M </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">xvals</span><span class="s2">)</span>
        <span class="s1">N </span><span class="s2">= </span><span class="s1">M </span><span class="s0">if </span><span class="s1">N </span><span class="s0">is None else </span><span class="s1">min</span><span class="s2">(</span><span class="s1">N</span><span class="s2">, </span><span class="s1">M</span><span class="s2">)</span>
        <span class="s1">DD </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">([</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">])</span>
        <span class="s1">DD</span><span class="s2">[:, </span><span class="s3">0</span><span class="s2">] = </span><span class="s1">fvals</span><span class="s2">[:]</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">N</span><span class="s2">):</span>
            <span class="s1">DD</span><span class="s2">[</span><span class="s1">i</span><span class="s2">:, </span><span class="s1">i</span><span class="s2">] = (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">DD</span><span class="s2">[</span><span class="s1">i </span><span class="s2">- </span><span class="s3">1</span><span class="s2">:, </span><span class="s1">i </span><span class="s2">- </span><span class="s3">1</span><span class="s2">]) /</span>
                         <span class="s2">(</span><span class="s1">xvals</span><span class="s2">[</span><span class="s1">i</span><span class="s2">:] - </span><span class="s1">xvals</span><span class="s2">[:</span><span class="s1">M </span><span class="s2">- </span><span class="s1">i</span><span class="s2">]))</span>
        <span class="s0">return </span><span class="s1">DD</span>

    <span class="s1">xvals </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">xvals</span><span class="s2">)</span>
    <span class="s1">dd </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">fvals</span><span class="s2">)</span>
    <span class="s1">row </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">fvals</span><span class="s2">)</span>
    <span class="s1">idx2Use </span><span class="s2">= (</span><span class="s3">0 </span><span class="s0">if </span><span class="s1">forward </span><span class="s0">else </span><span class="s2">-</span><span class="s3">1</span><span class="s2">)</span>
    <span class="s1">dd</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] = </span><span class="s1">fvals</span><span class="s2">[</span><span class="s1">idx2Use</span><span class="s2">]</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">xvals</span><span class="s2">)):</span>
        <span class="s1">denom </span><span class="s2">= </span><span class="s1">xvals</span><span class="s2">[</span><span class="s1">i</span><span class="s2">:</span><span class="s1">i </span><span class="s2">+ </span><span class="s1">len</span><span class="s2">(</span><span class="s1">row</span><span class="s2">) - </span><span class="s3">1</span><span class="s2">] - </span><span class="s1">xvals</span><span class="s2">[:</span><span class="s1">len</span><span class="s2">(</span><span class="s1">row</span><span class="s2">) - </span><span class="s3">1</span><span class="s2">]</span>
        <span class="s1">row </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">row</span><span class="s2">)[:] / </span><span class="s1">denom</span>
        <span class="s1">dd</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">row</span><span class="s2">[</span><span class="s1">idx2Use</span><span class="s2">]</span>
    <span class="s0">return </span><span class="s1">dd</span>


<span class="s0">def </span><span class="s1">_interpolated_poly</span><span class="s2">(</span><span class="s1">xvals</span><span class="s2">, </span><span class="s1">fvals</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Compute p(x) for the polynomial passing through the specified locations. 
 
    Use Neville's algorithm to compute p(x) where p is the minimal degree 
    polynomial passing through the points xvals, fvals&quot;&quot;&quot;</span>
    <span class="s1">xvals </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">xvals</span><span class="s2">)</span>
    <span class="s1">N </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">xvals</span><span class="s2">)</span>
    <span class="s1">Q </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">([</span><span class="s1">N</span><span class="s2">, </span><span class="s1">N</span><span class="s2">])</span>
    <span class="s1">D </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">([</span><span class="s1">N</span><span class="s2">, </span><span class="s1">N</span><span class="s2">])</span>
    <span class="s1">Q</span><span class="s2">[:, </span><span class="s3">0</span><span class="s2">] = </span><span class="s1">fvals</span><span class="s2">[:]</span>
    <span class="s1">D</span><span class="s2">[:, </span><span class="s3">0</span><span class="s2">] = </span><span class="s1">fvals</span><span class="s2">[:]</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">N</span><span class="s2">):</span>
        <span class="s1">alpha </span><span class="s2">= </span><span class="s1">D</span><span class="s2">[</span><span class="s1">k</span><span class="s2">:, </span><span class="s1">k </span><span class="s2">- </span><span class="s3">1</span><span class="s2">] - </span><span class="s1">Q</span><span class="s2">[</span><span class="s1">k </span><span class="s2">- </span><span class="s3">1</span><span class="s2">:</span><span class="s1">N </span><span class="s2">- </span><span class="s3">1</span><span class="s2">, </span><span class="s1">k </span><span class="s2">- </span><span class="s3">1</span><span class="s2">]</span>
        <span class="s1">diffik </span><span class="s2">= </span><span class="s1">xvals</span><span class="s2">[</span><span class="s3">0</span><span class="s2">:</span><span class="s1">N </span><span class="s2">- </span><span class="s1">k</span><span class="s2">] - </span><span class="s1">xvals</span><span class="s2">[</span><span class="s1">k</span><span class="s2">:</span><span class="s1">N</span><span class="s2">]</span>
        <span class="s1">Q</span><span class="s2">[</span><span class="s1">k</span><span class="s2">:, </span><span class="s1">k</span><span class="s2">] = (</span><span class="s1">xvals</span><span class="s2">[</span><span class="s1">k</span><span class="s2">:] - </span><span class="s1">x</span><span class="s2">) / </span><span class="s1">diffik </span><span class="s2">* </span><span class="s1">alpha</span>
        <span class="s1">D</span><span class="s2">[</span><span class="s1">k</span><span class="s2">:, </span><span class="s1">k</span><span class="s2">] = (</span><span class="s1">xvals</span><span class="s2">[:</span><span class="s1">N </span><span class="s2">- </span><span class="s1">k</span><span class="s2">] - </span><span class="s1">x</span><span class="s2">) / </span><span class="s1">diffik </span><span class="s2">* </span><span class="s1">alpha</span>
    <span class="s5"># Expect Q[-1, 1:] to be small relative to Q[-1, 0] as x approaches a root</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">Q</span><span class="s2">[-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">:]) + </span><span class="s1">Q</span><span class="s2">[-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">_inverse_poly_zero</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">fa</span><span class="s2">, </span><span class="s1">fb</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">, </span><span class="s1">fd</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Inverse cubic interpolation f-values -&gt; x-values 
 
    Given four points (fa, a), (fb, b), (fc, c), (fd, d) with 
    fa, fb, fc, fd all distinct, find poly IP(y) through the 4 points 
    and compute x=IP(0). 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">_interpolated_poly</span><span class="s2">([</span><span class="s1">fa</span><span class="s2">, </span><span class="s1">fb</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">, </span><span class="s1">fd</span><span class="s2">], [</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">], </span><span class="s3">0</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_newton_quadratic</span><span class="s2">(</span><span class="s1">ab</span><span class="s2">, </span><span class="s1">fab</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">fd</span><span class="s2">, </span><span class="s1">k</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Apply Newton-Raphson like steps, using divided differences to approximate f' 
 
    ab is a real interval [a, b] containing a root, 
    fab holds the real values of f(a), f(b) 
    d is a real number outside [ab, b] 
    k is the number of steps to apply 
    &quot;&quot;&quot;</span>
    <span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">= </span><span class="s1">ab</span>
    <span class="s1">fa</span><span class="s2">, </span><span class="s1">fb </span><span class="s2">= </span><span class="s1">fab</span>
    <span class="s1">_</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">A </span><span class="s2">= </span><span class="s1">_compute_divided_differences</span><span class="s2">([</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">d</span><span class="s2">], [</span><span class="s1">fa</span><span class="s2">, </span><span class="s1">fb</span><span class="s2">, </span><span class="s1">fd</span><span class="s2">],</span>
                                           <span class="s1">forward</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">full</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>

    <span class="s5"># _P  is the quadratic polynomial through the 3 points</span>
    <span class="s0">def </span><span class="s1">_P</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s5"># Horner evaluation of fa + B * (x - a) + A * (x - a) * (x - b)</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">A </span><span class="s2">* (</span><span class="s1">x </span><span class="s2">- </span><span class="s1">b</span><span class="s2">) + </span><span class="s1">B</span><span class="s2">) * (</span><span class="s1">x </span><span class="s2">- </span><span class="s1">a</span><span class="s2">) + </span><span class="s1">fa</span>

    <span class="s0">if </span><span class="s1">A </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
        <span class="s1">r </span><span class="s2">= </span><span class="s1">a </span><span class="s2">- </span><span class="s1">fa </span><span class="s2">/ </span><span class="s1">B</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">r </span><span class="s2">= (</span><span class="s1">a </span><span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sign</span><span class="s2">(</span><span class="s1">A</span><span class="s2">) * </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sign</span><span class="s2">(</span><span class="s1">fa</span><span class="s2">) &gt; </span><span class="s3">0 </span><span class="s0">else </span><span class="s1">b</span><span class="s2">)</span>
        <span class="s5"># Apply k Newton-Raphson steps to _P(x), starting from x=r</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">k</span><span class="s2">):</span>
            <span class="s1">r1 </span><span class="s2">= </span><span class="s1">r </span><span class="s2">- </span><span class="s1">_P</span><span class="s2">(</span><span class="s1">r</span><span class="s2">) / (</span><span class="s1">B </span><span class="s2">+ </span><span class="s1">A </span><span class="s2">* (</span><span class="s3">2 </span><span class="s2">* </span><span class="s1">r </span><span class="s2">- </span><span class="s1">a </span><span class="s2">- </span><span class="s1">b</span><span class="s2">))</span>
            <span class="s0">if not </span><span class="s2">(</span><span class="s1">ab</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] &lt; </span><span class="s1">r1 </span><span class="s2">&lt; </span><span class="s1">ab</span><span class="s2">[</span><span class="s3">1</span><span class="s2">]):</span>
                <span class="s0">if </span><span class="s2">(</span><span class="s1">ab</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] &lt; </span><span class="s1">r </span><span class="s2">&lt; </span><span class="s1">ab</span><span class="s2">[</span><span class="s3">1</span><span class="s2">]):</span>
                    <span class="s0">return </span><span class="s1">r</span>
                <span class="s1">r </span><span class="s2">= </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">ab</span><span class="s2">) / </span><span class="s3">2.0</span>
                <span class="s0">break</span>
            <span class="s1">r </span><span class="s2">= </span><span class="s1">r1</span>

    <span class="s0">return </span><span class="s1">r</span>


<span class="s0">class </span><span class="s1">TOMS748Solver</span><span class="s2">:</span>
    <span class="s6">&quot;&quot;&quot;Solve f(x, *args) == 0 using Algorithm748 of Alefeld, Potro &amp; Shi. 
    &quot;&quot;&quot;</span>
    <span class="s1">_MU </span><span class="s2">= </span><span class="s3">0.5</span>
    <span class="s1">_K_MIN </span><span class="s2">= </span><span class="s3">1</span>
    <span class="s1">_K_MAX </span><span class="s2">= </span><span class="s3">100  </span><span class="s5"># A very high value for real usage. Expect 1, 2, maybe 3.</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">f </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">args </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">function_calls </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">iterations </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">k </span><span class="s2">= </span><span class="s3">2</span>
        <span class="s5"># ab=[a,b] is a global interval containing a root</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ab </span><span class="s2">= [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">]</span>
        <span class="s5"># fab is function values at a, b</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">fab </span><span class="s2">= [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">d </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">fd </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">e </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">fe </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">disp </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">xtol </span><span class="s2">= </span><span class="s1">_xtol</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">rtol </span><span class="s2">= </span><span class="s1">_rtol</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">maxiter </span><span class="s2">= </span><span class="s1">_iter</span>

    <span class="s0">def </span><span class="s1">configure</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">, </span><span class="s1">k</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">disp </span><span class="s2">= </span><span class="s1">disp</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">xtol </span><span class="s2">= </span><span class="s1">xtol</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">rtol </span><span class="s2">= </span><span class="s1">rtol</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">maxiter </span><span class="s2">= </span><span class="s1">maxiter</span>
        <span class="s5"># Silently replace a low value of k with 1</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">k </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_K_MIN</span><span class="s2">)</span>
        <span class="s5"># Noisily replace a high value of k with self._K_MAX</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">k </span><span class="s2">&gt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_K_MAX</span><span class="s2">:</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s4">&quot;toms748: Overriding k: -&gt;%d&quot; </span><span class="s2">% </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_K_MAX</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s3">3</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">k </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_K_MAX</span>

    <span class="s0">def </span><span class="s1">_callf</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">error</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Call the user-supplied function, update book-keeping&quot;&quot;&quot;</span>
        <span class="s1">fx </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">self</span><span class="s2">.</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">function_calls </span><span class="s2">+= </span><span class="s3">1</span>
        <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">fx</span><span class="s2">) </span><span class="s0">and </span><span class="s1">error</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">f&quot;Invalid function value: f(</span><span class="s0">{</span><span class="s1">x</span><span class="s0">:</span><span class="s4">f</span><span class="s0">}</span><span class="s4">) -&gt; </span><span class="s0">{</span><span class="s1">fx</span><span class="s0">} </span><span class="s4">&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">fx</span>

    <span class="s0">def </span><span class="s1">get_result</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">flag</span><span class="s2">=</span><span class="s1">_ECONVERGED</span><span class="s2">):</span>
        <span class="s6">r&quot;&quot;&quot;Package the result and statistics into a tuple.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">function_calls</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">iterations</span><span class="s2">, </span><span class="s1">flag</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_update_bracket</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">_update_bracket</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fab</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">start</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=()):</span>
        <span class="s6">r&quot;&quot;&quot;Prepare for the iterations.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">function_calls </span><span class="s2">= </span><span class="s3">0</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">iterations </span><span class="s2">= </span><span class="s3">0</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">f </span><span class="s2">= </span><span class="s1">f</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">args </span><span class="s2">= </span><span class="s1">args</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[:] = [</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">]</span>
        <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) != </span><span class="s3">0</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Invalid x value: %s &quot; </span><span class="s2">% (</span><span class="s1">a</span><span class="s2">))</span>
        <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">b</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">(</span><span class="s1">b</span><span class="s2">) != </span><span class="s3">0</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Invalid x value: %s &quot; </span><span class="s2">% (</span><span class="s1">b</span><span class="s2">))</span>

        <span class="s1">fa </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_callf</span><span class="s2">(</span><span class="s1">a</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">fa</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">(</span><span class="s1">fa</span><span class="s2">) != </span><span class="s3">0</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">f&quot;Invalid function value: f(</span><span class="s0">{</span><span class="s1">a</span><span class="s0">:</span><span class="s4">f</span><span class="s0">}</span><span class="s4">) -&gt; </span><span class="s0">{</span><span class="s1">fa</span><span class="s0">} </span><span class="s4">&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">fa </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">_ECONVERGED</span><span class="s2">, </span><span class="s1">a</span>
        <span class="s1">fb </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_callf</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">fb</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">imag</span><span class="s2">(</span><span class="s1">fb</span><span class="s2">) != </span><span class="s3">0</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">f&quot;Invalid function value: f(</span><span class="s0">{</span><span class="s1">b</span><span class="s0">:</span><span class="s4">f</span><span class="s0">}</span><span class="s4">) -&gt; </span><span class="s0">{</span><span class="s1">fb</span><span class="s0">} </span><span class="s4">&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">fb </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">_ECONVERGED</span><span class="s2">, </span><span class="s1">b</span>

        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sign</span><span class="s2">(</span><span class="s1">fb</span><span class="s2">) * </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sign</span><span class="s2">(</span><span class="s1">fa</span><span class="s2">) &gt; </span><span class="s3">0</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;f(a) and f(b) must have different signs, but &quot;</span>
                             <span class="s4">f&quot;f(</span><span class="s0">{</span><span class="s1">a</span><span class="s0">:</span><span class="s4">e</span><span class="s0">}</span><span class="s4">)=</span><span class="s0">{</span><span class="s1">fa</span><span class="s0">:</span><span class="s4">e</span><span class="s0">}</span><span class="s4">, f(</span><span class="s0">{</span><span class="s1">b</span><span class="s0">:</span><span class="s4">e</span><span class="s0">}</span><span class="s4">)=</span><span class="s0">{</span><span class="s1">fb</span><span class="s0">:</span><span class="s4">e</span><span class="s0">} </span><span class="s4">&quot;</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">fab</span><span class="s2">[:] = [</span><span class="s1">fa</span><span class="s2">, </span><span class="s1">fb</span><span class="s2">]</span>

        <span class="s0">return </span><span class="s1">_EINPROGRESS</span><span class="s2">, </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">) / </span><span class="s3">2.0</span>

    <span class="s0">def </span><span class="s1">get_status</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Determine the current status.&quot;&quot;&quot;</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[:</span><span class="s3">2</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isclose</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">xtol</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">_ECONVERGED</span><span class="s2">, </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">) / </span><span class="s3">2.0</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">iterations </span><span class="s2">&gt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">maxiter</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">_ECONVERR</span><span class="s2">, </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">) / </span><span class="s3">2.0</span>
        <span class="s0">return </span><span class="s1">_EINPROGRESS</span><span class="s2">, </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">) / </span><span class="s3">2.0</span>

    <span class="s0">def </span><span class="s1">iterate</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;Perform one step in the algorithm. 
 
        Implements Algorithm 4.1(k=1) or 4.2(k=2) in [APS1995] 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">iterations </span><span class="s2">+= </span><span class="s3">1</span>
        <span class="s1">eps </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">float</span><span class="s2">).</span><span class="s1">eps</span>
        <span class="s1">d</span><span class="s2">, </span><span class="s1">fd</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">fe </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">d</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fd</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">e</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fe</span>
        <span class="s1">ab_width </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[</span><span class="s3">1</span><span class="s2">] - </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]  </span><span class="s5"># Need the start width below</span>
        <span class="s1">c </span><span class="s2">= </span><span class="s0">None</span>

        <span class="s0">for </span><span class="s1">nsteps </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s3">2</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">k</span><span class="s2">+</span><span class="s3">2</span><span class="s2">):</span>
            <span class="s5"># If the f-values are sufficiently separated, perform an inverse</span>
            <span class="s5"># polynomial interpolation step. Otherwise, nsteps repeats of</span>
            <span class="s5"># an approximate Newton-Raphson step.</span>
            <span class="s0">if </span><span class="s1">_notclose</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">fab </span><span class="s2">+ [</span><span class="s1">fd</span><span class="s2">, </span><span class="s1">fe</span><span class="s2">], </span><span class="s1">rtol</span><span class="s2">=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s3">32</span><span class="s2">*</span><span class="s1">eps</span><span class="s2">):</span>
                <span class="s1">c0 </span><span class="s2">= </span><span class="s1">_inverse_poly_zero</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[</span><span class="s3">1</span><span class="s2">], </span><span class="s1">d</span><span class="s2">, </span><span class="s1">e</span><span class="s2">,</span>
                                        <span class="s1">self</span><span class="s2">.</span><span class="s1">fab</span><span class="s2">[</span><span class="s3">0</span><span class="s2">], </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fab</span><span class="s2">[</span><span class="s3">1</span><span class="s2">], </span><span class="s1">fd</span><span class="s2">, </span><span class="s1">fe</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] &lt; </span><span class="s1">c0 </span><span class="s2">&lt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[</span><span class="s3">1</span><span class="s2">]:</span>
                    <span class="s1">c </span><span class="s2">= </span><span class="s1">c0</span>
            <span class="s0">if </span><span class="s1">c </span><span class="s0">is None</span><span class="s2">:</span>
                <span class="s1">c </span><span class="s2">= </span><span class="s1">_newton_quadratic</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fab</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">fd</span><span class="s2">, </span><span class="s1">nsteps</span><span class="s2">)</span>

            <span class="s1">fc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_callf</span><span class="s2">(</span><span class="s1">c</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">fc </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">_ECONVERGED</span><span class="s2">, </span><span class="s1">c</span>

            <span class="s5"># re-bracket</span>
            <span class="s1">e</span><span class="s2">, </span><span class="s1">fe </span><span class="s2">= </span><span class="s1">d</span><span class="s2">, </span><span class="s1">fd</span>
            <span class="s1">d</span><span class="s2">, </span><span class="s1">fd </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_update_bracket</span><span class="s2">(</span><span class="s1">c</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">)</span>

        <span class="s5"># u is the endpoint with the smallest f-value</span>
        <span class="s1">uix </span><span class="s2">= (</span><span class="s3">0 </span><span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">fab</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]) &lt; </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">fab</span><span class="s2">[</span><span class="s3">1</span><span class="s2">]) </span><span class="s0">else </span><span class="s3">1</span><span class="s2">)</span>
        <span class="s1">u</span><span class="s2">, </span><span class="s1">fu </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[</span><span class="s1">uix</span><span class="s2">], </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fab</span><span class="s2">[</span><span class="s1">uix</span><span class="s2">]</span>

        <span class="s1">_</span><span class="s2">, </span><span class="s1">A </span><span class="s2">= </span><span class="s1">_compute_divided_differences</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fab</span><span class="s2">,</span>
                                            <span class="s1">forward</span><span class="s2">=(</span><span class="s1">uix </span><span class="s2">== </span><span class="s3">0</span><span class="s2">), </span><span class="s1">full</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
        <span class="s1">c </span><span class="s2">= </span><span class="s1">u </span><span class="s2">- </span><span class="s3">2 </span><span class="s2">* </span><span class="s1">fu </span><span class="s2">/ </span><span class="s1">A</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">c </span><span class="s2">- </span><span class="s1">u</span><span class="s2">) &gt; </span><span class="s3">0.5 </span><span class="s2">* (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[</span><span class="s3">1</span><span class="s2">] - </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[</span><span class="s3">0</span><span class="s2">]):</span>
            <span class="s1">c </span><span class="s2">= </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">) / </span><span class="s3">2.0</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isclose</span><span class="s2">(</span><span class="s1">c</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">eps</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s3">0</span><span class="s2">):</span>
                <span class="s5"># c didn't change (much).</span>
                <span class="s5"># Either because the f-values at the endpoints have vastly</span>
                <span class="s5"># differing magnitudes, or because the root is very close to</span>
                <span class="s5"># that endpoint</span>
                <span class="s1">frs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">frexp</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">fab</span><span class="s2">)[</span><span class="s3">1</span><span class="s2">]</span>
                <span class="s0">if </span><span class="s1">frs</span><span class="s2">[</span><span class="s1">uix</span><span class="s2">] &lt; </span><span class="s1">frs</span><span class="s2">[</span><span class="s3">1 </span><span class="s2">- </span><span class="s1">uix</span><span class="s2">] - </span><span class="s3">50</span><span class="s2">:  </span><span class="s5"># Differ by more than 2**50</span>
                    <span class="s1">c </span><span class="s2">= (</span><span class="s3">31 </span><span class="s2">* </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[</span><span class="s1">uix</span><span class="s2">] + </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[</span><span class="s3">1 </span><span class="s2">- </span><span class="s1">uix</span><span class="s2">]) / </span><span class="s3">32</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s5"># Make a bigger adjustment, about the</span>
                    <span class="s5"># size of the requested tolerance.</span>
                    <span class="s1">mm </span><span class="s2">= (</span><span class="s3">1 </span><span class="s0">if </span><span class="s1">uix </span><span class="s2">== </span><span class="s3">0 </span><span class="s0">else </span><span class="s2">-</span><span class="s3">1</span><span class="s2">)</span>
                    <span class="s1">adj </span><span class="s2">= </span><span class="s1">mm </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">c</span><span class="s2">) * </span><span class="s1">self</span><span class="s2">.</span><span class="s1">rtol </span><span class="s2">+ </span><span class="s1">mm </span><span class="s2">* </span><span class="s1">self</span><span class="s2">.</span><span class="s1">xtol</span>
                    <span class="s1">c </span><span class="s2">= </span><span class="s1">u </span><span class="s2">+ </span><span class="s1">adj</span>
                <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] &lt; </span><span class="s1">c </span><span class="s2">&lt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[</span><span class="s3">1</span><span class="s2">]:</span>
                    <span class="s1">c </span><span class="s2">= </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">) / </span><span class="s3">2.0</span>

        <span class="s1">fc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_callf</span><span class="s2">(</span><span class="s1">c</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">fc </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">_ECONVERGED</span><span class="s2">, </span><span class="s1">c</span>

        <span class="s1">e</span><span class="s2">, </span><span class="s1">fe </span><span class="s2">= </span><span class="s1">d</span><span class="s2">, </span><span class="s1">fd</span>
        <span class="s1">d</span><span class="s2">, </span><span class="s1">fd </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_update_bracket</span><span class="s2">(</span><span class="s1">c</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">)</span>

        <span class="s5"># If the width of the new interval did not decrease enough, bisect</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[</span><span class="s3">1</span><span class="s2">] - </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] &gt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_MU </span><span class="s2">* </span><span class="s1">ab_width</span><span class="s2">:</span>
            <span class="s1">e</span><span class="s2">, </span><span class="s1">fe </span><span class="s2">= </span><span class="s1">d</span><span class="s2">, </span><span class="s1">fd</span>
            <span class="s1">z </span><span class="s2">= </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">) / </span><span class="s3">2.0</span>
            <span class="s1">fz </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_callf</span><span class="s2">(</span><span class="s1">z</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">fz </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">_ECONVERGED</span><span class="s2">, </span><span class="s1">z</span>
            <span class="s1">d</span><span class="s2">, </span><span class="s1">fd </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_update_bracket</span><span class="s2">(</span><span class="s1">z</span><span class="s2">, </span><span class="s1">fz</span><span class="s2">)</span>

        <span class="s5"># Record d and e for next iteration</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">d</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fd </span><span class="s2">= </span><span class="s1">d</span><span class="s2">, </span><span class="s1">fd</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">e</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fe </span><span class="s2">= </span><span class="s1">e</span><span class="s2">, </span><span class="s1">fe</span>

        <span class="s1">status</span><span class="s2">, </span><span class="s1">xn </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_status</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">status</span><span class="s2">, </span><span class="s1">xn</span>

    <span class="s0">def </span><span class="s1">solve</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(),</span>
              <span class="s1">xtol</span><span class="s2">=</span><span class="s1">_xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">_rtol</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s1">_iter</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s6">r&quot;&quot;&quot;Solve f(x) = 0 given an interval containing a root.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">configure</span><span class="s2">(</span><span class="s1">xtol</span><span class="s2">=</span><span class="s1">xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s1">maxiter</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s1">disp</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s1">k</span><span class="s2">)</span>
        <span class="s1">status</span><span class="s2">, </span><span class="s1">xn </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">start</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">status </span><span class="s2">== </span><span class="s1">_ECONVERGED</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_result</span><span class="s2">(</span><span class="s1">xn</span><span class="s2">)</span>

        <span class="s5"># The first step only has two x-values.</span>
        <span class="s1">c </span><span class="s2">= </span><span class="s1">_secant</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fab</span><span class="s2">)</span>
        <span class="s0">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[</span><span class="s3">0</span><span class="s2">] &lt; </span><span class="s1">c </span><span class="s2">&lt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">[</span><span class="s3">1</span><span class="s2">]:</span>
            <span class="s1">c </span><span class="s2">= </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">) / </span><span class="s3">2.0</span>
        <span class="s1">fc </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_callf</span><span class="s2">(</span><span class="s1">c</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">fc </span><span class="s2">== </span><span class="s3">0</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_result</span><span class="s2">(</span><span class="s1">c</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">d</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fd </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_update_bracket</span><span class="s2">(</span><span class="s1">c</span><span class="s2">, </span><span class="s1">fc</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">e</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fe </span><span class="s2">= </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">iterations </span><span class="s2">+= </span><span class="s3">1</span>

        <span class="s0">while True</span><span class="s2">:</span>
            <span class="s1">status</span><span class="s2">, </span><span class="s1">xn </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">iterate</span><span class="s2">()</span>
            <span class="s0">if </span><span class="s1">status </span><span class="s2">== </span><span class="s1">_ECONVERGED</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_result</span><span class="s2">(</span><span class="s1">xn</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">status </span><span class="s2">== </span><span class="s1">_ECONVERR</span><span class="s2">:</span>
                <span class="s1">fmt </span><span class="s2">= </span><span class="s4">&quot;Failed to converge after %d iterations, bracket is %s&quot;</span>
                <span class="s0">if </span><span class="s1">disp</span><span class="s2">:</span>
                    <span class="s1">msg </span><span class="s2">= </span><span class="s1">fmt </span><span class="s2">% (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">iterations </span><span class="s2">+ </span><span class="s3">1</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ab</span><span class="s2">)</span>
                    <span class="s0">raise </span><span class="s1">RuntimeError</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">)</span>
                <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">get_result</span><span class="s2">(</span><span class="s1">xn</span><span class="s2">, </span><span class="s1">_ECONVERR</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">toms748</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">k</span><span class="s2">=</span><span class="s3">1</span><span class="s2">,</span>
            <span class="s1">xtol</span><span class="s2">=</span><span class="s1">_xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">_rtol</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s1">_iter</span><span class="s2">,</span>
            <span class="s1">full_output</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Find a root using TOMS Algorithm 748 method. 
 
    Implements the Algorithm 748 method of Alefeld, Potro and Shi to find a 
    root of the function `f` on the interval `[a , b]`, where `f(a)` and 
    `f(b)` must have opposite signs. 
 
    It uses a mixture of inverse cubic interpolation and 
    &quot;Newton-quadratic&quot; steps. [APS1995]. 
 
    Parameters 
    ---------- 
    f : function 
        Python function returning a scalar. The function :math:`f` 
        must be continuous, and :math:`f(a)` and :math:`f(b)` 
        have opposite signs. 
    a : scalar, 
        lower boundary of the search interval 
    b : scalar, 
        upper boundary of the search interval 
    args : tuple, optional 
        containing extra arguments for the function `f`. 
        `f` is called by ``f(x, *args)``. 
    k : int, optional 
        The number of Newton quadratic steps to perform each 
        iteration. ``k&gt;=1``. 
    xtol : scalar, optional 
        The computed root ``x0`` will satisfy ``np.allclose(x, x0, 
        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. The 
        parameter must be positive. 
    rtol : scalar, optional 
        The computed root ``x0`` will satisfy ``np.allclose(x, x0, 
        atol=xtol, rtol=rtol)``, where ``x`` is the exact root. 
    maxiter : int, optional 
        If convergence is not achieved in `maxiter` iterations, an error is 
        raised. Must be &gt;= 0. 
    full_output : bool, optional 
        If `full_output` is False, the root is returned. If `full_output` is 
        True, the return value is ``(x, r)``, where `x` is the root, and `r` is 
        a `RootResults` object. 
    disp : bool, optional 
        If True, raise RuntimeError if the algorithm didn't converge. 
        Otherwise, the convergence status is recorded in the `RootResults` 
        return object. 
 
    Returns 
    ------- 
    root : float 
        Approximate root of `f` 
    r : `RootResults` (present if ``full_output = True``) 
        Object containing information about the convergence. In particular, 
        ``r.converged`` is True if the routine converged. 
 
    See Also 
    -------- 
    brentq, brenth, ridder, bisect, newton 
    fsolve : find roots in N dimensions. 
 
    Notes 
    ----- 
    `f` must be continuous. 
    Algorithm 748 with ``k=2`` is asymptotically the most efficient 
    algorithm known for finding roots of a four times continuously 
    differentiable function. 
    In contrast with Brent's algorithm, which may only decrease the length of 
    the enclosing bracket on the last step, Algorithm 748 decreases it each 
    iteration with the same asymptotic efficiency as it finds the root. 
 
    For easy statement of efficiency indices, assume that `f` has 4 
    continuouous deriviatives. 
    For ``k=1``, the convergence order is at least 2.7, and with about 
    asymptotically 2 function evaluations per iteration, the efficiency 
    index is approximately 1.65. 
    For ``k=2``, the order is about 4.6 with asymptotically 3 function 
    evaluations per iteration, and the efficiency index 1.66. 
    For higher values of `k`, the efficiency index approaches 
    the kth root of ``(3k-2)``, hence ``k=1`` or ``k=2`` are 
    usually appropriate. 
 
    References 
    ---------- 
    .. [APS1995] 
       Alefeld, G. E. and Potra, F. A. and Shi, Yixun, 
       *Algorithm 748: Enclosing Zeros of Continuous Functions*, 
       ACM Trans. Math. Softw. Volume 221(1995) 
       doi = {10.1145/210089.210111} 
 
    Examples 
    -------- 
    &gt;&gt;&gt; def f(x): 
    ...     return (x**3 - 1)  # only one real root at x = 1 
 
    &gt;&gt;&gt; from scipy import optimize 
    &gt;&gt;&gt; root, results = optimize.toms748(f, 0, 2, full_output=True) 
    &gt;&gt;&gt; root 
    1.0 
    &gt;&gt;&gt; results 
          converged: True 
               flag: converged 
     function_calls: 11 
         iterations: 5 
               root: 1.0 
             method: toms748 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">xtol </span><span class="s2">&lt;= </span><span class="s3">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;xtol too small (%g &lt;= 0)&quot; </span><span class="s2">% </span><span class="s1">xtol</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">rtol </span><span class="s2">&lt; </span><span class="s1">_rtol </span><span class="s2">/ </span><span class="s3">4</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">f&quot;rtol too small (</span><span class="s0">{</span><span class="s1">rtol</span><span class="s0">:</span><span class="s4">g</span><span class="s0">} </span><span class="s4">&lt; </span><span class="s0">{</span><span class="s1">_rtol</span><span class="s2">/</span><span class="s3">4</span><span class="s0">:</span><span class="s4">g</span><span class="s0">}</span><span class="s4">)&quot;</span><span class="s2">)</span>
    <span class="s1">maxiter </span><span class="s2">= </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">maxiter</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">maxiter </span><span class="s2">&lt; </span><span class="s3">1</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;maxiter must be greater than 0&quot;</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">a</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;a is not finite %s&quot; </span><span class="s2">% </span><span class="s1">a</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isfinite</span><span class="s2">(</span><span class="s1">b</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;b is not finite %s&quot; </span><span class="s2">% </span><span class="s1">b</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">a </span><span class="s2">&gt;= </span><span class="s1">b</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">f&quot;a and b are not an interval [</span><span class="s0">{</span><span class="s1">a</span><span class="s0">}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">b</span><span class="s0">}</span><span class="s4">]&quot;</span><span class="s2">)</span>
    <span class="s0">if not </span><span class="s1">k </span><span class="s2">&gt;= </span><span class="s3">1</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;k too small (%s &lt; 1)&quot; </span><span class="s2">% </span><span class="s1">k</span><span class="s2">)</span>

    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
        <span class="s1">args </span><span class="s2">= (</span><span class="s1">args</span><span class="s2">,)</span>
    <span class="s1">f </span><span class="s2">= </span><span class="s1">_wrap_nan_raise</span><span class="s2">(</span><span class="s1">f</span><span class="s2">)</span>
    <span class="s1">solver </span><span class="s2">= </span><span class="s1">TOMS748Solver</span><span class="s2">()</span>
    <span class="s1">result </span><span class="s2">= </span><span class="s1">solver</span><span class="s2">.</span><span class="s1">solve</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s1">k</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s1">xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">rtol</span><span class="s2">,</span>
                          <span class="s1">maxiter</span><span class="s2">=</span><span class="s1">maxiter</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s1">disp</span><span class="s2">)</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">function_calls</span><span class="s2">, </span><span class="s1">iterations</span><span class="s2">, </span><span class="s1">flag </span><span class="s2">= </span><span class="s1">result</span>
    <span class="s0">return </span><span class="s1">_results_select</span><span class="s2">(</span><span class="s1">full_output</span><span class="s2">, (</span><span class="s1">x</span><span class="s2">, </span><span class="s1">function_calls</span><span class="s2">, </span><span class="s1">iterations</span><span class="s2">, </span><span class="s1">flag</span><span class="s2">),</span>
                           <span class="s4">&quot;toms748&quot;</span><span class="s2">)</span>
</pre>
</body>
</html>