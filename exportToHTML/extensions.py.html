<html>
<head>
<title>extensions.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
extensions.py</font>
</center></td></tr></table>
<pre><span class="s0"># ext/declarative/extensions.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>
<span class="s0"># mypy: ignore-errors</span>


<span class="s2">&quot;&quot;&quot;Public API functions and helpers for declarative.&quot;&quot;&quot;</span>
<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">import </span><span class="s1">collections</span>
<span class="s3">import </span><span class="s1">contextlib</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>

<span class="s3">from </span><span class="s4">... </span><span class="s3">import </span><span class="s1">exc </span><span class="s3">as </span><span class="s1">sa_exc</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">Connection</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">Engine</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">orm </span><span class="s3">import </span><span class="s1">exc </span><span class="s3">as </span><span class="s1">orm_exc</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">orm </span><span class="s3">import </span><span class="s1">relationships</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">orm</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_mapper_or_none</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">orm</span><span class="s4">.</span><span class="s1">clsregistry </span><span class="s3">import </span><span class="s1">_resolver</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">orm</span><span class="s4">.</span><span class="s1">decl_base </span><span class="s3">import </span><span class="s1">_DeferredMapperConfig</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">orm</span><span class="s4">.</span><span class="s1">util </span><span class="s3">import </span><span class="s1">polymorphic_union</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">Table</span>
<span class="s3">from </span><span class="s4">...</span><span class="s1">util </span><span class="s3">import </span><span class="s1">OrderedDict</span>

<span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s4">...</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">MetaData</span>


<span class="s3">class </span><span class="s1">ConcreteBase</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;A helper class for 'concrete' declarative mappings. 
 
    :class:`.ConcreteBase` will use the :func:`.polymorphic_union` 
    function automatically, against all tables mapped as a subclass 
    to this class.   The function is called via the 
    ``__declare_last__()`` function, which is essentially 
    a hook for the :meth:`.after_configured` event. 
 
    :class:`.ConcreteBase` produces a mapped 
    table for the class itself.  Compare to :class:`.AbstractConcreteBase`, 
    which does not. 
 
    Example:: 
 
        from sqlalchemy.ext.declarative import ConcreteBase 
 
        class Employee(ConcreteBase, Base): 
            __tablename__ = 'employee' 
            employee_id = Column(Integer, primary_key=True) 
            name = Column(String(50)) 
            __mapper_args__ = { 
                            'polymorphic_identity':'employee', 
                            'concrete':True} 
 
        class Manager(Employee): 
            __tablename__ = 'manager' 
            employee_id = Column(Integer, primary_key=True) 
            name = Column(String(50)) 
            manager_data = Column(String(40)) 
            __mapper_args__ = { 
                            'polymorphic_identity':'manager', 
                            'concrete':True} 
 
 
    The name of the discriminator column used by :func:`.polymorphic_union` 
    defaults to the name ``type``.  To suit the use case of a mapping where an 
    actual column in a mapped table is already named ``type``, the 
    discriminator name can be configured by setting the 
    ``_concrete_discriminator_name`` attribute:: 
 
        class Employee(ConcreteBase, Base): 
            _concrete_discriminator_name = '_concrete_discriminator' 
 
    .. versionadded:: 1.3.19 Added the ``_concrete_discriminator_name`` 
       attribute to :class:`_declarative.ConcreteBase` so that the 
       virtual discriminator column name can be customized. 
 
    .. versionchanged:: 1.4.2 The ``_concrete_discriminator_name`` attribute 
       need only be placed on the basemost class to take correct effect for 
       all subclasses.   An explicit error message is now raised if the 
       mapped column names conflict with the discriminator name, whereas 
       in the 1.3.x series there would be some warnings and then a non-useful 
       query would be generated. 
 
    .. seealso:: 
 
        :class:`.AbstractConcreteBase` 
 
        :ref:`concrete_inheritance` 
 
 
    &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_create_polymorphic_union</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">mappers</span><span class="s4">, </span><span class="s1">discriminator_name</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">polymorphic_union</span><span class="s4">(</span>
            <span class="s1">OrderedDict</span><span class="s4">(</span>
                <span class="s4">(</span><span class="s1">mp</span><span class="s4">.</span><span class="s1">polymorphic_identity</span><span class="s4">, </span><span class="s1">mp</span><span class="s4">.</span><span class="s1">local_table</span><span class="s4">) </span><span class="s3">for </span><span class="s1">mp </span><span class="s3">in </span><span class="s1">mappers</span>
            <span class="s4">),</span>
            <span class="s1">discriminator_name</span><span class="s4">,</span>
            <span class="s5">&quot;pjoin&quot;</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">__declare_first__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):</span>
        <span class="s1">m </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__mapper__</span>
        <span class="s3">if </span><span class="s1">m</span><span class="s4">.</span><span class="s1">with_polymorphic</span><span class="s4">:</span>
            <span class="s3">return</span>

        <span class="s1">discriminator_name </span><span class="s4">= (</span>
            <span class="s1">getattr</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s5">&quot;_concrete_discriminator_name&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">or </span><span class="s5">&quot;type&quot;</span>
        <span class="s4">)</span>

        <span class="s1">mappers </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">self_and_descendants</span><span class="s4">)</span>
        <span class="s1">pjoin </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_create_polymorphic_union</span><span class="s4">(</span><span class="s1">mappers</span><span class="s4">, </span><span class="s1">discriminator_name</span><span class="s4">)</span>
        <span class="s1">m</span><span class="s4">.</span><span class="s1">_set_with_polymorphic</span><span class="s4">((</span><span class="s5">&quot;*&quot;</span><span class="s4">, </span><span class="s1">pjoin</span><span class="s4">))</span>
        <span class="s1">m</span><span class="s4">.</span><span class="s1">_set_polymorphic_on</span><span class="s4">(</span><span class="s1">pjoin</span><span class="s4">.</span><span class="s1">c</span><span class="s4">[</span><span class="s1">discriminator_name</span><span class="s4">])</span>


<span class="s3">class </span><span class="s1">AbstractConcreteBase</span><span class="s4">(</span><span class="s1">ConcreteBase</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A helper class for 'concrete' declarative mappings. 
 
    :class:`.AbstractConcreteBase` will use the :func:`.polymorphic_union` 
    function automatically, against all tables mapped as a subclass 
    to this class.   The function is called via the 
    ``__declare_first__()`` function, which is essentially 
    a hook for the :meth:`.before_configured` event. 
 
    :class:`.AbstractConcreteBase` applies :class:`_orm.Mapper` for its 
    immediately inheriting class, as would occur for any other 
    declarative mapped class. However, the :class:`_orm.Mapper` is not 
    mapped to any particular :class:`.Table` object.  Instead, it's 
    mapped directly to the &quot;polymorphic&quot; selectable produced by 
    :func:`.polymorphic_union`, and performs no persistence operations on its 
    own.  Compare to :class:`.ConcreteBase`, which maps its 
    immediately inheriting class to an actual 
    :class:`.Table` that stores rows directly. 
 
    .. note:: 
 
        The :class:`.AbstractConcreteBase` delays the mapper creation of the 
        base class until all the subclasses have been defined, 
        as it needs to create a mapping against a selectable that will include 
        all subclass tables.  In order to achieve this, it waits for the 
        **mapper configuration event** to occur, at which point it scans 
        through all the configured subclasses and sets up a mapping that will 
        query against all subclasses at once. 
 
        While this event is normally invoked automatically, in the case of 
        :class:`.AbstractConcreteBase`, it may be necessary to invoke it 
        explicitly after **all** subclass mappings are defined, if the first 
        operation is to be a query against this base class. To do so, once all 
        the desired classes have been configured, the 
        :meth:`_orm.registry.configure` method on the :class:`_orm.registry` 
        in use can be invoked, which is available in relation to a particular 
        declarative base class:: 
 
            Base.registry.configure() 
 
    Example:: 
 
        from sqlalchemy.orm import DeclarativeBase 
        from sqlalchemy.ext.declarative import AbstractConcreteBase 
 
        class Base(DeclarativeBase): 
            pass 
 
        class Employee(AbstractConcreteBase, Base): 
            pass 
 
        class Manager(Employee): 
            __tablename__ = 'manager' 
            employee_id = Column(Integer, primary_key=True) 
            name = Column(String(50)) 
            manager_data = Column(String(40)) 
 
            __mapper_args__ = { 
                'polymorphic_identity':'manager', 
                'concrete':True 
            } 
 
        Base.registry.configure() 
 
    The abstract base class is handled by declarative in a special way; 
    at class configuration time, it behaves like a declarative mixin 
    or an ``__abstract__`` base class.   Once classes are configured 
    and mappings are produced, it then gets mapped itself, but 
    after all of its descendants.  This is a very unique system of mapping 
    not found in any other SQLAlchemy API feature. 
 
    Using this approach, we can specify columns and properties 
    that will take place on mapped subclasses, in the way that 
    we normally do as in :ref:`declarative_mixins`:: 
 
        from sqlalchemy.ext.declarative import AbstractConcreteBase 
 
        class Company(Base): 
            __tablename__ = 'company' 
            id = Column(Integer, primary_key=True) 
 
        class Employee(AbstractConcreteBase, Base): 
            strict_attrs = True 
 
            employee_id = Column(Integer, primary_key=True) 
 
            @declared_attr 
            def company_id(cls): 
                return Column(ForeignKey('company.id')) 
 
            @declared_attr 
            def company(cls): 
                return relationship(&quot;Company&quot;) 
 
        class Manager(Employee): 
            __tablename__ = 'manager' 
 
            name = Column(String(50)) 
            manager_data = Column(String(40)) 
 
            __mapper_args__ = { 
                'polymorphic_identity':'manager', 
                'concrete':True 
            } 
 
        Base.registry.configure() 
 
    When we make use of our mappings however, both ``Manager`` and 
    ``Employee`` will have an independently usable ``.company`` attribute:: 
 
        session.execute( 
            select(Employee).filter(Employee.company.has(id=5)) 
        ) 
 
    :param strict_attrs: when specified on the base class, &quot;strict&quot; attribute 
     mode is enabled which attempts to limit ORM mapped attributes on the 
     base class to only those that are immediately present, while still 
     preserving &quot;polymorphic&quot; loading behavior. 
 
     .. versionadded:: 2.0 
 
    .. seealso:: 
 
        :class:`.ConcreteBase` 
 
        :ref:`concrete_inheritance` 
 
        :ref:`abstract_concrete_base` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__no_table__ </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">__declare_first__</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):</span>
        <span class="s1">cls</span><span class="s4">.</span><span class="s1">_sa_decl_prepare_nocascade</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_sa_decl_prepare_nocascade</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s5">&quot;__mapper__&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">):</span>
            <span class="s3">return</span>

        <span class="s1">to_map </span><span class="s4">= </span><span class="s1">_DeferredMapperConfig</span><span class="s4">.</span><span class="s1">config_for_cls</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>

        <span class="s0"># can't rely on 'self_and_descendants' here</span>
        <span class="s0"># since technically an immediate subclass</span>
        <span class="s0"># might not be mapped, but a subclass</span>
        <span class="s0"># may be.</span>
        <span class="s1">mappers </span><span class="s4">= []</span>
        <span class="s1">stack </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__subclasses__</span><span class="s4">())</span>
        <span class="s3">while </span><span class="s1">stack</span><span class="s4">:</span>
            <span class="s1">klass </span><span class="s4">= </span><span class="s1">stack</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">()</span>
            <span class="s1">stack</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">klass</span><span class="s4">.</span><span class="s1">__subclasses__</span><span class="s4">())</span>
            <span class="s1">mn </span><span class="s4">= </span><span class="s1">_mapper_or_none</span><span class="s4">(</span><span class="s1">klass</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">mn </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">mappers</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">mn</span><span class="s4">)</span>

        <span class="s1">discriminator_name </span><span class="s4">= (</span>
            <span class="s1">getattr</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s5">&quot;_concrete_discriminator_name&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">or </span><span class="s5">&quot;type&quot;</span>
        <span class="s4">)</span>
        <span class="s1">pjoin </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">_create_polymorphic_union</span><span class="s4">(</span><span class="s1">mappers</span><span class="s4">, </span><span class="s1">discriminator_name</span><span class="s4">)</span>

        <span class="s0"># For columns that were declared on the class, these</span>
        <span class="s0"># are normally ignored with the &quot;__no_table__&quot; mapping,</span>
        <span class="s0"># unless they have a different attribute key vs. col name</span>
        <span class="s0"># and are in the properties argument.</span>
        <span class="s0"># In that case, ensure we update the properties entry</span>
        <span class="s0"># to the correct column from the pjoin target table.</span>
        <span class="s1">declared_cols </span><span class="s4">= </span><span class="s1">set</span><span class="s4">(</span><span class="s1">to_map</span><span class="s4">.</span><span class="s1">declared_columns</span><span class="s4">)</span>
        <span class="s1">declared_col_keys </span><span class="s4">= {</span><span class="s1">c</span><span class="s4">.</span><span class="s1">key </span><span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">declared_cols</span><span class="s4">}</span>
        <span class="s3">for </span><span class="s1">k</span><span class="s4">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">to_map</span><span class="s4">.</span><span class="s1">properties</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()):</span>
            <span class="s3">if </span><span class="s1">v </span><span class="s3">in </span><span class="s1">declared_cols</span><span class="s4">:</span>
                <span class="s1">to_map</span><span class="s4">.</span><span class="s1">properties</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] = </span><span class="s1">pjoin</span><span class="s4">.</span><span class="s1">c</span><span class="s4">[</span><span class="s1">v</span><span class="s4">.</span><span class="s1">key</span><span class="s4">]</span>
                <span class="s1">declared_col_keys</span><span class="s4">.</span><span class="s1">remove</span><span class="s4">(</span><span class="s1">v</span><span class="s4">.</span><span class="s1">key</span><span class="s4">)</span>

        <span class="s1">to_map</span><span class="s4">.</span><span class="s1">local_table </span><span class="s4">= </span><span class="s1">pjoin</span>

        <span class="s1">strict_attrs </span><span class="s4">= </span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;strict_attrs&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>

        <span class="s1">m_args </span><span class="s4">= </span><span class="s1">to_map</span><span class="s4">.</span><span class="s1">mapper_args_fn </span><span class="s3">or </span><span class="s1">dict</span>

        <span class="s3">def </span><span class="s1">mapper_args</span><span class="s4">():</span>
            <span class="s1">args </span><span class="s4">= </span><span class="s1">m_args</span><span class="s4">()</span>
            <span class="s1">args</span><span class="s4">[</span><span class="s5">&quot;polymorphic_on&quot;</span><span class="s4">] = </span><span class="s1">pjoin</span><span class="s4">.</span><span class="s1">c</span><span class="s4">[</span><span class="s1">discriminator_name</span><span class="s4">]</span>
            <span class="s1">args</span><span class="s4">[</span><span class="s5">&quot;polymorphic_abstract&quot;</span><span class="s4">] = </span><span class="s3">True</span>
            <span class="s3">if </span><span class="s1">strict_attrs</span><span class="s4">:</span>
                <span class="s1">args</span><span class="s4">[</span><span class="s5">&quot;include_properties&quot;</span><span class="s4">] = (</span>
                    <span class="s1">set</span><span class="s4">(</span><span class="s1">pjoin</span><span class="s4">.</span><span class="s1">primary_key</span><span class="s4">)</span>
                    <span class="s4">| </span><span class="s1">declared_col_keys</span>
                    <span class="s4">| {</span><span class="s1">discriminator_name</span><span class="s4">}</span>
                <span class="s4">)</span>
                <span class="s1">args</span><span class="s4">[</span><span class="s5">&quot;with_polymorphic&quot;</span><span class="s4">] = (</span><span class="s5">&quot;*&quot;</span><span class="s4">, </span><span class="s1">pjoin</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">args</span>

        <span class="s1">to_map</span><span class="s4">.</span><span class="s1">mapper_args_fn </span><span class="s4">= </span><span class="s1">mapper_args</span>

        <span class="s1">to_map</span><span class="s4">.</span><span class="s1">map</span><span class="s4">()</span>

        <span class="s1">stack </span><span class="s4">= [</span><span class="s1">cls</span><span class="s4">]</span>
        <span class="s3">while </span><span class="s1">stack</span><span class="s4">:</span>
            <span class="s1">scls </span><span class="s4">= </span><span class="s1">stack</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s6">0</span><span class="s4">)</span>
            <span class="s1">stack</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span><span class="s1">scls</span><span class="s4">.</span><span class="s1">__subclasses__</span><span class="s4">())</span>
            <span class="s1">sm </span><span class="s4">= </span><span class="s1">_mapper_or_none</span><span class="s4">(</span><span class="s1">scls</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">sm </span><span class="s3">and </span><span class="s1">sm</span><span class="s4">.</span><span class="s1">concrete </span><span class="s3">and </span><span class="s1">sm</span><span class="s4">.</span><span class="s1">inherits </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s3">for </span><span class="s1">sup_ </span><span class="s3">in </span><span class="s1">scls</span><span class="s4">.</span><span class="s1">__mro__</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:]:</span>
                    <span class="s1">sup_sm </span><span class="s4">= </span><span class="s1">_mapper_or_none</span><span class="s4">(</span><span class="s1">sup_</span><span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">sup_sm</span><span class="s4">:</span>
                        <span class="s1">sm</span><span class="s4">.</span><span class="s1">_set_concrete_base</span><span class="s4">(</span><span class="s1">sup_sm</span><span class="s4">)</span>
                        <span class="s3">break</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_sa_raise_deferred_config</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">orm_exc</span><span class="s4">.</span><span class="s1">UnmappedClassError</span><span class="s4">(</span>
            <span class="s1">cls</span><span class="s4">,</span>
            <span class="s1">msg</span><span class="s4">=</span><span class="s5">&quot;Class %s is a subclass of AbstractConcreteBase and &quot;</span>
            <span class="s5">&quot;has a mapping pending until all subclasses are defined. &quot;</span>
            <span class="s5">&quot;Call the sqlalchemy.orm.configure_mappers() function after &quot;</span>
            <span class="s5">&quot;all subclasses have been defined to &quot;</span>
            <span class="s5">&quot;complete the mapping of this class.&quot;</span>
            <span class="s4">% </span><span class="s1">orm_exc</span><span class="s4">.</span><span class="s1">_safe_cls_name</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">),</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">DeferredReflection</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;A helper class for construction of mappings based on 
    a deferred reflection step. 
 
    Normally, declarative can be used with reflection by 
    setting a :class:`_schema.Table` object using autoload_with=engine 
    as the ``__table__`` attribute on a declarative class. 
    The caveat is that the :class:`_schema.Table` must be fully 
    reflected, or at the very least have a primary key column, 
    at the point at which a normal declarative mapping is 
    constructed, meaning the :class:`_engine.Engine` must be available 
    at class declaration time. 
 
    The :class:`.DeferredReflection` mixin moves the construction 
    of mappers to be at a later point, after a specific 
    method is called which first reflects all :class:`_schema.Table` 
    objects created so far.   Classes can define it as such:: 
 
        from sqlalchemy.ext.declarative import declarative_base 
        from sqlalchemy.ext.declarative import DeferredReflection 
        Base = declarative_base() 
 
        class MyClass(DeferredReflection, Base): 
            __tablename__ = 'mytable' 
 
    Above, ``MyClass`` is not yet mapped.   After a series of 
    classes have been defined in the above fashion, all tables 
    can be reflected and mappings created using 
    :meth:`.prepare`:: 
 
        engine = create_engine(&quot;someengine://...&quot;) 
        DeferredReflection.prepare(engine) 
 
    The :class:`.DeferredReflection` mixin can be applied to individual 
    classes, used as the base for the declarative base itself, 
    or used in a custom abstract class.   Using an abstract base 
    allows that only a subset of classes to be prepared for a 
    particular prepare step, which is necessary for applications 
    that use more than one engine.  For example, if an application 
    has two engines, you might use two bases, and prepare each 
    separately, e.g.:: 
 
        class ReflectedOne(DeferredReflection, Base): 
            __abstract__ = True 
 
        class ReflectedTwo(DeferredReflection, Base): 
            __abstract__ = True 
 
        class MyClass(ReflectedOne): 
            __tablename__ = 'mytable' 
 
        class MyOtherClass(ReflectedOne): 
            __tablename__ = 'myothertable' 
 
        class YetAnotherClass(ReflectedTwo): 
            __tablename__ = 'yetanothertable' 
 
        # ... etc. 
 
    Above, the class hierarchies for ``ReflectedOne`` and 
    ``ReflectedTwo`` can be configured separately:: 
 
        ReflectedOne.prepare(engine_one) 
        ReflectedTwo.prepare(engine_two) 
 
    .. seealso:: 
 
        :ref:`orm_declarative_reflected_deferred_reflection` - in the 
        :ref:`orm_declarative_table_config_toplevel` section. 
 
    &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">prepare</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">bind</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Engine</span><span class="s4">, </span><span class="s1">Connection</span><span class="s4">], **</span><span class="s1">reflect_kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Reflect all :class:`_schema.Table` objects for all current 
        :class:`.DeferredReflection` subclasses 
 
        :param bind: :class:`_engine.Engine` or :class:`_engine.Connection` 
         instance 
 
         ..versionchanged:: 2.0.16 a :class:`_engine.Connection` is also 
         accepted. 
 
        :param \**reflect_kw: additional keyword arguments passed to 
         :meth:`_schema.MetaData.reflect`, such as 
         :paramref:`_schema.MetaData.reflect.views`. 
 
         .. versionadded:: 2.0.16 
 
        &quot;&quot;&quot;</span>

        <span class="s1">to_map </span><span class="s4">= </span><span class="s1">_DeferredMapperConfig</span><span class="s4">.</span><span class="s1">classes_for_base</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">)</span>

        <span class="s1">metadata_to_table </span><span class="s4">= </span><span class="s1">collections</span><span class="s4">.</span><span class="s1">defaultdict</span><span class="s4">(</span><span class="s1">set</span><span class="s4">)</span>

        <span class="s0"># first collect the primary __table__ for each class into a</span>
        <span class="s0"># collection of metadata/schemaname -&gt; table names</span>
        <span class="s3">for </span><span class="s1">thingy </span><span class="s3">in </span><span class="s1">to_map</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">thingy</span><span class="s4">.</span><span class="s1">local_table </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">metadata_to_table</span><span class="s4">[</span>
                    <span class="s4">(</span><span class="s1">thingy</span><span class="s4">.</span><span class="s1">local_table</span><span class="s4">.</span><span class="s1">metadata</span><span class="s4">, </span><span class="s1">thingy</span><span class="s4">.</span><span class="s1">local_table</span><span class="s4">.</span><span class="s1">schema</span><span class="s4">)</span>
                <span class="s4">].</span><span class="s1">add</span><span class="s4">(</span><span class="s1">thingy</span><span class="s4">.</span><span class="s1">local_table</span><span class="s4">.</span><span class="s1">name</span><span class="s4">)</span>

        <span class="s0"># then reflect all those tables into their metadatas</span>

        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">, </span><span class="s1">Connection</span><span class="s4">):</span>
            <span class="s1">conn </span><span class="s4">= </span><span class="s1">bind</span>
            <span class="s1">ctx </span><span class="s4">= </span><span class="s1">contextlib</span><span class="s4">.</span><span class="s1">nullcontext</span><span class="s4">(</span><span class="s1">enter_result</span><span class="s4">=</span><span class="s1">conn</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">, </span><span class="s1">Engine</span><span class="s4">):</span>
            <span class="s1">ctx </span><span class="s4">= </span><span class="s1">bind</span><span class="s4">.</span><span class="s1">connect</span><span class="s4">()</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                <span class="s5">f&quot;Expected Engine or Connection, got </span><span class="s3">{</span><span class="s1">bind</span><span class="s3">!r}</span><span class="s5">&quot;</span>
            <span class="s4">)</span>

        <span class="s3">with </span><span class="s1">ctx </span><span class="s3">as </span><span class="s1">conn</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s4">(</span><span class="s1">metadata</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">), </span><span class="s1">table_names </span><span class="s3">in </span><span class="s1">metadata_to_table</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
                <span class="s1">metadata</span><span class="s4">.</span><span class="s1">reflect</span><span class="s4">(</span>
                    <span class="s1">conn</span><span class="s4">,</span>
                    <span class="s1">only</span><span class="s4">=</span><span class="s1">table_names</span><span class="s4">,</span>
                    <span class="s1">schema</span><span class="s4">=</span><span class="s1">schema</span><span class="s4">,</span>
                    <span class="s1">extend_existing</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                    <span class="s1">autoload_replace</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                    <span class="s4">**</span><span class="s1">reflect_kw</span><span class="s4">,</span>
                <span class="s4">)</span>

            <span class="s1">metadata_to_table</span><span class="s4">.</span><span class="s1">clear</span><span class="s4">()</span>

            <span class="s0"># .map() each class, then go through relationships and look</span>
            <span class="s0"># for secondary</span>
            <span class="s3">for </span><span class="s1">thingy </span><span class="s3">in </span><span class="s1">to_map</span><span class="s4">:</span>
                <span class="s1">thingy</span><span class="s4">.</span><span class="s1">map</span><span class="s4">()</span>

                <span class="s1">mapper </span><span class="s4">= </span><span class="s1">thingy</span><span class="s4">.</span><span class="s1">cls</span><span class="s4">.</span><span class="s1">__mapper__</span>
                <span class="s1">metadata </span><span class="s4">= </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">class_</span><span class="s4">.</span><span class="s1">metadata</span>

                <span class="s3">for </span><span class="s1">rel </span><span class="s3">in </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">_props</span><span class="s4">.</span><span class="s1">values</span><span class="s4">():</span>
                    <span class="s3">if </span><span class="s4">(</span>
                        <span class="s1">isinstance</span><span class="s4">(</span><span class="s1">rel</span><span class="s4">, </span><span class="s1">relationships</span><span class="s4">.</span><span class="s1">RelationshipProperty</span><span class="s4">)</span>
                        <span class="s3">and </span><span class="s1">rel</span><span class="s4">.</span><span class="s1">_init_args</span><span class="s4">.</span><span class="s1">secondary</span><span class="s4">.</span><span class="s1">_is_populated</span><span class="s4">()</span>
                    <span class="s4">):</span>
                        <span class="s1">secondary_arg </span><span class="s4">= </span><span class="s1">rel</span><span class="s4">.</span><span class="s1">_init_args</span><span class="s4">.</span><span class="s1">secondary</span>

                        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">secondary_arg</span><span class="s4">.</span><span class="s1">argument</span><span class="s4">, </span><span class="s1">Table</span><span class="s4">):</span>
                            <span class="s1">secondary_table </span><span class="s4">= </span><span class="s1">secondary_arg</span><span class="s4">.</span><span class="s1">argument</span>
                            <span class="s1">metadata_to_table</span><span class="s4">[</span>
                                <span class="s4">(</span>
                                    <span class="s1">secondary_table</span><span class="s4">.</span><span class="s1">metadata</span><span class="s4">,</span>
                                    <span class="s1">secondary_table</span><span class="s4">.</span><span class="s1">schema</span><span class="s4">,</span>
                                <span class="s4">)</span>
                            <span class="s4">].</span><span class="s1">add</span><span class="s4">(</span><span class="s1">secondary_table</span><span class="s4">.</span><span class="s1">name</span><span class="s4">)</span>
                        <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">secondary_arg</span><span class="s4">.</span><span class="s1">argument</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
                            <span class="s1">_</span><span class="s4">, </span><span class="s1">resolve_arg </span><span class="s4">= </span><span class="s1">_resolver</span><span class="s4">(</span><span class="s1">rel</span><span class="s4">.</span><span class="s1">parent</span><span class="s4">.</span><span class="s1">class_</span><span class="s4">, </span><span class="s1">rel</span><span class="s4">)</span>

                            <span class="s1">resolver </span><span class="s4">= </span><span class="s1">resolve_arg</span><span class="s4">(</span>
                                <span class="s1">secondary_arg</span><span class="s4">.</span><span class="s1">argument</span><span class="s4">, </span><span class="s3">True</span>
                            <span class="s4">)</span>
                            <span class="s1">metadata_to_table</span><span class="s4">[</span>
                                <span class="s4">(</span><span class="s1">metadata</span><span class="s4">, </span><span class="s1">thingy</span><span class="s4">.</span><span class="s1">local_table</span><span class="s4">.</span><span class="s1">schema</span><span class="s4">)</span>
                            <span class="s4">].</span><span class="s1">add</span><span class="s4">(</span><span class="s1">secondary_arg</span><span class="s4">.</span><span class="s1">argument</span><span class="s4">)</span>

                            <span class="s1">resolver</span><span class="s4">.</span><span class="s1">_resolvers </span><span class="s4">+= (</span>
                                <span class="s1">cls</span><span class="s4">.</span><span class="s1">_sa_deferred_table_resolver</span><span class="s4">(</span><span class="s1">metadata</span><span class="s4">),</span>
                            <span class="s4">)</span>

                            <span class="s1">secondary_arg</span><span class="s4">.</span><span class="s1">argument </span><span class="s4">= </span><span class="s1">resolver</span><span class="s4">()</span>

            <span class="s3">for </span><span class="s4">(</span><span class="s1">metadata</span><span class="s4">, </span><span class="s1">schema</span><span class="s4">), </span><span class="s1">table_names </span><span class="s3">in </span><span class="s1">metadata_to_table</span><span class="s4">.</span><span class="s1">items</span><span class="s4">():</span>
                <span class="s1">metadata</span><span class="s4">.</span><span class="s1">reflect</span><span class="s4">(</span>
                    <span class="s1">conn</span><span class="s4">,</span>
                    <span class="s1">only</span><span class="s4">=</span><span class="s1">table_names</span><span class="s4">,</span>
                    <span class="s1">schema</span><span class="s4">=</span><span class="s1">schema</span><span class="s4">,</span>
                    <span class="s1">extend_existing</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                    <span class="s1">autoload_replace</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_sa_deferred_table_resolver</span><span class="s4">(</span>
        <span class="s1">cls</span><span class="s4">, </span><span class="s1">metadata</span><span class="s4">: </span><span class="s1">MetaData</span>
    <span class="s4">) </span><span class="s1">-&gt; Callable</span><span class="s4">[[</span><span class="s1">str</span><span class="s4">], </span><span class="s1">Table</span><span class="s4">]:</span>
        <span class="s3">def </span><span class="s1">_resolve</span><span class="s4">(</span><span class="s1">key</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; Table</span><span class="s4">:</span>
            <span class="s0"># reflection has already occurred so this Table would have</span>
            <span class="s0"># its contents already</span>
            <span class="s3">return </span><span class="s1">Table</span><span class="s4">(</span><span class="s1">key</span><span class="s4">, </span><span class="s1">metadata</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">_resolve</span>

    <span class="s1">_sa_decl_prepare </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">_sa_raise_deferred_config</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">orm_exc</span><span class="s4">.</span><span class="s1">UnmappedClassError</span><span class="s4">(</span>
            <span class="s1">cls</span><span class="s4">,</span>
            <span class="s1">msg</span><span class="s4">=</span><span class="s5">&quot;Class %s is a subclass of DeferredReflection.  &quot;</span>
            <span class="s5">&quot;Mappings are not produced until the .prepare() &quot;</span>
            <span class="s5">&quot;method is called on the class hierarchy.&quot;</span>
            <span class="s4">% </span><span class="s1">orm_exc</span><span class="s4">.</span><span class="s1">_safe_cls_name</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">),</span>
        <span class="s4">)</span>
</pre>
</body>
</html>