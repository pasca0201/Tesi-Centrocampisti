<html>
<head>
<title>_splitter.pyx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_splitter.pyx</font>
</center></td></tr></table>
<pre><span class="s0"># Authors: Gilles Louppe &lt;g.louppe@gmail.com&gt;</span>
<span class="s0">#          Peter Prettenhofer &lt;peter.prettenhofer@gmail.com&gt;</span>
<span class="s0">#          Brian Holt &lt;bdholt1@gmail.com&gt;</span>
<span class="s0">#          Noel Dawe &lt;noel@dawe.me&gt;</span>
<span class="s0">#          Satrajit Gosh &lt;satrajit.ghosh@gmail.com&gt;</span>
<span class="s0">#          Lars Buitinck</span>
<span class="s0">#          Arnaud Joly &lt;arnaud.v.joly@gmail.com&gt;</span>
<span class="s0">#          Joel Nothman &lt;joel.nothman@gmail.com&gt;</span>
<span class="s0">#          Fares Hedayati &lt;fares.hedayati@gmail.com&gt;</span>
<span class="s0">#          Jacob Schreiber &lt;jmschreiber91@gmail.com&gt;</span>
<span class="s0">#</span>
<span class="s0"># License: BSD 3 clause</span>

<span class="s2">from </span><span class="s1">cython </span><span class="s2">cimport </span><span class="s1">final</span>
<span class="s2">from </span><span class="s1">libc</span><span class="s3">.</span><span class="s1">math </span><span class="s2">cimport </span><span class="s1">isnan</span>
<span class="s2">from </span><span class="s1">libc</span><span class="s3">.</span><span class="s1">stdlib </span><span class="s2">cimport </span><span class="s1">qsort</span>
<span class="s2">from </span><span class="s1">libc</span><span class="s3">.</span><span class="s1">string </span><span class="s2">cimport </span><span class="s1">memcpy</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">_criterion </span><span class="s2">cimport </span><span class="s1">Criterion</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_utils </span><span class="s2">cimport </span><span class="s1">log</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_utils </span><span class="s2">cimport </span><span class="s1">rand_int</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_utils </span><span class="s2">cimport </span><span class="s1">rand_uniform</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_utils </span><span class="s2">cimport </span><span class="s1">RAND_R_MAX</span>
<span class="s2">from </span><span class="s3">..</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_typedefs </span><span class="s2">cimport </span><span class="s1">int8_t</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">sparse </span><span class="s2">import </span><span class="s1">issparse</span>


<span class="s2">cdef </span><span class="s1">float64_t INFINITY </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span>

<span class="s0"># Mitigate precision differences between 32 bit and 64 bit</span>
<span class="s2">cdef </span><span class="s1">float32_t FEATURE_THRESHOLD </span><span class="s3">= </span><span class="s4">1e-7</span>

<span class="s0"># Constant to switch between algorithm non zero value extract algorithm</span>
<span class="s0"># in SparsePartitioner</span>
<span class="s2">cdef </span><span class="s1">float32_t EXTRACT_NNZ_SWITCH </span><span class="s3">= </span><span class="s4">0.1</span>

<span class="s2">cdef </span><span class="s1">inline void _init_split</span><span class="s3">(</span><span class="s1">SplitRecord</span><span class="s3">* </span><span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t start_pos</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">impurity_left </span><span class="s3">= </span><span class="s1">INFINITY</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">impurity_right </span><span class="s3">= </span><span class="s1">INFINITY</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">= </span><span class="s1">start_pos</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">feature </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">threshold </span><span class="s3">= </span><span class="s4">0.</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">improvement </span><span class="s3">= -</span><span class="s1">INFINITY</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">missing_go_to_left </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s1">self</span><span class="s3">.</span><span class="s1">n_missing </span><span class="s3">= </span><span class="s4">0</span>

<span class="s2">cdef class </span><span class="s1">Splitter</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot;Abstract splitter class. 
 
    Splitters are called by tree builders to find the best splits on both 
    sparse and dense data, one split at a time. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__cinit__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">Criterion criterion</span><span class="s3">,</span>
        <span class="s1">intp_t max_features</span><span class="s3">,</span>
        <span class="s1">intp_t min_samples_leaf</span><span class="s3">,</span>
        <span class="s1">float64_t min_weight_leaf</span><span class="s3">,</span>
        <span class="s1">object random_state</span><span class="s3">,</span>
        <span class="s1">const int8_t</span><span class="s3">[:] </span><span class="s1">monotonic_cst</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        criterion : Criterion 
            The criterion to measure the quality of a split. 
 
        max_features : intp_t 
            The maximal number of randomly selected features which can be 
            considered for a split. 
 
        min_samples_leaf : intp_t 
            The minimal number of samples each leaf can have, where splits 
            which would result in having less samples in a leaf are not 
            considered. 
 
        min_weight_leaf : float64_t 
            The minimal weight each leaf can have, where the weight is the sum 
            of the weights of each sample in it. 
 
        random_state : object 
            The user inputted random state to be used for pseudo-randomness 
 
        monotonic_cst : const int8_t[:] 
            Monotonicity constraints 
 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">criterion </span><span class="s3">= </span><span class="s1">criterion</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_features </span><span class="s3">= </span><span class="s4">0</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">max_features </span><span class="s3">= </span><span class="s1">max_features</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">min_samples_leaf </span><span class="s3">= </span><span class="s1">min_samples_leaf</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">min_weight_leaf </span><span class="s3">= </span><span class="s1">min_weight_leaf</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">random_state </span><span class="s3">= </span><span class="s1">random_state</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">monotonic_cst </span><span class="s3">= </span><span class="s1">monotonic_cst</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">with_monotonic_cst </span><span class="s3">= </span><span class="s1">monotonic_cst </span><span class="s2">is not None</span>

    <span class="s2">def </span><span class="s1">__getstate__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">{}</span>

    <span class="s2">def </span><span class="s1">__setstate__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">d</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">__reduce__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">), (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">criterion</span><span class="s3">,</span>
                             <span class="s1">self</span><span class="s3">.</span><span class="s1">max_features</span><span class="s3">,</span>
                             <span class="s1">self</span><span class="s3">.</span><span class="s1">min_samples_leaf</span><span class="s3">,</span>
                             <span class="s1">self</span><span class="s3">.</span><span class="s1">min_weight_leaf</span><span class="s3">,</span>
                             <span class="s1">self</span><span class="s3">.</span><span class="s1">random_state</span><span class="s3">,</span>
                             <span class="s1">self</span><span class="s3">.</span><span class="s1">monotonic_cst</span><span class="s3">), </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__getstate__</span><span class="s3">())</span>

    <span class="s2">cdef </span><span class="s1">int init</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">object X</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">y</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:] </span><span class="s1">sample_weight</span><span class="s3">,</span>
        <span class="s1">const unsigned char</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">missing_values_in_feature_mask</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Initialize the splitter. 
 
        Take in the input data X, the target Y, and optional sample weights. 
 
        Returns -1 in case of failure to allocate memory (and raise MemoryError) 
        or 0 otherwise. 
 
        Parameters 
        ---------- 
        X : object 
            This contains the inputs. Usually it is a 2d numpy array. 
 
        y : ndarray, dtype=float64_t 
            This is the vector of targets, or true labels, for the samples represented 
            as a Cython memoryview. 
 
        sample_weight : ndarray, dtype=float64_t 
            The weights of the samples, where higher weighted samples are fit 
            closer than lower weight samples. If not provided, all samples 
            are assumed to have uniform weight. This is represented 
            as a Cython memoryview. 
 
        has_missing : bool 
            At least one missing values is in X. 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">rand_r_state </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">RAND_R_MAX</span><span class="s3">)</span>
        <span class="s2">cdef </span><span class="s1">intp_t n_samples </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

        <span class="s0"># Create a new array which will be used to store nonzero</span>
        <span class="s0"># samples from the feature of interest</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">samples </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s2">cdef </span><span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">samples </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">samples</span>

        <span class="s2">cdef </span><span class="s1">intp_t i</span><span class="s3">, </span><span class="s1">j</span>
        <span class="s2">cdef </span><span class="s1">float64_t weighted_n_samples </span><span class="s3">= </span><span class="s4">0.0</span>
        <span class="s1">j </span><span class="s3">= </span><span class="s4">0</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">):</span>
            <span class="s0"># Only work with positively weighted samples</span>
            <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is None or </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] != </span><span class="s4">0.0</span><span class="s3">:</span>
                <span class="s1">samples</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">i</span>
                <span class="s1">j </span><span class="s3">+= </span><span class="s4">1</span>

            <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">weighted_n_samples </span><span class="s3">+= </span><span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">weighted_n_samples </span><span class="s3">+= </span><span class="s4">1.0</span>

        <span class="s0"># Number of samples is number of positively weighted samples</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples </span><span class="s3">= </span><span class="s1">j</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_samples </span><span class="s3">= </span><span class="s1">weighted_n_samples</span>

        <span class="s2">cdef </span><span class="s1">intp_t n_features </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">features </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n_features</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_features </span><span class="s3">= </span><span class="s1">n_features</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">feature_values </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">constant_features </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n_features</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">y </span><span class="s3">= </span><span class="s1">y</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">sample_weight</span>
        <span class="s2">if </span><span class="s1">missing_values_in_feature_mask </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">init_sum_missing</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">cdef </span><span class="s1">int node_reset</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">intp_t start</span><span class="s3">,</span>
        <span class="s1">intp_t end</span><span class="s3">,</span>
        <span class="s1">float64_t</span><span class="s3">* </span><span class="s1">weighted_n_node_samples</span>
    <span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Reset splitter on node samples[start:end]. 
 
        Returns -1 in case of failure to allocate memory (and raise MemoryError) 
        or 0 otherwise. 
 
        Parameters 
        ---------- 
        start : intp_t 
            The index of the first sample to consider 
        end : intp_t 
            The index of the last sample to consider 
        weighted_n_node_samples : ndarray, dtype=float64_t pointer 
            The total weight of those samples 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">start </span><span class="s3">= </span><span class="s1">start</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">= </span><span class="s1">end</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">init</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">sample_weight</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">weighted_n_samples</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">samples</span><span class="s3">,</span>
            <span class="s1">start</span><span class="s3">,</span>
            <span class="s1">end</span>
        <span class="s3">)</span>

        <span class="s1">weighted_n_node_samples</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span>
        <span class="s2">return </span><span class="s4">0</span>

    <span class="s2">cdef </span><span class="s1">int node_split</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">ParentInfo</span><span class="s3">* </span><span class="s1">parent_record</span><span class="s3">,</span>
        <span class="s1">SplitRecord</span><span class="s3">* </span><span class="s1">split</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>

        <span class="s6">&quot;&quot;&quot;Find the best split on node samples[start:end]. 
 
        This is a placeholder method. The majority of computation will be done 
        here. 
 
        It should return -1 upon errors. 
        &quot;&quot;&quot;</span>

        <span class="s2">pass</span>

    <span class="s2">cdef </span><span class="s1">void node_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t</span><span class="s3">* </span><span class="s1">dest</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Copy the value of node samples[start:end] into dest.&quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">node_value</span><span class="s3">(</span><span class="s1">dest</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">inline void clip_node_value</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t</span><span class="s3">* </span><span class="s1">dest</span><span class="s3">, </span><span class="s1">float64_t lower_bound</span><span class="s3">, </span><span class="s1">float64_t upper_bound</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Clip the value in dest between lower_bound and upper_bound for monotonic constraints.&quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">clip_node_value</span><span class="s3">(</span><span class="s1">dest</span><span class="s3">, </span><span class="s1">lower_bound</span><span class="s3">, </span><span class="s1">upper_bound</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">float64_t node_impurity</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Return the impurity of the current node.&quot;&quot;&quot;</span>

        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">node_impurity</span><span class="s3">()</span>

<span class="s2">cdef </span><span class="s1">inline void shift_missing_values_to_left_if_required</span><span class="s3">(</span>
    <span class="s1">SplitRecord</span><span class="s3">* </span><span class="s1">best</span><span class="s3">,</span>
    <span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">samples</span><span class="s3">,</span>
    <span class="s1">intp_t end</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
    <span class="s6">&quot;&quot;&quot;Shift missing value sample indices to the left of the split if required. 
 
    Note: this should always be called at the very end because it will 
    move samples around, thereby affecting the criterion. 
    This affects the computation of the children impurity, which affects 
    the computation of the next node. 
    &quot;&quot;&quot;</span>
    <span class="s2">cdef </span><span class="s1">intp_t i</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">current_end</span>
    <span class="s0"># The partitioner partitions the data such that the missing values are in</span>
    <span class="s0"># samples[-n_missing:] for the criterion to consume. If the missing values</span>
    <span class="s0"># are going to the right node, then the missing values are already in the</span>
    <span class="s0"># correct position. If the missing values go left, then we move the missing</span>
    <span class="s0"># values to samples[best.pos:best.pos+n_missing] and update `best.pos`.</span>
    <span class="s2">if </span><span class="s1">best</span><span class="s3">.</span><span class="s1">n_missing </span><span class="s3">&gt; </span><span class="s4">0 </span><span class="s2">and </span><span class="s1">best</span><span class="s3">.</span><span class="s1">missing_go_to_left</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">best</span><span class="s3">.</span><span class="s1">n_missing</span><span class="s3">):</span>
            <span class="s1">i </span><span class="s3">= </span><span class="s1">best</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">+ </span><span class="s1">p</span>
            <span class="s1">current_end </span><span class="s3">= </span><span class="s1">end </span><span class="s3">- </span><span class="s4">1 </span><span class="s3">- </span><span class="s1">p</span>
            <span class="s1">samples</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">current_end</span><span class="s3">] = </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">current_end</span><span class="s3">], </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s1">best</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">+= </span><span class="s1">best</span><span class="s3">.</span><span class="s1">n_missing</span>

<span class="s0"># Introduce a fused-class to make it possible to share the split implementation</span>
<span class="s0"># between the dense and sparse cases in the node_split_best and node_split_random</span>
<span class="s0"># functions. The alternative would have been to use inheritance-based polymorphism</span>
<span class="s0"># but it would have resulted in a ~10% overall tree fitting performance</span>
<span class="s0"># degradation caused by the overhead frequent virtual method lookups.</span>
<span class="s2">ctypedef </span><span class="s1">fused Partitioner</span><span class="s3">:</span>
    <span class="s1">DensePartitioner</span>
    <span class="s1">SparsePartitioner</span>

<span class="s2">cdef </span><span class="s1">inline int node_split_best</span><span class="s3">(</span>
    <span class="s1">Splitter splitter</span><span class="s3">,</span>
    <span class="s1">Partitioner partitioner</span><span class="s3">,</span>
    <span class="s1">Criterion criterion</span><span class="s3">,</span>
    <span class="s1">SplitRecord</span><span class="s3">* </span><span class="s1">split</span><span class="s3">,</span>
    <span class="s1">ParentInfo</span><span class="s3">* </span><span class="s1">parent_record</span><span class="s3">,</span>
    <span class="s1">bint with_monotonic_cst</span><span class="s3">,</span>
    <span class="s1">const int8_t</span><span class="s3">[:] </span><span class="s1">monotonic_cst</span><span class="s3">,</span>
<span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
    <span class="s6">&quot;&quot;&quot;Find the best split on node samples[start:end] 
 
    Returns -1 in case of failure to allocate memory (and raise MemoryError) 
    or 0 otherwise. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Find the best split</span>
    <span class="s2">cdef </span><span class="s1">intp_t start </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">start</span>
    <span class="s2">cdef </span><span class="s1">intp_t end </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">end</span>
    <span class="s2">cdef </span><span class="s1">intp_t end_non_missing</span>
    <span class="s2">cdef </span><span class="s1">intp_t n_missing </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s2">cdef </span><span class="s1">bint has_missing </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s2">cdef </span><span class="s1">intp_t n_searches</span>
    <span class="s2">cdef </span><span class="s1">intp_t n_left</span><span class="s3">, </span><span class="s1">n_right</span>
    <span class="s2">cdef </span><span class="s1">bint missing_go_to_left</span>

    <span class="s2">cdef </span><span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">samples </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">samples</span>
    <span class="s2">cdef </span><span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">features </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">features</span>
    <span class="s2">cdef </span><span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">constant_features </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">constant_features</span>
    <span class="s2">cdef </span><span class="s1">intp_t n_features </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">n_features</span>

    <span class="s2">cdef </span><span class="s1">float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">feature_values </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">feature_values</span>
    <span class="s2">cdef </span><span class="s1">intp_t max_features </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">max_features</span>
    <span class="s2">cdef </span><span class="s1">intp_t min_samples_leaf </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">min_samples_leaf</span>
    <span class="s2">cdef </span><span class="s1">float64_t min_weight_leaf </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">min_weight_leaf</span>
    <span class="s2">cdef </span><span class="s1">uint32_t</span><span class="s3">* </span><span class="s1">random_state </span><span class="s3">= &amp;</span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">rand_r_state</span>

    <span class="s2">cdef </span><span class="s1">SplitRecord best_split</span><span class="s3">, </span><span class="s1">current_split</span>
    <span class="s2">cdef </span><span class="s1">float64_t current_proxy_improvement </span><span class="s3">= -</span><span class="s1">INFINITY</span>
    <span class="s2">cdef </span><span class="s1">float64_t best_proxy_improvement </span><span class="s3">= -</span><span class="s1">INFINITY</span>

    <span class="s2">cdef </span><span class="s1">float64_t impurity </span><span class="s3">= </span><span class="s1">parent_record</span><span class="s3">.</span><span class="s1">impurity</span>
    <span class="s2">cdef </span><span class="s1">float64_t lower_bound </span><span class="s3">= </span><span class="s1">parent_record</span><span class="s3">.</span><span class="s1">lower_bound</span>
    <span class="s2">cdef </span><span class="s1">float64_t upper_bound </span><span class="s3">= </span><span class="s1">parent_record</span><span class="s3">.</span><span class="s1">upper_bound</span>

    <span class="s2">cdef </span><span class="s1">intp_t f_i </span><span class="s3">= </span><span class="s1">n_features</span>
    <span class="s2">cdef </span><span class="s1">intp_t f_j</span>
    <span class="s2">cdef </span><span class="s1">intp_t p</span>
    <span class="s2">cdef </span><span class="s1">intp_t p_prev</span>

    <span class="s2">cdef </span><span class="s1">intp_t n_visited_features </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s0"># Number of features discovered to be constant during the split search</span>
    <span class="s2">cdef </span><span class="s1">intp_t n_found_constants </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s0"># Number of features known to be constant and drawn without replacement</span>
    <span class="s2">cdef </span><span class="s1">intp_t n_drawn_constants </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s2">cdef </span><span class="s1">intp_t n_known_constants </span><span class="s3">= </span><span class="s1">parent_record</span><span class="s3">.</span><span class="s1">n_constant_features</span>
    <span class="s0"># n_total_constants = n_known_constants + n_found_constants</span>
    <span class="s2">cdef </span><span class="s1">intp_t n_total_constants </span><span class="s3">= </span><span class="s1">n_known_constants</span>

    <span class="s1">_init_split</span><span class="s3">(&amp;</span><span class="s1">best_split</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>

    <span class="s1">partitioner</span><span class="s3">.</span><span class="s1">init_node_split</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>

    <span class="s0"># Sample up to max_features without replacement using a</span>
    <span class="s0"># Fisher-Yates-based algorithm (using the local variables `f_i` and</span>
    <span class="s0"># `f_j` to compute a permutation of the `features` array).</span>
    <span class="s0">#</span>
    <span class="s0"># Skip the CPU intensive evaluation of the impurity criterion for</span>
    <span class="s0"># features that were already detected as constant (hence not suitable</span>
    <span class="s0"># for good splitting) by ancestor nodes and save the information on</span>
    <span class="s0"># newly discovered constant features to spare computation on descendant</span>
    <span class="s0"># nodes.</span>
    <span class="s2">while </span><span class="s3">(</span><span class="s1">f_i </span><span class="s3">&gt; </span><span class="s1">n_total_constants </span><span class="s2">and  </span><span class="s0"># Stop early if remaining features</span>
                                        <span class="s0"># are constant</span>
            <span class="s3">(</span><span class="s1">n_visited_features </span><span class="s3">&lt; </span><span class="s1">max_features </span><span class="s2">or</span>
             <span class="s0"># At least one drawn features must be non constant</span>
             <span class="s1">n_visited_features </span><span class="s3">&lt;= </span><span class="s1">n_found_constants </span><span class="s3">+ </span><span class="s1">n_drawn_constants</span><span class="s3">)):</span>

        <span class="s1">n_visited_features </span><span class="s3">+= </span><span class="s4">1</span>

        <span class="s0"># Loop invariant: elements of features in</span>
        <span class="s0"># - [:n_drawn_constant[ holds drawn and known constant features;</span>
        <span class="s0"># - [n_drawn_constant:n_known_constant[ holds known constant</span>
        <span class="s0">#   features that haven't been drawn yet;</span>
        <span class="s0"># - [n_known_constant:n_total_constant[ holds newly found constant</span>
        <span class="s0">#   features;</span>
        <span class="s0"># - [n_total_constant:f_i[ holds features that haven't been drawn</span>
        <span class="s0">#   yet and aren't constant apriori.</span>
        <span class="s0"># - [f_i:n_features[ holds features that have been drawn</span>
        <span class="s0">#   and aren't constant.</span>

        <span class="s0"># Draw a feature at random</span>
        <span class="s1">f_j </span><span class="s3">= </span><span class="s1">rand_int</span><span class="s3">(</span><span class="s1">n_drawn_constants</span><span class="s3">, </span><span class="s1">f_i </span><span class="s3">- </span><span class="s1">n_found_constants</span><span class="s3">,</span>
                       <span class="s1">random_state</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">f_j </span><span class="s3">&lt; </span><span class="s1">n_known_constants</span><span class="s3">:</span>
            <span class="s0"># f_j in the interval [n_drawn_constants, n_known_constants[</span>
            <span class="s1">features</span><span class="s3">[</span><span class="s1">n_drawn_constants</span><span class="s3">], </span><span class="s1">features</span><span class="s3">[</span><span class="s1">f_j</span><span class="s3">] = </span><span class="s1">features</span><span class="s3">[</span><span class="s1">f_j</span><span class="s3">], </span><span class="s1">features</span><span class="s3">[</span><span class="s1">n_drawn_constants</span><span class="s3">]</span>

            <span class="s1">n_drawn_constants </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">continue</span>

        <span class="s0"># f_j in the interval [n_known_constants, f_i - n_found_constants[</span>
        <span class="s1">f_j </span><span class="s3">+= </span><span class="s1">n_found_constants</span>
        <span class="s0"># f_j in the interval [n_total_constants, f_i[</span>
        <span class="s1">current_split</span><span class="s3">.</span><span class="s1">feature </span><span class="s3">= </span><span class="s1">features</span><span class="s3">[</span><span class="s1">f_j</span><span class="s3">]</span>
        <span class="s1">partitioner</span><span class="s3">.</span><span class="s1">sort_samples_and_feature_values</span><span class="s3">(</span><span class="s1">current_split</span><span class="s3">.</span><span class="s1">feature</span><span class="s3">)</span>
        <span class="s1">n_missing </span><span class="s3">= </span><span class="s1">partitioner</span><span class="s3">.</span><span class="s1">n_missing</span>
        <span class="s1">end_non_missing </span><span class="s3">= </span><span class="s1">end </span><span class="s3">- </span><span class="s1">n_missing</span>

        <span class="s2">if </span><span class="s3">(</span>
            <span class="s0"># All values for this feature are missing, or</span>
            <span class="s1">end_non_missing </span><span class="s3">== </span><span class="s1">start </span><span class="s2">or</span>
            <span class="s0"># This feature is considered constant (max - min &lt;= FEATURE_THRESHOLD)</span>
            <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">end_non_missing </span><span class="s3">- </span><span class="s4">1</span><span class="s3">] &lt;= </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">start</span><span class="s3">] + </span><span class="s1">FEATURE_THRESHOLD</span>
        <span class="s3">):</span>
            <span class="s0"># We consider this feature constant in this case.</span>
            <span class="s0"># Since finding a split among constant feature is not valuable,</span>
            <span class="s0"># we do not consider this feature for splitting.</span>
            <span class="s1">features</span><span class="s3">[</span><span class="s1">f_j</span><span class="s3">], </span><span class="s1">features</span><span class="s3">[</span><span class="s1">n_total_constants</span><span class="s3">] = </span><span class="s1">features</span><span class="s3">[</span><span class="s1">n_total_constants</span><span class="s3">], </span><span class="s1">features</span><span class="s3">[</span><span class="s1">f_j</span><span class="s3">]</span>

            <span class="s1">n_found_constants </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s1">n_total_constants </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">continue</span>

        <span class="s1">f_i </span><span class="s3">-= </span><span class="s4">1</span>
        <span class="s1">features</span><span class="s3">[</span><span class="s1">f_i</span><span class="s3">], </span><span class="s1">features</span><span class="s3">[</span><span class="s1">f_j</span><span class="s3">] = </span><span class="s1">features</span><span class="s3">[</span><span class="s1">f_j</span><span class="s3">], </span><span class="s1">features</span><span class="s3">[</span><span class="s1">f_i</span><span class="s3">]</span>
        <span class="s1">has_missing </span><span class="s3">= </span><span class="s1">n_missing </span><span class="s3">!= </span><span class="s4">0</span>
        <span class="s1">criterion</span><span class="s3">.</span><span class="s1">init_missing</span><span class="s3">(</span><span class="s1">n_missing</span><span class="s3">)  </span><span class="s0"># initialize even when n_missing == 0</span>

        <span class="s0"># Evaluate all splits</span>

        <span class="s0"># If there are missing values, then we search twice for the most optimal split.</span>
        <span class="s0"># The first search will have all the missing values going to the right node.</span>
        <span class="s0"># The second search will have all the missing values going to the left node.</span>
        <span class="s0"># If there are no missing values, then we search only once for the most</span>
        <span class="s0"># optimal split.</span>
        <span class="s1">n_searches </span><span class="s3">= </span><span class="s4">2 </span><span class="s2">if </span><span class="s1">has_missing </span><span class="s2">else </span><span class="s4">1</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_searches</span><span class="s3">):</span>
            <span class="s1">missing_go_to_left </span><span class="s3">= </span><span class="s1">i </span><span class="s3">== </span><span class="s4">1</span>
            <span class="s1">criterion</span><span class="s3">.</span><span class="s1">missing_go_to_left </span><span class="s3">= </span><span class="s1">missing_go_to_left</span>
            <span class="s1">criterion</span><span class="s3">.</span><span class="s1">reset</span><span class="s3">()</span>

            <span class="s1">p </span><span class="s3">= </span><span class="s1">start</span>

            <span class="s2">while </span><span class="s1">p </span><span class="s3">&lt; </span><span class="s1">end_non_missing</span><span class="s3">:</span>
                <span class="s1">partitioner</span><span class="s3">.</span><span class="s1">next_p</span><span class="s3">(&amp;</span><span class="s1">p_prev</span><span class="s3">, &amp;</span><span class="s1">p</span><span class="s3">)</span>

                <span class="s2">if </span><span class="s1">p </span><span class="s3">&gt;= </span><span class="s1">end_non_missing</span><span class="s3">:</span>
                    <span class="s2">continue</span>

                <span class="s2">if </span><span class="s1">missing_go_to_left</span><span class="s3">:</span>
                    <span class="s1">n_left </span><span class="s3">= </span><span class="s1">p </span><span class="s3">- </span><span class="s1">start </span><span class="s3">+ </span><span class="s1">n_missing</span>
                    <span class="s1">n_right </span><span class="s3">= </span><span class="s1">end_non_missing </span><span class="s3">- </span><span class="s1">p</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">n_left </span><span class="s3">= </span><span class="s1">p </span><span class="s3">- </span><span class="s1">start</span>
                    <span class="s1">n_right </span><span class="s3">= </span><span class="s1">end_non_missing </span><span class="s3">- </span><span class="s1">p </span><span class="s3">+ </span><span class="s1">n_missing</span>

                <span class="s0"># Reject if min_samples_leaf is not guaranteed</span>
                <span class="s2">if </span><span class="s1">n_left </span><span class="s3">&lt; </span><span class="s1">min_samples_leaf </span><span class="s2">or </span><span class="s1">n_right </span><span class="s3">&lt; </span><span class="s1">min_samples_leaf</span><span class="s3">:</span>
                    <span class="s2">continue</span>

                <span class="s1">current_split</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">= </span><span class="s1">p</span>
                <span class="s1">criterion</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">current_split</span><span class="s3">.</span><span class="s1">pos</span><span class="s3">)</span>

                <span class="s0"># Reject if monotonicity constraints are not satisfied</span>
                <span class="s2">if </span><span class="s3">(</span>
                    <span class="s1">with_monotonic_cst </span><span class="s2">and</span>
                    <span class="s1">monotonic_cst</span><span class="s3">[</span><span class="s1">current_split</span><span class="s3">.</span><span class="s1">feature</span><span class="s3">] != </span><span class="s4">0 </span><span class="s2">and</span>
                    <span class="s2">not </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">check_monotonicity</span><span class="s3">(</span>
                        <span class="s1">monotonic_cst</span><span class="s3">[</span><span class="s1">current_split</span><span class="s3">.</span><span class="s1">feature</span><span class="s3">],</span>
                        <span class="s1">lower_bound</span><span class="s3">,</span>
                        <span class="s1">upper_bound</span><span class="s3">,</span>
                    <span class="s3">)</span>
                <span class="s3">):</span>
                    <span class="s2">continue</span>

                <span class="s0"># Reject if min_weight_leaf is not satisfied</span>
                <span class="s2">if </span><span class="s3">((</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">&lt; </span><span class="s1">min_weight_leaf</span><span class="s3">) </span><span class="s2">or</span>
                        <span class="s3">(</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">&lt; </span><span class="s1">min_weight_leaf</span><span class="s3">)):</span>
                    <span class="s2">continue</span>

                <span class="s1">current_proxy_improvement </span><span class="s3">= </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">proxy_impurity_improvement</span><span class="s3">()</span>

                <span class="s2">if </span><span class="s1">current_proxy_improvement </span><span class="s3">&gt; </span><span class="s1">best_proxy_improvement</span><span class="s3">:</span>
                    <span class="s1">best_proxy_improvement </span><span class="s3">= </span><span class="s1">current_proxy_improvement</span>
                    <span class="s0"># sum of halves is used to avoid infinite value</span>
                    <span class="s1">current_split</span><span class="s3">.</span><span class="s1">threshold </span><span class="s3">= (</span>
                        <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">p_prev</span><span class="s3">] / </span><span class="s4">2.0 </span><span class="s3">+ </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">p</span><span class="s3">] / </span><span class="s4">2.0</span>
                    <span class="s3">)</span>

                    <span class="s2">if </span><span class="s3">(</span>
                        <span class="s1">current_split</span><span class="s3">.</span><span class="s1">threshold </span><span class="s3">== </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">p</span><span class="s3">] </span><span class="s2">or</span>
                        <span class="s1">current_split</span><span class="s3">.</span><span class="s1">threshold </span><span class="s3">== </span><span class="s1">INFINITY </span><span class="s2">or</span>
                        <span class="s1">current_split</span><span class="s3">.</span><span class="s1">threshold </span><span class="s3">== -</span><span class="s1">INFINITY</span>
                    <span class="s3">):</span>
                        <span class="s1">current_split</span><span class="s3">.</span><span class="s1">threshold </span><span class="s3">= </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">p_prev</span><span class="s3">]</span>

                    <span class="s1">current_split</span><span class="s3">.</span><span class="s1">n_missing </span><span class="s3">= </span><span class="s1">n_missing</span>
                    <span class="s2">if </span><span class="s1">n_missing </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
                        <span class="s1">current_split</span><span class="s3">.</span><span class="s1">missing_go_to_left </span><span class="s3">= </span><span class="s1">n_left </span><span class="s3">&gt; </span><span class="s1">n_right</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">current_split</span><span class="s3">.</span><span class="s1">missing_go_to_left </span><span class="s3">= </span><span class="s1">missing_go_to_left</span>

                    <span class="s1">best_split </span><span class="s3">= </span><span class="s1">current_split  </span><span class="s0"># copy</span>

        <span class="s0"># Evaluate when there are missing values and all missing values goes</span>
        <span class="s0"># to the right node and non-missing values goes to the left node.</span>
        <span class="s2">if </span><span class="s1">has_missing</span><span class="s3">:</span>
            <span class="s1">n_left</span><span class="s3">, </span><span class="s1">n_right </span><span class="s3">= </span><span class="s1">end </span><span class="s3">- </span><span class="s1">start </span><span class="s3">- </span><span class="s1">n_missing</span><span class="s3">, </span><span class="s1">n_missing</span>
            <span class="s1">p </span><span class="s3">= </span><span class="s1">end </span><span class="s3">- </span><span class="s1">n_missing</span>
            <span class="s1">missing_go_to_left </span><span class="s3">= </span><span class="s4">0</span>

            <span class="s2">if not </span><span class="s3">(</span><span class="s1">n_left </span><span class="s3">&lt; </span><span class="s1">min_samples_leaf </span><span class="s2">or </span><span class="s1">n_right </span><span class="s3">&lt; </span><span class="s1">min_samples_leaf</span><span class="s3">):</span>
                <span class="s1">criterion</span><span class="s3">.</span><span class="s1">missing_go_to_left </span><span class="s3">= </span><span class="s1">missing_go_to_left</span>
                <span class="s1">criterion</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>

                <span class="s2">if not </span><span class="s3">((</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">&lt; </span><span class="s1">min_weight_leaf</span><span class="s3">) </span><span class="s2">or</span>
                        <span class="s3">(</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">&lt; </span><span class="s1">min_weight_leaf</span><span class="s3">)):</span>
                    <span class="s1">current_proxy_improvement </span><span class="s3">= </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">proxy_impurity_improvement</span><span class="s3">()</span>

                    <span class="s2">if </span><span class="s1">current_proxy_improvement </span><span class="s3">&gt; </span><span class="s1">best_proxy_improvement</span><span class="s3">:</span>
                        <span class="s1">best_proxy_improvement </span><span class="s3">= </span><span class="s1">current_proxy_improvement</span>
                        <span class="s1">current_split</span><span class="s3">.</span><span class="s1">threshold </span><span class="s3">= </span><span class="s1">INFINITY</span>
                        <span class="s1">current_split</span><span class="s3">.</span><span class="s1">missing_go_to_left </span><span class="s3">= </span><span class="s1">missing_go_to_left</span>
                        <span class="s1">current_split</span><span class="s3">.</span><span class="s1">n_missing </span><span class="s3">= </span><span class="s1">n_missing</span>
                        <span class="s1">current_split</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">= </span><span class="s1">p</span>
                        <span class="s1">best_split </span><span class="s3">= </span><span class="s1">current_split</span>

    <span class="s0"># Reorganize into samples[start:best_split.pos] + samples[best_split.pos:end]</span>
    <span class="s2">if </span><span class="s1">best_split</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">&lt; </span><span class="s1">end</span><span class="s3">:</span>
        <span class="s1">partitioner</span><span class="s3">.</span><span class="s1">partition_samples_final</span><span class="s3">(</span>
            <span class="s1">best_split</span><span class="s3">.</span><span class="s1">pos</span><span class="s3">,</span>
            <span class="s1">best_split</span><span class="s3">.</span><span class="s1">threshold</span><span class="s3">,</span>
            <span class="s1">best_split</span><span class="s3">.</span><span class="s1">feature</span><span class="s3">,</span>
            <span class="s1">best_split</span><span class="s3">.</span><span class="s1">n_missing</span>
        <span class="s3">)</span>
        <span class="s1">criterion</span><span class="s3">.</span><span class="s1">init_missing</span><span class="s3">(</span><span class="s1">best_split</span><span class="s3">.</span><span class="s1">n_missing</span><span class="s3">)</span>
        <span class="s1">criterion</span><span class="s3">.</span><span class="s1">missing_go_to_left </span><span class="s3">= </span><span class="s1">best_split</span><span class="s3">.</span><span class="s1">missing_go_to_left</span>

        <span class="s1">criterion</span><span class="s3">.</span><span class="s1">reset</span><span class="s3">()</span>
        <span class="s1">criterion</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">best_split</span><span class="s3">.</span><span class="s1">pos</span><span class="s3">)</span>
        <span class="s1">criterion</span><span class="s3">.</span><span class="s1">children_impurity</span><span class="s3">(</span>
            <span class="s3">&amp;</span><span class="s1">best_split</span><span class="s3">.</span><span class="s1">impurity_left</span><span class="s3">, &amp;</span><span class="s1">best_split</span><span class="s3">.</span><span class="s1">impurity_right</span>
        <span class="s3">)</span>
        <span class="s1">best_split</span><span class="s3">.</span><span class="s1">improvement </span><span class="s3">= </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">impurity_improvement</span><span class="s3">(</span>
            <span class="s1">impurity</span><span class="s3">,</span>
            <span class="s1">best_split</span><span class="s3">.</span><span class="s1">impurity_left</span><span class="s3">,</span>
            <span class="s1">best_split</span><span class="s3">.</span><span class="s1">impurity_right</span>
        <span class="s3">)</span>

        <span class="s1">shift_missing_values_to_left_if_required</span><span class="s3">(&amp;</span><span class="s1">best_split</span><span class="s3">, </span><span class="s1">samples</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>

    <span class="s0"># Respect invariant for constant features: the original order of</span>
    <span class="s0"># element in features[:n_known_constants] must be preserved for sibling</span>
    <span class="s0"># and child nodes</span>
    <span class="s1">memcpy</span><span class="s3">(&amp;</span><span class="s1">features</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], &amp;</span><span class="s1">constant_features</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">intp_t</span><span class="s3">) * </span><span class="s1">n_known_constants</span><span class="s3">)</span>

    <span class="s0"># Copy newly found constant features</span>
    <span class="s1">memcpy</span><span class="s3">(&amp;</span><span class="s1">constant_features</span><span class="s3">[</span><span class="s1">n_known_constants</span><span class="s3">],</span>
           <span class="s3">&amp;</span><span class="s1">features</span><span class="s3">[</span><span class="s1">n_known_constants</span><span class="s3">],</span>
           <span class="s1">sizeof</span><span class="s3">(</span><span class="s1">intp_t</span><span class="s3">) * </span><span class="s1">n_found_constants</span><span class="s3">)</span>

    <span class="s0"># Return values</span>
    <span class="s1">parent_record</span><span class="s3">.</span><span class="s1">n_constant_features </span><span class="s3">= </span><span class="s1">n_total_constants</span>
    <span class="s1">split</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">best_split</span>
    <span class="s2">return </span><span class="s4">0</span>


<span class="s0"># Sort n-element arrays pointed to by feature_values and samples, simultaneously,</span>
<span class="s0"># by the values in feature_values. Algorithm: Introsort (Musser, SP&amp;E, 1997).</span>
<span class="s2">cdef </span><span class="s1">inline void sort</span><span class="s3">(</span><span class="s1">float32_t</span><span class="s3">* </span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">* </span><span class="s1">samples</span><span class="s3">, </span><span class="s1">intp_t n</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
    <span class="s2">if </span><span class="s1">n </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">return</span>
    <span class="s2">cdef </span><span class="s1">intp_t maxd </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">* &lt;</span><span class="s1">intp_t</span><span class="s3">&gt;</span><span class="s1">log</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">introsort</span><span class="s3">(</span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">samples</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">maxd</span><span class="s3">)</span>


<span class="s2">cdef </span><span class="s1">inline void swap</span><span class="s3">(</span><span class="s1">float32_t</span><span class="s3">* </span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">* </span><span class="s1">samples</span><span class="s3">,</span>
                      <span class="s1">intp_t i</span><span class="s3">, </span><span class="s1">intp_t j</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
    <span class="s0"># Helper for sort</span>
    <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">j</span><span class="s3">], </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
    <span class="s1">samples</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">j</span><span class="s3">], </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>


<span class="s2">cdef </span><span class="s1">inline float32_t median3</span><span class="s3">(</span><span class="s1">float32_t</span><span class="s3">* </span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">intp_t n</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
    <span class="s0"># Median of three pivot selection, after Bentley and McIlroy (1993).</span>
    <span class="s0"># Engineering a sort function. SP&amp;E. Requires 8/3 comparisons on average.</span>
    <span class="s2">cdef </span><span class="s1">float32_t a </span><span class="s3">= </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">b </span><span class="s3">= </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">n </span><span class="s3">/ </span><span class="s4">2</span><span class="s3">], </span><span class="s1">c </span><span class="s3">= </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">n </span><span class="s3">- </span><span class="s4">1</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">a </span><span class="s3">&lt; </span><span class="s1">b</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">b </span><span class="s3">&lt; </span><span class="s1">c</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">b</span>
        <span class="s2">elif </span><span class="s1">a </span><span class="s3">&lt; </span><span class="s1">c</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">c</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">a</span>
    <span class="s2">elif </span><span class="s1">b </span><span class="s3">&lt; </span><span class="s1">c</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">a </span><span class="s3">&lt; </span><span class="s1">c</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">a</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">c</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">b</span>


<span class="s0"># Introsort with median of 3 pivot selection and 3-way partition function</span>
<span class="s0"># (robust to repeated elements, e.g. lots of zero features).</span>
<span class="s2">cdef </span><span class="s1">void introsort</span><span class="s3">(</span><span class="s1">float32_t</span><span class="s3">* </span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">intp_t </span><span class="s3">*</span><span class="s1">samples</span><span class="s3">,</span>
                    <span class="s1">intp_t n</span><span class="s3">, </span><span class="s1">intp_t maxd</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
    <span class="s2">cdef </span><span class="s1">float32_t pivot</span>
    <span class="s2">cdef </span><span class="s1">intp_t i</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">r</span>

    <span class="s2">while </span><span class="s1">n </span><span class="s3">&gt; </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">maxd </span><span class="s3">&lt;= </span><span class="s4">0</span><span class="s3">:   </span><span class="s0"># max depth limit exceeded (&quot;gone quadratic&quot;)</span>
            <span class="s1">heapsort</span><span class="s3">(</span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">samples</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
            <span class="s2">return</span>
        <span class="s1">maxd </span><span class="s3">-= </span><span class="s4">1</span>

        <span class="s1">pivot </span><span class="s3">= </span><span class="s1">median3</span><span class="s3">(</span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>

        <span class="s0"># Three-way partition.</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s1">l </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">r </span><span class="s3">= </span><span class="s1">n</span>
        <span class="s2">while </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">r</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &lt; </span><span class="s1">pivot</span><span class="s3">:</span>
                <span class="s1">swap</span><span class="s3">(</span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">samples</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">l</span><span class="s3">)</span>
                <span class="s1">i </span><span class="s3">+= </span><span class="s4">1</span>
                <span class="s1">l </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">elif </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &gt; </span><span class="s1">pivot</span><span class="s3">:</span>
                <span class="s1">r </span><span class="s3">-= </span><span class="s4">1</span>
                <span class="s1">swap</span><span class="s3">(</span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">samples</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">r</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">i </span><span class="s3">+= </span><span class="s4">1</span>

        <span class="s1">introsort</span><span class="s3">(</span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">samples</span><span class="s3">, </span><span class="s1">l</span><span class="s3">, </span><span class="s1">maxd</span><span class="s3">)</span>
        <span class="s1">feature_values </span><span class="s3">+= </span><span class="s1">r</span>
        <span class="s1">samples </span><span class="s3">+= </span><span class="s1">r</span>
        <span class="s1">n </span><span class="s3">-= </span><span class="s1">r</span>


<span class="s2">cdef </span><span class="s1">inline void sift_down</span><span class="s3">(</span><span class="s1">float32_t</span><span class="s3">* </span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">* </span><span class="s1">samples</span><span class="s3">,</span>
                           <span class="s1">intp_t start</span><span class="s3">, </span><span class="s1">intp_t end</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
    <span class="s0"># Restore heap order in feature_values[start:end] by moving the max element to start.</span>
    <span class="s2">cdef </span><span class="s1">intp_t child</span><span class="s3">, </span><span class="s1">maxind</span><span class="s3">, </span><span class="s1">root</span>

    <span class="s1">root </span><span class="s3">= </span><span class="s1">start</span>
    <span class="s2">while True</span><span class="s3">:</span>
        <span class="s1">child </span><span class="s3">= </span><span class="s1">root </span><span class="s3">* </span><span class="s4">2 </span><span class="s3">+ </span><span class="s4">1</span>

        <span class="s0"># find max of root, left child, right child</span>
        <span class="s1">maxind </span><span class="s3">= </span><span class="s1">root</span>
        <span class="s2">if </span><span class="s1">child </span><span class="s3">&lt; </span><span class="s1">end </span><span class="s2">and </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">maxind</span><span class="s3">] &lt; </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">child</span><span class="s3">]:</span>
            <span class="s1">maxind </span><span class="s3">= </span><span class="s1">child</span>
        <span class="s2">if </span><span class="s1">child </span><span class="s3">+ </span><span class="s4">1 </span><span class="s3">&lt; </span><span class="s1">end </span><span class="s2">and </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">maxind</span><span class="s3">] &lt; </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">child </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">]:</span>
            <span class="s1">maxind </span><span class="s3">= </span><span class="s1">child </span><span class="s3">+ </span><span class="s4">1</span>

        <span class="s2">if </span><span class="s1">maxind </span><span class="s3">== </span><span class="s1">root</span><span class="s3">:</span>
            <span class="s2">break</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">swap</span><span class="s3">(</span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">samples</span><span class="s3">, </span><span class="s1">root</span><span class="s3">, </span><span class="s1">maxind</span><span class="s3">)</span>
            <span class="s1">root </span><span class="s3">= </span><span class="s1">maxind</span>


<span class="s2">cdef </span><span class="s1">void heapsort</span><span class="s3">(</span><span class="s1">float32_t</span><span class="s3">* </span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">* </span><span class="s1">samples</span><span class="s3">, </span><span class="s1">intp_t n</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
    <span class="s2">cdef </span><span class="s1">intp_t start</span><span class="s3">, </span><span class="s1">end</span>

    <span class="s0"># heapify</span>
    <span class="s1">start </span><span class="s3">= (</span><span class="s1">n </span><span class="s3">- </span><span class="s4">2</span><span class="s3">) / </span><span class="s4">2</span>
    <span class="s1">end </span><span class="s3">= </span><span class="s1">n</span>
    <span class="s2">while True</span><span class="s3">:</span>
        <span class="s1">sift_down</span><span class="s3">(</span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">samples</span><span class="s3">, </span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">start </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s2">break</span>
        <span class="s1">start </span><span class="s3">-= </span><span class="s4">1</span>

    <span class="s0"># sort by shrinking the heap, putting the max element immediately after it</span>
    <span class="s1">end </span><span class="s3">= </span><span class="s1">n </span><span class="s3">- </span><span class="s4">1</span>
    <span class="s2">while </span><span class="s1">end </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s1">swap</span><span class="s3">(</span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">samples</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>
        <span class="s1">sift_down</span><span class="s3">(</span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">samples</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>
        <span class="s1">end </span><span class="s3">= </span><span class="s1">end </span><span class="s3">- </span><span class="s4">1</span>

<span class="s2">cdef </span><span class="s1">inline int node_split_random</span><span class="s3">(</span>
    <span class="s1">Splitter splitter</span><span class="s3">,</span>
    <span class="s1">Partitioner partitioner</span><span class="s3">,</span>
    <span class="s1">Criterion criterion</span><span class="s3">,</span>
    <span class="s1">SplitRecord</span><span class="s3">* </span><span class="s1">split</span><span class="s3">,</span>
    <span class="s1">ParentInfo</span><span class="s3">* </span><span class="s1">parent_record</span><span class="s3">,</span>
    <span class="s1">bint with_monotonic_cst</span><span class="s3">,</span>
    <span class="s1">const int8_t</span><span class="s3">[:] </span><span class="s1">monotonic_cst</span><span class="s3">,</span>
<span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
    <span class="s6">&quot;&quot;&quot;Find the best random split on node samples[start:end] 
 
    Returns -1 in case of failure to allocate memory (and raise MemoryError) 
    or 0 otherwise. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Draw random splits and pick the best</span>
    <span class="s2">cdef </span><span class="s1">intp_t start </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">start</span>
    <span class="s2">cdef </span><span class="s1">intp_t end </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">end</span>

    <span class="s2">cdef </span><span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">features </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">features</span>
    <span class="s2">cdef </span><span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">constant_features </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">constant_features</span>
    <span class="s2">cdef </span><span class="s1">intp_t n_features </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">n_features</span>

    <span class="s2">cdef </span><span class="s1">intp_t max_features </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">max_features</span>
    <span class="s2">cdef </span><span class="s1">intp_t min_samples_leaf </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">min_samples_leaf</span>
    <span class="s2">cdef </span><span class="s1">float64_t min_weight_leaf </span><span class="s3">= </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">min_weight_leaf</span>
    <span class="s2">cdef </span><span class="s1">uint32_t</span><span class="s3">* </span><span class="s1">random_state </span><span class="s3">= &amp;</span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">rand_r_state</span>

    <span class="s2">cdef </span><span class="s1">SplitRecord best_split</span><span class="s3">, </span><span class="s1">current_split</span>
    <span class="s2">cdef </span><span class="s1">float64_t current_proxy_improvement </span><span class="s3">= - </span><span class="s1">INFINITY</span>
    <span class="s2">cdef </span><span class="s1">float64_t best_proxy_improvement </span><span class="s3">= - </span><span class="s1">INFINITY</span>

    <span class="s2">cdef </span><span class="s1">float64_t impurity </span><span class="s3">= </span><span class="s1">parent_record</span><span class="s3">.</span><span class="s1">impurity</span>
    <span class="s2">cdef </span><span class="s1">float64_t lower_bound </span><span class="s3">= </span><span class="s1">parent_record</span><span class="s3">.</span><span class="s1">lower_bound</span>
    <span class="s2">cdef </span><span class="s1">float64_t upper_bound </span><span class="s3">= </span><span class="s1">parent_record</span><span class="s3">.</span><span class="s1">upper_bound</span>

    <span class="s2">cdef </span><span class="s1">intp_t f_i </span><span class="s3">= </span><span class="s1">n_features</span>
    <span class="s2">cdef </span><span class="s1">intp_t f_j</span>
    <span class="s0"># Number of features discovered to be constant during the split search</span>
    <span class="s2">cdef </span><span class="s1">intp_t n_found_constants </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s0"># Number of features known to be constant and drawn without replacement</span>
    <span class="s2">cdef </span><span class="s1">intp_t n_drawn_constants </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s2">cdef </span><span class="s1">intp_t n_known_constants </span><span class="s3">= </span><span class="s1">parent_record</span><span class="s3">.</span><span class="s1">n_constant_features</span>
    <span class="s0"># n_total_constants = n_known_constants + n_found_constants</span>
    <span class="s2">cdef </span><span class="s1">intp_t n_total_constants </span><span class="s3">= </span><span class="s1">n_known_constants</span>
    <span class="s2">cdef </span><span class="s1">intp_t n_visited_features </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s2">cdef </span><span class="s1">float32_t min_feature_value</span>
    <span class="s2">cdef </span><span class="s1">float32_t max_feature_value</span>

    <span class="s1">_init_split</span><span class="s3">(&amp;</span><span class="s1">best_split</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>

    <span class="s1">partitioner</span><span class="s3">.</span><span class="s1">init_node_split</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">)</span>

    <span class="s0"># Sample up to max_features without replacement using a</span>
    <span class="s0"># Fisher-Yates-based algorithm (using the local variables `f_i` and</span>
    <span class="s0"># `f_j` to compute a permutation of the `features` array).</span>
    <span class="s0">#</span>
    <span class="s0"># Skip the CPU intensive evaluation of the impurity criterion for</span>
    <span class="s0"># features that were already detected as constant (hence not suitable</span>
    <span class="s0"># for good splitting) by ancestor nodes and save the information on</span>
    <span class="s0"># newly discovered constant features to spare computation on descendant</span>
    <span class="s0"># nodes.</span>
    <span class="s2">while </span><span class="s3">(</span><span class="s1">f_i </span><span class="s3">&gt; </span><span class="s1">n_total_constants </span><span class="s2">and  </span><span class="s0"># Stop early if remaining features</span>
                                        <span class="s0"># are constant</span>
            <span class="s3">(</span><span class="s1">n_visited_features </span><span class="s3">&lt; </span><span class="s1">max_features </span><span class="s2">or</span>
             <span class="s0"># At least one drawn features must be non constant</span>
             <span class="s1">n_visited_features </span><span class="s3">&lt;= </span><span class="s1">n_found_constants </span><span class="s3">+ </span><span class="s1">n_drawn_constants</span><span class="s3">)):</span>
        <span class="s1">n_visited_features </span><span class="s3">+= </span><span class="s4">1</span>

        <span class="s0"># Loop invariant: elements of features in</span>
        <span class="s0"># - [:n_drawn_constant[ holds drawn and known constant features;</span>
        <span class="s0"># - [n_drawn_constant:n_known_constant[ holds known constant</span>
        <span class="s0">#   features that haven't been drawn yet;</span>
        <span class="s0"># - [n_known_constant:n_total_constant[ holds newly found constant</span>
        <span class="s0">#   features;</span>
        <span class="s0"># - [n_total_constant:f_i[ holds features that haven't been drawn</span>
        <span class="s0">#   yet and aren't constant apriori.</span>
        <span class="s0"># - [f_i:n_features[ holds features that have been drawn</span>
        <span class="s0">#   and aren't constant.</span>

        <span class="s0"># Draw a feature at random</span>
        <span class="s1">f_j </span><span class="s3">= </span><span class="s1">rand_int</span><span class="s3">(</span><span class="s1">n_drawn_constants</span><span class="s3">, </span><span class="s1">f_i </span><span class="s3">- </span><span class="s1">n_found_constants</span><span class="s3">,</span>
                       <span class="s1">random_state</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">f_j </span><span class="s3">&lt; </span><span class="s1">n_known_constants</span><span class="s3">:</span>
            <span class="s0"># f_j in the interval [n_drawn_constants, n_known_constants[</span>
            <span class="s1">features</span><span class="s3">[</span><span class="s1">n_drawn_constants</span><span class="s3">], </span><span class="s1">features</span><span class="s3">[</span><span class="s1">f_j</span><span class="s3">] = </span><span class="s1">features</span><span class="s3">[</span><span class="s1">f_j</span><span class="s3">], </span><span class="s1">features</span><span class="s3">[</span><span class="s1">n_drawn_constants</span><span class="s3">]</span>
            <span class="s1">n_drawn_constants </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">continue</span>

        <span class="s0"># f_j in the interval [n_known_constants, f_i - n_found_constants[</span>
        <span class="s1">f_j </span><span class="s3">+= </span><span class="s1">n_found_constants</span>
        <span class="s0"># f_j in the interval [n_total_constants, f_i[</span>

        <span class="s1">current_split</span><span class="s3">.</span><span class="s1">feature </span><span class="s3">= </span><span class="s1">features</span><span class="s3">[</span><span class="s1">f_j</span><span class="s3">]</span>

        <span class="s0"># Find min, max</span>
        <span class="s1">partitioner</span><span class="s3">.</span><span class="s1">find_min_max</span><span class="s3">(</span>
            <span class="s1">current_split</span><span class="s3">.</span><span class="s1">feature</span><span class="s3">, &amp;</span><span class="s1">min_feature_value</span><span class="s3">, &amp;</span><span class="s1">max_feature_value</span>
        <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">max_feature_value </span><span class="s3">&lt;= </span><span class="s1">min_feature_value </span><span class="s3">+ </span><span class="s1">FEATURE_THRESHOLD</span><span class="s3">:</span>
            <span class="s1">features</span><span class="s3">[</span><span class="s1">f_j</span><span class="s3">], </span><span class="s1">features</span><span class="s3">[</span><span class="s1">n_total_constants</span><span class="s3">] = </span><span class="s1">features</span><span class="s3">[</span><span class="s1">n_total_constants</span><span class="s3">], </span><span class="s1">current_split</span><span class="s3">.</span><span class="s1">feature</span>

            <span class="s1">n_found_constants </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s1">n_total_constants </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">continue</span>

        <span class="s1">f_i </span><span class="s3">-= </span><span class="s4">1</span>
        <span class="s1">features</span><span class="s3">[</span><span class="s1">f_i</span><span class="s3">], </span><span class="s1">features</span><span class="s3">[</span><span class="s1">f_j</span><span class="s3">] = </span><span class="s1">features</span><span class="s3">[</span><span class="s1">f_j</span><span class="s3">], </span><span class="s1">features</span><span class="s3">[</span><span class="s1">f_i</span><span class="s3">]</span>

        <span class="s0"># Draw a random threshold</span>
        <span class="s1">current_split</span><span class="s3">.</span><span class="s1">threshold </span><span class="s3">= </span><span class="s1">rand_uniform</span><span class="s3">(</span>
            <span class="s1">min_feature_value</span><span class="s3">,</span>
            <span class="s1">max_feature_value</span><span class="s3">,</span>
            <span class="s1">random_state</span><span class="s3">,</span>
        <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">current_split</span><span class="s3">.</span><span class="s1">threshold </span><span class="s3">== </span><span class="s1">max_feature_value</span><span class="s3">:</span>
            <span class="s1">current_split</span><span class="s3">.</span><span class="s1">threshold </span><span class="s3">= </span><span class="s1">min_feature_value</span>

        <span class="s0"># Partition</span>
        <span class="s1">current_split</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">= </span><span class="s1">partitioner</span><span class="s3">.</span><span class="s1">partition_samples</span><span class="s3">(</span><span class="s1">current_split</span><span class="s3">.</span><span class="s1">threshold</span><span class="s3">)</span>

        <span class="s0"># Reject if min_samples_leaf is not guaranteed</span>
        <span class="s2">if </span><span class="s3">(((</span><span class="s1">current_split</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">- </span><span class="s1">start</span><span class="s3">) &lt; </span><span class="s1">min_samples_leaf</span><span class="s3">) </span><span class="s2">or</span>
                <span class="s3">((</span><span class="s1">end </span><span class="s3">- </span><span class="s1">current_split</span><span class="s3">.</span><span class="s1">pos</span><span class="s3">) &lt; </span><span class="s1">min_samples_leaf</span><span class="s3">)):</span>
            <span class="s2">continue</span>

        <span class="s0"># Evaluate split</span>
        <span class="s0"># At this point, the criterion has a view into the samples that was partitioned</span>
        <span class="s0"># by the partitioner. The criterion will use the partition to evaluating the split.</span>
        <span class="s1">criterion</span><span class="s3">.</span><span class="s1">reset</span><span class="s3">()</span>
        <span class="s1">criterion</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">current_split</span><span class="s3">.</span><span class="s1">pos</span><span class="s3">)</span>

        <span class="s0"># Reject if min_weight_leaf is not satisfied</span>
        <span class="s2">if </span><span class="s3">((</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">weighted_n_left </span><span class="s3">&lt; </span><span class="s1">min_weight_leaf</span><span class="s3">) </span><span class="s2">or</span>
                <span class="s3">(</span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">weighted_n_right </span><span class="s3">&lt; </span><span class="s1">min_weight_leaf</span><span class="s3">)):</span>
            <span class="s2">continue</span>

        <span class="s0"># Reject if monotonicity constraints are not satisfied</span>
        <span class="s2">if </span><span class="s3">(</span>
                <span class="s1">with_monotonic_cst </span><span class="s2">and</span>
                <span class="s1">monotonic_cst</span><span class="s3">[</span><span class="s1">current_split</span><span class="s3">.</span><span class="s1">feature</span><span class="s3">] != </span><span class="s4">0 </span><span class="s2">and</span>
                <span class="s2">not </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">check_monotonicity</span><span class="s3">(</span>
                    <span class="s1">monotonic_cst</span><span class="s3">[</span><span class="s1">current_split</span><span class="s3">.</span><span class="s1">feature</span><span class="s3">],</span>
                    <span class="s1">lower_bound</span><span class="s3">,</span>
                    <span class="s1">upper_bound</span><span class="s3">,</span>
                <span class="s3">)</span>
        <span class="s3">):</span>
            <span class="s2">continue</span>

        <span class="s1">current_proxy_improvement </span><span class="s3">= </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">proxy_impurity_improvement</span><span class="s3">()</span>

        <span class="s2">if </span><span class="s1">current_proxy_improvement </span><span class="s3">&gt; </span><span class="s1">best_proxy_improvement</span><span class="s3">:</span>
            <span class="s1">best_proxy_improvement </span><span class="s3">= </span><span class="s1">current_proxy_improvement</span>
            <span class="s1">best_split </span><span class="s3">= </span><span class="s1">current_split  </span><span class="s0"># copy</span>

    <span class="s0"># Reorganize into samples[start:best.pos] + samples[best.pos:end]</span>
    <span class="s2">if </span><span class="s1">best_split</span><span class="s3">.</span><span class="s1">pos </span><span class="s3">&lt; </span><span class="s1">end</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">current_split</span><span class="s3">.</span><span class="s1">feature </span><span class="s3">!= </span><span class="s1">best_split</span><span class="s3">.</span><span class="s1">feature</span><span class="s3">:</span>
            <span class="s0"># TODO: Pass in best.n_missing when random splitter supports missing values.</span>
            <span class="s1">partitioner</span><span class="s3">.</span><span class="s1">partition_samples_final</span><span class="s3">(</span>
                <span class="s1">best_split</span><span class="s3">.</span><span class="s1">pos</span><span class="s3">, </span><span class="s1">best_split</span><span class="s3">.</span><span class="s1">threshold</span><span class="s3">, </span><span class="s1">best_split</span><span class="s3">.</span><span class="s1">feature</span><span class="s3">, </span><span class="s4">0</span>
            <span class="s3">)</span>

        <span class="s1">criterion</span><span class="s3">.</span><span class="s1">reset</span><span class="s3">()</span>
        <span class="s1">criterion</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">best_split</span><span class="s3">.</span><span class="s1">pos</span><span class="s3">)</span>
        <span class="s1">criterion</span><span class="s3">.</span><span class="s1">children_impurity</span><span class="s3">(</span>
            <span class="s3">&amp;</span><span class="s1">best_split</span><span class="s3">.</span><span class="s1">impurity_left</span><span class="s3">, &amp;</span><span class="s1">best_split</span><span class="s3">.</span><span class="s1">impurity_right</span>
        <span class="s3">)</span>
        <span class="s1">best_split</span><span class="s3">.</span><span class="s1">improvement </span><span class="s3">= </span><span class="s1">criterion</span><span class="s3">.</span><span class="s1">impurity_improvement</span><span class="s3">(</span>
            <span class="s1">impurity</span><span class="s3">, </span><span class="s1">best_split</span><span class="s3">.</span><span class="s1">impurity_left</span><span class="s3">, </span><span class="s1">best_split</span><span class="s3">.</span><span class="s1">impurity_right</span>
        <span class="s3">)</span>

    <span class="s0"># Respect invariant for constant features: the original order of</span>
    <span class="s0"># element in features[:n_known_constants] must be preserved for sibling</span>
    <span class="s0"># and child nodes</span>
    <span class="s1">memcpy</span><span class="s3">(&amp;</span><span class="s1">features</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], &amp;</span><span class="s1">constant_features</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">intp_t</span><span class="s3">) * </span><span class="s1">n_known_constants</span><span class="s3">)</span>

    <span class="s0"># Copy newly found constant features</span>
    <span class="s1">memcpy</span><span class="s3">(&amp;</span><span class="s1">constant_features</span><span class="s3">[</span><span class="s1">n_known_constants</span><span class="s3">],</span>
           <span class="s3">&amp;</span><span class="s1">features</span><span class="s3">[</span><span class="s1">n_known_constants</span><span class="s3">],</span>
           <span class="s1">sizeof</span><span class="s3">(</span><span class="s1">intp_t</span><span class="s3">) * </span><span class="s1">n_found_constants</span><span class="s3">)</span>

    <span class="s0"># Return values</span>
    <span class="s1">parent_record</span><span class="s3">.</span><span class="s1">n_constant_features </span><span class="s3">= </span><span class="s1">n_total_constants</span>
    <span class="s1">split</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">best_split</span>
    <span class="s2">return </span><span class="s4">0</span>


<span class="s3">@</span><span class="s1">final</span>
<span class="s2">cdef class </span><span class="s1">DensePartitioner</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot;Partitioner specialized for dense data. 
 
    Note that this partitioner is agnostic to the splitting strategy (best vs. random). 
    &quot;&quot;&quot;</span>
    <span class="s2">cdef</span><span class="s3">:</span>
        <span class="s1">const float32_t</span><span class="s3">[:, :] </span><span class="s1">X</span>
        <span class="s2">cdef </span><span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">samples</span>
        <span class="s2">cdef </span><span class="s1">float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">feature_values</span>
        <span class="s2">cdef </span><span class="s1">intp_t start</span>
        <span class="s2">cdef </span><span class="s1">intp_t end</span>
        <span class="s2">cdef </span><span class="s1">intp_t n_missing</span>
        <span class="s2">cdef </span><span class="s1">const unsigned char</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">missing_values_in_feature_mask</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">const float32_t</span><span class="s3">[:, :] </span><span class="s1">X</span><span class="s3">,</span>
        <span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">samples</span><span class="s3">,</span>
        <span class="s1">float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">feature_values</span><span class="s3">,</span>
        <span class="s1">const unsigned char</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">missing_values_in_feature_mask</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">X </span><span class="s3">= </span><span class="s1">X</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">samples </span><span class="s3">= </span><span class="s1">samples</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">feature_values </span><span class="s3">= </span><span class="s1">feature_values</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">missing_values_in_feature_mask </span><span class="s3">= </span><span class="s1">missing_values_in_feature_mask</span>

    <span class="s2">cdef </span><span class="s1">inline void init_node_split</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t start</span><span class="s3">, </span><span class="s1">intp_t end</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Initialize splitter at the beginning of node_split.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">start </span><span class="s3">= </span><span class="s1">start</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">= </span><span class="s1">end</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_missing </span><span class="s3">= </span><span class="s4">0</span>

    <span class="s2">cdef </span><span class="s1">inline void sort_samples_and_feature_values</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t current_feature</span>
    <span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Simultaneously sort based on the feature_values. 
 
        Missing values are stored at the end of feature_values. 
        The number of missing values observed in feature_values is stored 
        in self.n_missing. 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef</span><span class="s3">:</span>
            <span class="s1">intp_t i</span><span class="s3">, </span><span class="s1">current_end</span>
            <span class="s1">float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">feature_values </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">feature_values</span>
            <span class="s1">const float32_t</span><span class="s3">[:, :] </span><span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">X</span>
            <span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">samples </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">samples</span>
            <span class="s1">intp_t n_missing </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">const unsigned char</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">missing_values_in_feature_mask </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">missing_values_in_feature_mask</span>

        <span class="s0"># Sort samples along that feature; by</span>
        <span class="s0"># copying the values into an array and</span>
        <span class="s0"># sorting the array in a manner which utilizes the cache more</span>
        <span class="s0"># effectively.</span>
        <span class="s2">if </span><span class="s1">missing_values_in_feature_mask </span><span class="s2">is not None and </span><span class="s1">missing_values_in_feature_mask</span><span class="s3">[</span><span class="s1">current_feature</span><span class="s3">]:</span>
            <span class="s1">i</span><span class="s3">, </span><span class="s1">current_end </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">- </span><span class="s4">1</span>
            <span class="s0"># Missing values are placed at the end and do not participate in the sorting.</span>
            <span class="s2">while </span><span class="s1">i </span><span class="s3">&lt;= </span><span class="s1">current_end</span><span class="s3">:</span>
                <span class="s0"># Finds the right-most value that is not missing so that</span>
                <span class="s0"># it can be swapped with missing values at its left.</span>
                <span class="s2">if </span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">X</span><span class="s3">[</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">current_end</span><span class="s3">], </span><span class="s1">current_feature</span><span class="s3">]):</span>
                    <span class="s1">n_missing </span><span class="s3">+= </span><span class="s4">1</span>
                    <span class="s1">current_end </span><span class="s3">-= </span><span class="s4">1</span>
                    <span class="s2">continue</span>

                <span class="s0"># X[samples[current_end], current_feature] is a non-missing value</span>
                <span class="s2">if </span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">X</span><span class="s3">[</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">current_feature</span><span class="s3">]):</span>
                    <span class="s1">samples</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">current_end</span><span class="s3">] = </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">current_end</span><span class="s3">], </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                    <span class="s1">n_missing </span><span class="s3">+= </span><span class="s4">1</span>
                    <span class="s1">current_end </span><span class="s3">-= </span><span class="s4">1</span>

                <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">X</span><span class="s3">[</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">current_feature</span><span class="s3">]</span>
                <span class="s1">i </span><span class="s3">+= </span><span class="s4">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># When there are no missing values, we only need to copy the data into</span>
            <span class="s0"># feature_values</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span><span class="s3">):</span>
                <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">X</span><span class="s3">[</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">current_feature</span><span class="s3">]</span>

        <span class="s1">sort</span><span class="s3">(&amp;</span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">], &amp;</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start </span><span class="s3">- </span><span class="s1">n_missing</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_missing </span><span class="s3">= </span><span class="s1">n_missing</span>

    <span class="s2">cdef </span><span class="s1">inline void find_min_max</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">intp_t current_feature</span><span class="s3">,</span>
        <span class="s1">float32_t</span><span class="s3">* </span><span class="s1">min_feature_value_out</span><span class="s3">,</span>
        <span class="s1">float32_t</span><span class="s3">* </span><span class="s1">max_feature_value_out</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Find the minimum and maximum value for current_feature.&quot;&quot;&quot;</span>
        <span class="s2">cdef</span><span class="s3">:</span>
            <span class="s1">intp_t p</span>
            <span class="s1">float32_t current_feature_value</span>
            <span class="s1">const float32_t</span><span class="s3">[:, :] </span><span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">X</span>
            <span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">samples </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">samples</span>
            <span class="s1">float32_t min_feature_value </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">], </span><span class="s1">current_feature</span><span class="s3">]</span>
            <span class="s1">float32_t max_feature_value </span><span class="s3">= </span><span class="s1">min_feature_value</span>
            <span class="s1">float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">feature_values </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">feature_values</span>

        <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">] = </span><span class="s1">min_feature_value</span>

        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span><span class="s3">):</span>
            <span class="s1">current_feature_value </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">p</span><span class="s3">], </span><span class="s1">current_feature</span><span class="s3">]</span>
            <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">p</span><span class="s3">] = </span><span class="s1">current_feature_value</span>

            <span class="s2">if </span><span class="s1">current_feature_value </span><span class="s3">&lt; </span><span class="s1">min_feature_value</span><span class="s3">:</span>
                <span class="s1">min_feature_value </span><span class="s3">= </span><span class="s1">current_feature_value</span>
            <span class="s2">elif </span><span class="s1">current_feature_value </span><span class="s3">&gt; </span><span class="s1">max_feature_value</span><span class="s3">:</span>
                <span class="s1">max_feature_value </span><span class="s3">= </span><span class="s1">current_feature_value</span>

        <span class="s1">min_feature_value_out</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">min_feature_value</span>
        <span class="s1">max_feature_value_out</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">max_feature_value</span>

    <span class="s2">cdef </span><span class="s1">inline void next_p</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">* </span><span class="s1">p_prev</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">* </span><span class="s1">p</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Compute the next p_prev and p for iteratiing over feature values. 
 
        The missing values are not included when iterating through the feature values. 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef</span><span class="s3">:</span>
            <span class="s1">float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">feature_values </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">feature_values</span>
            <span class="s1">intp_t end_non_missing </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_missing</span>

        <span class="s2">while </span><span class="s3">(</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] + </span><span class="s4">1 </span><span class="s3">&lt; </span><span class="s1">end_non_missing </span><span class="s2">and</span>
            <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">p</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] + </span><span class="s4">1</span><span class="s3">] &lt;= </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">p</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]] + </span><span class="s1">FEATURE_THRESHOLD</span>
        <span class="s3">):</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] += </span><span class="s4">1</span>

        <span class="s1">p_prev</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

        <span class="s0"># By adding 1, we have</span>
        <span class="s0"># (feature_values[p] &gt;= end) or (feature_values[p] &gt; feature_values[p - 1])</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] += </span><span class="s4">1</span>

    <span class="s2">cdef </span><span class="s1">inline intp_t partition_samples</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t current_threshold</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Partition samples for feature_values at the current_threshold.&quot;&quot;&quot;</span>
        <span class="s2">cdef</span><span class="s3">:</span>
            <span class="s1">intp_t p </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span>
            <span class="s1">intp_t partition_end </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span>
            <span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">samples </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">samples</span>
            <span class="s1">float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">feature_values </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">feature_values</span>

        <span class="s2">while </span><span class="s1">p </span><span class="s3">&lt; </span><span class="s1">partition_end</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">p</span><span class="s3">] &lt;= </span><span class="s1">current_threshold</span><span class="s3">:</span>
                <span class="s1">p </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">partition_end </span><span class="s3">-= </span><span class="s4">1</span>

                <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">p</span><span class="s3">], </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">partition_end</span><span class="s3">] = (</span>
                    <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">partition_end</span><span class="s3">], </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>
                <span class="s3">)</span>
                <span class="s1">samples</span><span class="s3">[</span><span class="s1">p</span><span class="s3">], </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">partition_end</span><span class="s3">] = </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">partition_end</span><span class="s3">], </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

        <span class="s2">return </span><span class="s1">partition_end</span>

    <span class="s2">cdef </span><span class="s1">inline void partition_samples_final</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">intp_t best_pos</span><span class="s3">,</span>
        <span class="s1">float64_t best_threshold</span><span class="s3">,</span>
        <span class="s1">intp_t best_feature</span><span class="s3">,</span>
        <span class="s1">intp_t best_n_missing</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Partition samples for X at the best_threshold and best_feature. 
 
        If missing values are present, this method partitions `samples` 
        so that the `best_n_missing` missing values' indices are in the 
        right-most end of `samples`, that is `samples[end_non_missing:end]`. 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef</span><span class="s3">:</span>
            <span class="s0"># Local invariance: start &lt;= p &lt;= partition_end &lt;= end</span>
            <span class="s1">intp_t start </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span>
            <span class="s1">intp_t p </span><span class="s3">= </span><span class="s1">start</span>
            <span class="s1">intp_t end </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">- </span><span class="s4">1</span>
            <span class="s1">intp_t partition_end </span><span class="s3">= </span><span class="s1">end </span><span class="s3">- </span><span class="s1">best_n_missing</span>
            <span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">samples </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">samples</span>
            <span class="s1">const float32_t</span><span class="s3">[:, :] </span><span class="s1">X </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">X</span>
            <span class="s1">float32_t current_value</span>

        <span class="s2">if </span><span class="s1">best_n_missing </span><span class="s3">!= </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s0"># Move samples with missing values to the end while partitioning the</span>
            <span class="s0"># non-missing samples</span>
            <span class="s2">while </span><span class="s1">p </span><span class="s3">&lt; </span><span class="s1">partition_end</span><span class="s3">:</span>
                <span class="s0"># Keep samples with missing values at the end</span>
                <span class="s2">if </span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">X</span><span class="s3">[</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">end</span><span class="s3">], </span><span class="s1">best_feature</span><span class="s3">]):</span>
                    <span class="s1">end </span><span class="s3">-= </span><span class="s4">1</span>
                    <span class="s2">continue</span>

                <span class="s0"># Swap sample with missing values with the sample at the end</span>
                <span class="s1">current_value </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">p</span><span class="s3">], </span><span class="s1">best_feature</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">current_value</span><span class="s3">):</span>
                    <span class="s1">samples</span><span class="s3">[</span><span class="s1">p</span><span class="s3">], </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">end</span><span class="s3">] = </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">end</span><span class="s3">], </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>
                    <span class="s1">end </span><span class="s3">-= </span><span class="s4">1</span>

                    <span class="s0"># The swapped sample at the end is always a non-missing value, so</span>
                    <span class="s0"># we can continue the algorithm without checking for missingness.</span>
                    <span class="s1">current_value </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">p</span><span class="s3">], </span><span class="s1">best_feature</span><span class="s3">]</span>

                <span class="s0"># Partition the non-missing samples</span>
                <span class="s2">if </span><span class="s1">current_value </span><span class="s3">&lt;= </span><span class="s1">best_threshold</span><span class="s3">:</span>
                    <span class="s1">p </span><span class="s3">+= </span><span class="s4">1</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">samples</span><span class="s3">[</span><span class="s1">p</span><span class="s3">], </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">partition_end</span><span class="s3">] = </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">partition_end</span><span class="s3">], </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>
                    <span class="s1">partition_end </span><span class="s3">-= </span><span class="s4">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># Partitioning routine when there are no missing values</span>
            <span class="s2">while </span><span class="s1">p </span><span class="s3">&lt; </span><span class="s1">partition_end</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">X</span><span class="s3">[</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">p</span><span class="s3">], </span><span class="s1">best_feature</span><span class="s3">] &lt;= </span><span class="s1">best_threshold</span><span class="s3">:</span>
                    <span class="s1">p </span><span class="s3">+= </span><span class="s4">1</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">samples</span><span class="s3">[</span><span class="s1">p</span><span class="s3">], </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">partition_end</span><span class="s3">] = </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">partition_end</span><span class="s3">], </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>
                    <span class="s1">partition_end </span><span class="s3">-= </span><span class="s4">1</span>


<span class="s3">@</span><span class="s1">final</span>
<span class="s2">cdef class </span><span class="s1">SparsePartitioner</span><span class="s3">:</span>
    <span class="s5">&quot;&quot;&quot;Partitioner specialized for sparse CSC data. 
 
    Note that this partitioner is agnostic to the splitting strategy (best vs. random). 
    &quot;&quot;&quot;</span>
    <span class="s2">cdef </span><span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">samples</span>
    <span class="s2">cdef </span><span class="s1">float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">feature_values</span>
    <span class="s2">cdef </span><span class="s1">intp_t start</span>
    <span class="s2">cdef </span><span class="s1">intp_t end</span>
    <span class="s2">cdef </span><span class="s1">intp_t n_missing</span>
    <span class="s2">cdef </span><span class="s1">const unsigned char</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">missing_values_in_feature_mask</span>

    <span class="s2">cdef </span><span class="s1">const float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_data</span>
    <span class="s2">cdef </span><span class="s1">const int32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_indices</span>
    <span class="s2">cdef </span><span class="s1">const int32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_indptr</span>

    <span class="s2">cdef </span><span class="s1">intp_t n_total_samples</span>

    <span class="s2">cdef </span><span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">index_to_samples</span>
    <span class="s2">cdef </span><span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">sorted_samples</span>

    <span class="s2">cdef </span><span class="s1">intp_t start_positive</span>
    <span class="s2">cdef </span><span class="s1">intp_t end_negative</span>
    <span class="s2">cdef </span><span class="s1">bint is_samples_sorted</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">object X</span><span class="s3">,</span>
        <span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">samples</span><span class="s3">,</span>
        <span class="s1">intp_t n_samples</span><span class="s3">,</span>
        <span class="s1">float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">feature_values</span><span class="s3">,</span>
        <span class="s1">const unsigned char</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">missing_values_in_feature_mask</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s2">if not </span><span class="s3">(</span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X</span><span class="s3">) </span><span class="s2">and </span><span class="s1">X</span><span class="s3">.</span><span class="s1">format </span><span class="s3">== </span><span class="s6">&quot;csc&quot;</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;X should be in csc format&quot;</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">samples </span><span class="s3">= </span><span class="s1">samples</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">feature_values </span><span class="s3">= </span><span class="s1">feature_values</span>

        <span class="s0"># Initialize X</span>
        <span class="s2">cdef </span><span class="s1">intp_t n_total_samples </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">X_data </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">data</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">X_indices </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">indices</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">X_indptr </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">indptr</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_total_samples </span><span class="s3">= </span><span class="s1">n_total_samples</span>

        <span class="s0"># Initialize auxiliary array used to perform split</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">index_to_samples </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">n_total_samples</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">=-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">sorted_samples </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>

        <span class="s2">cdef </span><span class="s1">intp_t p</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">index_to_samples</span><span class="s3">[</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]] = </span><span class="s1">p</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">missing_values_in_feature_mask </span><span class="s3">= </span><span class="s1">missing_values_in_feature_mask</span>

    <span class="s2">cdef </span><span class="s1">inline void init_node_split</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t start</span><span class="s3">, </span><span class="s1">intp_t end</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Initialize splitter at the beginning of node_split.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">start </span><span class="s3">= </span><span class="s1">start</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">= </span><span class="s1">end</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">is_samples_sorted </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_missing </span><span class="s3">= </span><span class="s4">0</span>

    <span class="s2">cdef </span><span class="s1">inline void sort_samples_and_feature_values</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t current_feature</span>
    <span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Simultaneously sort based on the feature_values.&quot;&quot;&quot;</span>
        <span class="s2">cdef</span><span class="s3">:</span>
            <span class="s1">float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">feature_values </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">feature_values</span>
            <span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">index_to_samples </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index_to_samples</span>
            <span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">samples </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">samples</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">extract_nnz</span><span class="s3">(</span><span class="s1">current_feature</span><span class="s3">)</span>
        <span class="s0"># Sort the positive and negative parts of `feature_values`</span>
        <span class="s1">sort</span><span class="s3">(&amp;</span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">], &amp;</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end_negative </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start_positive </span><span class="s3">&lt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span><span class="s3">:</span>
            <span class="s1">sort</span><span class="s3">(</span>
                <span class="s3">&amp;</span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start_positive</span><span class="s3">],</span>
                <span class="s3">&amp;</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start_positive</span><span class="s3">],</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start_positive</span>
            <span class="s3">)</span>

        <span class="s0"># Update index_to_samples to take into account the sort</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end_negative</span><span class="s3">):</span>
            <span class="s1">index_to_samples</span><span class="s3">[</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]] = </span><span class="s1">p</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start_positive</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span><span class="s3">):</span>
            <span class="s1">index_to_samples</span><span class="s3">[</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]] = </span><span class="s1">p</span>

        <span class="s0"># Add one or two zeros in feature_values, if there is any</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end_negative </span><span class="s3">&lt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start_positive</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">start_positive </span><span class="s3">-= </span><span class="s4">1</span>
            <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start_positive</span><span class="s3">] = </span><span class="s4">0.</span>

            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end_negative </span><span class="s3">!= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start_positive</span><span class="s3">:</span>
                <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">end_negative</span><span class="s3">] = </span><span class="s4">0.</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">end_negative </span><span class="s3">+= </span><span class="s4">1</span>

        <span class="s0"># XXX: When sparse supports missing values, this should be set to the</span>
        <span class="s0"># number of missing values for current_feature</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_missing </span><span class="s3">= </span><span class="s4">0</span>

    <span class="s2">cdef </span><span class="s1">inline void find_min_max</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">intp_t current_feature</span><span class="s3">,</span>
        <span class="s1">float32_t</span><span class="s3">* </span><span class="s1">min_feature_value_out</span><span class="s3">,</span>
        <span class="s1">float32_t</span><span class="s3">* </span><span class="s1">max_feature_value_out</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Find the minimum and maximum value for current_feature.&quot;&quot;&quot;</span>
        <span class="s2">cdef</span><span class="s3">:</span>
            <span class="s1">intp_t p</span>
            <span class="s1">float32_t current_feature_value</span><span class="s3">, </span><span class="s1">min_feature_value</span><span class="s3">, </span><span class="s1">max_feature_value</span>
            <span class="s1">float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">feature_values </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">feature_values</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">extract_nnz</span><span class="s3">(</span><span class="s1">current_feature</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end_negative </span><span class="s3">!= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start_positive</span><span class="s3">:</span>
            <span class="s0"># There is a zero</span>
            <span class="s1">min_feature_value </span><span class="s3">= </span><span class="s4">0</span>
            <span class="s1">max_feature_value </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">min_feature_value </span><span class="s3">= </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">]</span>
            <span class="s1">max_feature_value </span><span class="s3">= </span><span class="s1">min_feature_value</span>

        <span class="s0"># Find min, max in feature_values[start:end_negative]</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end_negative</span><span class="s3">):</span>
            <span class="s1">current_feature_value </span><span class="s3">= </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

            <span class="s2">if </span><span class="s1">current_feature_value </span><span class="s3">&lt; </span><span class="s1">min_feature_value</span><span class="s3">:</span>
                <span class="s1">min_feature_value </span><span class="s3">= </span><span class="s1">current_feature_value</span>
            <span class="s2">elif </span><span class="s1">current_feature_value </span><span class="s3">&gt; </span><span class="s1">max_feature_value</span><span class="s3">:</span>
                <span class="s1">max_feature_value </span><span class="s3">= </span><span class="s1">current_feature_value</span>

        <span class="s0"># Update min, max given feature_values[start_positive:end]</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start_positive</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span><span class="s3">):</span>
            <span class="s1">current_feature_value </span><span class="s3">= </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>

            <span class="s2">if </span><span class="s1">current_feature_value </span><span class="s3">&lt; </span><span class="s1">min_feature_value</span><span class="s3">:</span>
                <span class="s1">min_feature_value </span><span class="s3">= </span><span class="s1">current_feature_value</span>
            <span class="s2">elif </span><span class="s1">current_feature_value </span><span class="s3">&gt; </span><span class="s1">max_feature_value</span><span class="s3">:</span>
                <span class="s1">max_feature_value </span><span class="s3">= </span><span class="s1">current_feature_value</span>

        <span class="s1">min_feature_value_out</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">min_feature_value</span>
        <span class="s1">max_feature_value_out</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">max_feature_value</span>

    <span class="s2">cdef </span><span class="s1">inline void next_p</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">* </span><span class="s1">p_prev</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">* </span><span class="s1">p</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Compute the next p_prev and p for iteratiing over feature values.&quot;&quot;&quot;</span>
        <span class="s2">cdef</span><span class="s3">:</span>
            <span class="s1">intp_t p_next</span>
            <span class="s1">float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">feature_values </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">feature_values</span>

        <span class="s2">if </span><span class="s1">p</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] + </span><span class="s4">1 </span><span class="s3">!= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end_negative</span><span class="s3">:</span>
            <span class="s1">p_next </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] + </span><span class="s4">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">p_next </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start_positive</span>

        <span class="s2">while </span><span class="s3">(</span><span class="s1">p_next </span><span class="s3">&lt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s2">and</span>
                <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">p_next</span><span class="s3">] &lt;= </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">p</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]] + </span><span class="s1">FEATURE_THRESHOLD</span><span class="s3">):</span>
            <span class="s1">p</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">p_next</span>
            <span class="s2">if </span><span class="s1">p</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] + </span><span class="s4">1 </span><span class="s3">!= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end_negative</span><span class="s3">:</span>
                <span class="s1">p_next </span><span class="s3">= </span><span class="s1">p</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] + </span><span class="s4">1</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">p_next </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start_positive</span>

        <span class="s1">p_prev</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">p</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s1">p</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">p_next</span>

    <span class="s2">cdef </span><span class="s1">inline intp_t partition_samples</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t current_threshold</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Partition samples for feature_values at the current_threshold.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_partition</span><span class="s3">(</span><span class="s1">current_threshold</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start_positive</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">inline void partition_samples_final</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">intp_t best_pos</span><span class="s3">,</span>
        <span class="s1">float64_t best_threshold</span><span class="s3">,</span>
        <span class="s1">intp_t best_feature</span><span class="s3">,</span>
        <span class="s1">intp_t n_missing</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Partition samples for X at the best_threshold and best_feature.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">extract_nnz</span><span class="s3">(</span><span class="s1">best_feature</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_partition</span><span class="s3">(</span><span class="s1">best_threshold</span><span class="s3">, </span><span class="s1">best_pos</span><span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">inline intp_t _partition</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">float64_t threshold</span><span class="s3">, </span><span class="s1">intp_t zero_pos</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Partition samples[start:end] based on threshold.&quot;&quot;&quot;</span>
        <span class="s2">cdef</span><span class="s3">:</span>
            <span class="s1">intp_t p</span><span class="s3">, </span><span class="s1">partition_end</span>
            <span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">index_to_samples </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index_to_samples</span>
            <span class="s1">float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">feature_values </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">feature_values</span>
            <span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">samples </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">samples</span>

        <span class="s2">if </span><span class="s1">threshold </span><span class="s3">&lt; </span><span class="s4">0.</span><span class="s3">:</span>
            <span class="s1">p </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span>
            <span class="s1">partition_end </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end_negative</span>
        <span class="s2">elif </span><span class="s1">threshold </span><span class="s3">&gt; </span><span class="s4">0.</span><span class="s3">:</span>
            <span class="s1">p </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start_positive</span>
            <span class="s1">partition_end </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s0"># Data are already split</span>
            <span class="s2">return </span><span class="s1">zero_pos</span>

        <span class="s2">while </span><span class="s1">p </span><span class="s3">&lt; </span><span class="s1">partition_end</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">p</span><span class="s3">] &lt;= </span><span class="s1">threshold</span><span class="s3">:</span>
                <span class="s1">p </span><span class="s3">+= </span><span class="s4">1</span>

            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">partition_end </span><span class="s3">-= </span><span class="s4">1</span>

                <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">p</span><span class="s3">], </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">partition_end</span><span class="s3">] = (</span>
                    <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">partition_end</span><span class="s3">], </span><span class="s1">feature_values</span><span class="s3">[</span><span class="s1">p</span><span class="s3">]</span>
                <span class="s3">)</span>
                <span class="s1">sparse_swap</span><span class="s3">(</span><span class="s1">index_to_samples</span><span class="s3">, </span><span class="s1">samples</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">partition_end</span><span class="s3">)</span>

        <span class="s2">return </span><span class="s1">partition_end</span>

    <span class="s2">cdef </span><span class="s1">inline void extract_nnz</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">intp_t feature</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
        <span class="s6">&quot;&quot;&quot;Extract and partition values for a given feature. 
 
        The extracted values are partitioned between negative values 
        feature_values[start:end_negative[0]] and positive values 
        feature_values[start_positive[0]:end]. 
        The samples and index_to_samples are modified according to this 
        partition. 
 
        The extraction corresponds to the intersection between the arrays 
        X_indices[indptr_start:indptr_end] and samples[start:end]. 
        This is done efficiently using either an index_to_samples based approach 
        or binary search based approach. 
 
        Parameters 
        ---------- 
        feature : intp_t, 
            Index of the feature we want to extract non zero value. 
        &quot;&quot;&quot;</span>
        <span class="s2">cdef </span><span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">samples </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">samples</span>
        <span class="s2">cdef </span><span class="s1">float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">feature_values </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">feature_values</span>
        <span class="s2">cdef </span><span class="s1">intp_t indptr_start </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">feature</span><span class="s3">],</span>
        <span class="s2">cdef </span><span class="s1">intp_t indptr_end </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">X_indptr</span><span class="s3">[</span><span class="s1">feature </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">]</span>
        <span class="s2">cdef </span><span class="s1">intp_t n_indices </span><span class="s3">= &lt;</span><span class="s1">intp_t</span><span class="s3">&gt;(</span><span class="s1">indptr_end </span><span class="s3">- </span><span class="s1">indptr_start</span><span class="s3">)</span>
        <span class="s2">cdef </span><span class="s1">intp_t n_samples </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span>
        <span class="s2">cdef </span><span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">index_to_samples </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">index_to_samples</span>
        <span class="s2">cdef </span><span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">sorted_samples </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">sorted_samples</span>
        <span class="s2">cdef </span><span class="s1">const int32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_indices </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">X_indices</span>
        <span class="s2">cdef </span><span class="s1">const float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_data </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">X_data</span>

        <span class="s0"># Use binary search if n_samples * log(n_indices) &lt;</span>
        <span class="s0"># n_indices and index_to_samples approach otherwise.</span>
        <span class="s0"># O(n_samples * log(n_indices)) is the running time of binary</span>
        <span class="s0"># search and O(n_indices) is the running time of index_to_samples</span>
        <span class="s0"># approach.</span>
        <span class="s2">if </span><span class="s3">((</span><span class="s4">1 </span><span class="s3">- </span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_samples_sorted</span><span class="s3">) * </span><span class="s1">n_samples </span><span class="s3">* </span><span class="s1">log</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">) +</span>
                <span class="s1">n_samples </span><span class="s3">* </span><span class="s1">log</span><span class="s3">(</span><span class="s1">n_indices</span><span class="s3">) &lt; </span><span class="s1">EXTRACT_NNZ_SWITCH </span><span class="s3">* </span><span class="s1">n_indices</span><span class="s3">):</span>
            <span class="s1">extract_nnz_binary_search</span><span class="s3">(</span><span class="s1">X_indices</span><span class="s3">, </span><span class="s1">X_data</span><span class="s3">,</span>
                                      <span class="s1">indptr_start</span><span class="s3">, </span><span class="s1">indptr_end</span><span class="s3">,</span>
                                      <span class="s1">samples</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span><span class="s3">,</span>
                                      <span class="s1">index_to_samples</span><span class="s3">,</span>
                                      <span class="s1">feature_values</span><span class="s3">,</span>
                                      <span class="s3">&amp;</span><span class="s1">self</span><span class="s3">.</span><span class="s1">end_negative</span><span class="s3">, &amp;</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start_positive</span><span class="s3">,</span>
                                      <span class="s1">sorted_samples</span><span class="s3">, &amp;</span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_samples_sorted</span><span class="s3">)</span>

        <span class="s0"># Using an index to samples  technique to extract non zero values</span>
        <span class="s0"># index_to_samples is a mapping from X_indices to samples</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">extract_nnz_index_to_samples</span><span class="s3">(</span><span class="s1">X_indices</span><span class="s3">, </span><span class="s1">X_data</span><span class="s3">,</span>
                                         <span class="s1">indptr_start</span><span class="s3">, </span><span class="s1">indptr_end</span><span class="s3">,</span>
                                         <span class="s1">samples</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">start</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">end</span><span class="s3">,</span>
                                         <span class="s1">index_to_samples</span><span class="s3">,</span>
                                         <span class="s1">feature_values</span><span class="s3">,</span>
                                         <span class="s3">&amp;</span><span class="s1">self</span><span class="s3">.</span><span class="s1">end_negative</span><span class="s3">, &amp;</span><span class="s1">self</span><span class="s3">.</span><span class="s1">start_positive</span><span class="s3">)</span>


<span class="s2">cdef </span><span class="s1">int compare_SIZE_t</span><span class="s3">(</span><span class="s1">const void</span><span class="s3">* </span><span class="s1">a</span><span class="s3">, </span><span class="s1">const void</span><span class="s3">* </span><span class="s1">b</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
    <span class="s6">&quot;&quot;&quot;Comparison function for sort. 
 
    This must return an `int` as it is used by stdlib's qsort, which expects 
    an `int` return value. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s3">&lt;</span><span class="s1">int</span><span class="s3">&gt;((&lt;</span><span class="s1">intp_t</span><span class="s3">*&gt;</span><span class="s1">a</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">] - (&lt;</span><span class="s1">intp_t</span><span class="s3">*&gt;</span><span class="s1">b</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">])</span>


<span class="s2">cdef </span><span class="s1">inline void binary_search</span><span class="s3">(</span><span class="s1">const int32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">sorted_array</span><span class="s3">,</span>
                               <span class="s1">int32_t start</span><span class="s3">, </span><span class="s1">int32_t end</span><span class="s3">,</span>
                               <span class="s1">intp_t value</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">* </span><span class="s1">index</span><span class="s3">,</span>
                               <span class="s1">int32_t</span><span class="s3">* </span><span class="s1">new_start</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
    <span class="s6">&quot;&quot;&quot;Return the index of value in the sorted array. 
 
    If not found, return -1. new_start is the last pivot + 1 
    &quot;&quot;&quot;</span>
    <span class="s2">cdef </span><span class="s1">int32_t pivot</span>
    <span class="s1">index</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = -</span><span class="s4">1</span>
    <span class="s2">while </span><span class="s1">start </span><span class="s3">&lt; </span><span class="s1">end</span><span class="s3">:</span>
        <span class="s1">pivot </span><span class="s3">= </span><span class="s1">start </span><span class="s3">+ (</span><span class="s1">end </span><span class="s3">- </span><span class="s1">start</span><span class="s3">) / </span><span class="s4">2</span>

        <span class="s2">if </span><span class="s1">sorted_array</span><span class="s3">[</span><span class="s1">pivot</span><span class="s3">] == </span><span class="s1">value</span><span class="s3">:</span>
            <span class="s1">index</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">pivot</span>
            <span class="s1">start </span><span class="s3">= </span><span class="s1">pivot </span><span class="s3">+ </span><span class="s4">1</span>
            <span class="s2">break</span>

        <span class="s2">if </span><span class="s1">sorted_array</span><span class="s3">[</span><span class="s1">pivot</span><span class="s3">] &lt; </span><span class="s1">value</span><span class="s3">:</span>
            <span class="s1">start </span><span class="s3">= </span><span class="s1">pivot </span><span class="s3">+ </span><span class="s4">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">end </span><span class="s3">= </span><span class="s1">pivot</span>
    <span class="s1">new_start</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">start</span>


<span class="s2">cdef </span><span class="s1">inline void extract_nnz_index_to_samples</span><span class="s3">(</span><span class="s1">const int32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_indices</span><span class="s3">,</span>
                                              <span class="s1">const float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_data</span><span class="s3">,</span>
                                              <span class="s1">int32_t indptr_start</span><span class="s3">,</span>
                                              <span class="s1">int32_t indptr_end</span><span class="s3">,</span>
                                              <span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">samples</span><span class="s3">,</span>
                                              <span class="s1">intp_t start</span><span class="s3">,</span>
                                              <span class="s1">intp_t end</span><span class="s3">,</span>
                                              <span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">index_to_samples</span><span class="s3">,</span>
                                              <span class="s1">float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">feature_values</span><span class="s3">,</span>
                                              <span class="s1">intp_t</span><span class="s3">* </span><span class="s1">end_negative</span><span class="s3">,</span>
                                              <span class="s1">intp_t</span><span class="s3">* </span><span class="s1">start_positive</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
    <span class="s6">&quot;&quot;&quot;Extract and partition values for a feature using index_to_samples. 
 
    Complexity is O(indptr_end - indptr_start). 
    &quot;&quot;&quot;</span>
    <span class="s2">cdef </span><span class="s1">int32_t k</span>
    <span class="s2">cdef </span><span class="s1">intp_t index</span>
    <span class="s2">cdef </span><span class="s1">intp_t end_negative_ </span><span class="s3">= </span><span class="s1">start</span>
    <span class="s2">cdef </span><span class="s1">intp_t start_positive_ </span><span class="s3">= </span><span class="s1">end</span>

    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">indptr_start</span><span class="s3">, </span><span class="s1">indptr_end</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">start </span><span class="s3">&lt;= </span><span class="s1">index_to_samples</span><span class="s3">[</span><span class="s1">X_indices</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]] &lt; </span><span class="s1">end</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">X_data</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] &gt; </span><span class="s4">0</span><span class="s3">:</span>
                <span class="s1">start_positive_ </span><span class="s3">-= </span><span class="s4">1</span>
                <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">start_positive_</span><span class="s3">] = </span><span class="s1">X_data</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
                <span class="s1">index </span><span class="s3">= </span><span class="s1">index_to_samples</span><span class="s3">[</span><span class="s1">X_indices</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]]</span>
                <span class="s1">sparse_swap</span><span class="s3">(</span><span class="s1">index_to_samples</span><span class="s3">, </span><span class="s1">samples</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">start_positive_</span><span class="s3">)</span>

            <span class="s2">elif </span><span class="s1">X_data</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] &lt; </span><span class="s4">0</span><span class="s3">:</span>
                <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">end_negative_</span><span class="s3">] = </span><span class="s1">X_data</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
                <span class="s1">index </span><span class="s3">= </span><span class="s1">index_to_samples</span><span class="s3">[</span><span class="s1">X_indices</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]]</span>
                <span class="s1">sparse_swap</span><span class="s3">(</span><span class="s1">index_to_samples</span><span class="s3">, </span><span class="s1">samples</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">end_negative_</span><span class="s3">)</span>
                <span class="s1">end_negative_ </span><span class="s3">+= </span><span class="s4">1</span>

    <span class="s0"># Returned values</span>
    <span class="s1">end_negative</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">end_negative_</span>
    <span class="s1">start_positive</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">start_positive_</span>


<span class="s2">cdef </span><span class="s1">inline void extract_nnz_binary_search</span><span class="s3">(</span><span class="s1">const int32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_indices</span><span class="s3">,</span>
                                           <span class="s1">const float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">X_data</span><span class="s3">,</span>
                                           <span class="s1">int32_t indptr_start</span><span class="s3">,</span>
                                           <span class="s1">int32_t indptr_end</span><span class="s3">,</span>
                                           <span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">samples</span><span class="s3">,</span>
                                           <span class="s1">intp_t start</span><span class="s3">,</span>
                                           <span class="s1">intp_t end</span><span class="s3">,</span>
                                           <span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">index_to_samples</span><span class="s3">,</span>
                                           <span class="s1">float32_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">feature_values</span><span class="s3">,</span>
                                           <span class="s1">intp_t</span><span class="s3">* </span><span class="s1">end_negative</span><span class="s3">,</span>
                                           <span class="s1">intp_t</span><span class="s3">* </span><span class="s1">start_positive</span><span class="s3">,</span>
                                           <span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">sorted_samples</span><span class="s3">,</span>
                                           <span class="s1">bint</span><span class="s3">* </span><span class="s1">is_samples_sorted</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
    <span class="s6">&quot;&quot;&quot;Extract and partition values for a given feature using binary search. 
 
    If n_samples = end - start and n_indices = indptr_end - indptr_start, 
    the complexity is 
 
        O((1 - is_samples_sorted[0]) * n_samples * log(n_samples) + 
          n_samples * log(n_indices)). 
    &quot;&quot;&quot;</span>
    <span class="s2">cdef </span><span class="s1">intp_t n_samples</span>

    <span class="s2">if not </span><span class="s1">is_samples_sorted</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]:</span>
        <span class="s1">n_samples </span><span class="s3">= </span><span class="s1">end </span><span class="s3">- </span><span class="s1">start</span>
        <span class="s1">memcpy</span><span class="s3">(&amp;</span><span class="s1">sorted_samples</span><span class="s3">[</span><span class="s1">start</span><span class="s3">], &amp;</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">start</span><span class="s3">],</span>
               <span class="s1">n_samples </span><span class="s3">* </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">intp_t</span><span class="s3">))</span>
        <span class="s1">qsort</span><span class="s3">(&amp;</span><span class="s1">sorted_samples</span><span class="s3">[</span><span class="s1">start</span><span class="s3">], </span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">sizeof</span><span class="s3">(</span><span class="s1">intp_t</span><span class="s3">),</span>
              <span class="s1">compare_SIZE_t</span><span class="s3">)</span>
        <span class="s1">is_samples_sorted</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s4">1</span>

    <span class="s2">while </span><span class="s3">(</span><span class="s1">indptr_start </span><span class="s3">&lt; </span><span class="s1">indptr_end </span><span class="s2">and</span>
           <span class="s1">sorted_samples</span><span class="s3">[</span><span class="s1">start</span><span class="s3">] &gt; </span><span class="s1">X_indices</span><span class="s3">[</span><span class="s1">indptr_start</span><span class="s3">]):</span>
        <span class="s1">indptr_start </span><span class="s3">+= </span><span class="s4">1</span>

    <span class="s2">while </span><span class="s3">(</span><span class="s1">indptr_start </span><span class="s3">&lt; </span><span class="s1">indptr_end </span><span class="s2">and</span>
           <span class="s1">sorted_samples</span><span class="s3">[</span><span class="s1">end </span><span class="s3">- </span><span class="s4">1</span><span class="s3">] &lt; </span><span class="s1">X_indices</span><span class="s3">[</span><span class="s1">indptr_end </span><span class="s3">- </span><span class="s4">1</span><span class="s3">]):</span>
        <span class="s1">indptr_end </span><span class="s3">-= </span><span class="s4">1</span>

    <span class="s2">cdef </span><span class="s1">intp_t p </span><span class="s3">= </span><span class="s1">start</span>
    <span class="s2">cdef </span><span class="s1">intp_t index</span>
    <span class="s2">cdef </span><span class="s1">intp_t k</span>
    <span class="s2">cdef </span><span class="s1">intp_t end_negative_ </span><span class="s3">= </span><span class="s1">start</span>
    <span class="s2">cdef </span><span class="s1">intp_t start_positive_ </span><span class="s3">= </span><span class="s1">end</span>

    <span class="s2">while </span><span class="s3">(</span><span class="s1">p </span><span class="s3">&lt; </span><span class="s1">end </span><span class="s2">and </span><span class="s1">indptr_start </span><span class="s3">&lt; </span><span class="s1">indptr_end</span><span class="s3">):</span>
        <span class="s0"># Find index of sorted_samples[p] in X_indices</span>
        <span class="s1">binary_search</span><span class="s3">(</span><span class="s1">X_indices</span><span class="s3">, </span><span class="s1">indptr_start</span><span class="s3">, </span><span class="s1">indptr_end</span><span class="s3">,</span>
                      <span class="s1">sorted_samples</span><span class="s3">[</span><span class="s1">p</span><span class="s3">], &amp;</span><span class="s1">k</span><span class="s3">, &amp;</span><span class="s1">indptr_start</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">k </span><span class="s3">!= -</span><span class="s4">1</span><span class="s3">:</span>
            <span class="s0"># If k != -1, we have found a non zero value</span>

            <span class="s2">if </span><span class="s1">X_data</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] &gt; </span><span class="s4">0</span><span class="s3">:</span>
                <span class="s1">start_positive_ </span><span class="s3">-= </span><span class="s4">1</span>
                <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">start_positive_</span><span class="s3">] = </span><span class="s1">X_data</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
                <span class="s1">index </span><span class="s3">= </span><span class="s1">index_to_samples</span><span class="s3">[</span><span class="s1">X_indices</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]]</span>
                <span class="s1">sparse_swap</span><span class="s3">(</span><span class="s1">index_to_samples</span><span class="s3">, </span><span class="s1">samples</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">start_positive_</span><span class="s3">)</span>

            <span class="s2">elif </span><span class="s1">X_data</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] &lt; </span><span class="s4">0</span><span class="s3">:</span>
                <span class="s1">feature_values</span><span class="s3">[</span><span class="s1">end_negative_</span><span class="s3">] = </span><span class="s1">X_data</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
                <span class="s1">index </span><span class="s3">= </span><span class="s1">index_to_samples</span><span class="s3">[</span><span class="s1">X_indices</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]]</span>
                <span class="s1">sparse_swap</span><span class="s3">(</span><span class="s1">index_to_samples</span><span class="s3">, </span><span class="s1">samples</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">end_negative_</span><span class="s3">)</span>
                <span class="s1">end_negative_ </span><span class="s3">+= </span><span class="s4">1</span>
        <span class="s1">p </span><span class="s3">+= </span><span class="s4">1</span>

    <span class="s0"># Returned values</span>
    <span class="s1">end_negative</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">end_negative_</span>
    <span class="s1">start_positive</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s1">start_positive_</span>


<span class="s2">cdef </span><span class="s1">inline void sparse_swap</span><span class="s3">(</span><span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">index_to_samples</span><span class="s3">, </span><span class="s1">intp_t</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">samples</span><span class="s3">,</span>
                             <span class="s1">intp_t pos_1</span><span class="s3">, </span><span class="s1">intp_t pos_2</span><span class="s3">) </span><span class="s1">noexcept nogil</span><span class="s3">:</span>
    <span class="s6">&quot;&quot;&quot;Swap sample pos_1 and pos_2 preserving sparse invariant.&quot;&quot;&quot;</span>
    <span class="s1">samples</span><span class="s3">[</span><span class="s1">pos_1</span><span class="s3">], </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">pos_2</span><span class="s3">] = </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">pos_2</span><span class="s3">], </span><span class="s1">samples</span><span class="s3">[</span><span class="s1">pos_1</span><span class="s3">]</span>
    <span class="s1">index_to_samples</span><span class="s3">[</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">pos_1</span><span class="s3">]] = </span><span class="s1">pos_1</span>
    <span class="s1">index_to_samples</span><span class="s3">[</span><span class="s1">samples</span><span class="s3">[</span><span class="s1">pos_2</span><span class="s3">]] = </span><span class="s1">pos_2</span>


<span class="s2">cdef class </span><span class="s1">BestSplitter</span><span class="s3">(</span><span class="s1">Splitter</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Splitter for finding the best split on dense data.&quot;&quot;&quot;</span>
    <span class="s2">cdef </span><span class="s1">DensePartitioner partitioner</span>
    <span class="s2">cdef </span><span class="s1">int init</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">object X</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">y</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:] </span><span class="s1">sample_weight</span><span class="s3">,</span>
        <span class="s1">const unsigned char</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">missing_values_in_feature_mask</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">Splitter</span><span class="s3">.</span><span class="s1">init</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">, </span><span class="s1">missing_values_in_feature_mask</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">partitioner </span><span class="s3">= </span><span class="s1">DensePartitioner</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">samples</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">missing_values_in_feature_mask</span>
        <span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">int node_split</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">ParentInfo</span><span class="s3">* </span><span class="s1">parent_record</span><span class="s3">,</span>
            <span class="s1">SplitRecord</span><span class="s3">* </span><span class="s1">split</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">node_split_best</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">partitioner</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">criterion</span><span class="s3">,</span>
            <span class="s1">split</span><span class="s3">,</span>
            <span class="s1">parent_record</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">with_monotonic_cst</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">monotonic_cst</span><span class="s3">,</span>
        <span class="s3">)</span>

<span class="s2">cdef class </span><span class="s1">BestSparseSplitter</span><span class="s3">(</span><span class="s1">Splitter</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Splitter for finding the best split, using the sparse data.&quot;&quot;&quot;</span>
    <span class="s2">cdef </span><span class="s1">SparsePartitioner partitioner</span>
    <span class="s2">cdef </span><span class="s1">int init</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">object X</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">y</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:] </span><span class="s1">sample_weight</span><span class="s3">,</span>
        <span class="s1">const unsigned char</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">missing_values_in_feature_mask</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">Splitter</span><span class="s3">.</span><span class="s1">init</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">, </span><span class="s1">missing_values_in_feature_mask</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">partitioner </span><span class="s3">= </span><span class="s1">SparsePartitioner</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">samples</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">missing_values_in_feature_mask</span>
        <span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">int node_split</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">ParentInfo</span><span class="s3">* </span><span class="s1">parent_record</span><span class="s3">,</span>
            <span class="s1">SplitRecord</span><span class="s3">* </span><span class="s1">split</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">node_split_best</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">partitioner</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">criterion</span><span class="s3">,</span>
            <span class="s1">split</span><span class="s3">,</span>
            <span class="s1">parent_record</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">with_monotonic_cst</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">monotonic_cst</span><span class="s3">,</span>
        <span class="s3">)</span>

<span class="s2">cdef class </span><span class="s1">RandomSplitter</span><span class="s3">(</span><span class="s1">Splitter</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Splitter for finding the best random split on dense data.&quot;&quot;&quot;</span>
    <span class="s2">cdef </span><span class="s1">DensePartitioner partitioner</span>
    <span class="s2">cdef </span><span class="s1">int init</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">object X</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">y</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:] </span><span class="s1">sample_weight</span><span class="s3">,</span>
        <span class="s1">const unsigned char</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">missing_values_in_feature_mask</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">Splitter</span><span class="s3">.</span><span class="s1">init</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">, </span><span class="s1">missing_values_in_feature_mask</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">partitioner </span><span class="s3">= </span><span class="s1">DensePartitioner</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">samples</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">missing_values_in_feature_mask</span>
        <span class="s3">)</span>

    <span class="s2">cdef </span><span class="s1">int node_split</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">ParentInfo</span><span class="s3">* </span><span class="s1">parent_record</span><span class="s3">,</span>
            <span class="s1">SplitRecord</span><span class="s3">* </span><span class="s1">split</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">node_split_random</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">partitioner</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">criterion</span><span class="s3">,</span>
            <span class="s1">split</span><span class="s3">,</span>
            <span class="s1">parent_record</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">with_monotonic_cst</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">monotonic_cst</span><span class="s3">,</span>
        <span class="s3">)</span>

<span class="s2">cdef class </span><span class="s1">RandomSparseSplitter</span><span class="s3">(</span><span class="s1">Splitter</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Splitter for finding the best random split, using the sparse data.&quot;&quot;&quot;</span>
    <span class="s2">cdef </span><span class="s1">SparsePartitioner partitioner</span>
    <span class="s2">cdef </span><span class="s1">int init</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">object X</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:, ::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">y</span><span class="s3">,</span>
        <span class="s1">const float64_t</span><span class="s3">[:] </span><span class="s1">sample_weight</span><span class="s3">,</span>
        <span class="s1">const unsigned char</span><span class="s3">[::</span><span class="s4">1</span><span class="s3">] </span><span class="s1">missing_values_in_feature_mask</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1</span><span class="s3">:</span>
        <span class="s1">Splitter</span><span class="s3">.</span><span class="s1">init</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">, </span><span class="s1">missing_values_in_feature_mask</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">partitioner </span><span class="s3">= </span><span class="s1">SparsePartitioner</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">samples</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">feature_values</span><span class="s3">, </span><span class="s1">missing_values_in_feature_mask</span>
        <span class="s3">)</span>
    <span class="s2">cdef </span><span class="s1">int node_split</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">ParentInfo</span><span class="s3">* </span><span class="s1">parent_record</span><span class="s3">,</span>
            <span class="s1">SplitRecord</span><span class="s3">* </span><span class="s1">split</span><span class="s3">,</span>
    <span class="s3">) </span><span class="s2">except </span><span class="s3">-</span><span class="s4">1 </span><span class="s1">nogil</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">node_split_random</span><span class="s3">(</span>
            <span class="s1">self</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">partitioner</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">criterion</span><span class="s3">,</span>
            <span class="s1">split</span><span class="s3">,</span>
            <span class="s1">parent_record</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">with_monotonic_cst</span><span class="s3">,</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">monotonic_cst</span><span class="s3">,</span>
        <span class="s3">)</span>
</pre>
</body>
</html>