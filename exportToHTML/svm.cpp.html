<html>
<head>
<title>svm.cpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #6aab73;}
.s4 { color: #c77dbb;}
.s5 { color: #2aacb8;}
.s6 { color: #0da19e;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
svm.cpp</font>
</center></td></tr></table>
<pre><span class="s0">/* 
Copyright (c) 2000-2009 Chih-Chung Chang and Chih-Jen Lin 
All rights reserved. 
 
Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions 
are met: 
 
1. Redistributions of source code must retain the above copyright 
notice, this list of conditions and the following disclaimer. 
 
2. Redistributions in binary form must reproduce the above copyright 
notice, this list of conditions and the following disclaimer in the 
documentation and/or other materials provided with the distribution. 
 
3. Neither name of copyright holders nor the names of its contributors 
may be used to endorse or promote products derived from this software 
without specific prior written permission. 
 
 
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR 
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
*/</span>

<span class="s0">/* 
   Modified 2010: 
 
   - Support for dense data by Ming-Fang Weng 
 
   - Return indices for support vectors, Fabian Pedregosa 
     &lt;fabian.pedregosa@inria.fr&gt; 
 
   - Fixes to avoid name collision, Fabian Pedregosa 
 
   - Add support for instance weights, Fabian Pedregosa based on work 
     by Ming-Wei Chang, Hsuan-Tien Lin, Ming-Hen Tsai, Chia-Hua Ho and 
     Hsiang-Fu Yu, 
     &lt;https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/#weights_for_data_instances&gt;. 
 
   - Make labels sorted in svm_group_classes, Fabian Pedregosa. 
 
   Modified 2020: 
 
   - Improved random number generator by using a mersenne twister + tweaked 
     lemire postprocessor. This fixed a convergence issue on windows targets. 
     Sylvain Marie, Schneider Electric 
     see &lt;https://github.com/scikit-learn/scikit-learn/pull/13511#issuecomment-481729756&gt; 
 
   Modified 2021: 
 
   - Exposed number of iterations run in optimization, Juan Mart√≠n Loyola. 
     See &lt;https://github.com/scikit-learn/scikit-learn/pull/21408/&gt; 
 */</span>

<span class="s2">#include </span><span class="s1">&lt;math.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;stdio.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;stdlib.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;ctype.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;</span><span class="s2">float</span><span class="s1">.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;string.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;stdarg.h&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;climits&gt;</span>
<span class="s2">#include </span><span class="s1">&lt;random&gt;</span>
<span class="s2">#include </span><span class="s3">&quot;svm.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;_svm_cython_blas_helpers.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;../newrand/newrand.h&quot;</span>


<span class="s2">#ifndef </span><span class="s1">_LIBSVM_CPP</span>
<span class="s2">typedef float </span><span class="s1">Qfloat;</span>
<span class="s2">typedef signed char </span><span class="s1">schar;</span>
<span class="s2">#ifndef </span><span class="s1">min</span>
<span class="s1">template &lt;</span><span class="s4">class </span><span class="s1">T&gt; </span><span class="s2">static </span><span class="s4">inline </span><span class="s1">T min(T x,T y) { </span><span class="s2">return </span><span class="s1">(x&lt;y)?x:y; }</span>
<span class="s2">#endif</span>
<span class="s2">#ifndef </span><span class="s1">max</span>
<span class="s1">template &lt;</span><span class="s4">class </span><span class="s1">T&gt; </span><span class="s2">static </span><span class="s4">inline </span><span class="s1">T max(T x,T y) { </span><span class="s2">return </span><span class="s1">(x&gt;y)?x:y; }</span>
<span class="s2">#endif</span>
<span class="s1">template &lt;</span><span class="s4">class </span><span class="s1">T&gt; </span><span class="s2">static </span><span class="s4">inline </span><span class="s2">void </span><span class="s1">swap(T&amp; x, T&amp; y) { T t=x; x=y; y=t; }</span>
<span class="s1">template &lt;</span><span class="s4">class </span><span class="s1">S, </span><span class="s4">class </span><span class="s1">T&gt; </span><span class="s2">static </span><span class="s4">inline </span><span class="s2">void </span><span class="s1">clone(T*&amp; dst, S* src, </span><span class="s2">int </span><span class="s1">n)</span>
<span class="s1">{</span>
	<span class="s1">dst = </span><span class="s4">new </span><span class="s1">T[n];</span>
	<span class="s1">memcpy((</span><span class="s2">void </span><span class="s1">*)dst,(</span><span class="s2">void </span><span class="s1">*)src,</span><span class="s2">sizeof</span><span class="s1">(T)*n);</span>
<span class="s1">}</span>
<span class="s2">static </span><span class="s4">inline </span><span class="s2">double </span><span class="s1">powi(</span><span class="s2">double </span><span class="s1">base, </span><span class="s2">int </span><span class="s1">times)</span>
<span class="s1">{</span>
	<span class="s2">double </span><span class="s1">tmp = base, ret = </span><span class="s5">1.0</span><span class="s1">;</span>

	<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">t=times; t&gt;</span><span class="s5">0</span><span class="s1">; t/=</span><span class="s5">2</span><span class="s1">)</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(t%</span><span class="s5">2</span><span class="s1">==</span><span class="s5">1</span><span class="s1">) ret*=tmp;</span>
		<span class="s1">tmp = tmp * tmp;</span>
	<span class="s1">}</span>
	<span class="s2">return </span><span class="s1">ret;</span>
<span class="s1">}</span>
<span class="s2">#define </span><span class="s1">INF HUGE_VAL</span>
<span class="s2">#define </span><span class="s1">TAU </span><span class="s5">1</span><span class="s1">e-12</span>
<span class="s2">#define </span><span class="s1">Malloc(type,n) (type *)malloc((n)*</span><span class="s2">sizeof</span><span class="s1">(type))</span>

<span class="s2">static void </span><span class="s1">print_string_stdout(</span><span class="s2">const char </span><span class="s1">*s)</span>
<span class="s1">{</span>
	<span class="s1">fputs(s,stdout);</span>
	<span class="s1">fflush(stdout);</span>
<span class="s1">}</span>
<span class="s2">static void </span><span class="s1">(*svm_print_string) (</span><span class="s2">const char </span><span class="s1">*) = &amp;print_string_stdout;</span>

<span class="s2">static void </span><span class="s1">info(</span><span class="s2">const char </span><span class="s1">*fmt,...)</span>
<span class="s1">{</span>
	<span class="s2">char </span><span class="s1">buf[BUFSIZ];</span>
	<span class="s1">va_list ap;</span>
	<span class="s1">va_start(ap,fmt);</span>
	<span class="s1">vsprintf(buf,fmt,ap);</span>
	<span class="s1">va_end(ap);</span>
	<span class="s1">(*svm_print_string)(buf);</span>
<span class="s1">}</span>
<span class="s2">#endif</span>
<span class="s2">#define </span><span class="s1">_LIBSVM_CPP</span>


<span class="s0">/* yeah, this is ugly.  It helps us to have unique names for both sparse 
and dense versions of this library */</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
  <span class="s2">#ifdef </span><span class="s1">PREFIX</span>
    <span class="s2">#undef </span><span class="s1">PREFIX</span>
  <span class="s2">#endif</span>
  <span class="s2">#ifdef </span><span class="s1">NAMESPACE</span>
    <span class="s2">#undef </span><span class="s1">NAMESPACE</span>
  <span class="s2">#endif</span>
  <span class="s2">#define </span><span class="s1">PREFIX(name) svm_##name</span>
  <span class="s2">#define </span><span class="s1">NAMESPACE svm</span>
  <span class="s4">namespace </span><span class="s1">svm {</span>
<span class="s2">#else</span>
  <span class="s0">/* sparse representation */</span>
  <span class="s2">#ifdef </span><span class="s1">PREFIX</span>
    <span class="s2">#undef </span><span class="s1">PREFIX</span>
  <span class="s2">#endif</span>
  <span class="s2">#ifdef </span><span class="s1">NAMESPACE</span>
    <span class="s2">#undef </span><span class="s1">NAMESPACE</span>
  <span class="s2">#endif</span>
  <span class="s2">#define </span><span class="s1">PREFIX(name) svm_csr_##name</span>
  <span class="s2">#define </span><span class="s1">NAMESPACE svm_csr</span>
  <span class="s4">namespace </span><span class="s1">svm_csr {</span>
<span class="s2">#endif</span>


<span class="s0">//</span>
<span class="s0">// Kernel Cache</span>
<span class="s0">//</span>
<span class="s0">// l is the number of total data items</span>
<span class="s0">// size is the cache size limit in bytes</span>
<span class="s0">//</span>
<span class="s4">class </span><span class="s1">Cache</span>
<span class="s1">{</span>
<span class="s4">public</span><span class="s1">:</span>
	<span class="s1">Cache(</span><span class="s2">int </span><span class="s1">l,</span><span class="s2">long int </span><span class="s1">size);</span>
	<span class="s1">~Cache();</span>

	<span class="s0">// request data [0,len)</span>
	<span class="s0">// return some position p where [p,len) need to be filled</span>
	<span class="s0">// (p &gt;= len if nothing needs to be filled)</span>
	<span class="s2">int </span><span class="s1">get_data(</span><span class="s2">const int </span><span class="s1">index, Qfloat **data, </span><span class="s2">int </span><span class="s1">len);</span>
	<span class="s2">void </span><span class="s1">swap_index(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">j);</span>
<span class="s4">private</span><span class="s1">:</span>
	<span class="s2">int </span><span class="s1">l;</span>
	<span class="s2">long int </span><span class="s1">size;</span>
	<span class="s2">struct </span><span class="s1">head_t</span>
	<span class="s1">{</span>
		<span class="s1">head_t *prev, *next;	</span><span class="s0">// a circular list</span>
		<span class="s1">Qfloat *data;</span>
		<span class="s2">int </span><span class="s1">len;		</span><span class="s0">// data[0,len) is cached in this entry</span>
	<span class="s1">};</span>

	<span class="s1">head_t *head;</span>
	<span class="s1">head_t lru_head;</span>
	<span class="s2">void </span><span class="s1">lru_delete(head_t *h);</span>
	<span class="s2">void </span><span class="s1">lru_insert(head_t *h);</span>
<span class="s1">};</span>

<span class="s1">Cache::Cache(</span><span class="s2">int </span><span class="s1">l_,</span><span class="s2">long int </span><span class="s1">size_):l(l_),size(size_)</span>
<span class="s1">{</span>
	<span class="s1">head = (head_t *)calloc(l,</span><span class="s2">sizeof</span><span class="s1">(head_t));	</span><span class="s0">// initialized to 0</span>
	<span class="s1">size /= </span><span class="s2">sizeof</span><span class="s1">(Qfloat);</span>
	<span class="s1">size -= l * </span><span class="s2">sizeof</span><span class="s1">(head_t) / </span><span class="s2">sizeof</span><span class="s1">(Qfloat);</span>
	<span class="s1">size = max(size, </span><span class="s5">2 </span><span class="s1">* (</span><span class="s2">long int</span><span class="s1">) l);	</span><span class="s0">// cache must be large enough for two columns</span>
	<span class="s1">lru_head.next = lru_head.prev = &amp;lru_head;</span>
<span class="s1">}</span>

<span class="s1">Cache::~Cache()</span>
<span class="s1">{</span>
	<span class="s2">for</span><span class="s1">(head_t *h = lru_head.next; h != &amp;lru_head; h=h</span><span class="s6">-&gt;</span><span class="s1">next)</span>
		<span class="s1">free(h</span><span class="s6">-&gt;</span><span class="s1">data);</span>
	<span class="s1">free(head);</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">Cache::lru_delete(head_t *h)</span>
<span class="s1">{</span>
	<span class="s0">// delete from current location</span>
	<span class="s1">h</span><span class="s6">-&gt;</span><span class="s1">prev</span><span class="s6">-&gt;</span><span class="s1">next = h</span><span class="s6">-&gt;</span><span class="s1">next;</span>
	<span class="s1">h</span><span class="s6">-&gt;</span><span class="s1">next</span><span class="s6">-&gt;</span><span class="s1">prev = h</span><span class="s6">-&gt;</span><span class="s1">prev;</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">Cache::lru_insert(head_t *h)</span>
<span class="s1">{</span>
	<span class="s0">// insert to last position</span>
	<span class="s1">h</span><span class="s6">-&gt;</span><span class="s1">next = &amp;lru_head;</span>
	<span class="s1">h</span><span class="s6">-&gt;</span><span class="s1">prev = lru_head.prev;</span>
	<span class="s1">h</span><span class="s6">-&gt;</span><span class="s1">prev</span><span class="s6">-&gt;</span><span class="s1">next = h;</span>
	<span class="s1">h</span><span class="s6">-&gt;</span><span class="s1">next</span><span class="s6">-&gt;</span><span class="s1">prev = h;</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">Cache::get_data(</span><span class="s2">const int </span><span class="s1">index, Qfloat **data, </span><span class="s2">int </span><span class="s1">len)</span>
<span class="s1">{</span>
	<span class="s1">head_t *h = &amp;head[index];</span>
	<span class="s2">if</span><span class="s1">(h</span><span class="s6">-&gt;</span><span class="s1">len) lru_delete(h);</span>
	<span class="s2">int </span><span class="s1">more = len - h</span><span class="s6">-&gt;</span><span class="s1">len;</span>

	<span class="s2">if</span><span class="s1">(more &gt; </span><span class="s5">0</span><span class="s1">)</span>
	<span class="s1">{</span>
		<span class="s0">// free old space</span>
		<span class="s2">while</span><span class="s1">(size &lt; more)</span>
		<span class="s1">{</span>
			<span class="s1">head_t *old = lru_head.next;</span>
			<span class="s1">lru_delete(old);</span>
			<span class="s1">free(old</span><span class="s6">-&gt;</span><span class="s1">data);</span>
			<span class="s1">size += old</span><span class="s6">-&gt;</span><span class="s1">len;</span>
			<span class="s1">old</span><span class="s6">-&gt;</span><span class="s1">data = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s1">old</span><span class="s6">-&gt;</span><span class="s1">len = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s1">}</span>

		<span class="s0">// allocate new space</span>
		<span class="s1">h</span><span class="s6">-&gt;</span><span class="s1">data = (Qfloat *)realloc(h</span><span class="s6">-&gt;</span><span class="s1">data,</span><span class="s2">sizeof</span><span class="s1">(Qfloat)*len);</span>
		<span class="s1">size -= more;</span>
		<span class="s1">swap(h</span><span class="s6">-&gt;</span><span class="s1">len,len);</span>
	<span class="s1">}</span>

	<span class="s1">lru_insert(h);</span>
	<span class="s1">*data = h</span><span class="s6">-&gt;</span><span class="s1">data;</span>
	<span class="s2">return </span><span class="s1">len;</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">Cache::swap_index(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">j)</span>
<span class="s1">{</span>
	<span class="s2">if</span><span class="s1">(i==j) </span><span class="s2">return</span><span class="s1">;</span>

	<span class="s2">if</span><span class="s1">(head[i].len) lru_delete(&amp;head[i]);</span>
	<span class="s2">if</span><span class="s1">(head[j].len) lru_delete(&amp;head[j]);</span>
	<span class="s1">swap(head[i].data,head[j].data);</span>
	<span class="s1">swap(head[i].len,head[j].len);</span>
	<span class="s2">if</span><span class="s1">(head[i].len) lru_insert(&amp;head[i]);</span>
	<span class="s2">if</span><span class="s1">(head[j].len) lru_insert(&amp;head[j]);</span>

	<span class="s2">if</span><span class="s1">(i&gt;j) swap(i,j);</span>
	<span class="s2">for</span><span class="s1">(head_t *h = lru_head.next; h!=&amp;lru_head; h=h</span><span class="s6">-&gt;</span><span class="s1">next)</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(h</span><span class="s6">-&gt;</span><span class="s1">len &gt; i)</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(h</span><span class="s6">-&gt;</span><span class="s1">len &gt; j)</span>
				<span class="s1">swap(h</span><span class="s6">-&gt;</span><span class="s1">data[i],h</span><span class="s6">-&gt;</span><span class="s1">data[j]);</span>
			<span class="s2">else</span>
			<span class="s1">{</span>
				<span class="s0">// give up</span>
				<span class="s1">lru_delete(h);</span>
				<span class="s1">free(h</span><span class="s6">-&gt;</span><span class="s1">data);</span>
				<span class="s1">size += h</span><span class="s6">-&gt;</span><span class="s1">len;</span>
				<span class="s1">h</span><span class="s6">-&gt;</span><span class="s1">data = </span><span class="s5">0</span><span class="s1">;</span>
				<span class="s1">h</span><span class="s6">-&gt;</span><span class="s1">len = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">//</span>
<span class="s0">// Kernel evaluation</span>
<span class="s0">//</span>
<span class="s0">// the static method k_function is for doing single kernel evaluation</span>
<span class="s0">// the constructor of Kernel prepares to calculate the l*l kernel matrix</span>
<span class="s0">// the member function get_Q is for getting one column from the Q Matrix</span>
<span class="s0">//</span>
<span class="s4">class </span><span class="s1">QMatrix {</span>
<span class="s4">public</span><span class="s1">:</span>
	<span class="s4">virtual </span><span class="s1">Qfloat *get_Q(</span><span class="s2">int </span><span class="s1">column, </span><span class="s2">int </span><span class="s1">len) </span><span class="s2">const </span><span class="s1">= </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s4">virtual </span><span class="s2">double </span><span class="s1">*get_QD() </span><span class="s2">const </span><span class="s1">= </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s4">virtual </span><span class="s2">void </span><span class="s1">swap_index(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">j) </span><span class="s2">const </span><span class="s1">= </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s4">virtual </span><span class="s1">~QMatrix() {}</span>
<span class="s1">};</span>

<span class="s4">class </span><span class="s1">Kernel: </span><span class="s4">public </span><span class="s1">QMatrix {</span>
<span class="s4">public</span><span class="s1">:</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
	<span class="s1">Kernel(</span><span class="s2">int </span><span class="s1">l, PREFIX(node) * x, </span><span class="s2">const </span><span class="s1">svm_parameter&amp; param, BlasFunctions *blas_functions);</span>
<span class="s2">#else</span>
	<span class="s1">Kernel(</span><span class="s2">int </span><span class="s1">l, PREFIX(node) * </span><span class="s2">const </span><span class="s1">* x, </span><span class="s2">const </span><span class="s1">svm_parameter&amp; param, BlasFunctions *blas_functions);</span>
<span class="s2">#endif</span>
	<span class="s4">virtual </span><span class="s1">~Kernel();</span>

	<span class="s2">static double </span><span class="s1">k_function(</span><span class="s2">const </span><span class="s1">PREFIX(node) *x, </span><span class="s2">const </span><span class="s1">PREFIX(node) *y,</span>
				 <span class="s2">const </span><span class="s1">svm_parameter&amp; param, BlasFunctions *blas_functions);</span>
	<span class="s4">virtual </span><span class="s1">Qfloat *get_Q(</span><span class="s2">int </span><span class="s1">column, </span><span class="s2">int </span><span class="s1">len) </span><span class="s2">const </span><span class="s1">= </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s4">virtual </span><span class="s2">double </span><span class="s1">*get_QD() </span><span class="s2">const </span><span class="s1">= </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s4">virtual </span><span class="s2">void </span><span class="s1">swap_index(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">j) </span><span class="s2">const	</span><span class="s0">// no so const...</span>
	<span class="s1">{</span>
		<span class="s1">swap(x[i],x[j]);</span>
		<span class="s2">if</span><span class="s1">(x_square) swap(x_square[i],x_square[j]);</span>
	<span class="s1">}</span>
<span class="s4">protected</span><span class="s1">:</span>

	<span class="s2">double </span><span class="s1">(Kernel::*kernel_function)(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">j) </span><span class="s2">const</span><span class="s1">;</span>

<span class="s4">private</span><span class="s1">:</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
	<span class="s1">PREFIX(node) *x;</span>
<span class="s2">#else</span>
	<span class="s2">const </span><span class="s1">PREFIX(node) **x;</span>
<span class="s2">#endif</span>
	<span class="s2">double </span><span class="s1">*x_square;</span>
	<span class="s0">// scipy blas pointer</span>
	<span class="s1">BlasFunctions *m_blas;</span>

	<span class="s0">// svm_parameter</span>
	<span class="s2">const int </span><span class="s1">kernel_type;</span>
	<span class="s2">const int </span><span class="s1">degree;</span>
	<span class="s2">const double </span><span class="s1">gamma;</span>
	<span class="s2">const double </span><span class="s1">coef0;</span>

	<span class="s2">static double </span><span class="s1">dot(</span><span class="s2">const </span><span class="s1">PREFIX(node) *px, </span><span class="s2">const </span><span class="s1">PREFIX(node) *py, BlasFunctions *blas_functions);</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
	<span class="s2">static double </span><span class="s1">dot(</span><span class="s2">const </span><span class="s1">PREFIX(node) &amp;px, </span><span class="s2">const </span><span class="s1">PREFIX(node) &amp;py, BlasFunctions *blas_functions);</span>
<span class="s2">#endif</span>

	<span class="s2">double </span><span class="s1">kernel_linear(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">j) </span><span class="s2">const</span>
	<span class="s1">{</span>
		<span class="s2">return </span><span class="s1">dot(x[i],x[j],m_blas);</span>
	<span class="s1">}</span>
	<span class="s2">double </span><span class="s1">kernel_poly(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">j) </span><span class="s2">const</span>
	<span class="s1">{</span>
		<span class="s2">return </span><span class="s1">powi(gamma*dot(x[i],x[j],m_blas)+coef0,degree);</span>
	<span class="s1">}</span>
	<span class="s2">double </span><span class="s1">kernel_rbf(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">j) </span><span class="s2">const</span>
	<span class="s1">{</span>
		<span class="s2">return </span><span class="s1">exp(-gamma*(x_square[i]+x_square[j]-</span><span class="s5">2</span><span class="s1">*dot(x[i],x[j],m_blas)));</span>
	<span class="s1">}</span>
	<span class="s2">double </span><span class="s1">kernel_sigmoid(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">j) </span><span class="s2">const</span>
	<span class="s1">{</span>
		<span class="s2">return </span><span class="s1">tanh(gamma*dot(x[i],x[j],m_blas)+coef0);</span>
	<span class="s1">}</span>
	<span class="s2">double </span><span class="s1">kernel_precomputed(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">j) </span><span class="s2">const</span>
	<span class="s1">{</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
		<span class="s2">return </span><span class="s1">(x+i)</span><span class="s6">-&gt;</span><span class="s1">values[x[j].ind];</span>
<span class="s2">#else</span>
		<span class="s2">return </span><span class="s1">x[i][(</span><span class="s2">int</span><span class="s1">)(x[j][</span><span class="s5">0</span><span class="s1">].value)].value;</span>
<span class="s2">#endif</span>
	<span class="s1">}</span>
<span class="s1">};</span>

<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
<span class="s1">Kernel::Kernel(</span><span class="s2">int </span><span class="s1">l, PREFIX(node) * x_, </span><span class="s2">const </span><span class="s1">svm_parameter&amp; param, BlasFunctions *blas_functions)</span>
<span class="s2">#else</span>
<span class="s1">Kernel::Kernel(</span><span class="s2">int </span><span class="s1">l, PREFIX(node) * </span><span class="s2">const </span><span class="s1">* x_, </span><span class="s2">const </span><span class="s1">svm_parameter&amp; param, BlasFunctions *blas_functions)</span>
<span class="s2">#endif</span>
<span class="s1">:kernel_type(param.kernel_type), degree(param.degree),</span>
 <span class="s1">gamma(param.gamma), coef0(param.coef0)</span>
<span class="s1">{</span>
	<span class="s1">m_blas = blas_functions;</span>
	<span class="s2">switch</span><span class="s1">(kernel_type)</span>
	<span class="s1">{</span>
		<span class="s2">case </span><span class="s1">LINEAR:</span>
			<span class="s1">kernel_function = &amp;Kernel::kernel_linear;</span>
			<span class="s2">break</span><span class="s1">;</span>
		<span class="s2">case </span><span class="s1">POLY:</span>
			<span class="s1">kernel_function = &amp;Kernel::kernel_poly;</span>
			<span class="s2">break</span><span class="s1">;</span>
		<span class="s2">case </span><span class="s1">RBF:</span>
			<span class="s1">kernel_function = &amp;Kernel::kernel_rbf;</span>
			<span class="s2">break</span><span class="s1">;</span>
		<span class="s2">case </span><span class="s1">SIGMOID:</span>
			<span class="s1">kernel_function = &amp;Kernel::kernel_sigmoid;</span>
			<span class="s2">break</span><span class="s1">;</span>
		<span class="s2">case </span><span class="s1">PRECOMPUTED:</span>
			<span class="s1">kernel_function = &amp;Kernel::kernel_precomputed;</span>
			<span class="s2">break</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">clone(x,x_,l);</span>

	<span class="s2">if</span><span class="s1">(kernel_type == RBF)</span>
	<span class="s1">{</span>
		<span class="s1">x_square = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
		<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
			<span class="s1">x_square[i] = dot(x[i],x[i],blas_functions);</span>
	<span class="s1">}</span>
	<span class="s2">else</span>
		<span class="s1">x_square = </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s1">Kernel::~Kernel()</span>
<span class="s1">{</span>
	<span class="s2">delete</span><span class="s1">[] x;</span>
	<span class="s2">delete</span><span class="s1">[] x_square;</span>
<span class="s1">}</span>

<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
<span class="s2">double </span><span class="s1">Kernel::dot(</span><span class="s2">const </span><span class="s1">PREFIX(node) *px, </span><span class="s2">const </span><span class="s1">PREFIX(node) *py, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s2">double </span><span class="s1">sum = </span><span class="s5">0</span><span class="s1">;</span>

	<span class="s2">int </span><span class="s1">dim = min(px</span><span class="s6">-&gt;</span><span class="s1">dim, py</span><span class="s6">-&gt;</span><span class="s1">dim);</span>
	<span class="s1">sum = blas_functions</span><span class="s6">-&gt;</span><span class="s1">dot(dim, px</span><span class="s6">-&gt;</span><span class="s1">values, </span><span class="s5">1</span><span class="s1">, py</span><span class="s6">-&gt;</span><span class="s1">values, </span><span class="s5">1</span><span class="s1">);</span>
	<span class="s2">return </span><span class="s1">sum;</span>
<span class="s1">}</span>

<span class="s2">double </span><span class="s1">Kernel::dot(</span><span class="s2">const </span><span class="s1">PREFIX(node) &amp;px, </span><span class="s2">const </span><span class="s1">PREFIX(node) &amp;py, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s2">double </span><span class="s1">sum = </span><span class="s5">0</span><span class="s1">;</span>

	<span class="s2">int </span><span class="s1">dim = min(px.dim, py.dim);</span>
	<span class="s1">sum = blas_functions</span><span class="s6">-&gt;</span><span class="s1">dot(dim, px.values, </span><span class="s5">1</span><span class="s1">, py.values, </span><span class="s5">1</span><span class="s1">);</span>
	<span class="s2">return </span><span class="s1">sum;</span>
<span class="s1">}</span>
<span class="s2">#else</span>
<span class="s2">double </span><span class="s1">Kernel::dot(</span><span class="s2">const </span><span class="s1">PREFIX(node) *px, </span><span class="s2">const </span><span class="s1">PREFIX(node) *py, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s2">double </span><span class="s1">sum = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">while</span><span class="s1">(px</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1 </span><span class="s1">&amp;&amp; py</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(px</span><span class="s6">-&gt;</span><span class="s1">index == py</span><span class="s6">-&gt;</span><span class="s1">index)</span>
		<span class="s1">{</span>
			<span class="s1">sum += px</span><span class="s6">-&gt;</span><span class="s1">value * py</span><span class="s6">-&gt;</span><span class="s1">value;</span>
			<span class="s1">++px;</span>
			<span class="s1">++py;</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(px</span><span class="s6">-&gt;</span><span class="s1">index &gt; py</span><span class="s6">-&gt;</span><span class="s1">index)</span>
				<span class="s1">++py;</span>
			<span class="s2">else</span>
				<span class="s1">++px;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s2">return </span><span class="s1">sum;</span>
<span class="s1">}</span>
<span class="s2">#endif</span>

<span class="s2">double </span><span class="s1">Kernel::k_function(</span><span class="s2">const </span><span class="s1">PREFIX(node) *x, </span><span class="s2">const </span><span class="s1">PREFIX(node) *y,</span>
			  <span class="s2">const </span><span class="s1">svm_parameter&amp; param, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s2">switch</span><span class="s1">(param.kernel_type)</span>
	<span class="s1">{</span>
		<span class="s2">case </span><span class="s1">LINEAR:</span>
			<span class="s2">return </span><span class="s1">dot(x,y,blas_functions);</span>
		<span class="s2">case </span><span class="s1">POLY:</span>
			<span class="s2">return </span><span class="s1">powi(param.gamma*dot(x,y,blas_functions)+param.coef0,param.degree);</span>
		<span class="s2">case </span><span class="s1">RBF:</span>
		<span class="s1">{</span>
			<span class="s2">double </span><span class="s1">sum = </span><span class="s5">0</span><span class="s1">;</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
			<span class="s2">int </span><span class="s1">dim = min(x</span><span class="s6">-&gt;</span><span class="s1">dim, y</span><span class="s6">-&gt;</span><span class="s1">dim), i;</span>
			<span class="s2">double</span><span class="s1">* m_array = (</span><span class="s2">double</span><span class="s1">*)malloc(</span><span class="s2">sizeof</span><span class="s1">(</span><span class="s2">double</span><span class="s1">)*dim);</span>
			<span class="s2">for </span><span class="s1">(i = </span><span class="s5">0</span><span class="s1">; i &lt; dim; i++)</span>
			<span class="s1">{</span>
				<span class="s1">m_array[i] = x</span><span class="s6">-&gt;</span><span class="s1">values[i] - y</span><span class="s6">-&gt;</span><span class="s1">values[i];</span>
			<span class="s1">}</span>
			<span class="s1">sum = blas_functions</span><span class="s6">-&gt;</span><span class="s1">dot(dim, m_array, </span><span class="s5">1</span><span class="s1">, m_array, </span><span class="s5">1</span><span class="s1">);</span>
			<span class="s1">free(m_array);</span>
			<span class="s2">for </span><span class="s1">(; i &lt; x</span><span class="s6">-&gt;</span><span class="s1">dim; i++)</span>
				<span class="s1">sum += x</span><span class="s6">-&gt;</span><span class="s1">values[i] * x</span><span class="s6">-&gt;</span><span class="s1">values[i];</span>
			<span class="s2">for </span><span class="s1">(; i &lt; y</span><span class="s6">-&gt;</span><span class="s1">dim; i++)</span>
				<span class="s1">sum += y</span><span class="s6">-&gt;</span><span class="s1">values[i] * y</span><span class="s6">-&gt;</span><span class="s1">values[i];</span>
<span class="s2">#else</span>
			<span class="s2">while</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1 </span><span class="s1">&amp;&amp; y</span><span class="s6">-&gt;</span><span class="s1">index !=-</span><span class="s5">1</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index == y</span><span class="s6">-&gt;</span><span class="s1">index)</span>
				<span class="s1">{</span>
					<span class="s2">double </span><span class="s1">d = x</span><span class="s6">-&gt;</span><span class="s1">value - y</span><span class="s6">-&gt;</span><span class="s1">value;</span>
					<span class="s1">sum += d*d;</span>
					<span class="s1">++x;</span>
					<span class="s1">++y;</span>
				<span class="s1">}</span>
				<span class="s2">else</span>
				<span class="s1">{</span>
					<span class="s2">if</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index &gt; y</span><span class="s6">-&gt;</span><span class="s1">index)</span>
					<span class="s1">{</span>
						<span class="s1">sum += y</span><span class="s6">-&gt;</span><span class="s1">value * y</span><span class="s6">-&gt;</span><span class="s1">value;</span>
						<span class="s1">++y;</span>
					<span class="s1">}</span>
					<span class="s2">else</span>
					<span class="s1">{</span>
						<span class="s1">sum += x</span><span class="s6">-&gt;</span><span class="s1">value * x</span><span class="s6">-&gt;</span><span class="s1">value;</span>
						<span class="s1">++x;</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">}</span>

			<span class="s2">while</span><span class="s1">(x</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s1">sum += x</span><span class="s6">-&gt;</span><span class="s1">value * x</span><span class="s6">-&gt;</span><span class="s1">value;</span>
				<span class="s1">++x;</span>
			<span class="s1">}</span>

			<span class="s2">while</span><span class="s1">(y</span><span class="s6">-&gt;</span><span class="s1">index != -</span><span class="s5">1</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s1">sum += y</span><span class="s6">-&gt;</span><span class="s1">value * y</span><span class="s6">-&gt;</span><span class="s1">value;</span>
				<span class="s1">++y;</span>
			<span class="s1">}</span>
<span class="s2">#endif</span>
			<span class="s2">return </span><span class="s1">exp(-param.gamma*sum);</span>
		<span class="s1">}</span>
		<span class="s2">case </span><span class="s1">SIGMOID:</span>
			<span class="s2">return </span><span class="s1">tanh(param.gamma*dot(x,y,blas_functions)+param.coef0);</span>
		<span class="s2">case </span><span class="s1">PRECOMPUTED:  </span><span class="s0">//x: test (validation), y: SV</span>
                    <span class="s1">{</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
			<span class="s2">return </span><span class="s1">x</span><span class="s6">-&gt;</span><span class="s1">values[y</span><span class="s6">-&gt;</span><span class="s1">ind];</span>
<span class="s2">#else</span>
			<span class="s2">return </span><span class="s1">x[(</span><span class="s2">int</span><span class="s1">)(y</span><span class="s6">-&gt;</span><span class="s1">value)].value;</span>
<span class="s2">#endif</span>
                    <span class="s1">}</span>
		<span class="s2">default</span><span class="s1">:</span>
			<span class="s2">return </span><span class="s5">0</span><span class="s1">;  </span><span class="s0">// Unreachable</span>
	<span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">// An SMO algorithm in Fan et al., JMLR 6(2005), p. 1889--1918</span>
<span class="s0">// Solves:</span>
<span class="s0">//</span>
<span class="s0">//  min 0.5(\alpha^T Q \alpha) + p^T \alpha</span>
<span class="s0">//</span>
<span class="s0">//      y^T \alpha = \delta</span>
<span class="s0">//      y_i = +1 or -1</span>
<span class="s0">//      0 &lt;= alpha_i &lt;= Cp for y_i = 1</span>
<span class="s0">//      0 &lt;= alpha_i &lt;= Cn for y_i = -1</span>
<span class="s0">//</span>
<span class="s0">// Given:</span>
<span class="s0">//</span>
<span class="s0">//  Q, p, y, Cp, Cn, and an initial feasible point \alpha</span>
<span class="s0">//  l is the size of vectors and matrices</span>
<span class="s0">//  eps is the stopping tolerance</span>
<span class="s0">//</span>
<span class="s0">// solution will be put in \alpha, objective value will be put in obj</span>
<span class="s0">//</span>

<span class="s4">class </span><span class="s1">Solver {</span>
<span class="s4">public</span><span class="s1">:</span>
	<span class="s1">Solver() {};</span>
	<span class="s4">virtual </span><span class="s1">~Solver() {};</span>

	<span class="s2">struct </span><span class="s1">SolutionInfo {</span>
		<span class="s2">double </span><span class="s1">obj;</span>
		<span class="s2">double </span><span class="s1">rho;</span>
                <span class="s2">double </span><span class="s1">*upper_bound;</span>
		<span class="s2">double </span><span class="s1">r;	</span><span class="s0">// for Solver_NU</span>
                <span class="s2">bool </span><span class="s1">solve_timed_out;</span>
		<span class="s2">int </span><span class="s1">n_iter;</span>
	<span class="s1">};</span>

	<span class="s2">void </span><span class="s1">Solve(</span><span class="s2">int </span><span class="s1">l, </span><span class="s2">const </span><span class="s1">QMatrix&amp; Q, </span><span class="s2">const double </span><span class="s1">*p_, </span><span class="s2">const </span><span class="s1">schar *y_,</span>
		   <span class="s2">double </span><span class="s1">*alpha_, </span><span class="s2">const double </span><span class="s1">*C_, </span><span class="s2">double </span><span class="s1">eps,</span>
		   <span class="s1">SolutionInfo* si, </span><span class="s2">int </span><span class="s1">shrinking, </span><span class="s2">int </span><span class="s1">max_iter);</span>
<span class="s4">protected</span><span class="s1">:</span>
	<span class="s2">int </span><span class="s1">active_size;</span>
	<span class="s1">schar *y;</span>
	<span class="s2">double </span><span class="s1">*G;		</span><span class="s0">// gradient of objective function</span>
	<span class="s2">enum </span><span class="s1">{ LOWER_BOUND, UPPER_BOUND, FREE };</span>
	<span class="s2">char </span><span class="s1">*alpha_status;	</span><span class="s0">// LOWER_BOUND, UPPER_BOUND, FREE</span>
	<span class="s2">double </span><span class="s1">*alpha;</span>
	<span class="s2">const </span><span class="s1">QMatrix *Q;</span>
	<span class="s2">const double </span><span class="s1">*QD;</span>
	<span class="s2">double </span><span class="s1">eps;</span>
	<span class="s2">double </span><span class="s1">Cp,Cn;</span>
        <span class="s2">double </span><span class="s1">*C;</span>
	<span class="s2">double </span><span class="s1">*p;</span>
	<span class="s2">int </span><span class="s1">*active_set;</span>
	<span class="s2">double </span><span class="s1">*G_bar;		</span><span class="s0">// gradient, if we treat free variables as 0</span>
	<span class="s2">int </span><span class="s1">l;</span>
	<span class="s2">bool </span><span class="s1">unshrink;	</span><span class="s0">// XXX</span>

	<span class="s2">double </span><span class="s1">get_C(</span><span class="s2">int </span><span class="s1">i)</span>
	<span class="s1">{</span>
		<span class="s2">return </span><span class="s1">C[i];</span>
	<span class="s1">}</span>
	<span class="s2">void </span><span class="s1">update_alpha_status(</span><span class="s2">int </span><span class="s1">i)</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(alpha[i] &gt;= get_C(i))</span>
			<span class="s1">alpha_status[i] = UPPER_BOUND;</span>
		<span class="s2">else if</span><span class="s1">(alpha[i] &lt;= </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">alpha_status[i] = LOWER_BOUND;</span>
		<span class="s2">else </span><span class="s1">alpha_status[i] = FREE;</span>
	<span class="s1">}</span>
	<span class="s2">bool </span><span class="s1">is_upper_bound(</span><span class="s2">int </span><span class="s1">i) { </span><span class="s2">return </span><span class="s1">alpha_status[i] == UPPER_BOUND; }</span>
	<span class="s2">bool </span><span class="s1">is_lower_bound(</span><span class="s2">int </span><span class="s1">i) { </span><span class="s2">return </span><span class="s1">alpha_status[i] == LOWER_BOUND; }</span>
	<span class="s2">bool </span><span class="s1">is_free(</span><span class="s2">int </span><span class="s1">i) { </span><span class="s2">return </span><span class="s1">alpha_status[i] == FREE; }</span>
	<span class="s2">void </span><span class="s1">swap_index(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">j);</span>
	<span class="s2">void </span><span class="s1">reconstruct_gradient();</span>
	<span class="s4">virtual </span><span class="s2">int </span><span class="s1">select_working_set(</span><span class="s2">int </span><span class="s1">&amp;i, </span><span class="s2">int </span><span class="s1">&amp;j);</span>
	<span class="s4">virtual </span><span class="s2">double </span><span class="s1">calculate_rho();</span>
	<span class="s4">virtual </span><span class="s2">void </span><span class="s1">do_shrinking();</span>
<span class="s4">private</span><span class="s1">:</span>
	<span class="s2">bool </span><span class="s1">be_shrunk(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">double </span><span class="s1">Gmax1, </span><span class="s2">double </span><span class="s1">Gmax2);</span>
<span class="s1">};</span>

<span class="s2">void </span><span class="s1">Solver::swap_index(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">j)</span>
<span class="s1">{</span>
	<span class="s1">Q</span><span class="s6">-&gt;</span><span class="s1">swap_index(i,j);</span>
	<span class="s1">swap(y[i],y[j]);</span>
	<span class="s1">swap(G[i],G[j]);</span>
	<span class="s1">swap(alpha_status[i],alpha_status[j]);</span>
	<span class="s1">swap(alpha[i],alpha[j]);</span>
	<span class="s1">swap(p[i],p[j]);</span>
	<span class="s1">swap(active_set[i],active_set[j]);</span>
	<span class="s1">swap(G_bar[i],G_bar[j]);</span>
        <span class="s1">swap(C[i], C[j]);</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">Solver::reconstruct_gradient()</span>
<span class="s1">{</span>
	<span class="s0">// reconstruct inactive elements of G from G_bar and free variables</span>

	<span class="s2">if</span><span class="s1">(active_size == l) </span><span class="s2">return</span><span class="s1">;</span>

	<span class="s2">int </span><span class="s1">i,j;</span>
	<span class="s2">int </span><span class="s1">nr_free = </span><span class="s5">0</span><span class="s1">;</span>

	<span class="s2">for</span><span class="s1">(j=active_size;j&lt;l;j++)</span>
		<span class="s1">G[j] = G_bar[j] + p[j];</span>

	<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;active_size;j++)</span>
		<span class="s2">if</span><span class="s1">(is_free(j))</span>
			<span class="s1">nr_free++;</span>

	<span class="s2">if</span><span class="s1">(</span><span class="s5">2</span><span class="s1">*nr_free &lt; active_size)</span>
		<span class="s1">info(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">Warning: using -h 0 may be faster</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>

	<span class="s2">if </span><span class="s1">(nr_free*l &gt; </span><span class="s5">2</span><span class="s1">*active_size*(l-active_size))</span>
	<span class="s1">{</span>
		<span class="s2">for</span><span class="s1">(i=active_size;i&lt;l;i++)</span>
		<span class="s1">{</span>
			<span class="s2">const </span><span class="s1">Qfloat *Q_i = Q</span><span class="s6">-&gt;</span><span class="s1">get_Q(i,active_size);</span>
			<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;active_size;j++)</span>
				<span class="s2">if</span><span class="s1">(is_free(j))</span>
					<span class="s1">G[i] += alpha[j] * Q_i[j];</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s2">else</span>
	<span class="s1">{</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;active_size;i++)</span>
			<span class="s2">if</span><span class="s1">(is_free(i))</span>
			<span class="s1">{</span>
				<span class="s2">const </span><span class="s1">Qfloat *Q_i = Q</span><span class="s6">-&gt;</span><span class="s1">get_Q(i,l);</span>
				<span class="s2">double </span><span class="s1">alpha_i = alpha[i];</span>
				<span class="s2">for</span><span class="s1">(j=active_size;j&lt;l;j++)</span>
					<span class="s1">G[j] += alpha_i * Q_i[j];</span>
			<span class="s1">}</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">Solver::Solve(</span><span class="s2">int </span><span class="s1">l, </span><span class="s2">const </span><span class="s1">QMatrix&amp; Q, </span><span class="s2">const double </span><span class="s1">*p_, </span><span class="s2">const </span><span class="s1">schar *y_,</span>
		   <span class="s2">double </span><span class="s1">*alpha_, </span><span class="s2">const double </span><span class="s1">*C_, </span><span class="s2">double </span><span class="s1">eps,</span>
		   <span class="s1">SolutionInfo* si, </span><span class="s2">int </span><span class="s1">shrinking, </span><span class="s2">int </span><span class="s1">max_iter)</span>
<span class="s1">{</span>
	<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">l = l;</span>
	<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">Q = &amp;Q;</span>
	<span class="s1">QD=Q.get_QD();</span>
	<span class="s1">clone(p, p_,l);</span>
	<span class="s1">clone(y, y_,l);</span>
	<span class="s1">clone(alpha,alpha_,l);</span>
        <span class="s1">clone(C, C_, l);</span>
	<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">eps = eps;</span>
	<span class="s1">unshrink = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">si</span><span class="s6">-&gt;</span><span class="s1">solve_timed_out = </span><span class="s2">false</span><span class="s1">;</span>

	<span class="s0">// initialize alpha_status</span>
	<span class="s1">{</span>
		<span class="s1">alpha_status = </span><span class="s4">new </span><span class="s2">char</span><span class="s1">[l];</span>
		<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
			<span class="s1">update_alpha_status(i);</span>
	<span class="s1">}</span>

	<span class="s0">// initialize active set (for shrinking)</span>
	<span class="s1">{</span>
		<span class="s1">active_set = </span><span class="s4">new </span><span class="s2">int</span><span class="s1">[l];</span>
		<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
			<span class="s1">active_set[i] = i;</span>
		<span class="s1">active_size = l;</span>
	<span class="s1">}</span>

	<span class="s0">// initialize gradient</span>
	<span class="s1">{</span>
		<span class="s1">G = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
		<span class="s1">G_bar = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
		<span class="s2">int </span><span class="s1">i;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
		<span class="s1">{</span>
			<span class="s1">G[i] = p[i];</span>
			<span class="s1">G_bar[i] = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s1">}</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
			<span class="s2">if</span><span class="s1">(!is_lower_bound(i))</span>
			<span class="s1">{</span>
				<span class="s2">const </span><span class="s1">Qfloat *Q_i = Q.get_Q(i,l);</span>
				<span class="s2">double </span><span class="s1">alpha_i = alpha[i];</span>
				<span class="s2">int </span><span class="s1">j;</span>
				<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;l;j++)</span>
					<span class="s1">G[j] += alpha_i*Q_i[j];</span>
				<span class="s2">if</span><span class="s1">(is_upper_bound(i))</span>
					<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;l;j++)</span>
						<span class="s1">G_bar[j] += get_C(i) * Q_i[j];</span>
			<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s0">// optimization step</span>

	<span class="s2">int </span><span class="s1">iter = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">counter = min(l,</span><span class="s5">1000</span><span class="s1">)+</span><span class="s5">1</span><span class="s1">;</span>

	<span class="s2">while</span><span class="s1">(</span><span class="s5">1</span><span class="s1">)</span>
	<span class="s1">{</span>
                <span class="s0">// set max_iter to -1 to disable the mechanism</span>
                <span class="s2">if </span><span class="s1">((max_iter != -</span><span class="s5">1</span><span class="s1">) &amp;&amp; (iter &gt;= max_iter)) {</span>
                    <span class="s1">info(</span><span class="s3">&quot;WARN: libsvm Solver reached max_iter&quot;</span><span class="s1">);</span>
                    <span class="s1">si</span><span class="s6">-&gt;</span><span class="s1">solve_timed_out = </span><span class="s4">true</span><span class="s1">;</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>

		<span class="s0">// show progress and do shrinking</span>

		<span class="s2">if</span><span class="s1">(--counter == </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">counter = min(l,</span><span class="s5">1000</span><span class="s1">);</span>
			<span class="s2">if</span><span class="s1">(shrinking) do_shrinking();</span>
			<span class="s1">info(</span><span class="s3">&quot;.&quot;</span><span class="s1">);</span>
		<span class="s1">}</span>

		<span class="s2">int </span><span class="s1">i,j;</span>
		<span class="s2">if</span><span class="s1">(select_working_set(i,j)!=</span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s0">// reconstruct the whole gradient</span>
			<span class="s1">reconstruct_gradient();</span>
			<span class="s0">// reset active set size and check</span>
			<span class="s1">active_size = l;</span>
			<span class="s1">info(</span><span class="s3">&quot;*&quot;</span><span class="s1">);</span>
			<span class="s2">if</span><span class="s1">(select_working_set(i,j)!=</span><span class="s5">0</span><span class="s1">)</span>
				<span class="s2">break</span><span class="s1">;</span>
			<span class="s2">else</span>
				<span class="s1">counter = </span><span class="s5">1</span><span class="s1">;	</span><span class="s0">// do shrinking next iteration</span>
		<span class="s1">}</span>

		<span class="s1">++iter;</span>

		<span class="s0">// update alpha[i] and alpha[j], handle bounds carefully</span>

		<span class="s2">const </span><span class="s1">Qfloat *Q_i = Q.get_Q(i,active_size);</span>
		<span class="s2">const </span><span class="s1">Qfloat *Q_j = Q.get_Q(j,active_size);</span>

		<span class="s2">double </span><span class="s1">C_i = get_C(i);</span>
		<span class="s2">double </span><span class="s1">C_j = get_C(j);</span>

		<span class="s2">double </span><span class="s1">old_alpha_i = alpha[i];</span>
		<span class="s2">double </span><span class="s1">old_alpha_j = alpha[j];</span>

		<span class="s2">if</span><span class="s1">(y[i]!=y[j])</span>
		<span class="s1">{</span>
			<span class="s2">double </span><span class="s1">quad_coef = QD[i]+QD[j]+</span><span class="s5">2</span><span class="s1">*Q_i[j];</span>
			<span class="s2">if </span><span class="s1">(quad_coef &lt;= </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">quad_coef = TAU;</span>
			<span class="s2">double </span><span class="s1">delta = (-G[i]-G[j])/quad_coef;</span>
			<span class="s2">double </span><span class="s1">diff = alpha[i] - alpha[j];</span>
			<span class="s1">alpha[i] += delta;</span>
			<span class="s1">alpha[j] += delta;</span>

			<span class="s2">if</span><span class="s1">(diff &gt; </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(alpha[j] &lt; </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s1">alpha[j] = </span><span class="s5">0</span><span class="s1">;</span>
					<span class="s1">alpha[i] = diff;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s2">else</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(alpha[i] &lt; </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s1">alpha[i] = </span><span class="s5">0</span><span class="s1">;</span>
					<span class="s1">alpha[j] = -diff;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s2">if</span><span class="s1">(diff &gt; C_i - C_j)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(alpha[i] &gt; C_i)</span>
				<span class="s1">{</span>
					<span class="s1">alpha[i] = C_i;</span>
					<span class="s1">alpha[j] = C_i - diff;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s2">else</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(alpha[j] &gt; C_j)</span>
				<span class="s1">{</span>
					<span class="s1">alpha[j] = C_j;</span>
					<span class="s1">alpha[i] = C_j + diff;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s2">double </span><span class="s1">quad_coef = QD[i]+QD[j]-</span><span class="s5">2</span><span class="s1">*Q_i[j];</span>
			<span class="s2">if </span><span class="s1">(quad_coef &lt;= </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">quad_coef = TAU;</span>
			<span class="s2">double </span><span class="s1">delta = (G[i]-G[j])/quad_coef;</span>
			<span class="s2">double </span><span class="s1">sum = alpha[i] + alpha[j];</span>
			<span class="s1">alpha[i] -= delta;</span>
			<span class="s1">alpha[j] += delta;</span>

			<span class="s2">if</span><span class="s1">(sum &gt; C_i)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(alpha[i] &gt; C_i)</span>
				<span class="s1">{</span>
					<span class="s1">alpha[i] = C_i;</span>
					<span class="s1">alpha[j] = sum - C_i;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s2">else</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(alpha[j] &lt; </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s1">alpha[j] = </span><span class="s5">0</span><span class="s1">;</span>
					<span class="s1">alpha[i] = sum;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s2">if</span><span class="s1">(sum &gt; C_j)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(alpha[j] &gt; C_j)</span>
				<span class="s1">{</span>
					<span class="s1">alpha[j] = C_j;</span>
					<span class="s1">alpha[i] = sum - C_j;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s2">else</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(alpha[i] &lt; </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s1">alpha[i] = </span><span class="s5">0</span><span class="s1">;</span>
					<span class="s1">alpha[j] = sum;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s0">// update G</span>

		<span class="s2">double </span><span class="s1">delta_alpha_i = alpha[i] - old_alpha_i;</span>
		<span class="s2">double </span><span class="s1">delta_alpha_j = alpha[j] - old_alpha_j;</span>

		<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">k=</span><span class="s5">0</span><span class="s1">;k&lt;active_size;k++)</span>
		<span class="s1">{</span>
			<span class="s1">G[k] += Q_i[k]*delta_alpha_i + Q_j[k]*delta_alpha_j;</span>
		<span class="s1">}</span>

		<span class="s0">// update alpha_status and G_bar</span>

		<span class="s1">{</span>
			<span class="s2">bool </span><span class="s1">ui = is_upper_bound(i);</span>
			<span class="s2">bool </span><span class="s1">uj = is_upper_bound(j);</span>
			<span class="s1">update_alpha_status(i);</span>
			<span class="s1">update_alpha_status(j);</span>
			<span class="s2">int </span><span class="s1">k;</span>
			<span class="s2">if</span><span class="s1">(ui != is_upper_bound(i))</span>
			<span class="s1">{</span>
				<span class="s1">Q_i = Q.get_Q(i,l);</span>
				<span class="s2">if</span><span class="s1">(ui)</span>
					<span class="s2">for</span><span class="s1">(k=</span><span class="s5">0</span><span class="s1">;k&lt;l;k++)</span>
						<span class="s1">G_bar[k] -= C_i * Q_i[k];</span>
				<span class="s2">else</span>
					<span class="s2">for</span><span class="s1">(k=</span><span class="s5">0</span><span class="s1">;k&lt;l;k++)</span>
						<span class="s1">G_bar[k] += C_i * Q_i[k];</span>
			<span class="s1">}</span>

			<span class="s2">if</span><span class="s1">(uj != is_upper_bound(j))</span>
			<span class="s1">{</span>
				<span class="s1">Q_j = Q.get_Q(j,l);</span>
				<span class="s2">if</span><span class="s1">(uj)</span>
					<span class="s2">for</span><span class="s1">(k=</span><span class="s5">0</span><span class="s1">;k&lt;l;k++)</span>
						<span class="s1">G_bar[k] -= C_j * Q_j[k];</span>
				<span class="s2">else</span>
					<span class="s2">for</span><span class="s1">(k=</span><span class="s5">0</span><span class="s1">;k&lt;l;k++)</span>
						<span class="s1">G_bar[k] += C_j * Q_j[k];</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s0">// calculate rho</span>

	<span class="s1">si</span><span class="s6">-&gt;</span><span class="s1">rho = calculate_rho();</span>

	<span class="s0">// calculate objective value</span>
	<span class="s1">{</span>
		<span class="s2">double </span><span class="s1">v = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">int </span><span class="s1">i;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
			<span class="s1">v += alpha[i] * (G[i] + p[i]);</span>

		<span class="s1">si</span><span class="s6">-&gt;</span><span class="s1">obj = v/</span><span class="s5">2</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s0">// put back the solution</span>
	<span class="s1">{</span>
		<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
			<span class="s1">alpha_[active_set[i]] = alpha[i];</span>
	<span class="s1">}</span>

	<span class="s0">// juggle everything back</span>
	<span class="s0">/*{ 
        for(int i=0;i&lt;l;i++) 
            while(active_set[i] != i) 
                swap_index(i,active_set[i]); 
                // or Q.swap_index(i,active_set[i]); 
    }*/</span>

	<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
		<span class="s1">si</span><span class="s6">-&gt;</span><span class="s1">upper_bound[i] = C[i];</span>

	<span class="s0">// store number of iterations</span>
	<span class="s1">si</span><span class="s6">-&gt;</span><span class="s1">n_iter = iter;</span>

	<span class="s1">info(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">optimization finished, #iter = %d</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">,iter);</span>

	<span class="s2">delete</span><span class="s1">[] p;</span>
	<span class="s2">delete</span><span class="s1">[] y;</span>
	<span class="s2">delete</span><span class="s1">[] alpha;</span>
	<span class="s2">delete</span><span class="s1">[] alpha_status;</span>
	<span class="s2">delete</span><span class="s1">[] active_set;</span>
	<span class="s2">delete</span><span class="s1">[] G;</span>
	<span class="s2">delete</span><span class="s1">[] G_bar;</span>
	<span class="s2">delete</span><span class="s1">[] C;</span>
<span class="s1">}</span>

<span class="s0">// return 1 if already optimal, return 0 otherwise</span>
<span class="s2">int </span><span class="s1">Solver::select_working_set(</span><span class="s2">int </span><span class="s1">&amp;out_i, </span><span class="s2">int </span><span class="s1">&amp;out_j)</span>
<span class="s1">{</span>
	<span class="s0">// return i,j such that</span>
	<span class="s0">// i: maximizes -y_i * grad(f)_i, i in I_up(\alpha)</span>
	<span class="s0">// j: minimizes the decrease of obj value</span>
	<span class="s0">//    (if quadratic coefficient &lt;= 0, replace it with tau)</span>
	<span class="s0">//    -y_j*grad(f)_j &lt; -y_i*grad(f)_i, j in I_low(\alpha)</span>

	<span class="s2">double </span><span class="s1">Gmax = -INF;</span>
	<span class="s2">double </span><span class="s1">Gmax2 = -INF;</span>
	<span class="s2">int </span><span class="s1">Gmax_idx = -</span><span class="s5">1</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">Gmin_idx = -</span><span class="s5">1</span><span class="s1">;</span>
	<span class="s2">double </span><span class="s1">obj_diff_min = INF;</span>

	<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">t=</span><span class="s5">0</span><span class="s1">;t&lt;active_size;t++)</span>
		<span class="s2">if</span><span class="s1">(y[t]==+</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(!is_upper_bound(t))</span>
				<span class="s2">if</span><span class="s1">(-G[t] &gt;= Gmax)</span>
				<span class="s1">{</span>
					<span class="s1">Gmax = -G[t];</span>
					<span class="s1">Gmax_idx = t;</span>
				<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(!is_lower_bound(t))</span>
				<span class="s2">if</span><span class="s1">(G[t] &gt;= Gmax)</span>
				<span class="s1">{</span>
					<span class="s1">Gmax = G[t];</span>
					<span class="s1">Gmax_idx = t;</span>
				<span class="s1">}</span>
		<span class="s1">}</span>

	<span class="s2">int </span><span class="s1">i = Gmax_idx;</span>
	<span class="s2">const </span><span class="s1">Qfloat *Q_i = NULL;</span>
	<span class="s2">if</span><span class="s1">(i != -</span><span class="s5">1</span><span class="s1">) </span><span class="s0">// NULL Q_i not accessed: Gmax=-INF if i=-1</span>
		<span class="s1">Q_i = Q</span><span class="s6">-&gt;</span><span class="s1">get_Q(i,active_size);</span>

	<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">j=</span><span class="s5">0</span><span class="s1">;j&lt;active_size;j++)</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(y[j]==+</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s2">if </span><span class="s1">(!is_lower_bound(j))</span>
			<span class="s1">{</span>
				<span class="s2">double </span><span class="s1">grad_diff=Gmax+G[j];</span>
				<span class="s2">if </span><span class="s1">(G[j] &gt;= Gmax2)</span>
					<span class="s1">Gmax2 = G[j];</span>
				<span class="s2">if </span><span class="s1">(grad_diff &gt; </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s2">double </span><span class="s1">obj_diff;</span>
					<span class="s2">double </span><span class="s1">quad_coef = QD[i]+QD[j]-</span><span class="s5">2.0</span><span class="s1">*y[i]*Q_i[j];</span>
					<span class="s2">if </span><span class="s1">(quad_coef &gt; </span><span class="s5">0</span><span class="s1">)</span>
						<span class="s1">obj_diff = -(grad_diff*grad_diff)/quad_coef;</span>
					<span class="s2">else</span>
						<span class="s1">obj_diff = -(grad_diff*grad_diff)/TAU;</span>

					<span class="s2">if </span><span class="s1">(obj_diff &lt;= obj_diff_min)</span>
					<span class="s1">{</span>
						<span class="s1">Gmin_idx=j;</span>
						<span class="s1">obj_diff_min = obj_diff;</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s2">if </span><span class="s1">(!is_upper_bound(j))</span>
			<span class="s1">{</span>
				<span class="s2">double </span><span class="s1">grad_diff= Gmax-G[j];</span>
				<span class="s2">if </span><span class="s1">(-G[j] &gt;= Gmax2)</span>
					<span class="s1">Gmax2 = -G[j];</span>
				<span class="s2">if </span><span class="s1">(grad_diff &gt; </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s2">double </span><span class="s1">obj_diff;</span>
					<span class="s2">double </span><span class="s1">quad_coef = QD[i]+QD[j]+</span><span class="s5">2.0</span><span class="s1">*y[i]*Q_i[j];</span>
					<span class="s2">if </span><span class="s1">(quad_coef &gt; </span><span class="s5">0</span><span class="s1">)</span>
						<span class="s1">obj_diff = -(grad_diff*grad_diff)/quad_coef;</span>
					<span class="s2">else</span>
						<span class="s1">obj_diff = -(grad_diff*grad_diff)/TAU;</span>

					<span class="s2">if </span><span class="s1">(obj_diff &lt;= obj_diff_min)</span>
					<span class="s1">{</span>
						<span class="s1">Gmin_idx=j;</span>
						<span class="s1">obj_diff_min = obj_diff;</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s2">if</span><span class="s1">(Gmax+Gmax2 &lt; eps || Gmin_idx == -</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s2">return </span><span class="s5">1</span><span class="s1">;</span>

	<span class="s1">out_i = Gmax_idx;</span>
	<span class="s1">out_j = Gmin_idx;</span>
	<span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">bool </span><span class="s1">Solver::be_shrunk(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">double </span><span class="s1">Gmax1, </span><span class="s2">double </span><span class="s1">Gmax2)</span>
<span class="s1">{</span>
	<span class="s2">if</span><span class="s1">(is_upper_bound(i))</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(y[i]==+</span><span class="s5">1</span><span class="s1">)</span>
			<span class="s2">return</span><span class="s1">(-G[i] &gt; Gmax1);</span>
		<span class="s2">else</span>
			<span class="s2">return</span><span class="s1">(-G[i] &gt; Gmax2);</span>
	<span class="s1">}</span>
	<span class="s2">else if</span><span class="s1">(is_lower_bound(i))</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(y[i]==+</span><span class="s5">1</span><span class="s1">)</span>
			<span class="s2">return</span><span class="s1">(G[i] &gt; Gmax2);</span>
		<span class="s2">else</span>
			<span class="s2">return</span><span class="s1">(G[i] &gt; Gmax1);</span>
	<span class="s1">}</span>
	<span class="s2">else</span>
		<span class="s2">return</span><span class="s1">(</span><span class="s2">false</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">Solver::do_shrinking()</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">double </span><span class="s1">Gmax1 = -INF;		</span><span class="s0">// max { -y_i * grad(f)_i | i in I_up(\alpha) }</span>
	<span class="s2">double </span><span class="s1">Gmax2 = -INF;		</span><span class="s0">// max { y_i * grad(f)_i | i in I_low(\alpha) }</span>

	<span class="s0">// find maximal violating pair first</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;active_size;i++)</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(y[i]==+</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(!is_upper_bound(i))</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(-G[i] &gt;= Gmax1)</span>
					<span class="s1">Gmax1 = -G[i];</span>
			<span class="s1">}</span>
			<span class="s2">if</span><span class="s1">(!is_lower_bound(i))</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(G[i] &gt;= Gmax2)</span>
					<span class="s1">Gmax2 = G[i];</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(!is_upper_bound(i))</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(-G[i] &gt;= Gmax2)</span>
					<span class="s1">Gmax2 = -G[i];</span>
			<span class="s1">}</span>
			<span class="s2">if</span><span class="s1">(!is_lower_bound(i))</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(G[i] &gt;= Gmax1)</span>
					<span class="s1">Gmax1 = G[i];</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s2">if</span><span class="s1">(unshrink == </span><span class="s2">false </span><span class="s1">&amp;&amp; Gmax1 + Gmax2 &lt;= eps*</span><span class="s5">10</span><span class="s1">)</span>
	<span class="s1">{</span>
		<span class="s1">unshrink = </span><span class="s4">true</span><span class="s1">;</span>
		<span class="s1">reconstruct_gradient();</span>
		<span class="s1">active_size = l;</span>
		<span class="s1">info(</span><span class="s3">&quot;*&quot;</span><span class="s1">);</span>
	<span class="s1">}</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;active_size;i++)</span>
		<span class="s2">if </span><span class="s1">(be_shrunk(i, Gmax1, Gmax2))</span>
		<span class="s1">{</span>
			<span class="s1">active_size--;</span>
			<span class="s2">while </span><span class="s1">(active_size &gt; i)</span>
			<span class="s1">{</span>
				<span class="s2">if </span><span class="s1">(!be_shrunk(active_size, Gmax1, Gmax2))</span>
				<span class="s1">{</span>
					<span class="s1">swap_index(i,active_size);</span>
					<span class="s2">break</span><span class="s1">;</span>
				<span class="s1">}</span>
				<span class="s1">active_size--;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">double </span><span class="s1">Solver::calculate_rho()</span>
<span class="s1">{</span>
	<span class="s2">double </span><span class="s1">r;</span>
	<span class="s2">int </span><span class="s1">nr_free = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">double </span><span class="s1">ub = INF, lb = -INF, sum_free = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">;i&lt;active_size;i++)</span>
	<span class="s1">{</span>
		<span class="s2">double </span><span class="s1">yG = y[i]*G[i];</span>

		<span class="s2">if</span><span class="s1">(is_upper_bound(i))</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(y[i]==-</span><span class="s5">1</span><span class="s1">)</span>
				<span class="s1">ub = min(ub,yG);</span>
			<span class="s2">else</span>
				<span class="s1">lb = max(lb,yG);</span>
		<span class="s1">}</span>
		<span class="s2">else if</span><span class="s1">(is_lower_bound(i))</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(y[i]==+</span><span class="s5">1</span><span class="s1">)</span>
				<span class="s1">ub = min(ub,yG);</span>
			<span class="s2">else</span>
				<span class="s1">lb = max(lb,yG);</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s1">++nr_free;</span>
			<span class="s1">sum_free += yG;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s2">if</span><span class="s1">(nr_free&gt;</span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">r = sum_free/nr_free;</span>
	<span class="s2">else</span>
		<span class="s1">r = (ub+lb)/</span><span class="s5">2</span><span class="s1">;</span>

	<span class="s2">return </span><span class="s1">r;</span>
<span class="s1">}</span>

<span class="s0">//</span>
<span class="s0">// Solver for nu-svm classification and regression</span>
<span class="s0">//</span>
<span class="s0">// additional constraint: e^T \alpha = constant</span>
<span class="s0">//</span>
<span class="s4">class </span><span class="s1">Solver_NU : </span><span class="s4">public </span><span class="s1">Solver</span>
<span class="s1">{</span>
<span class="s4">public</span><span class="s1">:</span>
	<span class="s1">Solver_NU() {}</span>
	<span class="s2">void </span><span class="s1">Solve(</span><span class="s2">int </span><span class="s1">l, </span><span class="s2">const </span><span class="s1">QMatrix&amp; Q, </span><span class="s2">const double </span><span class="s1">*p, </span><span class="s2">const </span><span class="s1">schar *y,</span>
		   <span class="s2">double </span><span class="s1">*alpha, </span><span class="s2">const double </span><span class="s1">*C_, </span><span class="s2">double </span><span class="s1">eps,</span>
		   <span class="s1">SolutionInfo* si, </span><span class="s2">int </span><span class="s1">shrinking, </span><span class="s2">int </span><span class="s1">max_iter)</span>
	<span class="s1">{</span>
		<span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">si = si;</span>
		<span class="s1">Solver::Solve(l,Q,p,y,alpha,C_,eps,si,shrinking,max_iter);</span>
	<span class="s1">}</span>
<span class="s4">private</span><span class="s1">:</span>
	<span class="s1">SolutionInfo *si;</span>
	<span class="s2">int </span><span class="s1">select_working_set(</span><span class="s2">int </span><span class="s1">&amp;i, </span><span class="s2">int </span><span class="s1">&amp;j);</span>
	<span class="s2">double </span><span class="s1">calculate_rho();</span>
	<span class="s2">bool </span><span class="s1">be_shrunk(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">double </span><span class="s1">Gmax1, </span><span class="s2">double </span><span class="s1">Gmax2, </span><span class="s2">double </span><span class="s1">Gmax3, </span><span class="s2">double </span><span class="s1">Gmax4);</span>
	<span class="s2">void </span><span class="s1">do_shrinking();</span>
<span class="s1">};</span>

<span class="s0">// return 1 if already optimal, return 0 otherwise</span>
<span class="s2">int </span><span class="s1">Solver_NU::select_working_set(</span><span class="s2">int </span><span class="s1">&amp;out_i, </span><span class="s2">int </span><span class="s1">&amp;out_j)</span>
<span class="s1">{</span>
	<span class="s0">// return i,j such that y_i = y_j and</span>
	<span class="s0">// i: maximizes -y_i * grad(f)_i, i in I_up(\alpha)</span>
	<span class="s0">// j: minimizes the decrease of obj value</span>
	<span class="s0">//    (if quadratic coefficient &lt;= 0, replace it with tau)</span>
	<span class="s0">//    -y_j*grad(f)_j &lt; -y_i*grad(f)_i, j in I_low(\alpha)</span>

	<span class="s2">double </span><span class="s1">Gmaxp = -INF;</span>
	<span class="s2">double </span><span class="s1">Gmaxp2 = -INF;</span>
	<span class="s2">int </span><span class="s1">Gmaxp_idx = -</span><span class="s5">1</span><span class="s1">;</span>

	<span class="s2">double </span><span class="s1">Gmaxn = -INF;</span>
	<span class="s2">double </span><span class="s1">Gmaxn2 = -INF;</span>
	<span class="s2">int </span><span class="s1">Gmaxn_idx = -</span><span class="s5">1</span><span class="s1">;</span>

	<span class="s2">int </span><span class="s1">Gmin_idx = -</span><span class="s5">1</span><span class="s1">;</span>
	<span class="s2">double </span><span class="s1">obj_diff_min = INF;</span>

	<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">t=</span><span class="s5">0</span><span class="s1">;t&lt;active_size;t++)</span>
		<span class="s2">if</span><span class="s1">(y[t]==+</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(!is_upper_bound(t))</span>
				<span class="s2">if</span><span class="s1">(-G[t] &gt;= Gmaxp)</span>
				<span class="s1">{</span>
					<span class="s1">Gmaxp = -G[t];</span>
					<span class="s1">Gmaxp_idx = t;</span>
				<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(!is_lower_bound(t))</span>
				<span class="s2">if</span><span class="s1">(G[t] &gt;= Gmaxn)</span>
				<span class="s1">{</span>
					<span class="s1">Gmaxn = G[t];</span>
					<span class="s1">Gmaxn_idx = t;</span>
				<span class="s1">}</span>
		<span class="s1">}</span>

	<span class="s2">int </span><span class="s1">ip = Gmaxp_idx;</span>
	<span class="s2">int </span><span class="s1">in = Gmaxn_idx;</span>
	<span class="s2">const </span><span class="s1">Qfloat *Q_ip = NULL;</span>
	<span class="s2">const </span><span class="s1">Qfloat *Q_in = NULL;</span>
	<span class="s2">if</span><span class="s1">(ip != -</span><span class="s5">1</span><span class="s1">) </span><span class="s0">// NULL Q_ip not accessed: Gmaxp=-INF if ip=-1</span>
		<span class="s1">Q_ip = Q</span><span class="s6">-&gt;</span><span class="s1">get_Q(ip,active_size);</span>
	<span class="s2">if</span><span class="s1">(in != -</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">Q_in = Q</span><span class="s6">-&gt;</span><span class="s1">get_Q(in,active_size);</span>

	<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">j=</span><span class="s5">0</span><span class="s1">;j&lt;active_size;j++)</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(y[j]==+</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s2">if </span><span class="s1">(!is_lower_bound(j))</span>
			<span class="s1">{</span>
				<span class="s2">double </span><span class="s1">grad_diff=Gmaxp+G[j];</span>
				<span class="s2">if </span><span class="s1">(G[j] &gt;= Gmaxp2)</span>
					<span class="s1">Gmaxp2 = G[j];</span>
				<span class="s2">if </span><span class="s1">(grad_diff &gt; </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s2">double </span><span class="s1">obj_diff;</span>
					<span class="s2">double </span><span class="s1">quad_coef = QD[ip]+QD[j]-</span><span class="s5">2</span><span class="s1">*Q_ip[j];</span>
					<span class="s2">if </span><span class="s1">(quad_coef &gt; </span><span class="s5">0</span><span class="s1">)</span>
						<span class="s1">obj_diff = -(grad_diff*grad_diff)/quad_coef;</span>
					<span class="s2">else</span>
						<span class="s1">obj_diff = -(grad_diff*grad_diff)/TAU;</span>

					<span class="s2">if </span><span class="s1">(obj_diff &lt;= obj_diff_min)</span>
					<span class="s1">{</span>
						<span class="s1">Gmin_idx=j;</span>
						<span class="s1">obj_diff_min = obj_diff;</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s2">if </span><span class="s1">(!is_upper_bound(j))</span>
			<span class="s1">{</span>
				<span class="s2">double </span><span class="s1">grad_diff=Gmaxn-G[j];</span>
				<span class="s2">if </span><span class="s1">(-G[j] &gt;= Gmaxn2)</span>
					<span class="s1">Gmaxn2 = -G[j];</span>
				<span class="s2">if </span><span class="s1">(grad_diff &gt; </span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">{</span>
					<span class="s2">double </span><span class="s1">obj_diff;</span>
					<span class="s2">double </span><span class="s1">quad_coef = QD[in]+QD[j]-</span><span class="s5">2</span><span class="s1">*Q_in[j];</span>
					<span class="s2">if </span><span class="s1">(quad_coef &gt; </span><span class="s5">0</span><span class="s1">)</span>
						<span class="s1">obj_diff = -(grad_diff*grad_diff)/quad_coef;</span>
					<span class="s2">else</span>
						<span class="s1">obj_diff = -(grad_diff*grad_diff)/TAU;</span>

					<span class="s2">if </span><span class="s1">(obj_diff &lt;= obj_diff_min)</span>
					<span class="s1">{</span>
						<span class="s1">Gmin_idx=j;</span>
						<span class="s1">obj_diff_min = obj_diff;</span>
					<span class="s1">}</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s2">if</span><span class="s1">(max(Gmaxp+Gmaxp2,Gmaxn+Gmaxn2) &lt; eps || Gmin_idx == -</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s2">return </span><span class="s5">1</span><span class="s1">;</span>

	<span class="s2">if </span><span class="s1">(y[Gmin_idx] == +</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">out_i = Gmaxp_idx;</span>
	<span class="s2">else</span>
		<span class="s1">out_i = Gmaxn_idx;</span>
	<span class="s1">out_j = Gmin_idx;</span>

	<span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">bool </span><span class="s1">Solver_NU::be_shrunk(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">double </span><span class="s1">Gmax1, </span><span class="s2">double </span><span class="s1">Gmax2, </span><span class="s2">double </span><span class="s1">Gmax3, </span><span class="s2">double </span><span class="s1">Gmax4)</span>
<span class="s1">{</span>
	<span class="s2">if</span><span class="s1">(is_upper_bound(i))</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(y[i]==+</span><span class="s5">1</span><span class="s1">)</span>
			<span class="s2">return</span><span class="s1">(-G[i] &gt; Gmax1);</span>
		<span class="s2">else</span>
			<span class="s2">return</span><span class="s1">(-G[i] &gt; Gmax4);</span>
	<span class="s1">}</span>
	<span class="s2">else if</span><span class="s1">(is_lower_bound(i))</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(y[i]==+</span><span class="s5">1</span><span class="s1">)</span>
			<span class="s2">return</span><span class="s1">(G[i] &gt; Gmax2);</span>
		<span class="s2">else</span>
			<span class="s2">return</span><span class="s1">(G[i] &gt; Gmax3);</span>
	<span class="s1">}</span>
	<span class="s2">else</span>
		<span class="s2">return</span><span class="s1">(</span><span class="s2">false</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">Solver_NU::do_shrinking()</span>
<span class="s1">{</span>
	<span class="s2">double </span><span class="s1">Gmax1 = -INF;	</span><span class="s0">// max { -y_i * grad(f)_i | y_i = +1, i in I_up(\alpha) }</span>
	<span class="s2">double </span><span class="s1">Gmax2 = -INF;	</span><span class="s0">// max { y_i * grad(f)_i | y_i = +1, i in I_low(\alpha) }</span>
	<span class="s2">double </span><span class="s1">Gmax3 = -INF;	</span><span class="s0">// max { -y_i * grad(f)_i | y_i = -1, i in I_up(\alpha) }</span>
	<span class="s2">double </span><span class="s1">Gmax4 = -INF;	</span><span class="s0">// max { y_i * grad(f)_i | y_i = -1, i in I_low(\alpha) }</span>

	<span class="s0">// find maximal violating pair first</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;active_size;i++)</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(!is_upper_bound(i))</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(y[i]==+</span><span class="s5">1</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(-G[i] &gt; Gmax1) Gmax1 = -G[i];</span>
			<span class="s1">}</span>
			<span class="s2">else	if</span><span class="s1">(-G[i] &gt; Gmax4) Gmax4 = -G[i];</span>
		<span class="s1">}</span>
		<span class="s2">if</span><span class="s1">(!is_lower_bound(i))</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(y[i]==+</span><span class="s5">1</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(G[i] &gt; Gmax2) Gmax2 = G[i];</span>
			<span class="s1">}</span>
			<span class="s2">else	if</span><span class="s1">(G[i] &gt; Gmax3) Gmax3 = G[i];</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s2">if</span><span class="s1">(unshrink == </span><span class="s2">false </span><span class="s1">&amp;&amp; max(Gmax1+Gmax2,Gmax3+Gmax4) &lt;= eps*</span><span class="s5">10</span><span class="s1">)</span>
	<span class="s1">{</span>
		<span class="s1">unshrink = </span><span class="s4">true</span><span class="s1">;</span>
		<span class="s1">reconstruct_gradient();</span>
		<span class="s1">active_size = l;</span>
	<span class="s1">}</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;active_size;i++)</span>
		<span class="s2">if </span><span class="s1">(be_shrunk(i, Gmax1, Gmax2, Gmax3, Gmax4))</span>
		<span class="s1">{</span>
			<span class="s1">active_size--;</span>
			<span class="s2">while </span><span class="s1">(active_size &gt; i)</span>
			<span class="s1">{</span>
				<span class="s2">if </span><span class="s1">(!be_shrunk(active_size, Gmax1, Gmax2, Gmax3, Gmax4))</span>
				<span class="s1">{</span>
					<span class="s1">swap_index(i,active_size);</span>
					<span class="s2">break</span><span class="s1">;</span>
				<span class="s1">}</span>
				<span class="s1">active_size--;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">double </span><span class="s1">Solver_NU::calculate_rho()</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">nr_free1 = </span><span class="s5">0</span><span class="s1">,nr_free2 = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">double </span><span class="s1">ub1 = INF, ub2 = INF;</span>
	<span class="s2">double </span><span class="s1">lb1 = -INF, lb2 = -INF;</span>
	<span class="s2">double </span><span class="s1">sum_free1 = </span><span class="s5">0</span><span class="s1">, sum_free2 = </span><span class="s5">0</span><span class="s1">;</span>

	<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">;i&lt;active_size;i++)</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(y[i]==+</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(is_upper_bound(i))</span>
				<span class="s1">lb1 = max(lb1,G[i]);</span>
			<span class="s2">else if</span><span class="s1">(is_lower_bound(i))</span>
				<span class="s1">ub1 = min(ub1,G[i]);</span>
			<span class="s2">else</span>
			<span class="s1">{</span>
				<span class="s1">++nr_free1;</span>
				<span class="s1">sum_free1 += G[i];</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(is_upper_bound(i))</span>
				<span class="s1">lb2 = max(lb2,G[i]);</span>
			<span class="s2">else if</span><span class="s1">(is_lower_bound(i))</span>
				<span class="s1">ub2 = min(ub2,G[i]);</span>
			<span class="s2">else</span>
			<span class="s1">{</span>
				<span class="s1">++nr_free2;</span>
				<span class="s1">sum_free2 += G[i];</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s2">double </span><span class="s1">r1,r2;</span>
	<span class="s2">if</span><span class="s1">(nr_free1 &gt; </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">r1 = sum_free1/nr_free1;</span>
	<span class="s2">else</span>
		<span class="s1">r1 = (ub1+lb1)/</span><span class="s5">2</span><span class="s1">;</span>

	<span class="s2">if</span><span class="s1">(nr_free2 &gt; </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">r2 = sum_free2/nr_free2;</span>
	<span class="s2">else</span>
		<span class="s1">r2 = (ub2+lb2)/</span><span class="s5">2</span><span class="s1">;</span>

	<span class="s1">si</span><span class="s6">-&gt;</span><span class="s1">r = (r1+r2)/</span><span class="s5">2</span><span class="s1">;</span>
	<span class="s2">return </span><span class="s1">(r1-r2)/</span><span class="s5">2</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">//</span>
<span class="s0">// Q matrices for various formulations</span>
<span class="s0">//</span>
<span class="s4">class </span><span class="s1">SVC_Q: </span><span class="s4">public </span><span class="s1">Kernel</span>
<span class="s1">{</span>
<span class="s4">public</span><span class="s1">:</span>
	<span class="s1">SVC_Q(</span><span class="s2">const </span><span class="s1">PREFIX(problem)&amp; prob, </span><span class="s2">const </span><span class="s1">svm_parameter&amp; param, </span><span class="s2">const </span><span class="s1">schar *y_, BlasFunctions *blas_functions)</span>
	<span class="s1">:Kernel(prob.l, prob.x, param, blas_functions)</span>
	<span class="s1">{</span>
		<span class="s1">clone(y,y_,prob.l);</span>
		<span class="s1">cache = </span><span class="s4">new </span><span class="s1">Cache(prob.l,(</span><span class="s2">long int</span><span class="s1">)(param.cache_size*(</span><span class="s5">1</span><span class="s1">&lt;&lt;</span><span class="s5">20</span><span class="s1">)));</span>
		<span class="s1">QD = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[prob.l];</span>
		<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">;i&lt;prob.l;i++)</span>
			<span class="s1">QD[i] = (</span><span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">*kernel_function)(i,i);</span>
	<span class="s1">}</span>

	<span class="s1">Qfloat *get_Q(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">len) </span><span class="s2">const</span>
	<span class="s1">{</span>
		<span class="s1">Qfloat *data;</span>
		<span class="s2">int </span><span class="s1">start, j;</span>
		<span class="s2">if</span><span class="s1">((start = cache</span><span class="s6">-&gt;</span><span class="s1">get_data(i,&amp;data,len)) &lt; len)</span>
		<span class="s1">{</span>
			<span class="s2">for</span><span class="s1">(j=start;j&lt;len;j++)</span>
				<span class="s1">data[j] = (Qfloat)(y[i]*y[j]*(</span><span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">*kernel_function)(i,j));</span>
		<span class="s1">}</span>
		<span class="s2">return </span><span class="s1">data;</span>
	<span class="s1">}</span>

	<span class="s2">double </span><span class="s1">*get_QD() </span><span class="s2">const</span>
	<span class="s1">{</span>
		<span class="s2">return </span><span class="s1">QD;</span>
	<span class="s1">}</span>

	<span class="s2">void </span><span class="s1">swap_index(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">j) </span><span class="s2">const</span>
	<span class="s1">{</span>
		<span class="s1">cache</span><span class="s6">-&gt;</span><span class="s1">swap_index(i,j);</span>
		<span class="s1">Kernel::swap_index(i,j);</span>
		<span class="s1">swap(y[i],y[j]);</span>
		<span class="s1">swap(QD[i],QD[j]);</span>
	<span class="s1">}</span>

	<span class="s1">~SVC_Q()</span>
	<span class="s1">{</span>
		<span class="s2">delete</span><span class="s1">[] y;</span>
		<span class="s2">delete </span><span class="s1">cache;</span>
		<span class="s2">delete</span><span class="s1">[] QD;</span>
	<span class="s1">}</span>
<span class="s4">private</span><span class="s1">:</span>
	<span class="s1">schar *y;</span>
	<span class="s1">Cache *cache;</span>
	<span class="s2">double </span><span class="s1">*QD;</span>
<span class="s1">};</span>

<span class="s4">class </span><span class="s1">ONE_CLASS_Q: </span><span class="s4">public </span><span class="s1">Kernel</span>
<span class="s1">{</span>
<span class="s4">public</span><span class="s1">:</span>
	<span class="s1">ONE_CLASS_Q(</span><span class="s2">const </span><span class="s1">PREFIX(problem)&amp; prob, </span><span class="s2">const </span><span class="s1">svm_parameter&amp; param, BlasFunctions *blas_functions)</span>
	<span class="s1">:Kernel(prob.l, prob.x, param, blas_functions)</span>
	<span class="s1">{</span>
		<span class="s1">cache = </span><span class="s4">new </span><span class="s1">Cache(prob.l,(</span><span class="s2">long int</span><span class="s1">)(param.cache_size*(</span><span class="s5">1</span><span class="s1">&lt;&lt;</span><span class="s5">20</span><span class="s1">)));</span>
		<span class="s1">QD = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[prob.l];</span>
		<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">;i&lt;prob.l;i++)</span>
			<span class="s1">QD[i] = (</span><span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">*kernel_function)(i,i);</span>
	<span class="s1">}</span>

	<span class="s1">Qfloat *get_Q(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">len) </span><span class="s2">const</span>
	<span class="s1">{</span>
		<span class="s1">Qfloat *data;</span>
		<span class="s2">int </span><span class="s1">start, j;</span>
		<span class="s2">if</span><span class="s1">((start = cache</span><span class="s6">-&gt;</span><span class="s1">get_data(i,&amp;data,len)) &lt; len)</span>
		<span class="s1">{</span>
			<span class="s2">for</span><span class="s1">(j=start;j&lt;len;j++)</span>
				<span class="s1">data[j] = (Qfloat)(</span><span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">*kernel_function)(i,j);</span>
		<span class="s1">}</span>
		<span class="s2">return </span><span class="s1">data;</span>
	<span class="s1">}</span>

	<span class="s2">double </span><span class="s1">*get_QD() </span><span class="s2">const</span>
	<span class="s1">{</span>
		<span class="s2">return </span><span class="s1">QD;</span>
	<span class="s1">}</span>

	<span class="s2">void </span><span class="s1">swap_index(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">j) </span><span class="s2">const</span>
	<span class="s1">{</span>
		<span class="s1">cache</span><span class="s6">-&gt;</span><span class="s1">swap_index(i,j);</span>
		<span class="s1">Kernel::swap_index(i,j);</span>
		<span class="s1">swap(QD[i],QD[j]);</span>
	<span class="s1">}</span>

	<span class="s1">~ONE_CLASS_Q()</span>
	<span class="s1">{</span>
		<span class="s2">delete </span><span class="s1">cache;</span>
		<span class="s2">delete</span><span class="s1">[] QD;</span>
	<span class="s1">}</span>
<span class="s4">private</span><span class="s1">:</span>
	<span class="s1">Cache *cache;</span>
	<span class="s2">double </span><span class="s1">*QD;</span>
<span class="s1">};</span>

<span class="s4">class </span><span class="s1">SVR_Q: </span><span class="s4">public </span><span class="s1">Kernel</span>
<span class="s1">{</span>
<span class="s4">public</span><span class="s1">:</span>
	<span class="s1">SVR_Q(</span><span class="s2">const </span><span class="s1">PREFIX(problem)&amp; prob, </span><span class="s2">const </span><span class="s1">svm_parameter&amp; param, BlasFunctions *blas_functions)</span>
	<span class="s1">:Kernel(prob.l, prob.x, param, blas_functions)</span>
	<span class="s1">{</span>
		<span class="s1">l = prob.l;</span>
		<span class="s1">cache = </span><span class="s4">new </span><span class="s1">Cache(l,(</span><span class="s2">long int</span><span class="s1">)(param.cache_size*(</span><span class="s5">1</span><span class="s1">&lt;&lt;</span><span class="s5">20</span><span class="s1">)));</span>
		<span class="s1">QD = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[</span><span class="s5">2</span><span class="s1">*l];</span>
		<span class="s1">sign = </span><span class="s4">new </span><span class="s1">schar[</span><span class="s5">2</span><span class="s1">*l];</span>
		<span class="s1">index = </span><span class="s4">new </span><span class="s2">int</span><span class="s1">[</span><span class="s5">2</span><span class="s1">*l];</span>
		<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">k=</span><span class="s5">0</span><span class="s1">;k&lt;l;k++)</span>
		<span class="s1">{</span>
			<span class="s1">sign[k] = </span><span class="s5">1</span><span class="s1">;</span>
			<span class="s1">sign[k+l] = -</span><span class="s5">1</span><span class="s1">;</span>
			<span class="s1">index[k] = k;</span>
			<span class="s1">index[k+l] = k;</span>
			<span class="s1">QD[k] = (</span><span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">*kernel_function)(k,k);</span>
			<span class="s1">QD[k+l] = QD[k];</span>
		<span class="s1">}</span>
		<span class="s1">buffer[</span><span class="s5">0</span><span class="s1">] = </span><span class="s4">new </span><span class="s1">Qfloat[</span><span class="s5">2</span><span class="s1">*l];</span>
		<span class="s1">buffer[</span><span class="s5">1</span><span class="s1">] = </span><span class="s4">new </span><span class="s1">Qfloat[</span><span class="s5">2</span><span class="s1">*l];</span>
		<span class="s1">next_buffer = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s2">void </span><span class="s1">swap_index(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">j) </span><span class="s2">const</span>
	<span class="s1">{</span>
		<span class="s1">swap(sign[i],sign[j]);</span>
		<span class="s1">swap(index[i],index[j]);</span>
		<span class="s1">swap(QD[i],QD[j]);</span>
	<span class="s1">}</span>

	<span class="s1">Qfloat *get_Q(</span><span class="s2">int </span><span class="s1">i, </span><span class="s2">int </span><span class="s1">len) </span><span class="s2">const</span>
	<span class="s1">{</span>
		<span class="s1">Qfloat *data;</span>
		<span class="s2">int </span><span class="s1">j, real_i = index[i];</span>
		<span class="s2">if</span><span class="s1">(cache</span><span class="s6">-&gt;</span><span class="s1">get_data(real_i,&amp;data,l) &lt; l)</span>
		<span class="s1">{</span>
			<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;l;j++)</span>
				<span class="s1">data[j] = (Qfloat)(</span><span class="s4">this</span><span class="s6">-&gt;</span><span class="s1">*kernel_function)(real_i,j);</span>
		<span class="s1">}</span>

		<span class="s0">// reorder and copy</span>
		<span class="s1">Qfloat *buf = buffer[next_buffer];</span>
		<span class="s1">next_buffer = </span><span class="s5">1 </span><span class="s1">- next_buffer;</span>
		<span class="s1">schar si = sign[i];</span>
		<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;len;j++)</span>
			<span class="s1">buf[j] = (Qfloat) si * (Qfloat) sign[j] * data[index[j]];</span>
		<span class="s2">return </span><span class="s1">buf;</span>
	<span class="s1">}</span>

	<span class="s2">double </span><span class="s1">*get_QD() </span><span class="s2">const</span>
	<span class="s1">{</span>
		<span class="s2">return </span><span class="s1">QD;</span>
	<span class="s1">}</span>

	<span class="s1">~SVR_Q()</span>
	<span class="s1">{</span>
		<span class="s2">delete </span><span class="s1">cache;</span>
		<span class="s2">delete</span><span class="s1">[] sign;</span>
		<span class="s2">delete</span><span class="s1">[] index;</span>
		<span class="s2">delete</span><span class="s1">[] buffer[</span><span class="s5">0</span><span class="s1">];</span>
		<span class="s2">delete</span><span class="s1">[] buffer[</span><span class="s5">1</span><span class="s1">];</span>
		<span class="s2">delete</span><span class="s1">[] QD;</span>
	<span class="s1">}</span>
<span class="s4">private</span><span class="s1">:</span>
	<span class="s2">int </span><span class="s1">l;</span>
	<span class="s1">Cache *cache;</span>
	<span class="s1">schar *sign;</span>
	<span class="s2">int </span><span class="s1">*index;</span>
	<span class="s4">mutable </span><span class="s2">int </span><span class="s1">next_buffer;</span>
	<span class="s1">Qfloat *buffer[</span><span class="s5">2</span><span class="s1">];</span>
	<span class="s2">double </span><span class="s1">*QD;</span>
<span class="s1">};</span>

<span class="s0">//</span>
<span class="s0">// construct and solve various formulations</span>
<span class="s0">//</span>
<span class="s2">static void </span><span class="s1">solve_c_svc(</span>
	<span class="s2">const </span><span class="s1">PREFIX(problem) *prob, </span><span class="s2">const </span><span class="s1">svm_parameter* param,</span>
	<span class="s2">double </span><span class="s1">*alpha, Solver::SolutionInfo* si, </span><span class="s2">double </span><span class="s1">Cp, </span><span class="s2">double </span><span class="s1">Cn, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">l = prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">double </span><span class="s1">*minus_ones = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s1">schar *y = </span><span class="s4">new </span><span class="s1">schar[l];</span>
        <span class="s2">double </span><span class="s1">*C = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>

	<span class="s2">int </span><span class="s1">i;</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">alpha[i] = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s1">minus_ones[i] = -</span><span class="s5">1</span><span class="s1">;</span>
		<span class="s2">if</span><span class="s1">(prob</span><span class="s6">-&gt;</span><span class="s1">y[i] &gt; </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">y[i] = +</span><span class="s5">1</span><span class="s1">;</span>
			<span class="s1">C[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i]*Cp;</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s1">y[i] = -</span><span class="s5">1</span><span class="s1">;</span>
			<span class="s1">C[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i]*Cn;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s1">Solver s;</span>
	<span class="s1">s.Solve(l, SVC_Q(*prob,*param,y, blas_functions), minus_ones, y,</span>
		<span class="s1">alpha, C, param</span><span class="s6">-&gt;</span><span class="s1">eps, si, param</span><span class="s6">-&gt;</span><span class="s1">shrinking,</span>
                <span class="s1">param</span><span class="s6">-&gt;</span><span class="s1">max_iter);</span>

        <span class="s0">/* 
    double sum_alpha=0; 
    for(i=0;i&lt;l;i++) 
        sum_alpha += alpha[i]; 
 
    if (Cp==Cn) 
        info(&quot;nu = %f\n&quot;, sum_alpha/(Cp*prob-&gt;l)); 
        */</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
		<span class="s1">alpha[i] *= y[i];</span>

        <span class="s2">delete</span><span class="s1">[] C;</span>
	<span class="s2">delete</span><span class="s1">[] minus_ones;</span>
	<span class="s2">delete</span><span class="s1">[] y;</span>
<span class="s1">}</span>

<span class="s2">static void </span><span class="s1">solve_nu_svc(</span>
	<span class="s2">const </span><span class="s1">PREFIX(problem) *prob, </span><span class="s2">const </span><span class="s1">svm_parameter *param,</span>
	<span class="s2">double </span><span class="s1">*alpha, Solver::SolutionInfo* si, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">int </span><span class="s1">l = prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">double </span><span class="s1">nu = param</span><span class="s6">-&gt;</span><span class="s1">nu;</span>

	<span class="s1">schar *y = </span><span class="s4">new </span><span class="s1">schar[l];</span>
        <span class="s2">double </span><span class="s1">*C = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
        <span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(prob</span><span class="s6">-&gt;</span><span class="s1">y[i]&gt;</span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">y[i] = +</span><span class="s5">1</span><span class="s1">;</span>
		<span class="s2">else</span>
			<span class="s1">y[i] = -</span><span class="s5">1</span><span class="s1">;</span>

		<span class="s1">C[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i];</span>
	<span class="s1">}</span>

	<span class="s2">double </span><span class="s1">nu_l = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++) nu_l += nu*C[i];</span>
	<span class="s2">double </span><span class="s1">sum_pos = nu_l/</span><span class="s5">2</span><span class="s1">;</span>
	<span class="s2">double </span><span class="s1">sum_neg = nu_l/</span><span class="s5">2</span><span class="s1">;</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
		<span class="s2">if</span><span class="s1">(y[i] == +</span><span class="s5">1</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">alpha[i] = min(C[i],sum_pos);</span>
			<span class="s1">sum_pos -= alpha[i];</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s1">alpha[i] = min(C[i],sum_neg);</span>
			<span class="s1">sum_neg -= alpha[i];</span>
		<span class="s1">}</span>

	<span class="s2">double </span><span class="s1">*zeros = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
		<span class="s1">zeros[i] = </span><span class="s5">0</span><span class="s1">;</span>

	<span class="s1">Solver_NU s;</span>
	<span class="s1">s.Solve(l, SVC_Q(*prob,*param,y,blas_functions), zeros, y,</span>
		<span class="s1">alpha, C, param</span><span class="s6">-&gt;</span><span class="s1">eps, si,  param</span><span class="s6">-&gt;</span><span class="s1">shrinking, param</span><span class="s6">-&gt;</span><span class="s1">max_iter);</span>
	<span class="s2">double </span><span class="s1">r = si</span><span class="s6">-&gt;</span><span class="s1">r;</span>

	<span class="s1">info(</span><span class="s3">&quot;C = %f</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">,</span><span class="s5">1</span><span class="s1">/r);</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
        <span class="s1">{</span>
		<span class="s1">alpha[i] *= y[i]/r;</span>
		<span class="s1">si</span><span class="s6">-&gt;</span><span class="s1">upper_bound[i] /= r;</span>
        <span class="s1">}</span>

	<span class="s1">si</span><span class="s6">-&gt;</span><span class="s1">rho /= r;</span>
	<span class="s1">si</span><span class="s6">-&gt;</span><span class="s1">obj /= (r*r);</span>

        <span class="s2">delete</span><span class="s1">[] C;</span>
	<span class="s2">delete</span><span class="s1">[] y;</span>
	<span class="s2">delete</span><span class="s1">[] zeros;</span>
<span class="s1">}</span>

<span class="s2">static void </span><span class="s1">solve_one_class(</span>
	<span class="s2">const </span><span class="s1">PREFIX(problem) *prob, </span><span class="s2">const </span><span class="s1">svm_parameter *param,</span>
	<span class="s2">double </span><span class="s1">*alpha, Solver::SolutionInfo* si, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">l = prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">double </span><span class="s1">*zeros = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s1">schar *ones = </span><span class="s4">new </span><span class="s1">schar[l];</span>
	<span class="s2">double </span><span class="s1">*C = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[l];</span>
	<span class="s2">int </span><span class="s1">i;</span>

	<span class="s2">double </span><span class="s1">nu_l = </span><span class="s5">0</span><span class="s1">;</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">C[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i];</span>
		<span class="s1">nu_l += C[i] * param</span><span class="s6">-&gt;</span><span class="s1">nu;</span>
	<span class="s1">}</span>

	<span class="s1">i = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">while</span><span class="s1">(nu_l &gt; </span><span class="s5">0</span><span class="s1">)</span>
	<span class="s1">{</span>
		<span class="s1">alpha[i] = min(C[i],nu_l);</span>
		<span class="s1">nu_l -= alpha[i];</span>
		<span class="s1">++i;</span>
	<span class="s1">}</span>
	<span class="s2">for</span><span class="s1">(;i&lt;l;i++)</span>
		<span class="s1">alpha[i] = </span><span class="s5">0</span><span class="s1">;</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">zeros[i] = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s1">ones[i] = </span><span class="s5">1</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">Solver s;</span>
	<span class="s1">s.Solve(l, ONE_CLASS_Q(*prob,*param,blas_functions), zeros, ones,</span>
		<span class="s1">alpha, C, param</span><span class="s6">-&gt;</span><span class="s1">eps, si, param</span><span class="s6">-&gt;</span><span class="s1">shrinking, param</span><span class="s6">-&gt;</span><span class="s1">max_iter);</span>

        <span class="s2">delete</span><span class="s1">[] C;</span>
	<span class="s2">delete</span><span class="s1">[] zeros;</span>
	<span class="s2">delete</span><span class="s1">[] ones;</span>
<span class="s1">}</span>

<span class="s2">static void </span><span class="s1">solve_epsilon_svr(</span>
	<span class="s2">const </span><span class="s1">PREFIX(problem) *prob, </span><span class="s2">const </span><span class="s1">svm_parameter *param,</span>
	<span class="s2">double </span><span class="s1">*alpha, Solver::SolutionInfo* si, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">l = prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">double </span><span class="s1">*alpha2 = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[</span><span class="s5">2</span><span class="s1">*l];</span>
	<span class="s2">double </span><span class="s1">*linear_term = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[</span><span class="s5">2</span><span class="s1">*l];</span>
	<span class="s1">schar *y = </span><span class="s4">new </span><span class="s1">schar[</span><span class="s5">2</span><span class="s1">*l];</span>
        <span class="s2">double </span><span class="s1">*C = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[</span><span class="s5">2</span><span class="s1">*l];</span>
        <span class="s2">int </span><span class="s1">i;</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">alpha2[i] = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s1">linear_term[i] = param</span><span class="s6">-&gt;</span><span class="s1">p - prob</span><span class="s6">-&gt;</span><span class="s1">y[i];</span>
		<span class="s1">y[i] = </span><span class="s5">1</span><span class="s1">;</span>
                <span class="s1">C[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i]*param</span><span class="s6">-&gt;</span><span class="s1">C;</span>

		<span class="s1">alpha2[i+l] = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s1">linear_term[i+l] = param</span><span class="s6">-&gt;</span><span class="s1">p + prob</span><span class="s6">-&gt;</span><span class="s1">y[i];</span>
		<span class="s1">y[i+l] = -</span><span class="s5">1</span><span class="s1">;</span>
                <span class="s1">C[i+l] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i]*param</span><span class="s6">-&gt;</span><span class="s1">C;</span>
	<span class="s1">}</span>

	<span class="s1">Solver s;</span>
	<span class="s1">s.Solve(</span><span class="s5">2</span><span class="s1">*l, SVR_Q(*prob,*param,blas_functions), linear_term, y,</span>
		<span class="s1">alpha2, C, param</span><span class="s6">-&gt;</span><span class="s1">eps, si, param</span><span class="s6">-&gt;</span><span class="s1">shrinking, param</span><span class="s6">-&gt;</span><span class="s1">max_iter);</span>

	<span class="s2">double </span><span class="s1">sum_alpha = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">alpha[i] = alpha2[i] - alpha2[i+l];</span>
		<span class="s1">sum_alpha += fabs(alpha[i]);</span>
	<span class="s1">}</span>


	<span class="s2">delete</span><span class="s1">[] alpha2;</span>
	<span class="s2">delete</span><span class="s1">[] linear_term;</span>
        <span class="s2">delete</span><span class="s1">[] C;</span>
	<span class="s2">delete</span><span class="s1">[] y;</span>
<span class="s1">}</span>

<span class="s2">static void </span><span class="s1">solve_nu_svr(</span>
	<span class="s2">const </span><span class="s1">PREFIX(problem) *prob, </span><span class="s2">const </span><span class="s1">svm_parameter *param,</span>
	<span class="s2">double </span><span class="s1">*alpha, Solver::SolutionInfo* si, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">l = prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">double </span><span class="s1">*C = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[</span><span class="s5">2</span><span class="s1">*l];</span>
	<span class="s2">double </span><span class="s1">*alpha2 = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[</span><span class="s5">2</span><span class="s1">*l];</span>
	<span class="s2">double </span><span class="s1">*linear_term = </span><span class="s4">new </span><span class="s2">double</span><span class="s1">[</span><span class="s5">2</span><span class="s1">*l];</span>
	<span class="s1">schar *y = </span><span class="s4">new </span><span class="s1">schar[</span><span class="s5">2</span><span class="s1">*l];</span>
	<span class="s2">int </span><span class="s1">i;</span>

	<span class="s2">double </span><span class="s1">sum = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">C[i] = C[i+l] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i]*param</span><span class="s6">-&gt;</span><span class="s1">C;</span>
		<span class="s1">sum += C[i] * param</span><span class="s6">-&gt;</span><span class="s1">nu;</span>
	<span class="s1">}</span>
	<span class="s1">sum /= </span><span class="s5">2</span><span class="s1">;</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">alpha2[i] = alpha2[i+l] = min(sum,C[i]);</span>
		<span class="s1">sum -= alpha2[i];</span>

		<span class="s1">linear_term[i] = - prob</span><span class="s6">-&gt;</span><span class="s1">y[i];</span>
		<span class="s1">y[i] = </span><span class="s5">1</span><span class="s1">;</span>

		<span class="s1">linear_term[i+l] = prob</span><span class="s6">-&gt;</span><span class="s1">y[i];</span>
		<span class="s1">y[i+l] = -</span><span class="s5">1</span><span class="s1">;</span>
	<span class="s1">}</span>

	<span class="s1">Solver_NU s;</span>
	<span class="s1">s.Solve(</span><span class="s5">2</span><span class="s1">*l, SVR_Q(*prob,*param,blas_functions), linear_term, y,</span>
		<span class="s1">alpha2, C, param</span><span class="s6">-&gt;</span><span class="s1">eps, si, param</span><span class="s6">-&gt;</span><span class="s1">shrinking, param</span><span class="s6">-&gt;</span><span class="s1">max_iter);</span>

	<span class="s1">info(</span><span class="s3">&quot;epsilon = %f</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">,-si</span><span class="s6">-&gt;</span><span class="s1">r);</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
		<span class="s1">alpha[i] = alpha2[i] - alpha2[i+l];</span>

	<span class="s2">delete</span><span class="s1">[] alpha2;</span>
	<span class="s2">delete</span><span class="s1">[] linear_term;</span>
        <span class="s2">delete</span><span class="s1">[] C;</span>
	<span class="s2">delete</span><span class="s1">[] y;</span>
<span class="s1">}</span>

<span class="s0">//</span>
<span class="s0">// decision_function</span>
<span class="s0">//</span>
<span class="s2">struct </span><span class="s1">decision_function</span>
<span class="s1">{</span>
	<span class="s2">double </span><span class="s1">*alpha;</span>
	<span class="s2">double </span><span class="s1">rho;</span>
	<span class="s2">int </span><span class="s1">n_iter;</span>
<span class="s1">};</span>

<span class="s2">static </span><span class="s1">decision_function svm_train_one(</span>
	<span class="s2">const </span><span class="s1">PREFIX(problem) *prob, </span><span class="s2">const </span><span class="s1">svm_parameter *param,</span>
	<span class="s2">double </span><span class="s1">Cp, </span><span class="s2">double </span><span class="s1">Cn, </span><span class="s2">int </span><span class="s1">*status, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s2">double </span><span class="s1">*alpha = Malloc(</span><span class="s2">double</span><span class="s1">,prob</span><span class="s6">-&gt;</span><span class="s1">l);</span>
	<span class="s1">Solver::SolutionInfo si;</span>
	<span class="s2">switch</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">svm_type)</span>
	<span class="s1">{</span>
 		<span class="s2">case </span><span class="s1">C_SVC:</span>
			<span class="s1">si.upper_bound = Malloc(</span><span class="s2">double</span><span class="s1">,prob</span><span class="s6">-&gt;</span><span class="s1">l);</span>
 			<span class="s1">solve_c_svc(prob,param,alpha,&amp;si,Cp,Cn,blas_functions);</span>
 			<span class="s2">break</span><span class="s1">;</span>
 		<span class="s2">case </span><span class="s1">NU_SVC:</span>
			<span class="s1">si.upper_bound = Malloc(</span><span class="s2">double</span><span class="s1">,prob</span><span class="s6">-&gt;</span><span class="s1">l);</span>
 			<span class="s1">solve_nu_svc(prob,param,alpha,&amp;si,blas_functions);</span>
 			<span class="s2">break</span><span class="s1">;</span>
 		<span class="s2">case </span><span class="s1">ONE_CLASS:</span>
			<span class="s1">si.upper_bound = Malloc(</span><span class="s2">double</span><span class="s1">,prob</span><span class="s6">-&gt;</span><span class="s1">l);</span>
 			<span class="s1">solve_one_class(prob,param,alpha,&amp;si,blas_functions);</span>
 			<span class="s2">break</span><span class="s1">;</span>
 		<span class="s2">case </span><span class="s1">EPSILON_SVR:</span>
			<span class="s1">si.upper_bound = Malloc(</span><span class="s2">double</span><span class="s1">,</span><span class="s5">2</span><span class="s1">*prob</span><span class="s6">-&gt;</span><span class="s1">l);</span>
 			<span class="s1">solve_epsilon_svr(prob,param,alpha,&amp;si,blas_functions);</span>
 			<span class="s2">break</span><span class="s1">;</span>
 		<span class="s2">case </span><span class="s1">NU_SVR:</span>
			<span class="s1">si.upper_bound = Malloc(</span><span class="s2">double</span><span class="s1">,</span><span class="s5">2</span><span class="s1">*prob</span><span class="s6">-&gt;</span><span class="s1">l);</span>
 			<span class="s1">solve_nu_svr(prob,param,alpha,&amp;si,blas_functions);</span>
 			<span class="s2">break</span><span class="s1">;</span>
	<span class="s1">}</span>

        <span class="s1">*status |= si.solve_timed_out;</span>

	<span class="s1">info(</span><span class="s3">&quot;obj = %f, rho = %f</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">,si.obj,si.rho);</span>

	<span class="s0">// output SVs</span>

	<span class="s2">int </span><span class="s1">nSV = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">nBSV = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">;i&lt;prob</span><span class="s6">-&gt;</span><span class="s1">l;i++)</span>
	<span class="s1">{</span>
		<span class="s2">if</span><span class="s1">(fabs(alpha[i]) &gt; </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">++nSV;</span>
			<span class="s2">if</span><span class="s1">(prob</span><span class="s6">-&gt;</span><span class="s1">y[i] &gt; </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(fabs(alpha[i]) &gt;= si.upper_bound[i])</span>
					<span class="s1">++nBSV;</span>
			<span class="s1">}</span>
			<span class="s2">else</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(fabs(alpha[i]) &gt;= si.upper_bound[i])</span>
					<span class="s1">++nBSV;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

        <span class="s1">free(si.upper_bound);</span>

	<span class="s1">info(</span><span class="s3">&quot;nSV = %d, nBSV = %d</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">,nSV,nBSV);</span>

	<span class="s1">decision_function f;</span>
	<span class="s1">f.alpha = alpha;</span>
	<span class="s1">f.rho = si.rho;</span>
	<span class="s1">f.n_iter = si.n_iter;</span>
	<span class="s2">return </span><span class="s1">f;</span>
<span class="s1">}</span>

<span class="s0">// Platt's binary SVM Probabilistic Output: an improvement from Lin et al.</span>
<span class="s2">static void </span><span class="s1">sigmoid_train(</span>
	<span class="s2">int </span><span class="s1">l, </span><span class="s2">const double </span><span class="s1">*dec_values, </span><span class="s2">const double </span><span class="s1">*labels,</span>
	<span class="s2">double</span><span class="s1">&amp; A, </span><span class="s2">double</span><span class="s1">&amp; B)</span>
<span class="s1">{</span>
	<span class="s2">double </span><span class="s1">prior1=</span><span class="s5">0</span><span class="s1">, prior0 = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">i;</span>

	<span class="s2">for </span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
		<span class="s2">if </span><span class="s1">(labels[i] &gt; </span><span class="s5">0</span><span class="s1">) prior1+=</span><span class="s5">1</span><span class="s1">;</span>
		<span class="s2">else </span><span class="s1">prior0+=</span><span class="s5">1</span><span class="s1">;</span>

	<span class="s2">int </span><span class="s1">max_iter=</span><span class="s5">100</span><span class="s1">;	</span><span class="s0">// Maximal number of iterations</span>
	<span class="s2">double </span><span class="s1">min_step=</span><span class="s5">1</span><span class="s1">e-10;	</span><span class="s0">// Minimal step taken in line search</span>
	<span class="s2">double </span><span class="s1">sigma=</span><span class="s5">1</span><span class="s1">e-12;	</span><span class="s0">// For numerically strict PD of Hessian</span>
	<span class="s2">double </span><span class="s1">eps=</span><span class="s5">1</span><span class="s1">e-5;</span>
	<span class="s2">double </span><span class="s1">hiTarget=(prior1+</span><span class="s5">1.0</span><span class="s1">)/(prior1+</span><span class="s5">2.0</span><span class="s1">);</span>
	<span class="s2">double </span><span class="s1">loTarget=</span><span class="s5">1</span><span class="s1">/(prior0+</span><span class="s5">2.0</span><span class="s1">);</span>
	<span class="s2">double </span><span class="s1">*t=Malloc(</span><span class="s2">double</span><span class="s1">,l);</span>
	<span class="s2">double </span><span class="s1">fApB,p,q,h11,h22,h21,g1,g2,det,dA,dB,gd,stepsize;</span>
	<span class="s2">double </span><span class="s1">newA,newB,newf,d1,d2;</span>
	<span class="s2">int </span><span class="s1">iter;</span>

	<span class="s0">// Initial Point and Initial Fun Value</span>
	<span class="s1">A=</span><span class="s5">0.0</span><span class="s1">; B=log((prior0+</span><span class="s5">1.0</span><span class="s1">)/(prior1+</span><span class="s5">1.0</span><span class="s1">));</span>
	<span class="s2">double </span><span class="s1">fval = </span><span class="s5">0.0</span><span class="s1">;</span>

	<span class="s2">for </span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s2">if </span><span class="s1">(labels[i]&gt;</span><span class="s5">0</span><span class="s1">) t[i]=hiTarget;</span>
		<span class="s2">else </span><span class="s1">t[i]=loTarget;</span>
		<span class="s1">fApB = dec_values[i]*A+B;</span>
		<span class="s2">if </span><span class="s1">(fApB&gt;=</span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">fval += t[i]*fApB + log(</span><span class="s5">1</span><span class="s1">+exp(-fApB));</span>
		<span class="s2">else</span>
			<span class="s1">fval += (t[i] - </span><span class="s5">1</span><span class="s1">)*fApB +log(</span><span class="s5">1</span><span class="s1">+exp(fApB));</span>
	<span class="s1">}</span>
	<span class="s2">for </span><span class="s1">(iter=</span><span class="s5">0</span><span class="s1">;iter&lt;max_iter;iter++)</span>
	<span class="s1">{</span>
		<span class="s0">// Update Gradient and Hessian (use H' = H + sigma I)</span>
		<span class="s1">h11=sigma; </span><span class="s0">// numerically ensures strict PD</span>
		<span class="s1">h22=sigma;</span>
		<span class="s1">h21=</span><span class="s5">0.0</span><span class="s1">;g1=</span><span class="s5">0.0</span><span class="s1">;g2=</span><span class="s5">0.0</span><span class="s1">;</span>
		<span class="s2">for </span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
		<span class="s1">{</span>
			<span class="s1">fApB = dec_values[i]*A+B;</span>
			<span class="s2">if </span><span class="s1">(fApB &gt;= </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s1">p=exp(-fApB)/(</span><span class="s5">1.0</span><span class="s1">+exp(-fApB));</span>
				<span class="s1">q=</span><span class="s5">1.0</span><span class="s1">/(</span><span class="s5">1.0</span><span class="s1">+exp(-fApB));</span>
			<span class="s1">}</span>
			<span class="s2">else</span>
			<span class="s1">{</span>
				<span class="s1">p=</span><span class="s5">1.0</span><span class="s1">/(</span><span class="s5">1.0</span><span class="s1">+exp(fApB));</span>
				<span class="s1">q=exp(fApB)/(</span><span class="s5">1.0</span><span class="s1">+exp(fApB));</span>
			<span class="s1">}</span>
			<span class="s1">d2=p*q;</span>
			<span class="s1">h11+=dec_values[i]*dec_values[i]*d2;</span>
			<span class="s1">h22+=d2;</span>
			<span class="s1">h21+=dec_values[i]*d2;</span>
			<span class="s1">d1=t[i]-p;</span>
			<span class="s1">g1+=dec_values[i]*d1;</span>
			<span class="s1">g2+=d1;</span>
		<span class="s1">}</span>

		<span class="s0">// Stopping Criteria</span>
		<span class="s2">if </span><span class="s1">(fabs(g1)&lt;eps &amp;&amp; fabs(g2)&lt;eps)</span>
			<span class="s2">break</span><span class="s1">;</span>

		<span class="s0">// Finding Newton direction: -inv(H') * g</span>
		<span class="s1">det=h11*h22-h21*h21;</span>
		<span class="s1">dA=-(h22*g1 - h21 * g2) / det;</span>
		<span class="s1">dB=-(-h21*g1+ h11 * g2) / det;</span>
		<span class="s1">gd=g1*dA+g2*dB;</span>


		<span class="s1">stepsize = </span><span class="s5">1</span><span class="s1">;		</span><span class="s0">// Line Search</span>
		<span class="s2">while </span><span class="s1">(stepsize &gt;= min_step)</span>
		<span class="s1">{</span>
			<span class="s1">newA = A + stepsize * dA;</span>
			<span class="s1">newB = B + stepsize * dB;</span>

			<span class="s0">// New function value</span>
			<span class="s1">newf = </span><span class="s5">0.0</span><span class="s1">;</span>
			<span class="s2">for </span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
			<span class="s1">{</span>
				<span class="s1">fApB = dec_values[i]*newA+newB;</span>
				<span class="s2">if </span><span class="s1">(fApB &gt;= </span><span class="s5">0</span><span class="s1">)</span>
					<span class="s1">newf += t[i]*fApB + log(</span><span class="s5">1</span><span class="s1">+exp(-fApB));</span>
				<span class="s2">else</span>
					<span class="s1">newf += (t[i] - </span><span class="s5">1</span><span class="s1">)*fApB +log(</span><span class="s5">1</span><span class="s1">+exp(fApB));</span>
			<span class="s1">}</span>
			<span class="s0">// Check sufficient decrease</span>
			<span class="s2">if </span><span class="s1">(newf&lt;fval+</span><span class="s5">0.0001</span><span class="s1">*stepsize*gd)</span>
			<span class="s1">{</span>
				<span class="s1">A=newA;B=newB;fval=newf;</span>
				<span class="s2">break</span><span class="s1">;</span>
			<span class="s1">}</span>
			<span class="s2">else</span>
				<span class="s1">stepsize = stepsize / </span><span class="s5">2.0</span><span class="s1">;</span>
		<span class="s1">}</span>

		<span class="s2">if </span><span class="s1">(stepsize &lt; min_step)</span>
		<span class="s1">{</span>
			<span class="s1">info(</span><span class="s3">&quot;Line search fails in two-class probability estimates</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
			<span class="s2">break</span><span class="s1">;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

	<span class="s2">if </span><span class="s1">(iter&gt;=max_iter)</span>
		<span class="s1">info(</span><span class="s3">&quot;Reaching maximal iterations in two-class probability estimates</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
	<span class="s1">free(t);</span>
<span class="s1">}</span>

<span class="s2">static double </span><span class="s1">sigmoid_predict(</span><span class="s2">double </span><span class="s1">decision_value, </span><span class="s2">double </span><span class="s1">A, </span><span class="s2">double </span><span class="s1">B)</span>
<span class="s1">{</span>
	<span class="s2">double </span><span class="s1">fApB = decision_value*A+B;</span>
	<span class="s0">// 1-p used later; avoid catastrophic cancellation</span>
	<span class="s2">if </span><span class="s1">(fApB &gt;= </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s2">return </span><span class="s1">exp(-fApB)/(</span><span class="s5">1.0</span><span class="s1">+exp(-fApB));</span>
	<span class="s2">else</span>
		<span class="s2">return </span><span class="s5">1.0</span><span class="s1">/(</span><span class="s5">1</span><span class="s1">+exp(fApB)) ;</span>
<span class="s1">}</span>

<span class="s0">// Method 2 from the multiclass_prob paper by Wu, Lin, and Weng</span>
<span class="s2">static void </span><span class="s1">multiclass_probability(</span><span class="s2">int </span><span class="s1">k, </span><span class="s2">double </span><span class="s1">**r, </span><span class="s2">double </span><span class="s1">*p)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">t,j;</span>
	<span class="s2">int </span><span class="s1">iter = </span><span class="s5">0</span><span class="s1">, max_iter=max(</span><span class="s5">100</span><span class="s1">,k);</span>
	<span class="s2">double </span><span class="s1">**Q=Malloc(</span><span class="s2">double </span><span class="s1">*,k);</span>
	<span class="s2">double </span><span class="s1">*Qp=Malloc(</span><span class="s2">double</span><span class="s1">,k);</span>
	<span class="s2">double </span><span class="s1">pQp, eps=</span><span class="s5">0.005</span><span class="s1">/k;</span>

	<span class="s2">for </span><span class="s1">(t=</span><span class="s5">0</span><span class="s1">;t&lt;k;t++)</span>
	<span class="s1">{</span>
		<span class="s1">p[t]=</span><span class="s5">1.0</span><span class="s1">/k;  </span><span class="s0">// Valid if k = 1</span>
		<span class="s1">Q[t]=Malloc(</span><span class="s2">double</span><span class="s1">,k);</span>
		<span class="s1">Q[t][t]=</span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for </span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;t;j++)</span>
		<span class="s1">{</span>
			<span class="s1">Q[t][t]+=r[j][t]*r[j][t];</span>
			<span class="s1">Q[t][j]=Q[j][t];</span>
		<span class="s1">}</span>
		<span class="s2">for </span><span class="s1">(j=t+</span><span class="s5">1</span><span class="s1">;j&lt;k;j++)</span>
		<span class="s1">{</span>
			<span class="s1">Q[t][t]+=r[j][t]*r[j][t];</span>
			<span class="s1">Q[t][j]=-r[j][t]*r[t][j];</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s2">for </span><span class="s1">(iter=</span><span class="s5">0</span><span class="s1">;iter&lt;max_iter;iter++)</span>
	<span class="s1">{</span>
		<span class="s0">// stopping condition, recalculate QP,pQP for numerical accuracy</span>
		<span class="s1">pQp=</span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for </span><span class="s1">(t=</span><span class="s5">0</span><span class="s1">;t&lt;k;t++)</span>
		<span class="s1">{</span>
			<span class="s1">Qp[t]=</span><span class="s5">0</span><span class="s1">;</span>
			<span class="s2">for </span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;k;j++)</span>
				<span class="s1">Qp[t]+=Q[t][j]*p[j];</span>
			<span class="s1">pQp+=p[t]*Qp[t];</span>
		<span class="s1">}</span>
		<span class="s2">double </span><span class="s1">max_error=</span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for </span><span class="s1">(t=</span><span class="s5">0</span><span class="s1">;t&lt;k;t++)</span>
		<span class="s1">{</span>
			<span class="s2">double </span><span class="s1">error=fabs(Qp[t]-pQp);</span>
			<span class="s2">if </span><span class="s1">(error&gt;max_error)</span>
				<span class="s1">max_error=error;</span>
		<span class="s1">}</span>
		<span class="s2">if </span><span class="s1">(max_error&lt;eps) </span><span class="s2">break</span><span class="s1">;</span>

		<span class="s2">for </span><span class="s1">(t=</span><span class="s5">0</span><span class="s1">;t&lt;k;t++)</span>
		<span class="s1">{</span>
			<span class="s2">double </span><span class="s1">diff=(-Qp[t]+pQp)/Q[t][t];</span>
			<span class="s1">p[t]+=diff;</span>
			<span class="s1">pQp=(pQp+diff*(diff*Q[t][t]+</span><span class="s5">2</span><span class="s1">*Qp[t]))/(</span><span class="s5">1</span><span class="s1">+diff)/(</span><span class="s5">1</span><span class="s1">+diff);</span>
			<span class="s2">for </span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;k;j++)</span>
			<span class="s1">{</span>
				<span class="s1">Qp[j]=(Qp[j]+diff*Q[t][j])/(</span><span class="s5">1</span><span class="s1">+diff);</span>
				<span class="s1">p[j]/=(</span><span class="s5">1</span><span class="s1">+diff);</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s2">if </span><span class="s1">(iter&gt;=max_iter)</span>
		<span class="s1">info(</span><span class="s3">&quot;Exceeds max_iter in multiclass_prob</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
	<span class="s2">for</span><span class="s1">(t=</span><span class="s5">0</span><span class="s1">;t&lt;k;t++) free(Q[t]);</span>
	<span class="s1">free(Q);</span>
	<span class="s1">free(Qp);</span>
<span class="s1">}</span>

<span class="s0">// Cross-validation decision values for probability estimates</span>
<span class="s2">static void </span><span class="s1">svm_binary_svc_probability(</span>
	<span class="s2">const </span><span class="s1">PREFIX(problem) *prob, </span><span class="s2">const </span><span class="s1">svm_parameter *param,</span>
	<span class="s2">double </span><span class="s1">Cp, </span><span class="s2">double </span><span class="s1">Cn, </span><span class="s2">double</span><span class="s1">&amp; probA, </span><span class="s2">double</span><span class="s1">&amp; probB, </span><span class="s2">int </span><span class="s1">* status, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">int </span><span class="s1">nr_fold = </span><span class="s5">5</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">*perm = Malloc(</span><span class="s2">int</span><span class="s1">,prob</span><span class="s6">-&gt;</span><span class="s1">l);</span>
	<span class="s2">double </span><span class="s1">*dec_values = Malloc(</span><span class="s2">double</span><span class="s1">,prob</span><span class="s6">-&gt;</span><span class="s1">l);</span>

	<span class="s0">// random shuffle</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;prob</span><span class="s6">-&gt;</span><span class="s1">l;i++) perm[i]=i;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;prob</span><span class="s6">-&gt;</span><span class="s1">l;i++)</span>
	<span class="s1">{</span>
		<span class="s2">int </span><span class="s1">j = i+bounded_rand_int(prob</span><span class="s6">-&gt;</span><span class="s1">l-i);</span>
		<span class="s1">swap(perm[i],perm[j]);</span>
	<span class="s1">}</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_fold;i++)</span>
	<span class="s1">{</span>
		<span class="s2">int </span><span class="s1">begin = i*prob</span><span class="s6">-&gt;</span><span class="s1">l/nr_fold;</span>
		<span class="s2">int </span><span class="s1">end = (i+</span><span class="s5">1</span><span class="s1">)*prob</span><span class="s6">-&gt;</span><span class="s1">l/nr_fold;</span>
		<span class="s2">int </span><span class="s1">j,k;</span>
		<span class="s2">struct </span><span class="s1">PREFIX(problem) subprob;</span>

		<span class="s1">subprob.l = prob</span><span class="s6">-&gt;</span><span class="s1">l-(end-begin);</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
		<span class="s1">subprob.x = Malloc(</span><span class="s2">struct </span><span class="s1">PREFIX(node),subprob.l);</span>
<span class="s2">#else</span>
		<span class="s1">subprob.x = Malloc(</span><span class="s2">struct </span><span class="s1">PREFIX(node)*,subprob.l);</span>
<span class="s2">#endif</span>
		<span class="s1">subprob.y = Malloc(</span><span class="s2">double</span><span class="s1">,subprob.l);</span>
                <span class="s1">subprob.W = Malloc(</span><span class="s2">double</span><span class="s1">,subprob.l);</span>

		<span class="s1">k=</span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;begin;j++)</span>
		<span class="s1">{</span>
			<span class="s1">subprob.x[k] = prob</span><span class="s6">-&gt;</span><span class="s1">x[perm[j]];</span>
			<span class="s1">subprob.y[k] = prob</span><span class="s6">-&gt;</span><span class="s1">y[perm[j]];</span>
			<span class="s1">subprob.W[k] = prob</span><span class="s6">-&gt;</span><span class="s1">W[perm[j]];</span>
			<span class="s1">++k;</span>
		<span class="s1">}</span>
		<span class="s2">for</span><span class="s1">(j=end;j&lt;prob</span><span class="s6">-&gt;</span><span class="s1">l;j++)</span>
		<span class="s1">{</span>
			<span class="s1">subprob.x[k] = prob</span><span class="s6">-&gt;</span><span class="s1">x[perm[j]];</span>
			<span class="s1">subprob.y[k] = prob</span><span class="s6">-&gt;</span><span class="s1">y[perm[j]];</span>
			<span class="s1">subprob.W[k] = prob</span><span class="s6">-&gt;</span><span class="s1">W[perm[j]];</span>
			<span class="s1">++k;</span>
		<span class="s1">}</span>
		<span class="s2">int </span><span class="s1">p_count=</span><span class="s5">0</span><span class="s1">,n_count=</span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;k;j++)</span>
			<span class="s2">if</span><span class="s1">(subprob.y[j]&gt;</span><span class="s5">0</span><span class="s1">)</span>
				<span class="s1">p_count++;</span>
			<span class="s2">else</span>
				<span class="s1">n_count++;</span>

		<span class="s2">if</span><span class="s1">(p_count==</span><span class="s5">0 </span><span class="s1">&amp;&amp; n_count==</span><span class="s5">0</span><span class="s1">)</span>
			<span class="s2">for</span><span class="s1">(j=begin;j&lt;end;j++)</span>
				<span class="s1">dec_values[perm[j]] = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">else if</span><span class="s1">(p_count &gt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; n_count == </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s2">for</span><span class="s1">(j=begin;j&lt;end;j++)</span>
				<span class="s1">dec_values[perm[j]] = </span><span class="s5">1</span><span class="s1">;</span>
		<span class="s2">else if</span><span class="s1">(p_count == </span><span class="s5">0 </span><span class="s1">&amp;&amp; n_count &gt; </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s2">for</span><span class="s1">(j=begin;j&lt;end;j++)</span>
				<span class="s1">dec_values[perm[j]] = -</span><span class="s5">1</span><span class="s1">;</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s1">svm_parameter subparam = *param;</span>
			<span class="s1">subparam.probability=</span><span class="s5">0</span><span class="s1">;</span>
			<span class="s1">subparam.C=</span><span class="s5">1.0</span><span class="s1">;</span>
			<span class="s1">subparam.nr_weight=</span><span class="s5">2</span><span class="s1">;</span>
			<span class="s1">subparam.weight_label = Malloc(</span><span class="s2">int</span><span class="s1">,</span><span class="s5">2</span><span class="s1">);</span>
			<span class="s1">subparam.weight = Malloc(</span><span class="s2">double</span><span class="s1">,</span><span class="s5">2</span><span class="s1">);</span>
			<span class="s1">subparam.weight_label[</span><span class="s5">0</span><span class="s1">]=+</span><span class="s5">1</span><span class="s1">;</span>
			<span class="s1">subparam.weight_label[</span><span class="s5">1</span><span class="s1">]=-</span><span class="s5">1</span><span class="s1">;</span>
			<span class="s1">subparam.weight[</span><span class="s5">0</span><span class="s1">]=Cp;</span>
			<span class="s1">subparam.weight[</span><span class="s5">1</span><span class="s1">]=Cn;</span>
			<span class="s2">struct </span><span class="s1">PREFIX(model) *submodel = PREFIX(train)(&amp;subprob,&amp;subparam, status, blas_functions);</span>
			<span class="s2">for</span><span class="s1">(j=begin;j&lt;end;j++)</span>
			<span class="s1">{</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
                                <span class="s1">PREFIX(predict_values)(submodel,(prob</span><span class="s6">-&gt;</span><span class="s1">x+perm[j]),&amp;(dec_values[perm[j]]), blas_functions);</span>
<span class="s2">#else</span>
				<span class="s1">PREFIX(predict_values)(submodel,prob</span><span class="s6">-&gt;</span><span class="s1">x[perm[j]],&amp;(dec_values[perm[j]]), blas_functions);</span>
<span class="s2">#endif</span>
				<span class="s0">// ensure +1 -1 order; reason not using CV subroutine</span>
				<span class="s1">dec_values[perm[j]] *= submodel</span><span class="s6">-&gt;</span><span class="s1">label[</span><span class="s5">0</span><span class="s1">];</span>
			<span class="s1">}</span>
			<span class="s1">PREFIX(free_and_destroy_model)(&amp;submodel);</span>
			<span class="s1">PREFIX(destroy_param)(&amp;subparam);</span>
		<span class="s1">}</span>
		<span class="s1">free(subprob.x);</span>
		<span class="s1">free(subprob.y);</span>
                <span class="s1">free(subprob.W);</span>
	<span class="s1">}</span>
	<span class="s1">sigmoid_train(prob</span><span class="s6">-&gt;</span><span class="s1">l,dec_values,prob</span><span class="s6">-&gt;</span><span class="s1">y,probA,probB);</span>
	<span class="s1">free(dec_values);</span>
	<span class="s1">free(perm);</span>
<span class="s1">}</span>

<span class="s0">// Return parameter of a Laplace distribution</span>
<span class="s2">static double </span><span class="s1">svm_svr_probability(</span>
	<span class="s2">const </span><span class="s1">PREFIX(problem) *prob, </span><span class="s2">const </span><span class="s1">svm_parameter *param, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">int </span><span class="s1">nr_fold = </span><span class="s5">5</span><span class="s1">;</span>
	<span class="s2">double </span><span class="s1">*ymv = Malloc(</span><span class="s2">double</span><span class="s1">,prob</span><span class="s6">-&gt;</span><span class="s1">l);</span>
	<span class="s2">double </span><span class="s1">mae = </span><span class="s5">0</span><span class="s1">;</span>

	<span class="s1">svm_parameter newparam = *param;</span>
	<span class="s1">newparam.probability = </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s1">newparam.random_seed = -</span><span class="s5">1</span><span class="s1">; </span><span class="s0">// This is called from train, which already sets</span>
                               <span class="s0">// the seed.</span>
	<span class="s1">PREFIX(cross_validation)(prob,&amp;newparam,nr_fold,ymv, blas_functions);</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;prob</span><span class="s6">-&gt;</span><span class="s1">l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">ymv[i]=prob</span><span class="s6">-&gt;</span><span class="s1">y[i]-ymv[i];</span>
		<span class="s1">mae += fabs(ymv[i]);</span>
	<span class="s1">}</span>
	<span class="s1">mae /= prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">double </span><span class="s1">std=sqrt(</span><span class="s5">2</span><span class="s1">*mae*mae);</span>
	<span class="s2">int </span><span class="s1">count=</span><span class="s5">0</span><span class="s1">;</span>
	<span class="s1">mae=</span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;prob</span><span class="s6">-&gt;</span><span class="s1">l;i++)</span>
		<span class="s2">if </span><span class="s1">(fabs(ymv[i]) &gt; </span><span class="s5">5</span><span class="s1">*std)</span>
			<span class="s1">count=count+</span><span class="s5">1</span><span class="s1">;</span>
		<span class="s2">else</span>
			<span class="s1">mae+=fabs(ymv[i]);</span>
	<span class="s1">mae /= (prob</span><span class="s6">-&gt;</span><span class="s1">l-count);</span>
	<span class="s1">info(</span><span class="s3">&quot;Prob. model for test data: target value = predicted value + z,</span><span class="s2">\n</span><span class="s3">z: Laplace distribution e^(-|z|/sigma)/(2sigma),sigma= %g</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">,mae);</span>
	<span class="s1">free(ymv);</span>
	<span class="s2">return </span><span class="s1">mae;</span>
<span class="s1">}</span>



<span class="s0">// label: label name, start: begin of each class, count: #data of classes, perm: indices to the original data</span>
<span class="s0">// perm, length l, must be allocated before calling this subroutine</span>
<span class="s2">static void </span><span class="s1">svm_group_classes(</span><span class="s2">const </span><span class="s1">PREFIX(problem) *prob, </span><span class="s2">int </span><span class="s1">*nr_class_ret, </span><span class="s2">int </span><span class="s1">**label_ret, </span><span class="s2">int </span><span class="s1">**start_ret, </span><span class="s2">int </span><span class="s1">**count_ret, </span><span class="s2">int </span><span class="s1">*perm)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">l = prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">max_nr_class = </span><span class="s5">16</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">nr_class = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">int </span><span class="s1">*label = Malloc(</span><span class="s2">int</span><span class="s1">,max_nr_class);</span>
	<span class="s2">int </span><span class="s1">*count = Malloc(</span><span class="s2">int</span><span class="s1">,max_nr_class);</span>
	<span class="s2">int </span><span class="s1">*data_label = Malloc(</span><span class="s2">int</span><span class="s1">,l);</span>
	<span class="s2">int </span><span class="s1">i, j, this_label, this_count;</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">this_label = (</span><span class="s2">int</span><span class="s1">)prob</span><span class="s6">-&gt;</span><span class="s1">y[i];</span>
		<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;nr_class;j++)</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(this_label == label[j])</span>
			<span class="s1">{</span>
				<span class="s1">++count[j];</span>
				<span class="s2">break</span><span class="s1">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s2">if</span><span class="s1">(j == nr_class)</span>
		<span class="s1">{</span>
			<span class="s2">if</span><span class="s1">(nr_class == max_nr_class)</span>
			<span class="s1">{</span>
				<span class="s1">max_nr_class *= </span><span class="s5">2</span><span class="s1">;</span>
				<span class="s1">label = (</span><span class="s2">int </span><span class="s1">*)realloc(label,max_nr_class*</span><span class="s2">sizeof</span><span class="s1">(</span><span class="s2">int</span><span class="s1">));</span>
				<span class="s1">count = (</span><span class="s2">int </span><span class="s1">*)realloc(count,max_nr_class*</span><span class="s2">sizeof</span><span class="s1">(</span><span class="s2">int</span><span class="s1">));</span>
			<span class="s1">}</span>
			<span class="s1">label[nr_class] = this_label;</span>
			<span class="s1">count[nr_class] = </span><span class="s5">1</span><span class="s1">;</span>
			<span class="s1">++nr_class;</span>
		<span class="s1">}</span>
	<span class="s1">}</span>

        <span class="s0">/* 
         * Sort labels by straight insertion and apply the same 
         * transformation to array count. 
         */</span>
        <span class="s2">for</span><span class="s1">(j=</span><span class="s5">1</span><span class="s1">; j&lt;nr_class; j++)</span>
        <span class="s1">{</span>
                <span class="s1">i = j-1;</span>
                <span class="s1">this_label = label[j];</span>
                <span class="s1">this_count = count[j];</span>
                <span class="s2">while</span><span class="s1">(i&gt;=</span><span class="s5">0 </span><span class="s1">&amp;&amp; label[i] &gt; this_label)</span>
                <span class="s1">{</span>
                        <span class="s1">label[i+</span><span class="s5">1</span><span class="s1">] = label[i];</span>
                        <span class="s1">count[i+</span><span class="s5">1</span><span class="s1">] = count[i];</span>
                        <span class="s1">i--;</span>
                <span class="s1">}</span>
                <span class="s1">label[i+</span><span class="s5">1</span><span class="s1">] = this_label;</span>
                <span class="s1">count[i+</span><span class="s5">1</span><span class="s1">] = this_count;</span>
        <span class="s1">}</span>

        <span class="s2">for </span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">; i&lt;l; i++)</span>
        <span class="s1">{</span>
                <span class="s1">j = </span><span class="s5">0</span><span class="s1">;</span>
                <span class="s1">this_label = (</span><span class="s2">int</span><span class="s1">)prob</span><span class="s6">-&gt;</span><span class="s1">y[i];</span>
                <span class="s2">while</span><span class="s1">(this_label != label[j]){</span>
                        <span class="s1">j ++;</span>
                <span class="s1">}</span>
                <span class="s1">data_label[i] = j;</span>
        <span class="s1">}</span>

	<span class="s2">int </span><span class="s1">*start = Malloc(</span><span class="s2">int</span><span class="s1">,nr_class);</span>
	<span class="s1">start[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">1</span><span class="s1">;i&lt;nr_class;i++)</span>
		<span class="s1">start[i] = start[i-1]+count[i-1];</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
	<span class="s1">{</span>
		<span class="s1">perm[start[data_label[i]]] = i;</span>
		<span class="s1">++start[data_label[i]];</span>
	<span class="s1">}</span>

	<span class="s1">start[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">1</span><span class="s1">;i&lt;nr_class;i++)</span>
		<span class="s1">start[i] = start[i-1]+count[i-1];</span>

	<span class="s1">*nr_class_ret = nr_class;</span>
	<span class="s1">*label_ret = label;</span>
	<span class="s1">*start_ret = start;</span>
	<span class="s1">*count_ret = count;</span>
	<span class="s1">free(data_label);</span>
<span class="s1">}</span>

<span class="s1">} </span><span class="s0">/* end namespace */</span>

<span class="s0">// Remove zero weighed data as libsvm and some liblinear solvers require C &gt; 0.</span>
<span class="s0">//</span>
<span class="s2">static void </span><span class="s1">remove_zero_weight(PREFIX(problem) *newprob, </span><span class="s2">const </span><span class="s1">PREFIX(problem) *prob)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">int </span><span class="s1">l = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;prob</span><span class="s6">-&gt;</span><span class="s1">l;i++)</span>
		<span class="s2">if</span><span class="s1">(prob</span><span class="s6">-&gt;</span><span class="s1">W[i] &gt; </span><span class="s5">0</span><span class="s1">) l++;</span>
	<span class="s1">*newprob = *prob;</span>
	<span class="s1">newprob</span><span class="s6">-&gt;</span><span class="s1">l = l;</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
	<span class="s1">newprob</span><span class="s6">-&gt;</span><span class="s1">x = Malloc(PREFIX(node),l);</span>
<span class="s2">#else</span>
      	<span class="s1">newprob</span><span class="s6">-&gt;</span><span class="s1">x = Malloc(PREFIX(node) *,l);</span>
<span class="s2">#endif</span>
	<span class="s1">newprob</span><span class="s6">-&gt;</span><span class="s1">y = Malloc(</span><span class="s2">double</span><span class="s1">,l);</span>
	<span class="s1">newprob</span><span class="s6">-&gt;</span><span class="s1">W = Malloc(</span><span class="s2">double</span><span class="s1">,l);</span>

	<span class="s2">int </span><span class="s1">j = </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;prob</span><span class="s6">-&gt;</span><span class="s1">l;i++)</span>
		<span class="s2">if</span><span class="s1">(prob</span><span class="s6">-&gt;</span><span class="s1">W[i] &gt; </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s1">{</span>
			<span class="s1">newprob</span><span class="s6">-&gt;</span><span class="s1">x[j] = prob</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
			<span class="s1">newprob</span><span class="s6">-&gt;</span><span class="s1">y[j] = prob</span><span class="s6">-&gt;</span><span class="s1">y[i];</span>
			<span class="s1">newprob</span><span class="s6">-&gt;</span><span class="s1">W[j] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i];</span>
			<span class="s1">j++;</span>
		<span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">//</span>
<span class="s0">// Interface functions</span>
<span class="s0">//</span>
<span class="s1">PREFIX(model) *PREFIX(train)(</span><span class="s2">const </span><span class="s1">PREFIX(problem) *prob, </span><span class="s2">const </span><span class="s1">svm_parameter *param,</span>
        <span class="s2">int </span><span class="s1">*status, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s1">PREFIX(problem) newprob;</span>
	<span class="s1">remove_zero_weight(&amp;newprob, prob);</span>
	<span class="s1">prob = &amp;newprob;</span>

	<span class="s1">PREFIX(model) *model = Malloc(PREFIX(model),</span><span class="s5">1</span><span class="s1">);</span>
	<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">param = *param;</span>
	<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">free_sv = </span><span class="s5">0</span><span class="s1">;	</span><span class="s0">// XXX</span>

    <span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">random_seed &gt;= </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">{</span>
        <span class="s1">set_seed(param</span><span class="s6">-&gt;</span><span class="s1">random_seed);</span>
    <span class="s1">}</span>

	<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">svm_type == ONE_CLASS ||</span>
	   <span class="s1">param</span><span class="s6">-&gt;</span><span class="s1">svm_type == EPSILON_SVR ||</span>
	   <span class="s1">param</span><span class="s6">-&gt;</span><span class="s1">svm_type == NU_SVR)</span>
	<span class="s1">{</span>
		<span class="s0">// regression or one-class-svm</span>
		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">nr_class = </span><span class="s5">2</span><span class="s1">;</span>
		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">label = NULL;</span>
		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">nSV = NULL;</span>
		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">probA = NULL; model</span><span class="s6">-&gt;</span><span class="s1">probB = NULL;</span>
		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">sv_coef = Malloc(</span><span class="s2">double </span><span class="s1">*,</span><span class="s5">1</span><span class="s1">);</span>

		<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">probability &amp;&amp;</span>
		   <span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">svm_type == EPSILON_SVR ||</span>
		    <span class="s1">param</span><span class="s6">-&gt;</span><span class="s1">svm_type == NU_SVR))</span>
		<span class="s1">{</span>
			<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">probA = Malloc(</span><span class="s2">double</span><span class="s1">,</span><span class="s5">1</span><span class="s1">);</span>
			<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">probA[</span><span class="s5">0</span><span class="s1">] = NAMESPACE::svm_svr_probability(prob,param,blas_functions);</span>
		<span class="s1">}</span>

                <span class="s1">NAMESPACE::decision_function f = NAMESPACE::svm_train_one(prob,param,</span><span class="s5">0</span><span class="s1">,</span><span class="s5">0</span><span class="s1">, status,blas_functions);</span>
		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">rho = Malloc(</span><span class="s2">double</span><span class="s1">,</span><span class="s5">1</span><span class="s1">);</span>
		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">rho[</span><span class="s5">0</span><span class="s1">] = f.rho;</span>
		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">n_iter = Malloc(</span><span class="s2">int</span><span class="s1">,</span><span class="s5">1</span><span class="s1">);</span>
		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">n_iter[</span><span class="s5">0</span><span class="s1">] = f.n_iter;</span>

		<span class="s2">int </span><span class="s1">nSV = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">int </span><span class="s1">i;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;prob</span><span class="s6">-&gt;</span><span class="s1">l;i++)</span>
			<span class="s2">if</span><span class="s1">(fabs(f.alpha[i]) &gt; </span><span class="s5">0</span><span class="s1">) ++nSV;</span>
		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">l = nSV;</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">SV = Malloc(PREFIX(node),nSV);</span>
<span class="s2">#else</span>
		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">SV = Malloc(PREFIX(node) *,nSV);</span>
<span class="s2">#endif</span>
                <span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">sv_ind = Malloc(</span><span class="s2">int</span><span class="s1">, nSV);</span>
		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">sv_coef[</span><span class="s5">0</span><span class="s1">] = Malloc(</span><span class="s2">double</span><span class="s1">, nSV);</span>
		<span class="s2">int </span><span class="s1">j = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;prob</span><span class="s6">-&gt;</span><span class="s1">l;i++)</span>
			<span class="s2">if</span><span class="s1">(fabs(f.alpha[i]) &gt; </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s1">{</span>
				<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">SV[j] = prob</span><span class="s6">-&gt;</span><span class="s1">x[i];</span>
                                <span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">sv_ind[j] = i;</span>
				<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">sv_coef[</span><span class="s5">0</span><span class="s1">][j] = f.alpha[i];</span>
				<span class="s1">++j;</span>
			<span class="s1">}</span>

		<span class="s1">free(f.alpha);</span>
	<span class="s1">}</span>
	<span class="s2">else</span>
	<span class="s1">{</span>
		<span class="s0">// classification</span>
		<span class="s2">int </span><span class="s1">l = prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
		<span class="s2">int </span><span class="s1">nr_class;</span>
		<span class="s2">int </span><span class="s1">*label = NULL;</span>
		<span class="s2">int </span><span class="s1">*start = NULL;</span>
		<span class="s2">int </span><span class="s1">*count = NULL;</span>
		<span class="s2">int </span><span class="s1">*perm = Malloc(</span><span class="s2">int</span><span class="s1">,l);</span>

		<span class="s0">// group training data of the same class</span>
                <span class="s1">NAMESPACE::svm_group_classes(prob,&amp;nr_class,&amp;label,&amp;start,&amp;count,perm);</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
		<span class="s1">PREFIX(node) *x = Malloc(PREFIX(node),l);</span>
<span class="s2">#else</span>
		<span class="s1">PREFIX(node) **x = Malloc(PREFIX(node) *,l);</span>
<span class="s2">#endif</span>
                <span class="s2">double </span><span class="s1">*W = Malloc(</span><span class="s2">double</span><span class="s1">, l);</span>

		<span class="s2">int </span><span class="s1">i;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
                <span class="s1">{</span>
			<span class="s1">x[i] = prob</span><span class="s6">-&gt;</span><span class="s1">x[perm[i]];</span>
			<span class="s1">W[i] = prob</span><span class="s6">-&gt;</span><span class="s1">W[perm[i]];</span>
                <span class="s1">}</span>

		<span class="s0">// calculate weighted C</span>

		<span class="s2">double </span><span class="s1">*weighted_C = Malloc(</span><span class="s2">double</span><span class="s1">, nr_class);</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class;i++)</span>
			<span class="s1">weighted_C[i] = param</span><span class="s6">-&gt;</span><span class="s1">C;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;param</span><span class="s6">-&gt;</span><span class="s1">nr_weight;i++)</span>
		<span class="s1">{</span>
			<span class="s2">int </span><span class="s1">j;</span>
			<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;nr_class;j++)</span>
				<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">weight_label[i] == label[j])</span>
					<span class="s2">break</span><span class="s1">;</span>
			<span class="s2">if</span><span class="s1">(j == nr_class)</span>
				<span class="s1">fprintf(stderr,</span><span class="s3">&quot;warning: class label %d specified in weight is not found</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">, param</span><span class="s6">-&gt;</span><span class="s1">weight_label[i]);</span>
			<span class="s2">else</span>
				<span class="s1">weighted_C[j] *= param</span><span class="s6">-&gt;</span><span class="s1">weight[i];</span>
		<span class="s1">}</span>

		<span class="s0">// train k*(k-1)/2 models</span>

		<span class="s2">bool </span><span class="s1">*nonzero = Malloc(</span><span class="s2">bool</span><span class="s1">,l);</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
			<span class="s1">nonzero[i] = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s1">NAMESPACE::decision_function *f = Malloc(NAMESPACE::decision_function,nr_class*(nr_class-1)/</span><span class="s5">2</span><span class="s1">);</span>

		<span class="s2">double </span><span class="s1">*probA=NULL,*probB=NULL;</span>
		<span class="s2">if </span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">probability)</span>
		<span class="s1">{</span>
			<span class="s1">probA=Malloc(</span><span class="s2">double</span><span class="s1">,nr_class*(nr_class-1)/</span><span class="s5">2</span><span class="s1">);</span>
			<span class="s1">probB=Malloc(</span><span class="s2">double</span><span class="s1">,nr_class*(nr_class-1)/</span><span class="s5">2</span><span class="s1">);</span>
		<span class="s1">}</span>

		<span class="s2">int </span><span class="s1">p = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class;i++)</span>
			<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">j=i+</span><span class="s5">1</span><span class="s1">;j&lt;nr_class;j++)</span>
			<span class="s1">{</span>
				<span class="s1">PREFIX(problem) sub_prob;</span>
				<span class="s2">int </span><span class="s1">si = start[i], sj = start[j];</span>
				<span class="s2">int </span><span class="s1">ci = count[i], cj = count[j];</span>
				<span class="s1">sub_prob.l = ci+cj;</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
				<span class="s1">sub_prob.x = Malloc(PREFIX(node),sub_prob.l);</span>
<span class="s2">#else</span>
				<span class="s1">sub_prob.x = Malloc(PREFIX(node) *,sub_prob.l);</span>
<span class="s2">#endif</span>
				<span class="s1">sub_prob.W = Malloc(</span><span class="s2">double</span><span class="s1">,sub_prob.l);</span>
				<span class="s1">sub_prob.y = Malloc(</span><span class="s2">double</span><span class="s1">,sub_prob.l);</span>
				<span class="s2">int </span><span class="s1">k;</span>
				<span class="s2">for</span><span class="s1">(k=</span><span class="s5">0</span><span class="s1">;k&lt;ci;k++)</span>
				<span class="s1">{</span>
					<span class="s1">sub_prob.x[k] = x[si+k];</span>
					<span class="s1">sub_prob.y[k] = +</span><span class="s5">1</span><span class="s1">;</span>
					<span class="s1">sub_prob.W[k] = W[si+k];</span>
				<span class="s1">}</span>
				<span class="s2">for</span><span class="s1">(k=</span><span class="s5">0</span><span class="s1">;k&lt;cj;k++)</span>
				<span class="s1">{</span>
					<span class="s1">sub_prob.x[ci+k] = x[sj+k];</span>
					<span class="s1">sub_prob.y[ci+k] = -</span><span class="s5">1</span><span class="s1">;</span>
					<span class="s1">sub_prob.W[ci+k] = W[sj+k];</span>
				<span class="s1">}</span>

				<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">probability)</span>
                                    <span class="s1">NAMESPACE::svm_binary_svc_probability(&amp;sub_prob,param,weighted_C[i],weighted_C[j],probA[p],probB[p], status, blas_functions);</span>

				<span class="s1">f[p] = NAMESPACE::svm_train_one(&amp;sub_prob,param,weighted_C[i],weighted_C[j], status, blas_functions);</span>
				<span class="s2">for</span><span class="s1">(k=</span><span class="s5">0</span><span class="s1">;k&lt;ci;k++)</span>
					<span class="s2">if</span><span class="s1">(!nonzero[si+k] &amp;&amp; fabs(f[p].alpha[k]) &gt; </span><span class="s5">0</span><span class="s1">)</span>
						<span class="s1">nonzero[si+k] = </span><span class="s4">true</span><span class="s1">;</span>
				<span class="s2">for</span><span class="s1">(k=</span><span class="s5">0</span><span class="s1">;k&lt;cj;k++)</span>
					<span class="s2">if</span><span class="s1">(!nonzero[sj+k] &amp;&amp; fabs(f[p].alpha[ci+k]) &gt; </span><span class="s5">0</span><span class="s1">)</span>
						<span class="s1">nonzero[sj+k] = </span><span class="s4">true</span><span class="s1">;</span>
				<span class="s1">free(sub_prob.x);</span>
				<span class="s1">free(sub_prob.y);</span>
                                <span class="s1">free(sub_prob.W);</span>
				<span class="s1">++p;</span>
			<span class="s1">}</span>

		<span class="s0">// build output</span>

		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">nr_class = nr_class;</span>

		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">label = Malloc(</span><span class="s2">int</span><span class="s1">,nr_class);</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class;i++)</span>
			<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">label[i] = label[i];</span>

		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">rho = Malloc(</span><span class="s2">double</span><span class="s1">,nr_class*(nr_class-1)/</span><span class="s5">2</span><span class="s1">);</span>
		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">n_iter = Malloc(</span><span class="s2">int</span><span class="s1">,nr_class*(nr_class-1)/</span><span class="s5">2</span><span class="s1">);</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class*(nr_class-1)/</span><span class="s5">2</span><span class="s1">;i++)</span>
		<span class="s1">{</span>
			<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">rho[i] = f[i].rho;</span>
			<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">n_iter[i] = f[i].n_iter;</span>
		<span class="s1">}</span>

		<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">probability)</span>
		<span class="s1">{</span>
			<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">probA = Malloc(</span><span class="s2">double</span><span class="s1">,nr_class*(nr_class-1)/</span><span class="s5">2</span><span class="s1">);</span>
			<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">probB = Malloc(</span><span class="s2">double</span><span class="s1">,nr_class*(nr_class-1)/</span><span class="s5">2</span><span class="s1">);</span>
			<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class*(nr_class-1)/</span><span class="s5">2</span><span class="s1">;i++)</span>
			<span class="s1">{</span>
				<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">probA[i] = probA[i];</span>
				<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">probB[i] = probB[i];</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
		<span class="s1">{</span>
			<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">probA=NULL;</span>
			<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">probB=NULL;</span>
		<span class="s1">}</span>

		<span class="s2">int </span><span class="s1">total_sv = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">int </span><span class="s1">*nz_count = Malloc(</span><span class="s2">int</span><span class="s1">,nr_class);</span>
		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">nSV = Malloc(</span><span class="s2">int</span><span class="s1">,nr_class);</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class;i++)</span>
		<span class="s1">{</span>
			<span class="s2">int </span><span class="s1">nSV = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">j=</span><span class="s5">0</span><span class="s1">;j&lt;count[i];j++)</span>
				<span class="s2">if</span><span class="s1">(nonzero[start[i]+j])</span>
				<span class="s1">{</span>
					<span class="s1">++nSV;</span>
					<span class="s1">++total_sv;</span>
				<span class="s1">}</span>
			<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">nSV[i] = nSV;</span>
			<span class="s1">nz_count[i] = nSV;</span>
		<span class="s1">}</span>

                <span class="s1">info(</span><span class="s3">&quot;Total nSV = %d</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">,total_sv);</span>

		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">l = total_sv;</span>
                <span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">sv_ind = Malloc(</span><span class="s2">int</span><span class="s1">, total_sv);</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">SV = Malloc(PREFIX(node),total_sv);</span>
<span class="s2">#else</span>
		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">SV = Malloc(PREFIX(node) *,total_sv);</span>
<span class="s2">#endif</span>
		<span class="s1">p = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++) {</span>
			<span class="s2">if</span><span class="s1">(nonzero[i]) {</span>
                                <span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">SV[p] = x[i];</span>
                                <span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">sv_ind[p] = perm[i];</span>
                                <span class="s1">++p;</span>
                        <span class="s1">}</span>
                <span class="s1">}</span>

		<span class="s2">int </span><span class="s1">*nz_start = Malloc(</span><span class="s2">int</span><span class="s1">,nr_class);</span>
		<span class="s1">nz_start[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">1</span><span class="s1">;i&lt;nr_class;i++)</span>
			<span class="s1">nz_start[i] = nz_start[i-1]+nz_count[i-1];</span>

		<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">sv_coef = Malloc(</span><span class="s2">double </span><span class="s1">*,nr_class-1);</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class-1;i++)</span>
			<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">sv_coef[i] = Malloc(</span><span class="s2">double</span><span class="s1">,total_sv);</span>

		<span class="s1">p = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class;i++)</span>
			<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">j=i+</span><span class="s5">1</span><span class="s1">;j&lt;nr_class;j++)</span>
			<span class="s1">{</span>
				<span class="s0">// classifier (i,j): coefficients with</span>
				<span class="s0">// i are in sv_coef[j-1][nz_start[i]...],</span>
				<span class="s0">// j are in sv_coef[i][nz_start[j]...]</span>

				<span class="s2">int </span><span class="s1">si = start[i];</span>
				<span class="s2">int </span><span class="s1">sj = start[j];</span>
				<span class="s2">int </span><span class="s1">ci = count[i];</span>
				<span class="s2">int </span><span class="s1">cj = count[j];</span>

				<span class="s2">int </span><span class="s1">q = nz_start[i];</span>
				<span class="s2">int </span><span class="s1">k;</span>
				<span class="s2">for</span><span class="s1">(k=</span><span class="s5">0</span><span class="s1">;k&lt;ci;k++)</span>
					<span class="s2">if</span><span class="s1">(nonzero[si+k])</span>
						<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">sv_coef[j-1][q++] = f[p].alpha[k];</span>
				<span class="s1">q = nz_start[j];</span>
				<span class="s2">for</span><span class="s1">(k=</span><span class="s5">0</span><span class="s1">;k&lt;cj;k++)</span>
					<span class="s2">if</span><span class="s1">(nonzero[sj+k])</span>
						<span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">sv_coef[i][q++] = f[p].alpha[ci+k];</span>
				<span class="s1">++p;</span>
			<span class="s1">}</span>

		<span class="s1">free(label);</span>
		<span class="s1">free(probA);</span>
		<span class="s1">free(probB);</span>
		<span class="s1">free(count);</span>
		<span class="s1">free(perm);</span>
		<span class="s1">free(start);</span>
                <span class="s1">free(W);</span>
		<span class="s1">free(x);</span>
		<span class="s1">free(weighted_C);</span>
		<span class="s1">free(nonzero);</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class*(nr_class-1)/</span><span class="s5">2</span><span class="s1">;i++)</span>
			<span class="s1">free(f[i].alpha);</span>
		<span class="s1">free(f);</span>
		<span class="s1">free(nz_count);</span>
		<span class="s1">free(nz_start);</span>
	<span class="s1">}</span>
	<span class="s1">free(newprob.x);</span>
	<span class="s1">free(newprob.y);</span>
	<span class="s1">free(newprob.W);</span>
	<span class="s2">return </span><span class="s1">model;</span>
<span class="s1">}</span>

<span class="s0">// Stratified cross validation</span>
<span class="s2">void </span><span class="s1">PREFIX(cross_validation)(</span><span class="s2">const </span><span class="s1">PREFIX(problem) *prob, </span><span class="s2">const </span><span class="s1">svm_parameter *param, </span><span class="s2">int </span><span class="s1">nr_fold, </span><span class="s2">double </span><span class="s1">*target, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">int </span><span class="s1">*fold_start = Malloc(</span><span class="s2">int</span><span class="s1">,nr_fold+</span><span class="s5">1</span><span class="s1">);</span>
	<span class="s2">int </span><span class="s1">l = prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
	<span class="s2">int </span><span class="s1">*perm = Malloc(</span><span class="s2">int</span><span class="s1">,l);</span>
	<span class="s2">int </span><span class="s1">nr_class;</span>
    <span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">random_seed &gt;= </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">{</span>
        <span class="s1">set_seed(param</span><span class="s6">-&gt;</span><span class="s1">random_seed);</span>
    <span class="s1">}</span>

	<span class="s0">// stratified cv may not give leave-one-out rate</span>
	<span class="s0">// Each class to l folds -&gt; some folds may have zero elements</span>
	<span class="s2">if</span><span class="s1">((param</span><span class="s6">-&gt;</span><span class="s1">svm_type == C_SVC ||</span>
	    <span class="s1">param</span><span class="s6">-&gt;</span><span class="s1">svm_type == NU_SVC) &amp;&amp; nr_fold &lt; l)</span>
	<span class="s1">{</span>
		<span class="s2">int </span><span class="s1">*start = NULL;</span>
		<span class="s2">int </span><span class="s1">*label = NULL;</span>
		<span class="s2">int </span><span class="s1">*count = NULL;</span>
                <span class="s1">NAMESPACE::svm_group_classes(prob,&amp;nr_class,&amp;label,&amp;start,&amp;count,perm);</span>

		<span class="s0">// random shuffle and then data grouped by fold using the array perm</span>
		<span class="s2">int </span><span class="s1">*fold_count = Malloc(</span><span class="s2">int</span><span class="s1">,nr_fold);</span>
		<span class="s2">int </span><span class="s1">c;</span>
		<span class="s2">int </span><span class="s1">*index = Malloc(</span><span class="s2">int</span><span class="s1">,l);</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
			<span class="s1">index[i]=perm[i];</span>
		<span class="s2">for </span><span class="s1">(c=</span><span class="s5">0</span><span class="s1">; c&lt;nr_class; c++)</span>
			<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;count[c];i++)</span>
			<span class="s1">{</span>
				<span class="s2">int </span><span class="s1">j = i+bounded_rand_int(count[c]-i);</span>
				<span class="s1">swap(index[start[c]+j],index[start[c]+i]);</span>
			<span class="s1">}</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_fold;i++)</span>
		<span class="s1">{</span>
			<span class="s1">fold_count[i] = </span><span class="s5">0</span><span class="s1">;</span>
			<span class="s2">for </span><span class="s1">(c=</span><span class="s5">0</span><span class="s1">; c&lt;nr_class;c++)</span>
				<span class="s1">fold_count[i]+=(i+</span><span class="s5">1</span><span class="s1">)*count[c]/nr_fold-i*count[c]/nr_fold;</span>
		<span class="s1">}</span>
		<span class="s1">fold_start[</span><span class="s5">0</span><span class="s1">]=</span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for </span><span class="s1">(i=</span><span class="s5">1</span><span class="s1">;i&lt;=nr_fold;i++)</span>
			<span class="s1">fold_start[i] = fold_start[i-1]+fold_count[i-1];</span>
		<span class="s2">for </span><span class="s1">(c=</span><span class="s5">0</span><span class="s1">; c&lt;nr_class;c++)</span>
			<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_fold;i++)</span>
			<span class="s1">{</span>
				<span class="s2">int </span><span class="s1">begin = start[c]+i*count[c]/nr_fold;</span>
				<span class="s2">int </span><span class="s1">end = start[c]+(i+</span><span class="s5">1</span><span class="s1">)*count[c]/nr_fold;</span>
				<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">j=begin;j&lt;end;j++)</span>
				<span class="s1">{</span>
					<span class="s1">perm[fold_start[i]] = index[j];</span>
					<span class="s1">fold_start[i]++;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">fold_start[</span><span class="s5">0</span><span class="s1">]=</span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for </span><span class="s1">(i=</span><span class="s5">1</span><span class="s1">;i&lt;=nr_fold;i++)</span>
			<span class="s1">fold_start[i] = fold_start[i-1]+fold_count[i-1];</span>
		<span class="s1">free(start);</span>
		<span class="s1">free(label);</span>
		<span class="s1">free(count);</span>
		<span class="s1">free(index);</span>
		<span class="s1">free(fold_count);</span>
	<span class="s1">}</span>
	<span class="s2">else</span>
	<span class="s1">{</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++) perm[i]=i;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
		<span class="s1">{</span>
			<span class="s2">int </span><span class="s1">j = i+bounded_rand_int(l-i);</span>
			<span class="s1">swap(perm[i],perm[j]);</span>
		<span class="s1">}</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;=nr_fold;i++)</span>
			<span class="s1">fold_start[i]=i*l/nr_fold;</span>
	<span class="s1">}</span>

	<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_fold;i++)</span>
	<span class="s1">{</span>
		<span class="s2">int </span><span class="s1">begin = fold_start[i];</span>
		<span class="s2">int </span><span class="s1">end = fold_start[i+</span><span class="s5">1</span><span class="s1">];</span>
		<span class="s2">int </span><span class="s1">j,k;</span>
		<span class="s2">struct </span><span class="s1">PREFIX(problem) subprob;</span>

		<span class="s1">subprob.l = l-(end-begin);</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
		<span class="s1">subprob.x = Malloc(</span><span class="s2">struct </span><span class="s1">PREFIX(node),subprob.l);</span>
<span class="s2">#else</span>
		<span class="s1">subprob.x = Malloc(</span><span class="s2">struct </span><span class="s1">PREFIX(node)*,subprob.l);</span>
<span class="s2">#endif</span>
		<span class="s1">subprob.y = Malloc(</span><span class="s2">double</span><span class="s1">,subprob.l);</span>
		<span class="s1">subprob.W = Malloc(</span><span class="s2">double</span><span class="s1">,subprob.l);</span>

		<span class="s1">k=</span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;begin;j++)</span>
		<span class="s1">{</span>
			<span class="s1">subprob.x[k] = prob</span><span class="s6">-&gt;</span><span class="s1">x[perm[j]];</span>
			<span class="s1">subprob.y[k] = prob</span><span class="s6">-&gt;</span><span class="s1">y[perm[j]];</span>
			<span class="s1">subprob.W[k] = prob</span><span class="s6">-&gt;</span><span class="s1">W[perm[j]];</span>
			<span class="s1">++k;</span>
		<span class="s1">}</span>
		<span class="s2">for</span><span class="s1">(j=end;j&lt;l;j++)</span>
		<span class="s1">{</span>
			<span class="s1">subprob.x[k] = prob</span><span class="s6">-&gt;</span><span class="s1">x[perm[j]];</span>
			<span class="s1">subprob.y[k] = prob</span><span class="s6">-&gt;</span><span class="s1">y[perm[j]];</span>
			<span class="s1">subprob.W[k] = prob</span><span class="s6">-&gt;</span><span class="s1">W[perm[j]];</span>
			<span class="s1">++k;</span>
		<span class="s1">}</span>
                <span class="s2">int </span><span class="s1">dummy_status = </span><span class="s5">0</span><span class="s1">; </span><span class="s0">// IGNORES TIMEOUT ERRORS</span>
		<span class="s2">struct </span><span class="s1">PREFIX(model) *submodel = PREFIX(train)(&amp;subprob,param, &amp;dummy_status, blas_functions);</span>
		<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">probability &amp;&amp;</span>
		   <span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">svm_type == C_SVC || param</span><span class="s6">-&gt;</span><span class="s1">svm_type == NU_SVC))</span>
		<span class="s1">{</span>
			<span class="s2">double </span><span class="s1">*prob_estimates=Malloc(</span><span class="s2">double</span><span class="s1">, PREFIX(get_nr_class)(submodel));</span>
			<span class="s2">for</span><span class="s1">(j=begin;j&lt;end;j++)</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
				<span class="s1">target[perm[j]] = PREFIX(predict_probability)(submodel,(prob</span><span class="s6">-&gt;</span><span class="s1">x + perm[j]),prob_estimates, blas_functions);</span>
<span class="s2">#else</span>
                                <span class="s1">target[perm[j]] = PREFIX(predict_probability)(submodel,prob</span><span class="s6">-&gt;</span><span class="s1">x[perm[j]],prob_estimates, blas_functions);</span>
<span class="s2">#endif</span>
			<span class="s1">free(prob_estimates);</span>
		<span class="s1">}</span>
		<span class="s2">else</span>
			<span class="s2">for</span><span class="s1">(j=begin;j&lt;end;j++)</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
				<span class="s1">target[perm[j]] = PREFIX(predict)(submodel,prob</span><span class="s6">-&gt;</span><span class="s1">x+perm[j],blas_functions);</span>
<span class="s2">#else</span>
                <span class="s1">target[perm[j]] = PREFIX(predict)(submodel,prob</span><span class="s6">-&gt;</span><span class="s1">x[perm[j]],blas_functions);</span>
<span class="s2">#endif</span>
		<span class="s1">PREFIX(free_and_destroy_model)(&amp;submodel);</span>
		<span class="s1">free(subprob.x);</span>
		<span class="s1">free(subprob.y);</span>
                <span class="s1">free(subprob.W);</span>
	<span class="s1">}</span>
	<span class="s1">free(fold_start);</span>
	<span class="s1">free(perm);</span>
<span class="s1">}</span>


<span class="s2">int </span><span class="s1">PREFIX(get_svm_type)(</span><span class="s2">const </span><span class="s1">PREFIX(model) *model)</span>
<span class="s1">{</span>
	<span class="s2">return </span><span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">param.svm_type;</span>
<span class="s1">}</span>

<span class="s2">int </span><span class="s1">PREFIX(get_nr_class)(</span><span class="s2">const </span><span class="s1">PREFIX(model) *model)</span>
<span class="s1">{</span>
	<span class="s2">return </span><span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">nr_class;</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">PREFIX(get_labels)(</span><span class="s2">const </span><span class="s1">PREFIX(model) *model, </span><span class="s2">int</span><span class="s1">* label)</span>
<span class="s1">{</span>
	<span class="s2">if </span><span class="s1">(model</span><span class="s6">-&gt;</span><span class="s1">label != NULL)</span>
		<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">;i&lt;model</span><span class="s6">-&gt;</span><span class="s1">nr_class;i++)</span>
			<span class="s1">label[i] = model</span><span class="s6">-&gt;</span><span class="s1">label[i];</span>
<span class="s1">}</span>

<span class="s2">double </span><span class="s1">PREFIX(get_svr_probability)(</span><span class="s2">const </span><span class="s1">PREFIX(model) *model)</span>
<span class="s1">{</span>
	<span class="s2">if </span><span class="s1">((model</span><span class="s6">-&gt;</span><span class="s1">param.svm_type == EPSILON_SVR || model</span><span class="s6">-&gt;</span><span class="s1">param.svm_type == NU_SVR) &amp;&amp;</span>
	    <span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">probA!=NULL)</span>
		<span class="s2">return </span><span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">probA[</span><span class="s5">0</span><span class="s1">];</span>
	<span class="s2">else</span>
	<span class="s1">{</span>
		<span class="s1">fprintf(stderr,</span><span class="s3">&quot;Model doesn't contain information for SVR probability inference</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">);</span>
		<span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">double </span><span class="s1">PREFIX(predict_values)(</span><span class="s2">const </span><span class="s1">PREFIX(model) *model, </span><span class="s2">const </span><span class="s1">PREFIX(node) *x, </span><span class="s2">double</span><span class="s1">* dec_values, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">i;</span>
	<span class="s2">if</span><span class="s1">(model</span><span class="s6">-&gt;</span><span class="s1">param.svm_type == ONE_CLASS ||</span>
	   <span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">param.svm_type == EPSILON_SVR ||</span>
	   <span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">param.svm_type == NU_SVR)</span>
	<span class="s1">{</span>
		<span class="s2">double </span><span class="s1">*sv_coef = model</span><span class="s6">-&gt;</span><span class="s1">sv_coef[</span><span class="s5">0</span><span class="s1">];</span>
		<span class="s2">double </span><span class="s1">sum = </span><span class="s5">0</span><span class="s1">;</span>

		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;model</span><span class="s6">-&gt;</span><span class="s1">l;i++)</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
                    <span class="s1">sum += sv_coef[i] * NAMESPACE::Kernel::k_function(x,model</span><span class="s6">-&gt;</span><span class="s1">SV+i,model</span><span class="s6">-&gt;</span><span class="s1">param,blas_functions);</span>
<span class="s2">#else</span>
                <span class="s1">sum += sv_coef[i] * NAMESPACE::Kernel::k_function(x,model</span><span class="s6">-&gt;</span><span class="s1">SV[i],model</span><span class="s6">-&gt;</span><span class="s1">param,blas_functions);</span>
<span class="s2">#endif</span>
		<span class="s1">sum -= model</span><span class="s6">-&gt;</span><span class="s1">rho[</span><span class="s5">0</span><span class="s1">];</span>
		<span class="s1">*dec_values = sum;</span>

		<span class="s2">if</span><span class="s1">(model</span><span class="s6">-&gt;</span><span class="s1">param.svm_type == ONE_CLASS)</span>
			<span class="s2">return </span><span class="s1">(sum&gt;</span><span class="s5">0</span><span class="s1">)?</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">;</span>
		<span class="s2">else</span>
			<span class="s2">return </span><span class="s1">sum;</span>
	<span class="s1">}</span>
	<span class="s2">else</span>
	<span class="s1">{</span>
		<span class="s2">int </span><span class="s1">nr_class = model</span><span class="s6">-&gt;</span><span class="s1">nr_class;</span>
		<span class="s2">int </span><span class="s1">l = model</span><span class="s6">-&gt;</span><span class="s1">l;</span>

		<span class="s2">double </span><span class="s1">*kvalue = Malloc(</span><span class="s2">double</span><span class="s1">,l);</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
                    <span class="s1">kvalue[i] = NAMESPACE::Kernel::k_function(x,model</span><span class="s6">-&gt;</span><span class="s1">SV+i,model</span><span class="s6">-&gt;</span><span class="s1">param,blas_functions);</span>
<span class="s2">#else</span>
                <span class="s1">kvalue[i] = NAMESPACE::Kernel::k_function(x,model</span><span class="s6">-&gt;</span><span class="s1">SV[i],model</span><span class="s6">-&gt;</span><span class="s1">param,blas_functions);</span>
<span class="s2">#endif</span>

		<span class="s2">int </span><span class="s1">*start = Malloc(</span><span class="s2">int</span><span class="s1">,nr_class);</span>
		<span class="s1">start[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">1</span><span class="s1">;i&lt;nr_class;i++)</span>
			<span class="s1">start[i] = start[i-1]+model</span><span class="s6">-&gt;</span><span class="s1">nSV[i-1];</span>

		<span class="s2">int </span><span class="s1">*vote = Malloc(</span><span class="s2">int</span><span class="s1">,nr_class);</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class;i++)</span>
			<span class="s1">vote[i] = </span><span class="s5">0</span><span class="s1">;</span>

		<span class="s2">int </span><span class="s1">p=</span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class;i++)</span>
			<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">j=i+</span><span class="s5">1</span><span class="s1">;j&lt;nr_class;j++)</span>
			<span class="s1">{</span>
				<span class="s2">double </span><span class="s1">sum = </span><span class="s5">0</span><span class="s1">;</span>
				<span class="s2">int </span><span class="s1">si = start[i];</span>
				<span class="s2">int </span><span class="s1">sj = start[j];</span>
				<span class="s2">int </span><span class="s1">ci = model</span><span class="s6">-&gt;</span><span class="s1">nSV[i];</span>
				<span class="s2">int </span><span class="s1">cj = model</span><span class="s6">-&gt;</span><span class="s1">nSV[j];</span>

				<span class="s2">int </span><span class="s1">k;</span>
				<span class="s2">double </span><span class="s1">*coef1 = model</span><span class="s6">-&gt;</span><span class="s1">sv_coef[j-1];</span>
				<span class="s2">double </span><span class="s1">*coef2 = model</span><span class="s6">-&gt;</span><span class="s1">sv_coef[i];</span>
				<span class="s2">for</span><span class="s1">(k=</span><span class="s5">0</span><span class="s1">;k&lt;ci;k++)</span>
					<span class="s1">sum += coef1[si+k] * kvalue[si+k];</span>
				<span class="s2">for</span><span class="s1">(k=</span><span class="s5">0</span><span class="s1">;k&lt;cj;k++)</span>
					<span class="s1">sum += coef2[sj+k] * kvalue[sj+k];</span>
				<span class="s1">sum -= model</span><span class="s6">-&gt;</span><span class="s1">rho[p];</span>
				<span class="s1">dec_values[p] = sum;</span>

				<span class="s2">if</span><span class="s1">(dec_values[p] &gt; </span><span class="s5">0</span><span class="s1">)</span>
					<span class="s1">++vote[i];</span>
				<span class="s2">else</span>
					<span class="s1">++vote[j];</span>
				<span class="s1">p++;</span>
			<span class="s1">}</span>

		<span class="s2">int </span><span class="s1">vote_max_idx = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">1</span><span class="s1">;i&lt;nr_class;i++)</span>
			<span class="s2">if</span><span class="s1">(vote[i] &gt; vote[vote_max_idx])</span>
				<span class="s1">vote_max_idx = i;</span>

		<span class="s1">free(kvalue);</span>
		<span class="s1">free(start);</span>
		<span class="s1">free(vote);</span>
		<span class="s2">return </span><span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">label[vote_max_idx];</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">double </span><span class="s1">PREFIX(predict)(</span><span class="s2">const </span><span class="s1">PREFIX(model) *model, </span><span class="s2">const </span><span class="s1">PREFIX(node) *x, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s2">int </span><span class="s1">nr_class = model</span><span class="s6">-&gt;</span><span class="s1">nr_class;</span>
	<span class="s2">double </span><span class="s1">*dec_values;</span>
	<span class="s2">if</span><span class="s1">(model</span><span class="s6">-&gt;</span><span class="s1">param.svm_type == ONE_CLASS ||</span>
	   <span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">param.svm_type == EPSILON_SVR ||</span>
	   <span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">param.svm_type == NU_SVR)</span>
		<span class="s1">dec_values = Malloc(</span><span class="s2">double</span><span class="s1">, </span><span class="s5">1</span><span class="s1">);</span>
	<span class="s2">else</span>
		<span class="s1">dec_values = Malloc(</span><span class="s2">double</span><span class="s1">, nr_class*(nr_class-1)/</span><span class="s5">2</span><span class="s1">);</span>
	<span class="s2">double </span><span class="s1">pred_result = PREFIX(predict_values)(model, x, dec_values, blas_functions);</span>
	<span class="s1">free(dec_values);</span>
	<span class="s2">return </span><span class="s1">pred_result;</span>
<span class="s1">}</span>

<span class="s2">double </span><span class="s1">PREFIX(predict_probability)(</span>
	<span class="s2">const </span><span class="s1">PREFIX(model) *model, </span><span class="s2">const </span><span class="s1">PREFIX(node) *x, </span><span class="s2">double </span><span class="s1">*prob_estimates, BlasFunctions *blas_functions)</span>
<span class="s1">{</span>
	<span class="s2">if </span><span class="s1">((model</span><span class="s6">-&gt;</span><span class="s1">param.svm_type == C_SVC || model</span><span class="s6">-&gt;</span><span class="s1">param.svm_type == NU_SVC) &amp;&amp;</span>
	    <span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">probA!=NULL &amp;&amp; model</span><span class="s6">-&gt;</span><span class="s1">probB!=NULL)</span>
	<span class="s1">{</span>
		<span class="s2">int </span><span class="s1">i;</span>
		<span class="s2">int </span><span class="s1">nr_class = model</span><span class="s6">-&gt;</span><span class="s1">nr_class;</span>
		<span class="s2">double </span><span class="s1">*dec_values = Malloc(</span><span class="s2">double</span><span class="s1">, nr_class*(nr_class-1)/</span><span class="s5">2</span><span class="s1">);</span>
		<span class="s1">PREFIX(predict_values)(model, x, dec_values, blas_functions);</span>

		<span class="s2">double </span><span class="s1">min_prob=</span><span class="s5">1</span><span class="s1">e-7;</span>
		<span class="s2">double </span><span class="s1">**pairwise_prob=Malloc(</span><span class="s2">double </span><span class="s1">*,nr_class);</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class;i++)</span>
			<span class="s1">pairwise_prob[i]=Malloc(</span><span class="s2">double</span><span class="s1">,nr_class);</span>
		<span class="s2">int </span><span class="s1">k=</span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class;i++)</span>
			<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">j=i+</span><span class="s5">1</span><span class="s1">;j&lt;nr_class;j++)</span>
			<span class="s1">{</span>
                            <span class="s1">pairwise_prob[i][j]=min(max(NAMESPACE::sigmoid_predict(dec_values[k],model</span><span class="s6">-&gt;</span><span class="s1">probA[k],model</span><span class="s6">-&gt;</span><span class="s1">probB[k]),min_prob),</span><span class="s5">1</span><span class="s1">-min_prob);</span>
				<span class="s1">pairwise_prob[j][i]=</span><span class="s5">1</span><span class="s1">-pairwise_prob[i][j];</span>
				<span class="s1">k++;</span>
			<span class="s1">}</span>
                <span class="s1">NAMESPACE::multiclass_probability(nr_class,pairwise_prob,prob_estimates);</span>

		<span class="s2">int </span><span class="s1">prob_max_idx = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">1</span><span class="s1">;i&lt;nr_class;i++)</span>
			<span class="s2">if</span><span class="s1">(prob_estimates[i] &gt; prob_estimates[prob_max_idx])</span>
				<span class="s1">prob_max_idx = i;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class;i++)</span>
			<span class="s1">free(pairwise_prob[i]);</span>
		<span class="s1">free(dec_values);</span>
		<span class="s1">free(pairwise_prob);</span>
		<span class="s2">return </span><span class="s1">model</span><span class="s6">-&gt;</span><span class="s1">label[prob_max_idx];</span>
	<span class="s1">}</span>
	<span class="s2">else</span>
		<span class="s2">return </span><span class="s1">PREFIX(predict)(model, x, blas_functions);</span>
<span class="s1">}</span>


<span class="s2">void </span><span class="s1">PREFIX(free_model_content)(PREFIX(model)* model_ptr)</span>
<span class="s1">{</span>
	<span class="s2">if</span><span class="s1">(model_ptr</span><span class="s6">-&gt;</span><span class="s1">free_sv &amp;&amp; model_ptr</span><span class="s6">-&gt;</span><span class="s1">l &gt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; model_ptr</span><span class="s6">-&gt;</span><span class="s1">SV != NULL)</span>
<span class="s2">#ifdef </span><span class="s1">_DENSE_REP</span>
		<span class="s2">for </span><span class="s1">(</span><span class="s2">int </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; model_ptr</span><span class="s6">-&gt;</span><span class="s1">l; i++)</span>
			<span class="s1">free(model_ptr</span><span class="s6">-&gt;</span><span class="s1">SV[i].values);</span>
<span class="s2">#else</span>
		<span class="s1">free((</span><span class="s2">void </span><span class="s1">*)(model_ptr</span><span class="s6">-&gt;</span><span class="s1">SV[</span><span class="s5">0</span><span class="s1">]));</span>
<span class="s2">#endif</span>

	<span class="s2">if</span><span class="s1">(model_ptr</span><span class="s6">-&gt;</span><span class="s1">sv_coef)</span>
	<span class="s1">{</span>
		<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">0</span><span class="s1">;i&lt;model_ptr</span><span class="s6">-&gt;</span><span class="s1">nr_class-1;i++)</span>
			<span class="s1">free(model_ptr</span><span class="s6">-&gt;</span><span class="s1">sv_coef[i]);</span>
	<span class="s1">}</span>

	<span class="s1">free(model_ptr</span><span class="s6">-&gt;</span><span class="s1">SV);</span>
	<span class="s1">model_ptr</span><span class="s6">-&gt;</span><span class="s1">SV = NULL;</span>

	<span class="s1">free(model_ptr</span><span class="s6">-&gt;</span><span class="s1">sv_coef);</span>
	<span class="s1">model_ptr</span><span class="s6">-&gt;</span><span class="s1">sv_coef = NULL;</span>

	<span class="s1">free(model_ptr</span><span class="s6">-&gt;</span><span class="s1">sv_ind);</span>
	<span class="s1">model_ptr</span><span class="s6">-&gt;</span><span class="s1">sv_ind = NULL;</span>

	<span class="s1">free(model_ptr</span><span class="s6">-&gt;</span><span class="s1">rho);</span>
	<span class="s1">model_ptr</span><span class="s6">-&gt;</span><span class="s1">rho = NULL;</span>

	<span class="s1">free(model_ptr</span><span class="s6">-&gt;</span><span class="s1">label);</span>
	<span class="s1">model_ptr</span><span class="s6">-&gt;</span><span class="s1">label= NULL;</span>

	<span class="s1">free(model_ptr</span><span class="s6">-&gt;</span><span class="s1">probA);</span>
	<span class="s1">model_ptr</span><span class="s6">-&gt;</span><span class="s1">probA = NULL;</span>

	<span class="s1">free(model_ptr</span><span class="s6">-&gt;</span><span class="s1">probB);</span>
	<span class="s1">model_ptr</span><span class="s6">-&gt;</span><span class="s1">probB= NULL;</span>

	<span class="s1">free(model_ptr</span><span class="s6">-&gt;</span><span class="s1">nSV);</span>
	<span class="s1">model_ptr</span><span class="s6">-&gt;</span><span class="s1">nSV = NULL;</span>

	<span class="s1">free(model_ptr</span><span class="s6">-&gt;</span><span class="s1">n_iter);</span>
	<span class="s1">model_ptr</span><span class="s6">-&gt;</span><span class="s1">n_iter = NULL;</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">PREFIX(free_and_destroy_model)(PREFIX(model)** model_ptr_ptr)</span>
<span class="s1">{</span>
	<span class="s2">if</span><span class="s1">(model_ptr_ptr != NULL &amp;&amp; *model_ptr_ptr != NULL)</span>
	<span class="s1">{</span>
		<span class="s1">PREFIX(free_model_content)(*model_ptr_ptr);</span>
		<span class="s1">free(*model_ptr_ptr);</span>
		<span class="s1">*model_ptr_ptr = NULL;</span>
	<span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">PREFIX(destroy_param)(svm_parameter* param)</span>
<span class="s1">{</span>
	<span class="s1">free(param</span><span class="s6">-&gt;</span><span class="s1">weight_label);</span>
	<span class="s1">free(param</span><span class="s6">-&gt;</span><span class="s1">weight);</span>
<span class="s1">}</span>

<span class="s2">const char </span><span class="s1">*PREFIX(check_parameter)(</span><span class="s2">const </span><span class="s1">PREFIX(problem) *prob, </span><span class="s2">const </span><span class="s1">svm_parameter *param)</span>
<span class="s1">{</span>
	<span class="s0">// svm_type</span>

	<span class="s2">int </span><span class="s1">svm_type = param</span><span class="s6">-&gt;</span><span class="s1">svm_type;</span>
	<span class="s2">if</span><span class="s1">(svm_type != C_SVC &amp;&amp;</span>
	   <span class="s1">svm_type != NU_SVC &amp;&amp;</span>
	   <span class="s1">svm_type != ONE_CLASS &amp;&amp;</span>
	   <span class="s1">svm_type != EPSILON_SVR &amp;&amp;</span>
	   <span class="s1">svm_type != NU_SVR)</span>
		<span class="s2">return </span><span class="s3">&quot;unknown svm type&quot;</span><span class="s1">;</span>

	<span class="s0">// kernel_type, degree</span>

	<span class="s2">int </span><span class="s1">kernel_type = param</span><span class="s6">-&gt;</span><span class="s1">kernel_type;</span>
	<span class="s2">if</span><span class="s1">(kernel_type != LINEAR &amp;&amp;</span>
	   <span class="s1">kernel_type != POLY &amp;&amp;</span>
	   <span class="s1">kernel_type != RBF &amp;&amp;</span>
	   <span class="s1">kernel_type != SIGMOID &amp;&amp;</span>
	   <span class="s1">kernel_type != PRECOMPUTED)</span>
		<span class="s2">return </span><span class="s3">&quot;unknown kernel type&quot;</span><span class="s1">;</span>

	<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">gamma &lt; </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s2">return </span><span class="s3">&quot;gamma &lt; 0&quot;</span><span class="s1">;</span>

	<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">degree &lt; </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s2">return </span><span class="s3">&quot;degree of polynomial kernel &lt; 0&quot;</span><span class="s1">;</span>

	<span class="s0">// cache_size,eps,C,nu,p,shrinking</span>

	<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">cache_size &lt;= </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s2">return </span><span class="s3">&quot;cache_size &lt;= 0&quot;</span><span class="s1">;</span>

	<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">eps &lt;= </span><span class="s5">0</span><span class="s1">)</span>
		<span class="s2">return </span><span class="s3">&quot;eps &lt;= 0&quot;</span><span class="s1">;</span>

	<span class="s2">if</span><span class="s1">(svm_type == C_SVC ||</span>
	   <span class="s1">svm_type == EPSILON_SVR ||</span>
	   <span class="s1">svm_type == NU_SVR)</span>
		<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">C &lt;= </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s2">return </span><span class="s3">&quot;C &lt;= 0&quot;</span><span class="s1">;</span>

	<span class="s2">if</span><span class="s1">(svm_type == NU_SVC ||</span>
	   <span class="s1">svm_type == ONE_CLASS ||</span>
	   <span class="s1">svm_type == NU_SVR)</span>
		<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">nu &lt;= </span><span class="s5">0 </span><span class="s1">|| param</span><span class="s6">-&gt;</span><span class="s1">nu &gt; </span><span class="s5">1</span><span class="s1">)</span>
			<span class="s2">return </span><span class="s3">&quot;nu &lt;= 0 or nu &gt; 1&quot;</span><span class="s1">;</span>

	<span class="s2">if</span><span class="s1">(svm_type == EPSILON_SVR)</span>
		<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">p &lt; </span><span class="s5">0</span><span class="s1">)</span>
			<span class="s2">return </span><span class="s3">&quot;p &lt; 0&quot;</span><span class="s1">;</span>

	<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">shrinking != </span><span class="s5">0 </span><span class="s1">&amp;&amp;</span>
	   <span class="s1">param</span><span class="s6">-&gt;</span><span class="s1">shrinking != </span><span class="s5">1</span><span class="s1">)</span>
		<span class="s2">return </span><span class="s3">&quot;shrinking != 0 and shrinking != 1&quot;</span><span class="s1">;</span>

	<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">probability != </span><span class="s5">0 </span><span class="s1">&amp;&amp;</span>
	   <span class="s1">param</span><span class="s6">-&gt;</span><span class="s1">probability != </span><span class="s5">1</span><span class="s1">)</span>
		<span class="s2">return </span><span class="s3">&quot;probability != 0 and probability != 1&quot;</span><span class="s1">;</span>

	<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">probability == </span><span class="s5">1 </span><span class="s1">&amp;&amp;</span>
	   <span class="s1">svm_type == ONE_CLASS)</span>
		<span class="s2">return </span><span class="s3">&quot;one-class SVM probability output not supported yet&quot;</span><span class="s1">;</span>


	<span class="s0">// check whether nu-svc is feasible</span>

	<span class="s2">if</span><span class="s1">(svm_type == NU_SVC)</span>
	<span class="s1">{</span>
		<span class="s2">int </span><span class="s1">l = prob</span><span class="s6">-&gt;</span><span class="s1">l;</span>
		<span class="s2">int </span><span class="s1">max_nr_class = </span><span class="s5">16</span><span class="s1">;</span>
		<span class="s2">int </span><span class="s1">nr_class = </span><span class="s5">0</span><span class="s1">;</span>
		<span class="s2">int </span><span class="s1">*label = Malloc(</span><span class="s2">int</span><span class="s1">,max_nr_class);</span>
		<span class="s2">double </span><span class="s1">*count = Malloc(</span><span class="s2">double</span><span class="s1">,max_nr_class);</span>

		<span class="s2">int </span><span class="s1">i;</span>
		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;l;i++)</span>
		<span class="s1">{</span>
			<span class="s2">int </span><span class="s1">this_label = (</span><span class="s2">int</span><span class="s1">)prob</span><span class="s6">-&gt;</span><span class="s1">y[i];</span>
			<span class="s2">int </span><span class="s1">j;</span>
			<span class="s2">for</span><span class="s1">(j=</span><span class="s5">0</span><span class="s1">;j&lt;nr_class;j++)</span>
				<span class="s2">if</span><span class="s1">(this_label == label[j])</span>
				<span class="s1">{</span>
					<span class="s1">count[j] += prob</span><span class="s6">-&gt;</span><span class="s1">W[i];</span>
					<span class="s2">break</span><span class="s1">;</span>
				<span class="s1">}</span>
			<span class="s2">if</span><span class="s1">(j == nr_class)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(nr_class == max_nr_class)</span>
				<span class="s1">{</span>
					<span class="s1">max_nr_class *= </span><span class="s5">2</span><span class="s1">;</span>
					<span class="s1">label = (</span><span class="s2">int </span><span class="s1">*)realloc(label,max_nr_class*</span><span class="s2">sizeof</span><span class="s1">(</span><span class="s2">int</span><span class="s1">));</span>
					<span class="s1">count = (</span><span class="s2">double </span><span class="s1">*)realloc(count,max_nr_class*</span><span class="s2">sizeof</span><span class="s1">(</span><span class="s2">double</span><span class="s1">));</span>

				<span class="s1">}</span>
				<span class="s1">label[nr_class] = this_label;</span>
				<span class="s1">count[nr_class] = prob</span><span class="s6">-&gt;</span><span class="s1">W[i];</span>
				<span class="s1">++nr_class;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s2">for</span><span class="s1">(i=</span><span class="s5">0</span><span class="s1">;i&lt;nr_class;i++)</span>
		<span class="s1">{</span>
			<span class="s2">double </span><span class="s1">n1 = count[i];</span>
			<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">j=i+</span><span class="s5">1</span><span class="s1">;j&lt;nr_class;j++)</span>
			<span class="s1">{</span>
				<span class="s2">double </span><span class="s1">n2 = count[j];</span>
				<span class="s2">if</span><span class="s1">(param</span><span class="s6">-&gt;</span><span class="s1">nu*(n1+n2)/</span><span class="s5">2 </span><span class="s1">&gt; min(n1,n2))</span>
				<span class="s1">{</span>
					<span class="s1">free(label);</span>
					<span class="s1">free(count);</span>
					<span class="s2">return </span><span class="s3">&quot;specified nu is infeasible&quot;</span><span class="s1">;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
		<span class="s1">}</span>
		<span class="s1">free(label);</span>
		<span class="s1">free(count);</span>
	<span class="s1">}</span>

	<span class="s2">if</span><span class="s1">(svm_type == C_SVC ||</span>
	   <span class="s1">svm_type == EPSILON_SVR ||</span>
	   <span class="s1">svm_type == NU_SVR ||</span>
	   <span class="s1">svm_type == ONE_CLASS)</span>
	<span class="s1">{</span>
		<span class="s1">PREFIX(problem) newprob;</span>
		<span class="s0">// filter samples with negative and null weights</span>
		<span class="s1">remove_zero_weight(&amp;newprob, prob);</span>

		<span class="s0">// all samples were removed</span>
		<span class="s2">if</span><span class="s1">(newprob.l == </span><span class="s5">0</span><span class="s1">) {</span>
			<span class="s1">free(newprob.x);</span>
			<span class="s1">free(newprob.y);</span>
			<span class="s1">free(newprob.W);</span>
			<span class="s2">return </span><span class="s3">&quot;Invalid input - all samples have zero or negative weights.&quot;</span><span class="s1">;</span>
		<span class="s1">}</span>
		<span class="s2">else if</span><span class="s1">(prob</span><span class="s6">-&gt;</span><span class="s1">l != newprob.l &amp;&amp;</span>
		        <span class="s1">svm_type == C_SVC)</span>
		<span class="s1">{</span>
			<span class="s2">bool </span><span class="s1">only_one_label = </span><span class="s4">true</span><span class="s1">;</span>
			<span class="s2">int </span><span class="s1">first_label = newprob.y[</span><span class="s5">0</span><span class="s1">];</span>
			<span class="s2">for</span><span class="s1">(</span><span class="s2">int </span><span class="s1">i=</span><span class="s5">1</span><span class="s1">;i&lt;newprob.l;i++)</span>
			<span class="s1">{</span>
				<span class="s2">if</span><span class="s1">(newprob.y[i] != first_label)</span>
				<span class="s1">{</span>
					<span class="s1">only_one_label = </span><span class="s2">false</span><span class="s1">;</span>
					<span class="s2">break</span><span class="s1">;</span>
				<span class="s1">}</span>
			<span class="s1">}</span>
			<span class="s2">if</span><span class="s1">(only_one_label) {</span>
				<span class="s1">free(newprob.x);</span>
				<span class="s1">free(newprob.y);</span>
				<span class="s1">free(newprob.W);</span>
				<span class="s2">return </span><span class="s3">&quot;Invalid input - all samples with positive weights belong to the same class.&quot;</span><span class="s1">;</span>
			<span class="s1">}</span>
		<span class="s1">}</span>

		<span class="s1">free(newprob.x);</span>
		<span class="s1">free(newprob.y);</span>
		<span class="s1">free(newprob.W);</span>
	<span class="s1">}</span>
	<span class="s2">return </span><span class="s1">NULL;</span>
<span class="s1">}</span>

<span class="s2">void </span><span class="s1">PREFIX(set_print_string_function)(</span><span class="s2">void </span><span class="s1">(*print_func)(</span><span class="s2">const char </span><span class="s1">*))</span>
<span class="s1">{</span>
	<span class="s2">if</span><span class="s1">(print_func == NULL)</span>
		<span class="s1">svm_print_string = &amp;print_string_stdout;</span>
	<span class="s2">else</span>
		<span class="s1">svm_print_string = print_func;</span>
<span class="s1">}</span>
</pre>
</body>
</html>