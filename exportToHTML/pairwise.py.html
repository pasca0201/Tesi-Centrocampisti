<html>
<head>
<title>pairwise.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pairwise.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Metrics for pairwise distances and affinity of sets of samples.&quot;&quot;&quot;</span>

<span class="s2"># Authors: Alexandre Gramfort &lt;alexandre.gramfort@inria.fr&gt;</span>
<span class="s2">#          Mathieu Blondel &lt;mathieu@mblondel.org&gt;</span>
<span class="s2">#          Robert Layton &lt;robertlayton@gmail.com&gt;</span>
<span class="s2">#          Andreas Mueller &lt;amueller@ais.uni-bonn.de&gt;</span>
<span class="s2">#          Philippe Gervais &lt;philippe.gervais@inria.fr&gt;</span>
<span class="s2">#          Lars Buitinck</span>
<span class="s2">#          Joel Nothman &lt;joel.nothman@gmail.com&gt;</span>
<span class="s2"># License: BSD 3 clause</span>

<span class="s3">import </span><span class="s1">itertools</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">partial</span>
<span class="s3">from </span><span class="s1">numbers </span><span class="s3">import </span><span class="s1">Integral</span><span class="s4">, </span><span class="s1">Real</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">joblib </span><span class="s3">import </span><span class="s1">effective_n_jobs</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse </span><span class="s3">import </span><span class="s1">csr_matrix</span><span class="s4">, </span><span class="s1">issparse</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">spatial </span><span class="s3">import </span><span class="s1">distance</span>

<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">config_context</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">exceptions </span><span class="s3">import </span><span class="s1">DataConversionWarning</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">preprocessing </span><span class="s3">import </span><span class="s1">normalize</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">check_array</span><span class="s4">,</span>
    <span class="s1">gen_batches</span><span class="s4">,</span>
    <span class="s1">gen_even_slices</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_array_api </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">_find_matching_floating_dtype</span><span class="s4">,</span>
    <span class="s1">_is_numpy_namespace</span><span class="s4">,</span>
    <span class="s1">get_namespace</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_chunking </span><span class="s3">import </span><span class="s1">get_chunk_n_rows</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_mask </span><span class="s3">import </span><span class="s1">_get_mask</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_missing </span><span class="s3">import </span><span class="s1">is_scalar_nan</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_param_validation </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">Hidden</span><span class="s4">,</span>
    <span class="s1">Interval</span><span class="s4">,</span>
    <span class="s1">MissingValues</span><span class="s4">,</span>
    <span class="s1">Options</span><span class="s4">,</span>
    <span class="s1">StrOptions</span><span class="s4">,</span>
    <span class="s1">validate_params</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">extmath </span><span class="s3">import </span><span class="s1">row_norms</span><span class="s4">, </span><span class="s1">safe_sparse_dot</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">fixes </span><span class="s3">import </span><span class="s1">parse_version</span><span class="s4">, </span><span class="s1">sp_base_version</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">parallel </span><span class="s3">import </span><span class="s1">Parallel</span><span class="s4">, </span><span class="s1">delayed</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">validation </span><span class="s3">import </span><span class="s1">_num_samples</span><span class="s4">, </span><span class="s1">check_non_negative</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_pairwise_distances_reduction </span><span class="s3">import </span><span class="s1">ArgKmin</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_pairwise_fast </span><span class="s3">import </span><span class="s1">_chi2_kernel_fast</span><span class="s4">, </span><span class="s1">_sparse_manhattan</span>


<span class="s2"># Utility Functions</span>
<span class="s3">def </span><span class="s1">_return_float_dtype</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    1. If dtype of X and Y is float32, then dtype float32 is returned. 
    2. Else dtype float is returned. 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">and not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">):</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">Y </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">Y_dtype </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span>
    <span class="s3">elif not </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">) </span><span class="s3">and not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">):</span>
        <span class="s1">Y </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">)</span>
        <span class="s1">Y_dtype </span><span class="s4">= </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">dtype</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">Y_dtype </span><span class="s4">= </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">dtype</span>

    <span class="s3">if </span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">== </span><span class="s1">Y_dtype </span><span class="s4">== </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">:</span>
        <span class="s1">dtype </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">dtype </span><span class="s4">= </span><span class="s1">float</span>

    <span class="s3">return </span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">dtype</span>


<span class="s3">def </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span>
    <span class="s1">X</span><span class="s4">,</span>
    <span class="s1">Y</span><span class="s4">,</span>
    <span class="s4">*,</span>
    <span class="s1">precomputed</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s1">dtype</span><span class="s4">=</span><span class="s5">&quot;infer_float&quot;</span><span class="s4">,</span>
    <span class="s1">accept_sparse</span><span class="s4">=</span><span class="s5">&quot;csr&quot;</span><span class="s4">,</span>
    <span class="s1">force_all_finite</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
    <span class="s1">ensure_2d</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
    <span class="s1">copy</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Set X and Y appropriately and checks inputs. 
 
    If Y is None, it is set as a pointer to X (i.e. not a copy). 
    If Y is given, this does not happen. 
    All distance metrics should use this function first to assert that the 
    given parameters are correct and safe to use. 
 
    Specifically, this function first ensures that both X and Y are arrays, 
    then checks that they are at least two dimensional while ensuring that 
    their elements are floats (or dtype if provided). Finally, the function 
    checks that the size of the second dimension of the two arrays is equal, or 
    the equivalent check for a precomputed distance matrix. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples_X, n_features) 
 
    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features) 
 
    precomputed : bool, default=False 
        True if X is to be treated as precomputed distances to the samples in 
        Y. 
 
    dtype : str, type, list of type or None default=&quot;infer_float&quot; 
        Data type required for X and Y. If &quot;infer_float&quot;, the dtype will be an 
        appropriate float type selected by _return_float_dtype. If None, the 
        dtype of the input is preserved. 
 
        .. versionadded:: 0.18 
 
    accept_sparse : str, bool or list/tuple of str, default='csr' 
        String[s] representing allowed sparse matrix formats, such as 'csc', 
        'csr', etc. If the input is sparse but not in the allowed format, 
        it will be converted to the first listed format. True allows the input 
        to be any format. False means that a sparse matrix input will 
        raise an error. 
 
    force_all_finite : bool or 'allow-nan', default=True 
        Whether to raise an error on np.inf, np.nan, pd.NA in array. The 
        possibilities are: 
 
        - True: Force all values of array to be finite. 
        - False: accepts np.inf, np.nan, pd.NA in array. 
        - 'allow-nan': accepts only np.nan and pd.NA values in array. Values 
          cannot be infinite. 
 
        .. versionadded:: 0.22 
           ``force_all_finite`` accepts the string ``'allow-nan'``. 
 
        .. versionchanged:: 0.23 
           Accepts `pd.NA` and converts it into `np.nan`. 
 
    ensure_2d : bool, default=True 
        Whether to raise an error when the input arrays are not 2-dimensional. Setting 
        this to `False` is necessary when using a custom metric with certain 
        non-numerical inputs (e.g. a list of strings). 
 
        .. versionadded:: 1.5 
 
    copy : bool, default=False 
        Whether a forced copy will be triggered. If copy=False, a copy might 
        be triggered by a conversion. 
 
        .. versionadded:: 0.22 
 
    Returns 
    ------- 
    safe_X : {array-like, sparse matrix} of shape (n_samples_X, n_features) 
        An array equal to X, guaranteed to be a numpy array. 
 
    safe_Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features) 
        An array equal to Y if Y was not None, guaranteed to be a numpy array. 
        If Y was None, safe_Y will be a pointer to X. 
    &quot;&quot;&quot;</span>
    <span class="s1">xp</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">get_namespace</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">any</span><span class="s4">([</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">), </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">)]) </span><span class="s3">or </span><span class="s1">_is_numpy_namespace</span><span class="s4">(</span><span class="s1">xp</span><span class="s4">):</span>
        <span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">dtype_float </span><span class="s4">= </span><span class="s1">_return_float_dtype</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">dtype_float </span><span class="s4">= </span><span class="s1">_find_matching_floating_dtype</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>

    <span class="s1">estimator </span><span class="s4">= </span><span class="s5">&quot;check_pairwise_arrays&quot;</span>
    <span class="s3">if </span><span class="s1">dtype </span><span class="s4">== </span><span class="s5">&quot;infer_float&quot;</span><span class="s4">:</span>
        <span class="s1">dtype </span><span class="s4">= </span><span class="s1">dtype_float</span>

    <span class="s3">if </span><span class="s1">Y </span><span class="s3">is </span><span class="s1">X </span><span class="s3">or </span><span class="s1">Y </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_array</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">accept_sparse</span><span class="s4">=</span><span class="s1">accept_sparse</span><span class="s4">,</span>
            <span class="s1">dtype</span><span class="s4">=</span><span class="s1">dtype</span><span class="s4">,</span>
            <span class="s1">copy</span><span class="s4">=</span><span class="s1">copy</span><span class="s4">,</span>
            <span class="s1">force_all_finite</span><span class="s4">=</span><span class="s1">force_all_finite</span><span class="s4">,</span>
            <span class="s1">estimator</span><span class="s4">=</span><span class="s1">estimator</span><span class="s4">,</span>
            <span class="s1">ensure_2d</span><span class="s4">=</span><span class="s1">ensure_2d</span><span class="s4">,</span>
        <span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">check_array</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">accept_sparse</span><span class="s4">=</span><span class="s1">accept_sparse</span><span class="s4">,</span>
            <span class="s1">dtype</span><span class="s4">=</span><span class="s1">dtype</span><span class="s4">,</span>
            <span class="s1">copy</span><span class="s4">=</span><span class="s1">copy</span><span class="s4">,</span>
            <span class="s1">force_all_finite</span><span class="s4">=</span><span class="s1">force_all_finite</span><span class="s4">,</span>
            <span class="s1">estimator</span><span class="s4">=</span><span class="s1">estimator</span><span class="s4">,</span>
            <span class="s1">ensure_2d</span><span class="s4">=</span><span class="s1">ensure_2d</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">Y </span><span class="s4">= </span><span class="s1">check_array</span><span class="s4">(</span>
            <span class="s1">Y</span><span class="s4">,</span>
            <span class="s1">accept_sparse</span><span class="s4">=</span><span class="s1">accept_sparse</span><span class="s4">,</span>
            <span class="s1">dtype</span><span class="s4">=</span><span class="s1">dtype</span><span class="s4">,</span>
            <span class="s1">copy</span><span class="s4">=</span><span class="s1">copy</span><span class="s4">,</span>
            <span class="s1">force_all_finite</span><span class="s4">=</span><span class="s1">force_all_finite</span><span class="s4">,</span>
            <span class="s1">estimator</span><span class="s4">=</span><span class="s1">estimator</span><span class="s4">,</span>
            <span class="s1">ensure_2d</span><span class="s4">=</span><span class="s1">ensure_2d</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">if </span><span class="s1">precomputed</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] != </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;Precomputed metric requires shape &quot;</span>
                <span class="s5">&quot;(n_queries, n_indexed). Got (%d, %d) &quot;</span>
                <span class="s5">&quot;for %d indexed.&quot; </span><span class="s4">% (</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">], </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])</span>
            <span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">ensure_2d </span><span class="s3">and </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] != </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]:</span>
        <span class="s2"># Only check the number of features if 2d arrays are enforced. Otherwise,</span>
        <span class="s2"># validation is left to the user for custom metrics.</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
            <span class="s5">&quot;Incompatible dimension for X and Y matrices: &quot;</span>
            <span class="s5">&quot;X.shape[1] == %d while Y.shape[1] == %d&quot; </span><span class="s4">% (</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">], </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">])</span>
        <span class="s4">)</span>

    <span class="s3">return </span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span>


<span class="s3">def </span><span class="s1">check_paired_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Set X and Y appropriately and checks inputs for paired distances. 
 
    All paired distance metrics should use this function first to assert that 
    the given parameters are correct and safe to use. 
 
    Specifically, this function first ensures that both X and Y are arrays, 
    then checks that they are at least two dimensional while ensuring that 
    their elements are floats. Finally, the function checks that the size 
    of the dimensions of the two arrays are equal. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples_X, n_features) 
 
    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features) 
 
    Returns 
    ------- 
    safe_X : {array-like, sparse matrix} of shape (n_samples_X, n_features) 
        An array equal to X, guaranteed to be a numpy array. 
 
    safe_Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features) 
        An array equal to Y if Y was not None, guaranteed to be a numpy array. 
        If Y was None, safe_Y will be a pointer to X. 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">!= </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
            <span class="s5">&quot;X and Y should be of same shape. They were respectively %r and %r long.&quot;</span>
            <span class="s4">% (</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">)</span>
        <span class="s4">)</span>
    <span class="s3">return </span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span>


<span class="s2"># Pairwise distances</span>
<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;Y_norm_squared&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;squared&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;X_norm_squared&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">euclidean_distances</span><span class="s4">(</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, *, </span><span class="s1">Y_norm_squared</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">squared</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">X_norm_squared</span><span class="s4">=</span><span class="s3">None</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the distance matrix between each pair from a vector array X and Y. 
 
    For efficiency reasons, the euclidean distance between a pair of row 
    vector x and y is computed as:: 
 
        dist(x, y) = sqrt(dot(x, x) - 2 * dot(x, y) + dot(y, y)) 
 
    This formulation has two advantages over other ways of computing distances. 
    First, it is computationally efficient when dealing with sparse data. 
    Second, if one argument varies but the other remains unchanged, then 
    `dot(x, x)` and/or `dot(y, y)` can be pre-computed. 
 
    However, this is not the most precise way of doing this computation, 
    because this equation potentially suffers from &quot;catastrophic cancellation&quot;. 
    Also, the distance matrix returned by this function may not be exactly 
    symmetric as required by, e.g., ``scipy.spatial.distance`` functions. 
 
    Read more in the :ref:`User Guide &lt;metrics&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples_X, n_features) 
        An array where each row is a sample and each column is a feature. 
 
    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), \ 
            default=None 
        An array where each row is a sample and each column is a feature. 
        If `None`, method uses `Y=X`. 
 
    Y_norm_squared : array-like of shape (n_samples_Y,) or (n_samples_Y, 1) \ 
            or (1, n_samples_Y), default=None 
        Pre-computed dot-products of vectors in Y (e.g., 
        ``(Y**2).sum(axis=1)``) 
        May be ignored in some cases, see the note below. 
 
    squared : bool, default=False 
        Return squared Euclidean distances. 
 
    X_norm_squared : array-like of shape (n_samples_X,) or (n_samples_X, 1) \ 
            or (1, n_samples_X), default=None 
        Pre-computed dot-products of vectors in X (e.g., 
        ``(X**2).sum(axis=1)``) 
        May be ignored in some cases, see the note below. 
 
    Returns 
    ------- 
    distances : ndarray of shape (n_samples_X, n_samples_Y) 
        Returns the distances between the row vectors of `X` 
        and the row vectors of `Y`. 
 
    See Also 
    -------- 
    paired_distances : Distances between pairs of elements of X and Y. 
 
    Notes 
    ----- 
    To achieve a better accuracy, `X_norm_squared`Â and `Y_norm_squared` may be 
    unused if they are passed as `np.float32`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import euclidean_distances 
    &gt;&gt;&gt; X = [[0, 1], [1, 1]] 
    &gt;&gt;&gt; # distance between rows of X 
    &gt;&gt;&gt; euclidean_distances(X, X) 
    array([[0., 1.], 
           [1., 0.]]) 
    &gt;&gt;&gt; # get distance to origin 
    &gt;&gt;&gt; euclidean_distances(X, [[0, 0]]) 
    array([[1.        ], 
           [1.41421356]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">X_norm_squared </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">X_norm_squared </span><span class="s4">= </span><span class="s1">check_array</span><span class="s4">(</span><span class="s1">X_norm_squared</span><span class="s4">, </span><span class="s1">ensure_2d</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
        <span class="s1">original_shape </span><span class="s4">= </span><span class="s1">X_norm_squared</span><span class="s4">.</span><span class="s1">shape</span>
        <span class="s3">if </span><span class="s1">X_norm_squared</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">== (</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">],):</span>
            <span class="s1">X_norm_squared </span><span class="s4">= </span><span class="s1">X_norm_squared</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">(-</span><span class="s6">1</span><span class="s4">, </span><span class="s6">1</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">X_norm_squared</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">== (</span><span class="s6">1</span><span class="s4">, </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]):</span>
            <span class="s1">X_norm_squared </span><span class="s4">= </span><span class="s1">X_norm_squared</span><span class="s4">.</span><span class="s1">T</span>
        <span class="s3">if </span><span class="s1">X_norm_squared</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">!= (</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s6">1</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">f&quot;Incompatible dimensions for X of shape </span><span class="s3">{</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s3">} </span><span class="s5">and &quot;</span>
                <span class="s5">f&quot;X_norm_squared of shape </span><span class="s3">{</span><span class="s1">original_shape</span><span class="s3">}</span><span class="s5">.&quot;</span>
            <span class="s4">)</span>

    <span class="s3">if </span><span class="s1">Y_norm_squared </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">Y_norm_squared </span><span class="s4">= </span><span class="s1">check_array</span><span class="s4">(</span><span class="s1">Y_norm_squared</span><span class="s4">, </span><span class="s1">ensure_2d</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
        <span class="s1">original_shape </span><span class="s4">= </span><span class="s1">Y_norm_squared</span><span class="s4">.</span><span class="s1">shape</span>
        <span class="s3">if </span><span class="s1">Y_norm_squared</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">== (</span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">],):</span>
            <span class="s1">Y_norm_squared </span><span class="s4">= </span><span class="s1">Y_norm_squared</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">Y_norm_squared</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">== (</span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s6">1</span><span class="s4">):</span>
            <span class="s1">Y_norm_squared </span><span class="s4">= </span><span class="s1">Y_norm_squared</span><span class="s4">.</span><span class="s1">T</span>
        <span class="s3">if </span><span class="s1">Y_norm_squared</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">!= (</span><span class="s6">1</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">f&quot;Incompatible dimensions for Y of shape </span><span class="s3">{</span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s3">} </span><span class="s5">and &quot;</span>
                <span class="s5">f&quot;Y_norm_squared of shape </span><span class="s3">{</span><span class="s1">original_shape</span><span class="s3">}</span><span class="s5">.&quot;</span>
            <span class="s4">)</span>

    <span class="s3">return </span><span class="s1">_euclidean_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">X_norm_squared</span><span class="s4">, </span><span class="s1">Y_norm_squared</span><span class="s4">, </span><span class="s1">squared</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_euclidean_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">X_norm_squared</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">Y_norm_squared</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">squared</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Computational part of euclidean_distances 
 
    Assumes inputs are already checked. 
 
    If norms are passed as float32, they are unused. If arrays are passed as 
    float32, norms needs to be recomputed on upcast chunks. 
    TODO: use a float64 accumulator in row_norms to avoid the latter. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">X_norm_squared </span><span class="s3">is not None and </span><span class="s1">X_norm_squared</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">!= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">:</span>
        <span class="s1">XX </span><span class="s4">= </span><span class="s1">X_norm_squared</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">(-</span><span class="s6">1</span><span class="s4">, </span><span class="s6">1</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">!= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">:</span>
        <span class="s1">XX </span><span class="s4">= </span><span class="s1">row_norms</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">squared</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">XX </span><span class="s4">= </span><span class="s3">None</span>

    <span class="s3">if </span><span class="s1">Y </span><span class="s3">is </span><span class="s1">X</span><span class="s4">:</span>
        <span class="s1">YY </span><span class="s4">= </span><span class="s3">None if </span><span class="s1">XX </span><span class="s3">is None else </span><span class="s1">XX</span><span class="s4">.</span><span class="s1">T</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">Y_norm_squared </span><span class="s3">is not None and </span><span class="s1">Y_norm_squared</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">!= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">:</span>
            <span class="s1">YY </span><span class="s4">= </span><span class="s1">Y_norm_squared</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">!= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">:</span>
            <span class="s1">YY </span><span class="s4">= </span><span class="s1">row_norms</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">, </span><span class="s1">squared</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">, :]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">YY </span><span class="s4">= </span><span class="s3">None</span>

    <span class="s3">if </span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">== </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32 </span><span class="s3">or </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">== </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">:</span>
        <span class="s2"># To minimize precision issues with float32, we compute the distance</span>
        <span class="s2"># matrix on chunks of X and Y upcast to float64</span>
        <span class="s1">distances </span><span class="s4">= </span><span class="s1">_euclidean_distances_upcast</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">XX</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">YY</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s2"># if dtype is already float64, no need to chunk and upcast</span>
        <span class="s1">distances </span><span class="s4">= -</span><span class="s6">2 </span><span class="s4">* </span><span class="s1">safe_sparse_dot</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">dense_output</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
        <span class="s1">distances </span><span class="s4">+= </span><span class="s1">XX</span>
        <span class="s1">distances </span><span class="s4">+= </span><span class="s1">YY</span>
    <span class="s1">np</span><span class="s4">.</span><span class="s1">maximum</span><span class="s4">(</span><span class="s1">distances</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s1">out</span><span class="s4">=</span><span class="s1">distances</span><span class="s4">)</span>

    <span class="s2"># Ensure that distances between vectors and themselves are set to 0.0.</span>
    <span class="s2"># This may not be the case due to floating point rounding errors.</span>
    <span class="s3">if </span><span class="s1">X </span><span class="s3">is </span><span class="s1">Y</span><span class="s4">:</span>
        <span class="s1">np</span><span class="s4">.</span><span class="s1">fill_diagonal</span><span class="s4">(</span><span class="s1">distances</span><span class="s4">, </span><span class="s6">0</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">distances </span><span class="s3">if </span><span class="s1">squared </span><span class="s3">else </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">distances</span><span class="s4">, </span><span class="s1">out</span><span class="s4">=</span><span class="s1">distances</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;squared&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;missing_values&quot;</span><span class="s4">: [</span><span class="s1">MissingValues</span><span class="s4">(</span><span class="s1">numeric_only</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)],</span>
        <span class="s5">&quot;copy&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">nan_euclidean_distances</span><span class="s4">(</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, *, </span><span class="s1">squared</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">missing_values</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">nan</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s3">True</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Calculate the euclidean distances in the presence of missing values. 
 
    Compute the euclidean distance between each pair of samples in X and Y, 
    where Y=X is assumed if Y=None. When calculating the distance between a 
    pair of samples, this formulation ignores feature coordinates with a 
    missing value in either sample and scales up the weight of the remaining 
    coordinates: 
 
        dist(x,y) = sqrt(weight * sq. distance from present coordinates) 
        where, 
        weight = Total # of coordinates / # of present coordinates 
 
    For example, the distance between ``[3, na, na, 6]`` and ``[1, na, 4, 5]`` 
    is: 
 
        .. math:: 
            \\sqrt{\\frac{4}{2}((3-1)^2 + (6-5)^2)} 
 
    If all the coordinates are missing or if there are no common present 
    coordinates then NaN is returned for that pair. 
 
    Read more in the :ref:`User Guide &lt;metrics&gt;`. 
 
    .. versionadded:: 0.22 
 
    Parameters 
    ---------- 
    X : array-like of shape (n_samples_X, n_features) 
        An array where each row is a sample and each column is a feature. 
 
    Y : array-like of shape (n_samples_Y, n_features), default=None 
        An array where each row is a sample and each column is a feature. 
        If `None`, method uses `Y=X`. 
 
    squared : bool, default=False 
        Return squared Euclidean distances. 
 
    missing_values : np.nan, float or int, default=np.nan 
        Representation of missing value. 
 
    copy : bool, default=True 
        Make and use a deep copy of X and Y (if Y exists). 
 
    Returns 
    ------- 
    distances : ndarray of shape (n_samples_X, n_samples_Y) 
        Returns the distances between the row vectors of `X` 
        and the row vectors of `Y`. 
 
    See Also 
    -------- 
    paired_distances : Distances between pairs of elements of X and Y. 
 
    References 
    ---------- 
    * John K. Dixon, &quot;Pattern Recognition with Partly Missing Data&quot;, 
      IEEE Transactions on Systems, Man, and Cybernetics, Volume: 9, Issue: 
      10, pp. 617 - 621, Oct. 1979. 
      http://ieeexplore.ieee.org/abstract/document/4310090/ 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import nan_euclidean_distances 
    &gt;&gt;&gt; nan = float(&quot;NaN&quot;) 
    &gt;&gt;&gt; X = [[0, 1], [1, nan]] 
    &gt;&gt;&gt; nan_euclidean_distances(X, X) # distance between rows of X 
    array([[0.        , 1.41421356], 
           [1.41421356, 0.        ]]) 
 
    &gt;&gt;&gt; # get distance to origin 
    &gt;&gt;&gt; nan_euclidean_distances(X, [[0, 0]]) 
    array([[1.        ], 
           [1.41421356]]) 
    &quot;&quot;&quot;</span>

    <span class="s1">force_all_finite </span><span class="s4">= </span><span class="s5">&quot;allow-nan&quot; </span><span class="s3">if </span><span class="s1">is_scalar_nan</span><span class="s4">(</span><span class="s1">missing_values</span><span class="s4">) </span><span class="s3">else True</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span>
        <span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">accept_sparse</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">force_all_finite</span><span class="s4">=</span><span class="s1">force_all_finite</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s1">copy</span>
    <span class="s4">)</span>
    <span class="s2"># Get missing mask for X</span>
    <span class="s1">missing_X </span><span class="s4">= </span><span class="s1">_get_mask</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">missing_values</span><span class="s4">)</span>

    <span class="s2"># Get missing mask for Y</span>
    <span class="s1">missing_Y </span><span class="s4">= </span><span class="s1">missing_X </span><span class="s3">if </span><span class="s1">Y </span><span class="s3">is </span><span class="s1">X </span><span class="s3">else </span><span class="s1">_get_mask</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">, </span><span class="s1">missing_values</span><span class="s4">)</span>

    <span class="s2"># set missing values to zero</span>
    <span class="s1">X</span><span class="s4">[</span><span class="s1">missing_X</span><span class="s4">] = </span><span class="s6">0</span>
    <span class="s1">Y</span><span class="s4">[</span><span class="s1">missing_Y</span><span class="s4">] = </span><span class="s6">0</span>

    <span class="s1">distances </span><span class="s4">= </span><span class="s1">euclidean_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">squared</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

    <span class="s2"># Adjust distances for missing values</span>
    <span class="s1">XX </span><span class="s4">= </span><span class="s1">X </span><span class="s4">* </span><span class="s1">X</span>
    <span class="s1">YY </span><span class="s4">= </span><span class="s1">Y </span><span class="s4">* </span><span class="s1">Y</span>
    <span class="s1">distances </span><span class="s4">-= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">XX</span><span class="s4">, </span><span class="s1">missing_Y</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>
    <span class="s1">distances </span><span class="s4">-= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">missing_X</span><span class="s4">, </span><span class="s1">YY</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>

    <span class="s1">np</span><span class="s4">.</span><span class="s1">clip</span><span class="s4">(</span><span class="s1">distances</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">out</span><span class="s4">=</span><span class="s1">distances</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">X </span><span class="s3">is </span><span class="s1">Y</span><span class="s4">:</span>
        <span class="s2"># Ensure that distances between vectors and themselves are set to 0.0.</span>
        <span class="s2"># This may not be the case due to floating point rounding errors.</span>
        <span class="s1">np</span><span class="s4">.</span><span class="s1">fill_diagonal</span><span class="s4">(</span><span class="s1">distances</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">)</span>

    <span class="s1">present_X </span><span class="s4">= </span><span class="s6">1 </span><span class="s4">- </span><span class="s1">missing_X</span>
    <span class="s1">present_Y </span><span class="s4">= </span><span class="s1">present_X </span><span class="s3">if </span><span class="s1">Y </span><span class="s3">is </span><span class="s1">X </span><span class="s3">else </span><span class="s4">~</span><span class="s1">missing_Y</span>
    <span class="s1">present_count </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">present_X</span><span class="s4">, </span><span class="s1">present_Y</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)</span>
    <span class="s1">distances</span><span class="s4">[</span><span class="s1">present_count </span><span class="s4">== </span><span class="s6">0</span><span class="s4">] = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">nan</span>
    <span class="s2"># avoid divide by zero</span>
    <span class="s1">np</span><span class="s4">.</span><span class="s1">maximum</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">present_count</span><span class="s4">, </span><span class="s1">out</span><span class="s4">=</span><span class="s1">present_count</span><span class="s4">)</span>
    <span class="s1">distances </span><span class="s4">/= </span><span class="s1">present_count</span>
    <span class="s1">distances </span><span class="s4">*= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>

    <span class="s3">if not </span><span class="s1">squared</span><span class="s4">:</span>
        <span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">distances</span><span class="s4">, </span><span class="s1">out</span><span class="s4">=</span><span class="s1">distances</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">distances</span>


<span class="s3">def </span><span class="s1">_euclidean_distances_upcast</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">XX</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">YY</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">batch_size</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Euclidean distances between X and Y. 
 
    Assumes X and Y have float32 dtype. 
    Assumes XX and YY have float64 dtype or are None. 
 
    X and Y are upcast to float64 by chunks, which size is chosen to limit 
    memory increase by approximately 10% (at least 10MiB). 
    &quot;&quot;&quot;</span>
    <span class="s1">n_samples_X </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
    <span class="s1">n_samples_Y </span><span class="s4">= </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
    <span class="s1">n_features </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>

    <span class="s1">distances </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">((</span><span class="s1">n_samples_X</span><span class="s4">, </span><span class="s1">n_samples_Y</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">batch_size </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">x_density </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">nnz </span><span class="s4">/ </span><span class="s1">np</span><span class="s4">.</span><span class="s1">prod</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">) </span><span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">else </span><span class="s6">1</span>
        <span class="s1">y_density </span><span class="s4">= </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">nnz </span><span class="s4">/ </span><span class="s1">np</span><span class="s4">.</span><span class="s1">prod</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">) </span><span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">) </span><span class="s3">else </span><span class="s6">1</span>

        <span class="s2"># Allow 10% more memory than X, Y and the distance matrix take (at</span>
        <span class="s2"># least 10MiB)</span>
        <span class="s1">maxmem </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span>
            <span class="s4">(</span>
                <span class="s4">(</span><span class="s1">x_density </span><span class="s4">* </span><span class="s1">n_samples_X </span><span class="s4">+ </span><span class="s1">y_density </span><span class="s4">* </span><span class="s1">n_samples_Y</span><span class="s4">) * </span><span class="s1">n_features</span>
                <span class="s4">+ (</span><span class="s1">x_density </span><span class="s4">* </span><span class="s1">n_samples_X </span><span class="s4">* </span><span class="s1">y_density </span><span class="s4">* </span><span class="s1">n_samples_Y</span><span class="s4">)</span>
            <span class="s4">)</span>
            <span class="s4">/ </span><span class="s6">10</span><span class="s4">,</span>
            <span class="s6">10 </span><span class="s4">* </span><span class="s6">2</span><span class="s4">**</span><span class="s6">17</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s2"># The increase amount of memory in 8-byte blocks is:</span>
        <span class="s2"># - x_density * batch_size * n_features (copy of chunk of X)</span>
        <span class="s2"># - y_density * batch_size * n_features (copy of chunk of Y)</span>
        <span class="s2"># - batch_size * batch_size (chunk of distance matrix)</span>
        <span class="s2"># Hence xÂ² + (xd+yd)kx = M, where x=batch_size, k=n_features, M=maxmem</span>
        <span class="s2">#                                 xd=x_density and yd=y_density</span>
        <span class="s1">tmp </span><span class="s4">= (</span><span class="s1">x_density </span><span class="s4">+ </span><span class="s1">y_density</span><span class="s4">) * </span><span class="s1">n_features</span>
        <span class="s1">batch_size </span><span class="s4">= (-</span><span class="s1">tmp </span><span class="s4">+ </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">tmp</span><span class="s4">**</span><span class="s6">2 </span><span class="s4">+ </span><span class="s6">4 </span><span class="s4">* </span><span class="s1">maxmem</span><span class="s4">)) / </span><span class="s6">2</span>
        <span class="s1">batch_size </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s1">int</span><span class="s4">(</span><span class="s1">batch_size</span><span class="s4">), </span><span class="s6">1</span><span class="s4">)</span>

    <span class="s1">x_batches </span><span class="s4">= </span><span class="s1">gen_batches</span><span class="s4">(</span><span class="s1">n_samples_X</span><span class="s4">, </span><span class="s1">batch_size</span><span class="s4">)</span>

    <span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">x_slice </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">x_batches</span><span class="s4">):</span>
        <span class="s1">X_chunk </span><span class="s4">= </span><span class="s1">X</span><span class="s4">[</span><span class="s1">x_slice</span><span class="s4">].</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">XX </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">XX_chunk </span><span class="s4">= </span><span class="s1">row_norms</span><span class="s4">(</span><span class="s1">X_chunk</span><span class="s4">, </span><span class="s1">squared</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">XX_chunk </span><span class="s4">= </span><span class="s1">XX</span><span class="s4">[</span><span class="s1">x_slice</span><span class="s4">]</span>

        <span class="s1">y_batches </span><span class="s4">= </span><span class="s1">gen_batches</span><span class="s4">(</span><span class="s1">n_samples_Y</span><span class="s4">, </span><span class="s1">batch_size</span><span class="s4">)</span>

        <span class="s3">for </span><span class="s1">j</span><span class="s4">, </span><span class="s1">y_slice </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">y_batches</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">X </span><span class="s3">is </span><span class="s1">Y </span><span class="s3">and </span><span class="s1">j </span><span class="s4">&lt; </span><span class="s1">i</span><span class="s4">:</span>
                <span class="s2"># when X is Y the distance matrix is symmetric so we only need</span>
                <span class="s2"># to compute half of it.</span>
                <span class="s1">d </span><span class="s4">= </span><span class="s1">distances</span><span class="s4">[</span><span class="s1">y_slice</span><span class="s4">, </span><span class="s1">x_slice</span><span class="s4">].</span><span class="s1">T</span>

            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">Y_chunk </span><span class="s4">= </span><span class="s1">Y</span><span class="s4">[</span><span class="s1">y_slice</span><span class="s4">].</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">YY </span><span class="s3">is None</span><span class="s4">:</span>
                    <span class="s1">YY_chunk </span><span class="s4">= </span><span class="s1">row_norms</span><span class="s4">(</span><span class="s1">Y_chunk</span><span class="s4">, </span><span class="s1">squared</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">, :]</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">YY_chunk </span><span class="s4">= </span><span class="s1">YY</span><span class="s4">[:, </span><span class="s1">y_slice</span><span class="s4">]</span>

                <span class="s1">d </span><span class="s4">= -</span><span class="s6">2 </span><span class="s4">* </span><span class="s1">safe_sparse_dot</span><span class="s4">(</span><span class="s1">X_chunk</span><span class="s4">, </span><span class="s1">Y_chunk</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">dense_output</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
                <span class="s1">d </span><span class="s4">+= </span><span class="s1">XX_chunk</span>
                <span class="s1">d </span><span class="s4">+= </span><span class="s1">YY_chunk</span>

            <span class="s1">distances</span><span class="s4">[</span><span class="s1">x_slice</span><span class="s4">, </span><span class="s1">y_slice</span><span class="s4">] = </span><span class="s1">d</span><span class="s4">.</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">distances</span>


<span class="s3">def </span><span class="s1">_argmin_min_reduce</span><span class="s4">(</span><span class="s1">dist</span><span class="s4">, </span><span class="s1">start</span><span class="s4">):</span>
    <span class="s2"># `start` is specified in the signature but not used. This is because the higher</span>
    <span class="s2"># order `pairwise_distances_chunked` function needs reduction functions that are</span>
    <span class="s2"># passed as argument to have a two arguments signature.</span>
    <span class="s1">indices </span><span class="s4">= </span><span class="s1">dist</span><span class="s4">.</span><span class="s1">argmin</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>
    <span class="s1">values </span><span class="s4">= </span><span class="s1">dist</span><span class="s4">[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s1">dist</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]), </span><span class="s1">indices</span><span class="s4">]</span>
    <span class="s3">return </span><span class="s1">indices</span><span class="s4">, </span><span class="s1">values</span>


<span class="s3">def </span><span class="s1">_argmin_reduce</span><span class="s4">(</span><span class="s1">dist</span><span class="s4">, </span><span class="s1">start</span><span class="s4">):</span>
    <span class="s2"># `start` is specified in the signature but not used. This is because the higher</span>
    <span class="s2"># order `pairwise_distances_chunked` function needs reduction functions that are</span>
    <span class="s2"># passed as argument to have a two arguments signature.</span>
    <span class="s3">return </span><span class="s1">dist</span><span class="s4">.</span><span class="s1">argmin</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>


<span class="s1">_VALID_METRICS </span><span class="s4">= [</span>
    <span class="s5">&quot;euclidean&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;l2&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;l1&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;manhattan&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;cityblock&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;braycurtis&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;canberra&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;chebyshev&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;correlation&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;cosine&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;dice&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;hamming&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;jaccard&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;mahalanobis&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;matching&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;minkowski&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;rogerstanimoto&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;russellrao&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;seuclidean&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;sokalmichener&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;sokalsneath&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;sqeuclidean&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;yule&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;wminkowski&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;nan_euclidean&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;haversine&quot;</span><span class="s4">,</span>
<span class="s4">]</span>
<span class="s3">if </span><span class="s1">sp_base_version </span><span class="s4">&lt; </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s5">&quot;1.11&quot;</span><span class="s4">):  </span><span class="s2"># pragma: no cover</span>
    <span class="s2"># Deprecated in SciPy 1.9 and removed in SciPy 1.11</span>
    <span class="s1">_VALID_METRICS </span><span class="s4">+= [</span><span class="s5">&quot;kulsinski&quot;</span><span class="s4">]</span>
<span class="s3">if </span><span class="s1">sp_base_version </span><span class="s4">&lt; </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s5">&quot;1.9&quot;</span><span class="s4">):</span>
    <span class="s2"># Deprecated in SciPy 1.0 and removed in SciPy 1.9</span>
    <span class="s1">_VALID_METRICS </span><span class="s4">+= [</span><span class="s5">&quot;matching&quot;</span><span class="s4">]</span>

<span class="s1">_NAN_METRICS </span><span class="s4">= [</span><span class="s5">&quot;nan_euclidean&quot;</span><span class="s4">]</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;axis&quot;</span><span class="s4">: [</span><span class="s1">Options</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, {</span><span class="s6">0</span><span class="s4">, </span><span class="s6">1</span><span class="s4">})],</span>
        <span class="s5">&quot;metric&quot;</span><span class="s4">: [</span>
            <span class="s1">StrOptions</span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s1">_VALID_METRICS</span><span class="s4">).</span><span class="s1">union</span><span class="s4">(</span><span class="s1">ArgKmin</span><span class="s4">.</span><span class="s1">valid_metrics</span><span class="s4">())),</span>
            <span class="s1">callable</span><span class="s4">,</span>
        <span class="s4">],</span>
        <span class="s5">&quot;metric_kwargs&quot;</span><span class="s4">: [</span><span class="s1">dict</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,  </span><span class="s2"># metric is not validated yet</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">pairwise_distances_argmin_min</span><span class="s4">(</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, *, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">1</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s5">&quot;euclidean&quot;</span><span class="s4">, </span><span class="s1">metric_kwargs</span><span class="s4">=</span><span class="s3">None</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute minimum distances between one point and a set of points. 
 
    This function computes for each row in X, the index of the row of Y which 
    is closest (according to the specified distance). The minimal distances are 
    also returned. 
 
    This is mostly equivalent to calling: 
 
        (pairwise_distances(X, Y=Y, metric=metric).argmin(axis=axis), 
         pairwise_distances(X, Y=Y, metric=metric).min(axis=axis)) 
 
    but uses much less memory, and is faster for large arrays. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples_X, n_features) 
        Array containing points. 
 
    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features) 
        Array containing points. 
 
    axis : int, default=1 
        Axis along which the argmin and distances are to be computed. 
 
    metric : str or callable, default='euclidean' 
        Metric to use for distance computation. Any metric from scikit-learn 
        or scipy.spatial.distance can be used. 
 
        If metric is a callable function, it is called on each 
        pair of instances (rows) and the resulting value recorded. The callable 
        should take two arrays as input and return one value indicating the 
        distance between them. This works for Scipy's metrics, but is less 
        efficient than passing the metric name as a string. 
 
        Distance matrices are not supported. 
 
        Valid values for metric are: 
 
        - from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2', 
          'manhattan'] 
 
        - from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev', 
          'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 
          'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao', 
          'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 
          'yule'] 
 
        See the documentation for scipy.spatial.distance for details on these 
        metrics. 
 
        .. note:: 
           `'kulsinski'` is deprecated from SciPy 1.9 and will be removed in SciPy 1.11. 
 
        .. note:: 
           `'matching'` has been removed in SciPy 1.9 (use `'hamming'` instead). 
 
    metric_kwargs : dict, default=None 
        Keyword arguments to pass to specified metric function. 
 
    Returns 
    ------- 
    argmin : ndarray 
        Y[argmin[i], :] is the row in Y that is closest to X[i, :]. 
 
    distances : ndarray 
        The array of minimum distances. `distances[i]` is the distance between 
        the i-th row in X and the argmin[i]-th row in Y. 
 
    See Also 
    -------- 
    pairwise_distances : Distances between every pair of samples of X and Y. 
    pairwise_distances_argmin : Same as `pairwise_distances_argmin_min` but only 
        returns the argmins. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import pairwise_distances_argmin_min 
    &gt;&gt;&gt; X = [[0, 0, 0], [1, 1, 1]] 
    &gt;&gt;&gt; Y = [[1, 0, 0], [1, 1, 0]] 
    &gt;&gt;&gt; argmin, distances = pairwise_distances_argmin_min(X, Y) 
    &gt;&gt;&gt; argmin 
    array([0, 1]) 
    &gt;&gt;&gt; distances 
    array([1., 1.]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">axis </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">X</span>

    <span class="s3">if </span><span class="s1">metric_kwargs </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">metric_kwargs </span><span class="s4">= {}</span>

    <span class="s3">if </span><span class="s1">ArgKmin</span><span class="s4">.</span><span class="s1">is_usable_for</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">):</span>
        <span class="s2"># This is an adaptor for one &quot;sqeuclidean&quot; specification.</span>
        <span class="s2"># For this backend, we can directly use &quot;sqeuclidean&quot;.</span>
        <span class="s3">if </span><span class="s1">metric_kwargs</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;squared&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">) </span><span class="s3">and </span><span class="s1">metric </span><span class="s4">== </span><span class="s5">&quot;euclidean&quot;</span><span class="s4">:</span>
            <span class="s1">metric </span><span class="s4">= </span><span class="s5">&quot;sqeuclidean&quot;</span>
            <span class="s1">metric_kwargs </span><span class="s4">= {}</span>

        <span class="s1">values</span><span class="s4">, </span><span class="s1">indices </span><span class="s4">= </span><span class="s1">ArgKmin</span><span class="s4">.</span><span class="s1">compute</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">=</span><span class="s1">X</span><span class="s4">,</span>
            <span class="s1">Y</span><span class="s4">=</span><span class="s1">Y</span><span class="s4">,</span>
            <span class="s1">k</span><span class="s4">=</span><span class="s6">1</span><span class="s4">,</span>
            <span class="s1">metric</span><span class="s4">=</span><span class="s1">metric</span><span class="s4">,</span>
            <span class="s1">metric_kwargs</span><span class="s4">=</span><span class="s1">metric_kwargs</span><span class="s4">,</span>
            <span class="s1">strategy</span><span class="s4">=</span><span class="s5">&quot;auto&quot;</span><span class="s4">,</span>
            <span class="s1">return_distance</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">values </span><span class="s4">= </span><span class="s1">values</span><span class="s4">.</span><span class="s1">flatten</span><span class="s4">()</span>
        <span class="s1">indices </span><span class="s4">= </span><span class="s1">indices</span><span class="s4">.</span><span class="s1">flatten</span><span class="s4">()</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s2"># Joblib-based backend, which is used when user-defined callable</span>
        <span class="s2"># are passed for metric.</span>

        <span class="s2"># This won't be used in the future once PairwiseDistancesReductions support:</span>
        <span class="s2">#   - DistanceMetrics which work on supposedly binary data</span>
        <span class="s2">#   - CSR-dense and dense-CSR case if 'euclidean' in metric.</span>

        <span class="s2"># Turn off check for finiteness because this is costly and because arrays</span>
        <span class="s2"># have already been validated.</span>
        <span class="s3">with </span><span class="s1">config_context</span><span class="s4">(</span><span class="s1">assume_finite</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
            <span class="s1">indices</span><span class="s4">, </span><span class="s1">values </span><span class="s4">= </span><span class="s1">zip</span><span class="s4">(</span>
                <span class="s4">*</span><span class="s1">pairwise_distances_chunked</span><span class="s4">(</span>
                    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">reduce_func</span><span class="s4">=</span><span class="s1">_argmin_min_reduce</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s1">metric</span><span class="s4">, **</span><span class="s1">metric_kwargs</span>
                <span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s1">indices </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">concatenate</span><span class="s4">(</span><span class="s1">indices</span><span class="s4">)</span>
        <span class="s1">values </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">concatenate</span><span class="s4">(</span><span class="s1">values</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">indices</span><span class="s4">, </span><span class="s1">values</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;axis&quot;</span><span class="s4">: [</span><span class="s1">Options</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, {</span><span class="s6">0</span><span class="s4">, </span><span class="s6">1</span><span class="s4">})],</span>
        <span class="s5">&quot;metric&quot;</span><span class="s4">: [</span>
            <span class="s1">StrOptions</span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s1">_VALID_METRICS</span><span class="s4">).</span><span class="s1">union</span><span class="s4">(</span><span class="s1">ArgKmin</span><span class="s4">.</span><span class="s1">valid_metrics</span><span class="s4">())),</span>
            <span class="s1">callable</span><span class="s4">,</span>
        <span class="s4">],</span>
        <span class="s5">&quot;metric_kwargs&quot;</span><span class="s4">: [</span><span class="s1">dict</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,  </span><span class="s2"># metric is not validated yet</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">pairwise_distances_argmin</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, *, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">1</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s5">&quot;euclidean&quot;</span><span class="s4">, </span><span class="s1">metric_kwargs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute minimum distances between one point and a set of points. 
 
    This function computes for each row in X, the index of the row of Y which 
    is closest (according to the specified distance). 
 
    This is mostly equivalent to calling: 
 
        pairwise_distances(X, Y=Y, metric=metric).argmin(axis=axis) 
 
    but uses much less memory, and is faster for large arrays. 
 
    This function works with dense 2D arrays only. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples_X, n_features) 
        Array containing points. 
 
    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features) 
        Arrays containing points. 
 
    axis : int, default=1 
        Axis along which the argmin and distances are to be computed. 
 
    metric : str or callable, default=&quot;euclidean&quot; 
        Metric to use for distance computation. Any metric from scikit-learn 
        or scipy.spatial.distance can be used. 
 
        If metric is a callable function, it is called on each 
        pair of instances (rows) and the resulting value recorded. The callable 
        should take two arrays as input and return one value indicating the 
        distance between them. This works for Scipy's metrics, but is less 
        efficient than passing the metric name as a string. 
 
        Distance matrices are not supported. 
 
        Valid values for metric are: 
 
        - from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2', 
          'manhattan'] 
 
        - from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev', 
          'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 
          'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao', 
          'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 
          'yule'] 
 
        See the documentation for scipy.spatial.distance for details on these 
        metrics. 
 
        .. note:: 
           `'kulsinski'` is deprecated from SciPy 1.9 and will be removed in SciPy 1.11. 
 
        .. note:: 
           `'matching'` has been removed in SciPy 1.9 (use `'hamming'` instead). 
 
    metric_kwargs : dict, default=None 
        Keyword arguments to pass to specified metric function. 
 
    Returns 
    ------- 
    argmin : numpy.ndarray 
        Y[argmin[i], :] is the row in Y that is closest to X[i, :]. 
 
    See Also 
    -------- 
    pairwise_distances : Distances between every pair of samples of X and Y. 
    pairwise_distances_argmin_min : Same as `pairwise_distances_argmin` but also 
        returns the distances. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import pairwise_distances_argmin 
    &gt;&gt;&gt; X = [[0, 0, 0], [1, 1, 1]] 
    &gt;&gt;&gt; Y = [[1, 0, 0], [1, 1, 0]] 
    &gt;&gt;&gt; pairwise_distances_argmin(X, Y) 
    array([0, 1]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">axis </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">X</span>

    <span class="s3">if </span><span class="s1">metric_kwargs </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">metric_kwargs </span><span class="s4">= {}</span>

    <span class="s3">if </span><span class="s1">ArgKmin</span><span class="s4">.</span><span class="s1">is_usable_for</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">):</span>
        <span class="s2"># This is an adaptor for one &quot;sqeuclidean&quot; specification.</span>
        <span class="s2"># For this backend, we can directly use &quot;sqeuclidean&quot;.</span>
        <span class="s3">if </span><span class="s1">metric_kwargs</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;squared&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">) </span><span class="s3">and </span><span class="s1">metric </span><span class="s4">== </span><span class="s5">&quot;euclidean&quot;</span><span class="s4">:</span>
            <span class="s1">metric </span><span class="s4">= </span><span class="s5">&quot;sqeuclidean&quot;</span>
            <span class="s1">metric_kwargs </span><span class="s4">= {}</span>

        <span class="s1">indices </span><span class="s4">= </span><span class="s1">ArgKmin</span><span class="s4">.</span><span class="s1">compute</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">=</span><span class="s1">X</span><span class="s4">,</span>
            <span class="s1">Y</span><span class="s4">=</span><span class="s1">Y</span><span class="s4">,</span>
            <span class="s1">k</span><span class="s4">=</span><span class="s6">1</span><span class="s4">,</span>
            <span class="s1">metric</span><span class="s4">=</span><span class="s1">metric</span><span class="s4">,</span>
            <span class="s1">metric_kwargs</span><span class="s4">=</span><span class="s1">metric_kwargs</span><span class="s4">,</span>
            <span class="s1">strategy</span><span class="s4">=</span><span class="s5">&quot;auto&quot;</span><span class="s4">,</span>
            <span class="s1">return_distance</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">indices </span><span class="s4">= </span><span class="s1">indices</span><span class="s4">.</span><span class="s1">flatten</span><span class="s4">()</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s2"># Joblib-based backend, which is used when user-defined callable</span>
        <span class="s2"># are passed for metric.</span>

        <span class="s2"># This won't be used in the future once PairwiseDistancesReductions support:</span>
        <span class="s2">#   - DistanceMetrics which work on supposedly binary data</span>
        <span class="s2">#   - CSR-dense and dense-CSR case if 'euclidean' in metric.</span>

        <span class="s2"># Turn off check for finiteness because this is costly and because arrays</span>
        <span class="s2"># have already been validated.</span>
        <span class="s3">with </span><span class="s1">config_context</span><span class="s4">(</span><span class="s1">assume_finite</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
            <span class="s1">indices </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">concatenate</span><span class="s4">(</span>
                <span class="s1">list</span><span class="s4">(</span>
                    <span class="s2"># This returns a np.ndarray generator whose arrays we need</span>
                    <span class="s2"># to flatten into one.</span>
                    <span class="s1">pairwise_distances_chunked</span><span class="s4">(</span>
                        <span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">reduce_func</span><span class="s4">=</span><span class="s1">_argmin_reduce</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s1">metric</span><span class="s4">, **</span><span class="s1">metric_kwargs</span>
                    <span class="s4">)</span>
                <span class="s4">)</span>
            <span class="s4">)</span>

    <span class="s3">return </span><span class="s1">indices</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span><span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">], </span><span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">]},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">haversine_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the Haversine distance between samples in X and Y. 
 
    The Haversine (or great circle) distance is the angular distance between 
    two points on the surface of a sphere. The first coordinate of each point 
    is assumed to be the latitude, the second is the longitude, given 
    in radians. The dimension of the data must be 2. 
 
    .. math:: 
       D(x, y) = 2\\arcsin[\\sqrt{\\sin^2((x_{lat} - y_{lat}) / 2) 
                                + \\cos(x_{lat})\\cos(y_{lat})\\ 
                                sin^2((x_{lon} - y_{lon}) / 2)}] 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples_X, 2) 
        A feature array. 
 
    Y : {array-like, sparse matrix} of shape (n_samples_Y, 2), default=None 
        An optional second feature array. If `None`, uses `Y=X`. 
 
    Returns 
    ------- 
    distances : ndarray of shape (n_samples_X, n_samples_Y) 
        The distance matrix. 
 
    Notes 
    ----- 
    As the Earth is nearly spherical, the haversine formula provides a good 
    approximation of the distance between two points of the Earth surface, with 
    a less than 1% error on average. 
 
    Examples 
    -------- 
    We want to calculate the distance between the Ezeiza Airport 
    (Buenos Aires, Argentina) and the Charles de Gaulle Airport (Paris, 
    France). 
 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import haversine_distances 
    &gt;&gt;&gt; from math import radians 
    &gt;&gt;&gt; bsas = [-34.83333, -58.5166646] 
    &gt;&gt;&gt; paris = [49.0083899664, 2.53844117956] 
    &gt;&gt;&gt; bsas_in_radians = [radians(_) for _ in bsas] 
    &gt;&gt;&gt; paris_in_radians = [radians(_) for _ in paris] 
    &gt;&gt;&gt; result = haversine_distances([bsas_in_radians, paris_in_radians]) 
    &gt;&gt;&gt; result * 6371000/1000  # multiply by Earth radius to get kilometers 
    array([[    0.        , 11099.54035582], 
           [11099.54035582,     0.        ]]) 
    &quot;&quot;&quot;</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">metrics </span><span class="s3">import </span><span class="s1">DistanceMetric</span>

    <span class="s3">return </span><span class="s1">DistanceMetric</span><span class="s4">.</span><span class="s1">get_metric</span><span class="s4">(</span><span class="s5">&quot;haversine&quot;</span><span class="s4">).</span><span class="s1">pairwise</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">manhattan_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the L1 distances between the vectors in X and Y. 
 
    Read more in the :ref:`User Guide &lt;metrics&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples_X, n_features) 
        An array where each row is a sample and each column is a feature. 
 
    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), default=None 
        An array where each row is a sample and each column is a feature. 
        If `None`, method uses `Y=X`. 
 
    Returns 
    ------- 
    distances : ndarray of shape (n_samples_X, n_samples_Y) 
        Pairwise L1 distances. 
 
    Notes 
    ----- 
    When X and/or Y are CSR sparse matrices and they are not already 
    in canonical format, this function modifies them in-place to 
    make them canonical. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import manhattan_distances 
    &gt;&gt;&gt; manhattan_distances([[3]], [[3]]) 
    array([[0.]]) 
    &gt;&gt;&gt; manhattan_distances([[3]], [[2]]) 
    array([[1.]]) 
    &gt;&gt;&gt; manhattan_distances([[2]], [[3]]) 
    array([[1.]]) 
    &gt;&gt;&gt; manhattan_distances([[1, 2], [3, 4]],\ 
         [[1, 2], [0, 3]]) 
    array([[0., 2.], 
           [4., 4.]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">or </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">):</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">csr_matrix</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
        <span class="s1">Y </span><span class="s4">= </span><span class="s1">csr_matrix</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
        <span class="s1">X</span><span class="s4">.</span><span class="s1">sum_duplicates</span><span class="s4">()  </span><span class="s2"># this also sorts indices in-place</span>
        <span class="s1">Y</span><span class="s4">.</span><span class="s1">sum_duplicates</span><span class="s4">()</span>
        <span class="s1">D </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]))</span>
        <span class="s1">_sparse_manhattan</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">data</span><span class="s4">, </span><span class="s1">X</span><span class="s4">.</span><span class="s1">indices</span><span class="s4">, </span><span class="s1">X</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">data</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">indices</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">, </span><span class="s1">D</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">D</span>

    <span class="s3">return </span><span class="s1">distance</span><span class="s4">.</span><span class="s1">cdist</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s5">&quot;cityblock&quot;</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">cosine_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute cosine distance between samples in X and Y. 
 
    Cosine distance is defined as 1.0 minus the cosine similarity. 
 
    Read more in the :ref:`User Guide &lt;metrics&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples_X, n_features) 
        Matrix `X`. 
 
    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), \ 
            default=None 
        Matrix `Y`. 
 
    Returns 
    ------- 
    distances : ndarray of shape (n_samples_X, n_samples_Y) 
        Returns the cosine distance between samples in X and Y. 
 
    See Also 
    -------- 
    cosine_similarity : Compute cosine similarity between samples in X and Y. 
    scipy.spatial.distance.cosine : Dense matrices only. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import cosine_distances 
    &gt;&gt;&gt; X = [[0, 0, 0], [1, 1, 1]] 
    &gt;&gt;&gt; Y = [[1, 0, 0], [1, 1, 0]] 
    &gt;&gt;&gt; cosine_distances(X, Y) 
    array([[1.     , 1.     ], 
           [0.42..., 0.18...]]) 
    &quot;&quot;&quot;</span>
    <span class="s2"># 1.0 - cosine_similarity(X, Y) without copy</span>
    <span class="s1">S </span><span class="s4">= </span><span class="s1">cosine_similarity</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s1">S </span><span class="s4">*= -</span><span class="s6">1</span>
    <span class="s1">S </span><span class="s4">+= </span><span class="s6">1</span>
    <span class="s1">np</span><span class="s4">.</span><span class="s1">clip</span><span class="s4">(</span><span class="s1">S</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s6">2</span><span class="s4">, </span><span class="s1">out</span><span class="s4">=</span><span class="s1">S</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">X </span><span class="s3">is </span><span class="s1">Y </span><span class="s3">or </span><span class="s1">Y </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s2"># Ensure that distances between vectors and themselves are set to 0.0.</span>
        <span class="s2"># This may not be the case due to floating point rounding errors.</span>
        <span class="s1">np</span><span class="s4">.</span><span class="s1">fill_diagonal</span><span class="s4">(</span><span class="s1">S</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">S</span>


<span class="s2"># Paired distances</span>
<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span><span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">], </span><span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">]},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">paired_euclidean_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the paired euclidean distances between X and Y. 
 
    Read more in the :ref:`User Guide &lt;metrics&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples, n_features) 
        Input array/matrix X. 
 
    Y : {array-like, sparse matrix} of shape (n_samples, n_features) 
        Input array/matrix Y. 
 
    Returns 
    ------- 
    distances : ndarray of shape (n_samples,) 
        Output array/matrix containing the calculated paired euclidean 
        distances. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import paired_euclidean_distances 
    &gt;&gt;&gt; X = [[0, 0, 0], [1, 1, 1]] 
    &gt;&gt;&gt; Y = [[1, 0, 0], [1, 1, 0]] 
    &gt;&gt;&gt; paired_euclidean_distances(X, Y) 
    array([1., 1.]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_paired_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">row_norms</span><span class="s4">(</span><span class="s1">X </span><span class="s4">- </span><span class="s1">Y</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span><span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">], </span><span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">]},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">paired_manhattan_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the paired L1 distances between X and Y. 
 
    Distances are calculated between (X[0], Y[0]), (X[1], Y[1]), ..., 
    (X[n_samples], Y[n_samples]). 
 
    Read more in the :ref:`User Guide &lt;metrics&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples, n_features) 
        An array-like where each row is a sample and each column is a feature. 
 
    Y : {array-like, sparse matrix} of shape (n_samples, n_features) 
        An array-like where each row is a sample and each column is a feature. 
 
    Returns 
    ------- 
    distances : ndarray of shape (n_samples,) 
        L1 paired distances between the row vectors of `X` 
        and the row vectors of `Y`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import paired_manhattan_distances 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; X = np.array([[1, 1, 0], [0, 1, 0], [0, 0, 1]]) 
    &gt;&gt;&gt; Y = np.array([[0, 1, 0], [0, 0, 1], [0, 0, 0]]) 
    &gt;&gt;&gt; paired_manhattan_distances(X, Y) 
    array([1., 2., 1.]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_paired_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s1">diff </span><span class="s4">= </span><span class="s1">X </span><span class="s4">- </span><span class="s1">Y</span>
    <span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">diff</span><span class="s4">):</span>
        <span class="s1">diff</span><span class="s4">.</span><span class="s1">data </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">diff</span><span class="s4">.</span><span class="s1">data</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">squeeze</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span><span class="s1">diff</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)))</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">abs</span><span class="s4">(</span><span class="s1">diff</span><span class="s4">).</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span><span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">], </span><span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">]},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">paired_cosine_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the paired cosine distances between X and Y. 
 
    Read more in the :ref:`User Guide &lt;metrics&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples, n_features) 
        An array where each row is a sample and each column is a feature. 
 
    Y : {array-like, sparse matrix} of shape (n_samples, n_features) 
        An array where each row is a sample and each column is a feature. 
 
    Returns 
    ------- 
    distances : ndarray of shape (n_samples,) 
        Returns the distances between the row vectors of `X` 
        and the row vectors of `Y`, where `distances[i]` is the 
        distance between `X[i]` and `Y[i]`. 
 
    Notes 
    ----- 
    The cosine distance is equivalent to the half the squared 
    euclidean distance if each sample is normalized to unit norm. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import paired_cosine_distances 
    &gt;&gt;&gt; X = [[0, 0, 0], [1, 1, 1]] 
    &gt;&gt;&gt; Y = [[1, 0, 0], [1, 1, 0]] 
    &gt;&gt;&gt; paired_cosine_distances(X, Y) 
    array([0.5       , 0.18...]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_paired_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s6">0.5 </span><span class="s4">* </span><span class="s1">row_norms</span><span class="s4">(</span><span class="s1">normalize</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) - </span><span class="s1">normalize</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">), </span><span class="s1">squared</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>


<span class="s1">PAIRED_DISTANCES </span><span class="s4">= {</span>
    <span class="s5">&quot;cosine&quot;</span><span class="s4">: </span><span class="s1">paired_cosine_distances</span><span class="s4">,</span>
    <span class="s5">&quot;euclidean&quot;</span><span class="s4">: </span><span class="s1">paired_euclidean_distances</span><span class="s4">,</span>
    <span class="s5">&quot;l2&quot;</span><span class="s4">: </span><span class="s1">paired_euclidean_distances</span><span class="s4">,</span>
    <span class="s5">&quot;l1&quot;</span><span class="s4">: </span><span class="s1">paired_manhattan_distances</span><span class="s4">,</span>
    <span class="s5">&quot;manhattan&quot;</span><span class="s4">: </span><span class="s1">paired_manhattan_distances</span><span class="s4">,</span>
    <span class="s5">&quot;cityblock&quot;</span><span class="s4">: </span><span class="s1">paired_manhattan_distances</span><span class="s4">,</span>
<span class="s4">}</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;metric&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s1">PAIRED_DISTANCES</span><span class="s4">)), </span><span class="s1">callable</span><span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">paired_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, *, </span><span class="s1">metric</span><span class="s4">=</span><span class="s5">&quot;euclidean&quot;</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the paired distances between X and Y. 
 
    Compute the distances between (X[0], Y[0]), (X[1], Y[1]), etc... 
 
    Read more in the :ref:`User Guide &lt;metrics&gt;`. 
 
    Parameters 
    ---------- 
    X : ndarray of shape (n_samples, n_features) 
        Array 1 for distance computation. 
 
    Y : ndarray of shape (n_samples, n_features) 
        Array 2 for distance computation. 
 
    metric : str or callable, default=&quot;euclidean&quot; 
        The metric to use when calculating distance between instances in a 
        feature array. If metric is a string, it must be one of the options 
        specified in PAIRED_DISTANCES, including &quot;euclidean&quot;, 
        &quot;manhattan&quot;, or &quot;cosine&quot;. 
        Alternatively, if metric is a callable function, it is called on each 
        pair of instances (rows) and the resulting value recorded. The callable 
        should take two arrays from `X` as input and return a value indicating 
        the distance between them. 
 
    **kwds : dict 
        Unused parameters. 
 
    Returns 
    ------- 
    distances : ndarray of shape (n_samples,) 
        Returns the distances between the row vectors of `X` 
        and the row vectors of `Y`. 
 
    See Also 
    -------- 
    sklearn.metrics.pairwise_distances : Computes the distance between every pair of 
        samples. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import paired_distances 
    &gt;&gt;&gt; X = [[0, 1], [1, 1]] 
    &gt;&gt;&gt; Y = [[0, 1], [2, 1]] 
    &gt;&gt;&gt; paired_distances(X, Y) 
    array([0., 1.]) 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">metric </span><span class="s3">in </span><span class="s1">PAIRED_DISTANCES</span><span class="s4">:</span>
        <span class="s1">func </span><span class="s4">= </span><span class="s1">PAIRED_DISTANCES</span><span class="s4">[</span><span class="s1">metric</span><span class="s4">]</span>
        <span class="s3">return </span><span class="s1">func</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">callable</span><span class="s4">(</span><span class="s1">metric</span><span class="s4">):</span>
        <span class="s2"># Check the matrix first (it is usually done by the metric)</span>
        <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_paired_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
        <span class="s1">distances </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">X</span><span class="s4">))</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)):</span>
            <span class="s1">distances</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s1">metric</span><span class="s4">(</span><span class="s1">X</span><span class="s4">[</span><span class="s1">i</span><span class="s4">], </span><span class="s1">Y</span><span class="s4">[</span><span class="s1">i</span><span class="s4">])</span>
        <span class="s3">return </span><span class="s1">distances</span>


<span class="s2"># Kernels</span>
<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;dense_output&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">linear_kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">dense_output</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the linear kernel between X and Y. 
 
    Read more in the :ref:`User Guide &lt;linear_kernel&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples_X, n_features) 
        A feature array. 
 
    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), default=None 
        An optional second feature array. If `None`, uses `Y=X`. 
 
    dense_output : bool, default=True 
        Whether to return dense output even when the input is sparse. If 
        ``False``, the output is sparse if both input arrays are sparse. 
 
        .. versionadded:: 0.20 
 
    Returns 
    ------- 
    kernel : ndarray of shape (n_samples_X, n_samples_Y) 
        The Gram matrix of the linear kernel, i.e. `X @ Y.T`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import linear_kernel 
    &gt;&gt;&gt; X = [[0, 0, 0], [1, 1, 1]] 
    &gt;&gt;&gt; Y = [[1, 0, 0], [1, 1, 0]] 
    &gt;&gt;&gt; linear_kernel(X, Y) 
    array([[0., 0.], 
           [1., 2.]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">safe_sparse_dot</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">dense_output</span><span class="s4">=</span><span class="s1">dense_output</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;degree&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;gamma&quot;</span><span class="s4">: [</span>
            <span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">),</span>
            <span class="s3">None</span><span class="s4">,</span>
            <span class="s1">Hidden</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">),</span>
        <span class="s4">],</span>
        <span class="s5">&quot;coef0&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;neither&quot;</span><span class="s4">)],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">polynomial_kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">degree</span><span class="s4">=</span><span class="s6">3</span><span class="s4">, </span><span class="s1">gamma</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">coef0</span><span class="s4">=</span><span class="s6">1</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Compute the polynomial kernel between X and Y. 
 
        K(X, Y) = (gamma &lt;X, Y&gt; + coef0) ^ degree 
 
    Read more in the :ref:`User Guide &lt;polynomial_kernel&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples_X, n_features) 
        A feature array. 
 
    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), default=None 
        An optional second feature array. If `None`, uses `Y=X`. 
 
    degree : float, default=3 
        Kernel degree. 
 
    gamma : float, default=None 
        Coefficient of the vector inner product. If None, defaults to 1.0 / n_features. 
 
    coef0 : float, default=1 
        Constant offset added to scaled inner product. 
 
    Returns 
    ------- 
    kernel : ndarray of shape (n_samples_X, n_samples_Y) 
        The polynomial kernel. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import polynomial_kernel 
    &gt;&gt;&gt; X = [[0, 0, 0], [1, 1, 1]] 
    &gt;&gt;&gt; Y = [[1, 0, 0], [1, 1, 0]] 
    &gt;&gt;&gt; polynomial_kernel(X, Y, degree=2) 
    array([[1.     , 1.     ], 
           [1.77..., 2.77...]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">gamma </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">gamma </span><span class="s4">= </span><span class="s6">1.0 </span><span class="s4">/ </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>

    <span class="s1">K </span><span class="s4">= </span><span class="s1">safe_sparse_dot</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">dense_output</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s1">K </span><span class="s4">*= </span><span class="s1">gamma</span>
    <span class="s1">K </span><span class="s4">+= </span><span class="s1">coef0</span>
    <span class="s1">K </span><span class="s4">**= </span><span class="s1">degree</span>
    <span class="s3">return </span><span class="s1">K</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;gamma&quot;</span><span class="s4">: [</span>
            <span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">),</span>
            <span class="s3">None</span><span class="s4">,</span>
            <span class="s1">Hidden</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">),</span>
        <span class="s4">],</span>
        <span class="s5">&quot;coef0&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;neither&quot;</span><span class="s4">)],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">sigmoid_kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">gamma</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">coef0</span><span class="s4">=</span><span class="s6">1</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the sigmoid kernel between X and Y. 
 
        K(X, Y) = tanh(gamma &lt;X, Y&gt; + coef0) 
 
    Read more in the :ref:`User Guide &lt;sigmoid_kernel&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples_X, n_features) 
        A feature array. 
 
    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), default=None 
        An optional second feature array. If `None`, uses `Y=X`. 
 
    gamma : float, default=None 
        Coefficient of the vector inner product. If None, defaults to 1.0 / n_features. 
 
    coef0 : float, default=1 
        Constant offset added to scaled inner product. 
 
    Returns 
    ------- 
    kernel : ndarray of shape (n_samples_X, n_samples_Y) 
        Sigmoid kernel between two arrays. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import sigmoid_kernel 
    &gt;&gt;&gt; X = [[0, 0, 0], [1, 1, 1]] 
    &gt;&gt;&gt; Y = [[1, 0, 0], [1, 1, 0]] 
    &gt;&gt;&gt; sigmoid_kernel(X, Y) 
    array([[0.76..., 0.76...], 
           [0.87..., 0.93...]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">gamma </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">gamma </span><span class="s4">= </span><span class="s6">1.0 </span><span class="s4">/ </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>

    <span class="s1">K </span><span class="s4">= </span><span class="s1">safe_sparse_dot</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">dense_output</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s1">K </span><span class="s4">*= </span><span class="s1">gamma</span>
    <span class="s1">K </span><span class="s4">+= </span><span class="s1">coef0</span>
    <span class="s1">np</span><span class="s4">.</span><span class="s1">tanh</span><span class="s4">(</span><span class="s1">K</span><span class="s4">, </span><span class="s1">K</span><span class="s4">)  </span><span class="s2"># compute tanh in-place</span>
    <span class="s3">return </span><span class="s1">K</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;gamma&quot;</span><span class="s4">: [</span>
            <span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">),</span>
            <span class="s3">None</span><span class="s4">,</span>
            <span class="s1">Hidden</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">),</span>
        <span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">rbf_kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">gamma</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the rbf (gaussian) kernel between X and Y. 
 
        K(x, y) = exp(-gamma ||x-y||^2) 
 
    for each pair of rows x in X and y in Y. 
 
    Read more in the :ref:`User Guide &lt;rbf_kernel&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples_X, n_features) 
        A feature array. 
 
    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), default=None 
        An optional second feature array. If `None`, uses `Y=X`. 
 
    gamma : float, default=None 
        If None, defaults to 1.0 / n_features. 
 
    Returns 
    ------- 
    kernel : ndarray of shape (n_samples_X, n_samples_Y) 
        The RBF kernel. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import rbf_kernel 
    &gt;&gt;&gt; X = [[0, 0, 0], [1, 1, 1]] 
    &gt;&gt;&gt; Y = [[1, 0, 0], [1, 1, 0]] 
    &gt;&gt;&gt; rbf_kernel(X, Y) 
    array([[0.71..., 0.51...], 
           [0.51..., 0.71...]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">gamma </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">gamma </span><span class="s4">= </span><span class="s6">1.0 </span><span class="s4">/ </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>

    <span class="s1">K </span><span class="s4">= </span><span class="s1">euclidean_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">squared</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s1">K </span><span class="s4">*= -</span><span class="s1">gamma</span>
    <span class="s1">np</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(</span><span class="s1">K</span><span class="s4">, </span><span class="s1">K</span><span class="s4">)  </span><span class="s2"># exponentiate K in-place</span>
    <span class="s3">return </span><span class="s1">K</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;gamma&quot;</span><span class="s4">: [</span>
            <span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;neither&quot;</span><span class="s4">),</span>
            <span class="s1">Hidden</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">),</span>
            <span class="s3">None</span><span class="s4">,</span>
        <span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">laplacian_kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">gamma</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the laplacian kernel between X and Y. 
 
    The laplacian kernel is defined as:: 
 
        K(x, y) = exp(-gamma ||x-y||_1) 
 
    for each pair of rows x in X and y in Y. 
    Read more in the :ref:`User Guide &lt;laplacian_kernel&gt;`. 
 
    .. versionadded:: 0.17 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples_X, n_features) 
        A feature array. 
 
    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), default=None 
        An optional second feature array. If `None`, uses `Y=X`. 
 
    gamma : float, default=None 
        If None, defaults to 1.0 / n_features. Otherwise it should be strictly positive. 
 
    Returns 
    ------- 
    kernel : ndarray of shape (n_samples_X, n_samples_Y) 
        The kernel matrix. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import laplacian_kernel 
    &gt;&gt;&gt; X = [[0, 0, 0], [1, 1, 1]] 
    &gt;&gt;&gt; Y = [[1, 0, 0], [1, 1, 0]] 
    &gt;&gt;&gt; laplacian_kernel(X, Y) 
    array([[0.71..., 0.51...], 
           [0.51..., 0.71...]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">gamma </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">gamma </span><span class="s4">= </span><span class="s6">1.0 </span><span class="s4">/ </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>

    <span class="s1">K </span><span class="s4">= -</span><span class="s1">gamma </span><span class="s4">* </span><span class="s1">manhattan_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s1">np</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(</span><span class="s1">K</span><span class="s4">, </span><span class="s1">K</span><span class="s4">)  </span><span class="s2"># exponentiate K in-place</span>
    <span class="s3">return </span><span class="s1">K</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;dense_output&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">cosine_similarity</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">dense_output</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute cosine similarity between samples in X and Y. 
 
    Cosine similarity, or the cosine kernel, computes similarity as the 
    normalized dot product of X and Y: 
 
        K(X, Y) = &lt;X, Y&gt; / (||X||*||Y||) 
 
    On L2-normalized data, this function is equivalent to linear_kernel. 
 
    Read more in the :ref:`User Guide &lt;cosine_similarity&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples_X, n_features) 
        Input data. 
 
    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), \ 
            default=None 
        Input data. If ``None``, the output will be the pairwise 
        similarities between all samples in ``X``. 
 
    dense_output : bool, default=True 
        Whether to return dense output even when the input is sparse. If 
        ``False``, the output is sparse if both input arrays are sparse. 
 
        .. versionadded:: 0.17 
           parameter ``dense_output`` for dense output. 
 
    Returns 
    ------- 
    similarities : ndarray or sparse matrix of shape (n_samples_X, n_samples_Y) 
        Returns the cosine similarity between samples in X and Y. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import cosine_similarity 
    &gt;&gt;&gt; X = [[0, 0, 0], [1, 1, 1]] 
    &gt;&gt;&gt; Y = [[1, 0, 0], [1, 1, 0]] 
    &gt;&gt;&gt; cosine_similarity(X, Y) 
    array([[0.     , 0.     ], 
           [0.57..., 0.81...]]) 
    &quot;&quot;&quot;</span>
    <span class="s2"># to avoid recursive import</span>

    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>

    <span class="s1">X_normalized </span><span class="s4">= </span><span class="s1">normalize</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">X </span><span class="s3">is </span><span class="s1">Y</span><span class="s4">:</span>
        <span class="s1">Y_normalized </span><span class="s4">= </span><span class="s1">X_normalized</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">Y_normalized </span><span class="s4">= </span><span class="s1">normalize</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

    <span class="s1">K </span><span class="s4">= </span><span class="s1">safe_sparse_dot</span><span class="s4">(</span><span class="s1">X_normalized</span><span class="s4">, </span><span class="s1">Y_normalized</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">dense_output</span><span class="s4">=</span><span class="s1">dense_output</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">K</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span><span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">], </span><span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">]},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">additive_chi2_kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the additive chi-squared kernel between observations in X and Y. 
 
    The chi-squared kernel is computed between each pair of rows in X and Y.  X 
    and Y have to be non-negative. This kernel is most commonly applied to 
    histograms. 
 
    The chi-squared kernel is given by:: 
 
        k(x, y) = -Sum [(x - y)^2 / (x + y)] 
 
    It can be interpreted as a weighted difference per entry. 
 
    Read more in the :ref:`User Guide &lt;chi2_kernel&gt;`. 
 
    Parameters 
    ---------- 
    X : array-like of shape (n_samples_X, n_features) 
        A feature array. 
 
    Y : array-like of shape (n_samples_Y, n_features), default=None 
        An optional second feature array. If `None`, uses `Y=X`. 
 
    Returns 
    ------- 
    kernel : ndarray of shape (n_samples_X, n_samples_Y) 
        The kernel matrix. 
 
    See Also 
    -------- 
    chi2_kernel : The exponentiated version of the kernel, which is usually 
        preferable. 
    sklearn.kernel_approximation.AdditiveChi2Sampler : A Fourier approximation 
        to this kernel. 
 
    Notes 
    ----- 
    As the negative of a distance, this kernel is only conditionally positive 
    definite. 
 
    References 
    ---------- 
    * Zhang, J. and Marszalek, M. and Lazebnik, S. and Schmid, C. 
      Local features and kernels for classification of texture and object 
      categories: A comprehensive study 
      International Journal of Computer Vision 2007 
      https://hal.archives-ouvertes.fr/hal-00171412/document 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import additive_chi2_kernel 
    &gt;&gt;&gt; X = [[0, 0, 0], [1, 1, 1]] 
    &gt;&gt;&gt; Y = [[1, 0, 0], [1, 1, 0]] 
    &gt;&gt;&gt; additive_chi2_kernel(X, Y) 
    array([[-1., -2.], 
           [-2., -1.]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">accept_sparse</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s4">(</span><span class="s1">X </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">).</span><span class="s1">any</span><span class="s4">():</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;X contains negative values.&quot;</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">Y </span><span class="s3">is not </span><span class="s1">X </span><span class="s3">and </span><span class="s4">(</span><span class="s1">Y </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">).</span><span class="s1">any</span><span class="s4">():</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Y contains negative values.&quot;</span><span class="s4">)</span>

    <span class="s1">result </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)</span>
    <span class="s1">_chi2_kernel_fast</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">result</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">result</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;gamma&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;neither&quot;</span><span class="s4">), </span><span class="s1">Hidden</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">)],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">chi2_kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">gamma</span><span class="s4">=</span><span class="s6">1.0</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the exponential chi-squared kernel between X and Y. 
 
    The chi-squared kernel is computed between each pair of rows in X and Y.  X 
    and Y have to be non-negative. This kernel is most commonly applied to 
    histograms. 
 
    The chi-squared kernel is given by:: 
 
        k(x, y) = exp(-gamma Sum [(x - y)^2 / (x + y)]) 
 
    It can be interpreted as a weighted difference per entry. 
 
    Read more in the :ref:`User Guide &lt;chi2_kernel&gt;`. 
 
    Parameters 
    ---------- 
    X : array-like of shape (n_samples_X, n_features) 
        A feature array. 
 
    Y : array-like of shape (n_samples_Y, n_features), default=None 
        An optional second feature array. If `None`, uses `Y=X`. 
 
    gamma : float, default=1 
        Scaling parameter of the chi2 kernel. 
 
    Returns 
    ------- 
    kernel : ndarray of shape (n_samples_X, n_samples_Y) 
        The kernel matrix. 
 
    See Also 
    -------- 
    additive_chi2_kernel : The additive version of this kernel. 
    sklearn.kernel_approximation.AdditiveChi2Sampler : A Fourier approximation 
        to the additive version of this kernel. 
 
    References 
    ---------- 
    * Zhang, J. and Marszalek, M. and Lazebnik, S. and Schmid, C. 
      Local features and kernels for classification of texture and object 
      categories: A comprehensive study 
      International Journal of Computer Vision 2007 
      https://hal.archives-ouvertes.fr/hal-00171412/document 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import chi2_kernel 
    &gt;&gt;&gt; X = [[0, 0, 0], [1, 1, 1]] 
    &gt;&gt;&gt; Y = [[1, 0, 0], [1, 1, 0]] 
    &gt;&gt;&gt; chi2_kernel(X, Y) 
    array([[0.36..., 0.13...], 
           [0.13..., 0.36...]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">K </span><span class="s4">= </span><span class="s1">additive_chi2_kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s1">K </span><span class="s4">*= </span><span class="s1">gamma</span>
    <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(</span><span class="s1">K</span><span class="s4">, </span><span class="s1">K</span><span class="s4">)</span>


<span class="s2"># Helper functions - distance</span>
<span class="s1">PAIRWISE_DISTANCE_FUNCTIONS </span><span class="s4">= {</span>
    <span class="s2"># If updating this dictionary, update the doc in both distance_metrics()</span>
    <span class="s2"># and also in pairwise_distances()!</span>
    <span class="s5">&quot;cityblock&quot;</span><span class="s4">: </span><span class="s1">manhattan_distances</span><span class="s4">,</span>
    <span class="s5">&quot;cosine&quot;</span><span class="s4">: </span><span class="s1">cosine_distances</span><span class="s4">,</span>
    <span class="s5">&quot;euclidean&quot;</span><span class="s4">: </span><span class="s1">euclidean_distances</span><span class="s4">,</span>
    <span class="s5">&quot;haversine&quot;</span><span class="s4">: </span><span class="s1">haversine_distances</span><span class="s4">,</span>
    <span class="s5">&quot;l2&quot;</span><span class="s4">: </span><span class="s1">euclidean_distances</span><span class="s4">,</span>
    <span class="s5">&quot;l1&quot;</span><span class="s4">: </span><span class="s1">manhattan_distances</span><span class="s4">,</span>
    <span class="s5">&quot;manhattan&quot;</span><span class="s4">: </span><span class="s1">manhattan_distances</span><span class="s4">,</span>
    <span class="s5">&quot;precomputed&quot;</span><span class="s4">: </span><span class="s3">None</span><span class="s4">,  </span><span class="s2"># HACK: precomputed is always allowed, never called</span>
    <span class="s5">&quot;nan_euclidean&quot;</span><span class="s4">: </span><span class="s1">nan_euclidean_distances</span><span class="s4">,</span>
<span class="s4">}</span>


<span class="s3">def </span><span class="s1">distance_metrics</span><span class="s4">():</span>
    <span class="s0">&quot;&quot;&quot;Valid metrics for pairwise_distances. 
 
    This function simply returns the valid pairwise distance metrics. 
    It exists to allow for a description of the mapping for 
    each of the valid strings. 
 
    The valid distance metrics, and the function they map to, are: 
 
    =============== ======================================== 
    metric          Function 
    =============== ======================================== 
    'cityblock'     metrics.pairwise.manhattan_distances 
    'cosine'        metrics.pairwise.cosine_distances 
    'euclidean'     metrics.pairwise.euclidean_distances 
    'haversine'     metrics.pairwise.haversine_distances 
    'l1'            metrics.pairwise.manhattan_distances 
    'l2'            metrics.pairwise.euclidean_distances 
    'manhattan'     metrics.pairwise.manhattan_distances 
    'nan_euclidean' metrics.pairwise.nan_euclidean_distances 
    =============== ======================================== 
 
    Read more in the :ref:`User Guide &lt;metrics&gt;`. 
 
    Returns 
    ------- 
    distance_metrics : dict 
        Returns valid metrics for pairwise_distances. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">PAIRWISE_DISTANCE_FUNCTIONS</span>


<span class="s3">def </span><span class="s1">_dist_wrapper</span><span class="s4">(</span><span class="s1">dist_func</span><span class="s4">, </span><span class="s1">dist_matrix</span><span class="s4">, </span><span class="s1">slice_</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Write in-place to a slice of a distance matrix.&quot;&quot;&quot;</span>
    <span class="s1">dist_matrix</span><span class="s4">[:, </span><span class="s1">slice_</span><span class="s4">] = </span><span class="s1">dist_func</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_parallel_pairwise</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">func</span><span class="s4">, </span><span class="s1">n_jobs</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Break the pairwise matrix in n_jobs even slices 
    and compute them using multithreading.&quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">Y </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">Y </span><span class="s4">= </span><span class="s1">X</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">dtype </span><span class="s4">= </span><span class="s1">_return_float_dtype</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">effective_n_jobs</span><span class="s4">(</span><span class="s1">n_jobs</span><span class="s4">) == </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">func</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">)</span>

    <span class="s2"># enforce a threading backend to prevent data communication overhead</span>
    <span class="s1">fd </span><span class="s4">= </span><span class="s1">delayed</span><span class="s4">(</span><span class="s1">_dist_wrapper</span><span class="s4">)</span>
    <span class="s1">ret </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">((</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;F&quot;</span><span class="s4">)</span>
    <span class="s1">Parallel</span><span class="s4">(</span><span class="s1">backend</span><span class="s4">=</span><span class="s5">&quot;threading&quot;</span><span class="s4">, </span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">n_jobs</span><span class="s4">)(</span>
        <span class="s1">fd</span><span class="s4">(</span><span class="s1">func</span><span class="s4">, </span><span class="s1">ret</span><span class="s4">, </span><span class="s1">s</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">[</span><span class="s1">s</span><span class="s4">], **</span><span class="s1">kwds</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">s </span><span class="s3">in </span><span class="s1">gen_even_slices</span><span class="s4">(</span><span class="s1">_num_samples</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">), </span><span class="s1">effective_n_jobs</span><span class="s4">(</span><span class="s1">n_jobs</span><span class="s4">))</span>
    <span class="s4">)</span>

    <span class="s3">if </span><span class="s4">(</span><span class="s1">X </span><span class="s3">is </span><span class="s1">Y </span><span class="s3">or </span><span class="s1">Y </span><span class="s3">is None</span><span class="s4">) </span><span class="s3">and </span><span class="s1">func </span><span class="s3">is </span><span class="s1">euclidean_distances</span><span class="s4">:</span>
        <span class="s2"># zeroing diagonal for euclidean norm.</span>
        <span class="s2"># TODO: do it also for other norms.</span>
        <span class="s1">np</span><span class="s4">.</span><span class="s1">fill_diagonal</span><span class="s4">(</span><span class="s1">ret</span><span class="s4">, </span><span class="s6">0</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">_pairwise_callable</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">, </span><span class="s1">force_all_finite</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Handle the callable case for pairwise_{distances,kernels}.&quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span>
        <span class="s1">X</span><span class="s4">,</span>
        <span class="s1">Y</span><span class="s4">,</span>
        <span class="s1">dtype</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">force_all_finite</span><span class="s4">=</span><span class="s1">force_all_finite</span><span class="s4">,</span>
        <span class="s1">ensure_2d</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">)</span>

    <span class="s3">if </span><span class="s1">X </span><span class="s3">is </span><span class="s1">Y</span><span class="s4">:</span>
        <span class="s2"># Only calculate metric for upper triangle</span>
        <span class="s1">out </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">((</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s5">&quot;float&quot;</span><span class="s4">)</span>
        <span class="s1">iterator </span><span class="s4">= </span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">combinations</span><span class="s4">(</span><span class="s1">range</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]), </span><span class="s6">2</span><span class="s4">)</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">j </span><span class="s3">in </span><span class="s1">iterator</span><span class="s4">:</span>
            <span class="s2"># scipy has not yet implemented 1D sparse slices; once implemented this can</span>
            <span class="s2"># be removed and `arr[ind]` can be simply used.</span>
            <span class="s1">x </span><span class="s4">= </span><span class="s1">X</span><span class="s4">[[</span><span class="s1">i</span><span class="s4">], :] </span><span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">else </span><span class="s1">X</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
            <span class="s1">y </span><span class="s4">= </span><span class="s1">Y</span><span class="s4">[[</span><span class="s1">j</span><span class="s4">], :] </span><span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">) </span><span class="s3">else </span><span class="s1">Y</span><span class="s4">[</span><span class="s1">j</span><span class="s4">]</span>
            <span class="s1">out</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, </span><span class="s1">j</span><span class="s4">] = </span><span class="s1">metric</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">)</span>

        <span class="s2"># Make symmetric</span>
        <span class="s2"># NB: out += out.T will produce incorrect results</span>
        <span class="s1">out </span><span class="s4">= </span><span class="s1">out </span><span class="s4">+ </span><span class="s1">out</span><span class="s4">.</span><span class="s1">T</span>

        <span class="s2"># Calculate diagonal</span>
        <span class="s2"># NB: nonzero diagonals are allowed for both metrics and kernels</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]):</span>
            <span class="s2"># scipy has not yet implemented 1D sparse slices; once implemented this can</span>
            <span class="s2"># be removed and `arr[ind]` can be simply used.</span>
            <span class="s1">x </span><span class="s4">= </span><span class="s1">X</span><span class="s4">[[</span><span class="s1">i</span><span class="s4">], :] </span><span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">else </span><span class="s1">X</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
            <span class="s1">out</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, </span><span class="s1">i</span><span class="s4">] = </span><span class="s1">metric</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">x</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">)</span>

    <span class="s3">else</span><span class="s4">:</span>
        <span class="s2"># Calculate all cells</span>
        <span class="s1">out </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">((</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s5">&quot;float&quot;</span><span class="s4">)</span>
        <span class="s1">iterator </span><span class="s4">= </span><span class="s1">itertools</span><span class="s4">.</span><span class="s1">product</span><span class="s4">(</span><span class="s1">range</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]), </span><span class="s1">range</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]))</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">j </span><span class="s3">in </span><span class="s1">iterator</span><span class="s4">:</span>
            <span class="s2"># scipy has not yet implemented 1D sparse slices; once implemented this can</span>
            <span class="s2"># be removed and `arr[ind]` can be simply used.</span>
            <span class="s1">x </span><span class="s4">= </span><span class="s1">X</span><span class="s4">[[</span><span class="s1">i</span><span class="s4">], :] </span><span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">else </span><span class="s1">X</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
            <span class="s1">y </span><span class="s4">= </span><span class="s1">Y</span><span class="s4">[[</span><span class="s1">j</span><span class="s4">], :] </span><span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">) </span><span class="s3">else </span><span class="s1">Y</span><span class="s4">[</span><span class="s1">j</span><span class="s4">]</span>
            <span class="s1">out</span><span class="s4">[</span><span class="s1">i</span><span class="s4">, </span><span class="s1">j</span><span class="s4">] = </span><span class="s1">metric</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">out</span>


<span class="s3">def </span><span class="s1">_check_chunk_size</span><span class="s4">(</span><span class="s1">reduced</span><span class="s4">, </span><span class="s1">chunk_size</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Checks chunk is a sequence of expected size or a tuple of same.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">reduced </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">return</span>
    <span class="s1">is_tuple </span><span class="s4">= </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">reduced</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">is_tuple</span><span class="s4">:</span>
        <span class="s1">reduced </span><span class="s4">= (</span><span class="s1">reduced</span><span class="s4">,)</span>
    <span class="s3">if </span><span class="s1">any</span><span class="s4">(</span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">r</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">) </span><span class="s3">or not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">r</span><span class="s4">, </span><span class="s5">&quot;__iter__&quot;</span><span class="s4">) </span><span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">reduced</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span>
            <span class="s5">&quot;reduce_func returned %r. Expected sequence(s) of length %d.&quot;</span>
            <span class="s4">% (</span><span class="s1">reduced </span><span class="s3">if </span><span class="s1">is_tuple </span><span class="s3">else </span><span class="s1">reduced</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">chunk_size</span><span class="s4">)</span>
        <span class="s4">)</span>
    <span class="s3">if </span><span class="s1">any</span><span class="s4">(</span><span class="s1">_num_samples</span><span class="s4">(</span><span class="s1">r</span><span class="s4">) != </span><span class="s1">chunk_size </span><span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">reduced</span><span class="s4">):</span>
        <span class="s1">actual_size </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">_num_samples</span><span class="s4">(</span><span class="s1">r</span><span class="s4">) </span><span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">reduced</span><span class="s4">)</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
            <span class="s5">&quot;reduce_func returned object of length %s. &quot;</span>
            <span class="s5">&quot;Expected same length as input: %d.&quot;</span>
            <span class="s4">% (</span><span class="s1">actual_size </span><span class="s3">if </span><span class="s1">is_tuple </span><span class="s3">else </span><span class="s1">actual_size</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">chunk_size</span><span class="s4">)</span>
        <span class="s4">)</span>


<span class="s3">def </span><span class="s1">_precompute_metric_params</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Precompute data-derived metric parameters if not provided.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">metric </span><span class="s4">== </span><span class="s5">&quot;seuclidean&quot; </span><span class="s3">and </span><span class="s5">&quot;V&quot; </span><span class="s3">not in </span><span class="s1">kwds</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">X </span><span class="s3">is </span><span class="s1">Y</span><span class="s4">:</span>
            <span class="s1">V </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">var</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s6">0</span><span class="s4">, </span><span class="s1">ddof</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;The 'V' parameter is required for the seuclidean metric &quot;</span>
                <span class="s5">&quot;when Y is passed.&quot;</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s4">{</span><span class="s5">&quot;V&quot;</span><span class="s4">: </span><span class="s1">V</span><span class="s4">}</span>
    <span class="s3">if </span><span class="s1">metric </span><span class="s4">== </span><span class="s5">&quot;mahalanobis&quot; </span><span class="s3">and </span><span class="s5">&quot;VI&quot; </span><span class="s3">not in </span><span class="s1">kwds</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">X </span><span class="s3">is </span><span class="s1">Y</span><span class="s4">:</span>
            <span class="s1">VI </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">inv</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">cov</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">T</span><span class="s4">)).</span><span class="s1">T</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;The 'VI' parameter is required for the mahalanobis metric &quot;</span>
                <span class="s5">&quot;when Y is passed.&quot;</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s4">{</span><span class="s5">&quot;VI&quot;</span><span class="s4">: </span><span class="s1">VI</span><span class="s4">}</span>
    <span class="s3">return </span><span class="s4">{}</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;reduce_func&quot;</span><span class="s4">: [</span><span class="s1">callable</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;metric&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;precomputed&quot;</span><span class="s4">}.</span><span class="s1">union</span><span class="s4">(</span><span class="s1">_VALID_METRICS</span><span class="s4">)), </span><span class="s1">callable</span><span class="s4">],</span>
        <span class="s5">&quot;n_jobs&quot;</span><span class="s4">: [</span><span class="s1">Integral</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;working_memory&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">), </span><span class="s3">None</span><span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,  </span><span class="s2"># metric is not validated yet</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">pairwise_distances_chunked</span><span class="s4">(</span>
    <span class="s1">X</span><span class="s4">,</span>
    <span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">*,</span>
    <span class="s1">reduce_func</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">metric</span><span class="s4">=</span><span class="s5">&quot;euclidean&quot;</span><span class="s4">,</span>
    <span class="s1">n_jobs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">working_memory</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">**</span><span class="s1">kwds</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Generate a distance matrix chunk by chunk with optional reduction. 
 
    In cases where not all of a pairwise distance matrix needs to be 
    stored at once, this is used to calculate pairwise distances in 
    ``working_memory``-sized chunks.  If ``reduce_func`` is given, it is 
    run on each chunk and its return values are concatenated into lists, 
    arrays or sparse matrices. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples_X, n_samples_X) or \ 
            (n_samples_X, n_features) 
        Array of pairwise distances between samples, or a feature array. 
        The shape the array should be (n_samples_X, n_samples_X) if 
        metric='precomputed' and (n_samples_X, n_features) otherwise. 
 
    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), default=None 
        An optional second feature array. Only allowed if 
        metric != &quot;precomputed&quot;. 
 
    reduce_func : callable, default=None 
        The function which is applied on each chunk of the distance matrix, 
        reducing it to needed values.  ``reduce_func(D_chunk, start)`` 
        is called repeatedly, where ``D_chunk`` is a contiguous vertical 
        slice of the pairwise distance matrix, starting at row ``start``. 
        It should return one of: None; an array, a list, or a sparse matrix 
        of length ``D_chunk.shape[0]``; or a tuple of such objects. 
        Returning None is useful for in-place operations, rather than 
        reductions. 
 
        If None, pairwise_distances_chunked returns a generator of vertical 
        chunks of the distance matrix. 
 
    metric : str or callable, default='euclidean' 
        The metric to use when calculating distance between instances in a 
        feature array. If metric is a string, it must be one of the options 
        allowed by scipy.spatial.distance.pdist for its metric parameter, 
        or a metric listed in pairwise.PAIRWISE_DISTANCE_FUNCTIONS. 
        If metric is &quot;precomputed&quot;, X is assumed to be a distance matrix. 
        Alternatively, if metric is a callable function, it is called on 
        each pair of instances (rows) and the resulting value recorded. 
        The callable should take two arrays from X as input and return a 
        value indicating the distance between them. 
 
    n_jobs : int, default=None 
        The number of jobs to use for the computation. This works by 
        breaking down the pairwise matrix into n_jobs even slices and 
        computing them in parallel. 
 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    working_memory : float, default=None 
        The sought maximum memory for temporary distance matrix chunks. 
        When None (default), the value of 
        ``sklearn.get_config()['working_memory']`` is used. 
 
    **kwds : optional keyword parameters 
        Any further parameters are passed directly to the distance function. 
        If using a scipy.spatial.distance metric, the parameters are still 
        metric dependent. See the scipy docs for usage examples. 
 
    Yields 
    ------ 
    D_chunk : {ndarray, sparse matrix} 
        A contiguous slice of distance matrix, optionally processed by 
        ``reduce_func``. 
 
    Examples 
    -------- 
    Without reduce_func: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.metrics import pairwise_distances_chunked 
    &gt;&gt;&gt; X = np.random.RandomState(0).rand(5, 3) 
    &gt;&gt;&gt; D_chunk = next(pairwise_distances_chunked(X)) 
    &gt;&gt;&gt; D_chunk 
    array([[0.  ..., 0.29..., 0.41..., 0.19..., 0.57...], 
           [0.29..., 0.  ..., 0.57..., 0.41..., 0.76...], 
           [0.41..., 0.57..., 0.  ..., 0.44..., 0.90...], 
           [0.19..., 0.41..., 0.44..., 0.  ..., 0.51...], 
           [0.57..., 0.76..., 0.90..., 0.51..., 0.  ...]]) 
 
    Retrieve all neighbors and average distance within radius r: 
 
    &gt;&gt;&gt; r = .2 
    &gt;&gt;&gt; def reduce_func(D_chunk, start): 
    ...     neigh = [np.flatnonzero(d &lt; r) for d in D_chunk] 
    ...     avg_dist = (D_chunk * (D_chunk &lt; r)).mean(axis=1) 
    ...     return neigh, avg_dist 
    &gt;&gt;&gt; gen = pairwise_distances_chunked(X, reduce_func=reduce_func) 
    &gt;&gt;&gt; neigh, avg_dist = next(gen) 
    &gt;&gt;&gt; neigh 
    [array([0, 3]), array([1]), array([2]), array([0, 3]), array([4])] 
    &gt;&gt;&gt; avg_dist 
    array([0.039..., 0.        , 0.        , 0.039..., 0.        ]) 
 
    Where r is defined per sample, we need to make use of ``start``: 
 
    &gt;&gt;&gt; r = [.2, .4, .4, .3, .1] 
    &gt;&gt;&gt; def reduce_func(D_chunk, start): 
    ...     neigh = [np.flatnonzero(d &lt; r[i]) 
    ...              for i, d in enumerate(D_chunk, start)] 
    ...     return neigh 
    &gt;&gt;&gt; neigh = next(pairwise_distances_chunked(X, reduce_func=reduce_func)) 
    &gt;&gt;&gt; neigh 
    [array([0, 3]), array([0, 1]), array([2]), array([0, 3]), array([4])] 
 
    Force row-by-row generation by reducing ``working_memory``: 
 
    &gt;&gt;&gt; gen = pairwise_distances_chunked(X, reduce_func=reduce_func, 
    ...                                  working_memory=0) 
    &gt;&gt;&gt; next(gen) 
    [array([0, 3])] 
    &gt;&gt;&gt; next(gen) 
    [array([0, 1])] 
    &quot;&quot;&quot;</span>
    <span class="s1">n_samples_X </span><span class="s4">= </span><span class="s1">_num_samples</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">metric </span><span class="s4">== </span><span class="s5">&quot;precomputed&quot;</span><span class="s4">:</span>
        <span class="s1">slices </span><span class="s4">= (</span><span class="s1">slice</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">n_samples_X</span><span class="s4">),)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">Y </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">Y </span><span class="s4">= </span><span class="s1">X</span>
        <span class="s2"># We get as many rows as possible within our working_memory budget to</span>
        <span class="s2"># store len(Y) distances in each row of output.</span>
        <span class="s2">#</span>
        <span class="s2"># Note:</span>
        <span class="s2">#  - this will get at least 1 row, even if 1 row of distances will</span>
        <span class="s2">#    exceed working_memory.</span>
        <span class="s2">#  - this does not account for any temporary memory usage while</span>
        <span class="s2">#    calculating distances (e.g. difference of vectors in manhattan</span>
        <span class="s2">#    distance.</span>
        <span class="s1">chunk_n_rows </span><span class="s4">= </span><span class="s1">get_chunk_n_rows</span><span class="s4">(</span>
            <span class="s1">row_bytes</span><span class="s4">=</span><span class="s6">8 </span><span class="s4">* </span><span class="s1">_num_samples</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">),</span>
            <span class="s1">max_n_rows</span><span class="s4">=</span><span class="s1">n_samples_X</span><span class="s4">,</span>
            <span class="s1">working_memory</span><span class="s4">=</span><span class="s1">working_memory</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">slices </span><span class="s4">= </span><span class="s1">gen_batches</span><span class="s4">(</span><span class="s1">n_samples_X</span><span class="s4">, </span><span class="s1">chunk_n_rows</span><span class="s4">)</span>

    <span class="s2"># precompute data-derived metric params</span>
    <span class="s1">params </span><span class="s4">= </span><span class="s1">_precompute_metric_params</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s1">metric</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">)</span>
    <span class="s1">kwds</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(**</span><span class="s1">params</span><span class="s4">)</span>

    <span class="s3">for </span><span class="s1">sl </span><span class="s3">in </span><span class="s1">slices</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">sl</span><span class="s4">.</span><span class="s1">start </span><span class="s4">== </span><span class="s6">0 </span><span class="s3">and </span><span class="s1">sl</span><span class="s4">.</span><span class="s1">stop </span><span class="s4">== </span><span class="s1">n_samples_X</span><span class="s4">:</span>
            <span class="s1">X_chunk </span><span class="s4">= </span><span class="s1">X  </span><span class="s2"># enable optimised paths for X is Y</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">X_chunk </span><span class="s4">= </span><span class="s1">X</span><span class="s4">[</span><span class="s1">sl</span><span class="s4">]</span>
        <span class="s1">D_chunk </span><span class="s4">= </span><span class="s1">pairwise_distances</span><span class="s4">(</span><span class="s1">X_chunk</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s1">metric</span><span class="s4">, </span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">n_jobs</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s4">(</span><span class="s1">X </span><span class="s3">is </span><span class="s1">Y </span><span class="s3">or </span><span class="s1">Y </span><span class="s3">is None</span><span class="s4">) </span><span class="s3">and </span><span class="s1">PAIRWISE_DISTANCE_FUNCTIONS</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span>
            <span class="s1">metric</span><span class="s4">, </span><span class="s3">None</span>
        <span class="s4">) </span><span class="s3">is </span><span class="s1">euclidean_distances</span><span class="s4">:</span>
            <span class="s2"># zeroing diagonal, taking care of aliases of &quot;euclidean&quot;,</span>
            <span class="s2"># i.e. &quot;l2&quot;</span>
            <span class="s1">D_chunk</span><span class="s4">.</span><span class="s1">flat</span><span class="s4">[</span><span class="s1">sl</span><span class="s4">.</span><span class="s1">start </span><span class="s4">:: </span><span class="s1">_num_samples</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) + </span><span class="s6">1</span><span class="s4">] = </span><span class="s6">0</span>
        <span class="s3">if </span><span class="s1">reduce_func </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">chunk_size </span><span class="s4">= </span><span class="s1">D_chunk</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
            <span class="s1">D_chunk </span><span class="s4">= </span><span class="s1">reduce_func</span><span class="s4">(</span><span class="s1">D_chunk</span><span class="s4">, </span><span class="s1">sl</span><span class="s4">.</span><span class="s1">start</span><span class="s4">)</span>
            <span class="s1">_check_chunk_size</span><span class="s4">(</span><span class="s1">D_chunk</span><span class="s4">, </span><span class="s1">chunk_size</span><span class="s4">)</span>
        <span class="s3">yield </span><span class="s1">D_chunk</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;metric&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s1">_VALID_METRICS</span><span class="s4">) | {</span><span class="s5">&quot;precomputed&quot;</span><span class="s4">}), </span><span class="s1">callable</span><span class="s4">],</span>
        <span class="s5">&quot;n_jobs&quot;</span><span class="s4">: [</span><span class="s1">Integral</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;force_all_finite&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">, </span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;allow-nan&quot;</span><span class="s4">})],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">pairwise_distances</span><span class="s4">(</span>
    <span class="s1">X</span><span class="s4">,</span>
    <span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">metric</span><span class="s4">=</span><span class="s5">&quot;euclidean&quot;</span><span class="s4">,</span>
    <span class="s4">*,</span>
    <span class="s1">n_jobs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">force_all_finite</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
    <span class="s4">**</span><span class="s1">kwds</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the distance matrix from a vector array X and optional Y. 
 
    This method takes either a vector array or a distance matrix, and returns 
    a distance matrix. 
    If the input is a vector array, the distances are computed. 
    If the input is a distances matrix, it is returned instead. 
    If the input is a collection of non-numeric data (e.g. a list of strings or a 
    boolean array), a custom metric must be passed. 
 
    This method provides a safe way to take a distance matrix as input, while 
    preserving compatibility with many other algorithms that take a vector 
    array. 
 
    If Y is given (default is None), then the returned matrix is the pairwise 
    distance between the arrays from both X and Y. 
 
    Valid values for metric are: 
 
    - From scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2', 
      'manhattan']. These metrics support sparse matrix 
      inputs. 
      ['nan_euclidean'] but it does not yet support sparse matrices. 
 
    - From scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev', 
      'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 'mahalanobis', 
      'minkowski', 'rogerstanimoto', 'russellrao', 'seuclidean', 
      'sokalmichener', 'sokalsneath', 'sqeuclidean', 'yule'] 
      See the documentation for scipy.spatial.distance for details on these 
      metrics. These metrics do not support sparse matrix inputs. 
 
    .. note:: 
        `'kulsinski'` is deprecated from SciPy 1.9 and will be removed in SciPy 1.11. 
 
    .. note:: 
        `'matching'` has been removed in SciPy 1.9 (use `'hamming'` instead). 
 
    Note that in the case of 'cityblock', 'cosine' and 'euclidean' (which are 
    valid scipy.spatial.distance metrics), the scikit-learn implementation 
    will be used, which is faster and has support for sparse matrices (except 
    for 'cityblock'). For a verbose description of the metrics from 
    scikit-learn, see :func:`sklearn.metrics.pairwise.distance_metrics` 
    function. 
 
    Read more in the :ref:`User Guide &lt;metrics&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples_X, n_samples_X) or \ 
            (n_samples_X, n_features) 
        Array of pairwise distances between samples, or a feature array. 
        The shape of the array should be (n_samples_X, n_samples_X) if 
        metric == &quot;precomputed&quot; and (n_samples_X, n_features) otherwise. 
 
    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), default=None 
        An optional second feature array. Only allowed if 
        metric != &quot;precomputed&quot;. 
 
    metric : str or callable, default='euclidean' 
        The metric to use when calculating distance between instances in a 
        feature array. If metric is a string, it must be one of the options 
        allowed by scipy.spatial.distance.pdist for its metric parameter, or 
        a metric listed in ``pairwise.PAIRWISE_DISTANCE_FUNCTIONS``. 
        If metric is &quot;precomputed&quot;, X is assumed to be a distance matrix. 
        Alternatively, if metric is a callable function, it is called on each 
        pair of instances (rows) and the resulting value recorded. The callable 
        should take two arrays from X as input and return a value indicating 
        the distance between them. 
 
    n_jobs : int, default=None 
        The number of jobs to use for the computation. This works by breaking 
        down the pairwise matrix into n_jobs even slices and computing them 
        using multithreading. 
 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
        The &quot;euclidean&quot; and &quot;cosine&quot; metrics rely heavily on BLAS which is already 
        multithreaded. So, increasing `n_jobs` would likely cause oversubscription 
        and quickly degrade performance. 
 
    force_all_finite : bool or 'allow-nan', default=True 
        Whether to raise an error on np.inf, np.nan, pd.NA in array. Ignored 
        for a metric listed in ``pairwise.PAIRWISE_DISTANCE_FUNCTIONS``. The 
        possibilities are: 
 
        - True: Force all values of array to be finite. 
        - False: accepts np.inf, np.nan, pd.NA in array. 
        - 'allow-nan': accepts only np.nan and pd.NA values in array. Values 
          cannot be infinite. 
 
        .. versionadded:: 0.22 
           ``force_all_finite`` accepts the string ``'allow-nan'``. 
 
        .. versionchanged:: 0.23 
           Accepts `pd.NA` and converts it into `np.nan`. 
 
    **kwds : optional keyword parameters 
        Any further parameters are passed directly to the distance function. 
        If using a scipy.spatial.distance metric, the parameters are still 
        metric dependent. See the scipy docs for usage examples. 
 
    Returns 
    ------- 
    D : ndarray of shape (n_samples_X, n_samples_X) or \ 
            (n_samples_X, n_samples_Y) 
        A distance matrix D such that D_{i, j} is the distance between the 
        ith and jth vectors of the given matrix X, if Y is None. 
        If Y is not None, then D_{i, j} is the distance between the ith array 
        from X and the jth array from Y. 
 
    See Also 
    -------- 
    pairwise_distances_chunked : Performs the same calculation as this 
        function, but returns a generator of chunks of the distance matrix, in 
        order to limit memory usage. 
    sklearn.metrics.pairwise.paired_distances : Computes the distances between 
        corresponding elements of two arrays. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import pairwise_distances 
    &gt;&gt;&gt; X = [[0, 0, 0], [1, 1, 1]] 
    &gt;&gt;&gt; Y = [[1, 0, 0], [1, 1, 0]] 
    &gt;&gt;&gt; pairwise_distances(X, Y, metric='sqeuclidean') 
    array([[1., 2.], 
           [2., 1.]]) 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">metric </span><span class="s4">== </span><span class="s5">&quot;precomputed&quot;</span><span class="s4">:</span>
        <span class="s1">X</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">precomputed</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">force_all_finite</span><span class="s4">=</span><span class="s1">force_all_finite</span>
        <span class="s4">)</span>

        <span class="s1">whom </span><span class="s4">= (</span>
            <span class="s5">&quot;`pairwise_distances`. Precomputed distance &quot;</span>
            <span class="s5">&quot; need to have non-negative values.&quot;</span>
        <span class="s4">)</span>
        <span class="s1">check_non_negative</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">whom</span><span class="s4">=</span><span class="s1">whom</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">X</span>
    <span class="s3">elif </span><span class="s1">metric </span><span class="s3">in </span><span class="s1">PAIRWISE_DISTANCE_FUNCTIONS</span><span class="s4">:</span>
        <span class="s1">func </span><span class="s4">= </span><span class="s1">PAIRWISE_DISTANCE_FUNCTIONS</span><span class="s4">[</span><span class="s1">metric</span><span class="s4">]</span>
    <span class="s3">elif </span><span class="s1">callable</span><span class="s4">(</span><span class="s1">metric</span><span class="s4">):</span>
        <span class="s1">func </span><span class="s4">= </span><span class="s1">partial</span><span class="s4">(</span>
            <span class="s1">_pairwise_callable</span><span class="s4">,</span>
            <span class="s1">metric</span><span class="s4">=</span><span class="s1">metric</span><span class="s4">,</span>
            <span class="s1">force_all_finite</span><span class="s4">=</span><span class="s1">force_all_finite</span><span class="s4">,</span>
            <span class="s4">**</span><span class="s1">kwds</span><span class="s4">,</span>
        <span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">or </span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">Y</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;scipy distance metrics do not support sparse matrices.&quot;</span><span class="s4">)</span>

        <span class="s1">dtype </span><span class="s4">= </span><span class="s1">bool </span><span class="s3">if </span><span class="s1">metric </span><span class="s3">in </span><span class="s1">PAIRWISE_BOOLEAN_FUNCTIONS </span><span class="s3">else </span><span class="s5">&quot;infer_float&quot;</span>

        <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is </span><span class="s1">bool </span><span class="s3">and </span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">!= </span><span class="s1">bool </span><span class="s3">or </span><span class="s4">(</span><span class="s1">Y </span><span class="s3">is not None and </span><span class="s1">Y</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">!= </span><span class="s1">bool</span><span class="s4">)):</span>
            <span class="s1">msg </span><span class="s4">= </span><span class="s5">&quot;Data was converted to boolean for metric %s&quot; </span><span class="s4">% </span><span class="s1">metric</span>
            <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span><span class="s1">msg</span><span class="s4">, </span><span class="s1">DataConversionWarning</span><span class="s4">)</span>

        <span class="s1">X</span><span class="s4">, </span><span class="s1">Y </span><span class="s4">= </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">force_all_finite</span><span class="s4">=</span><span class="s1">force_all_finite</span>
        <span class="s4">)</span>

        <span class="s2"># precompute data-derived metric params</span>
        <span class="s1">params </span><span class="s4">= </span><span class="s1">_precompute_metric_params</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s1">metric</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">)</span>
        <span class="s1">kwds</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(**</span><span class="s1">params</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">effective_n_jobs</span><span class="s4">(</span><span class="s1">n_jobs</span><span class="s4">) == </span><span class="s6">1 </span><span class="s3">and </span><span class="s1">X </span><span class="s3">is </span><span class="s1">Y</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">distance</span><span class="s4">.</span><span class="s1">squareform</span><span class="s4">(</span><span class="s1">distance</span><span class="s4">.</span><span class="s1">pdist</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s1">metric</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">))</span>
        <span class="s1">func </span><span class="s4">= </span><span class="s1">partial</span><span class="s4">(</span><span class="s1">distance</span><span class="s4">.</span><span class="s1">cdist</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s1">metric</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">_parallel_pairwise</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">func</span><span class="s4">, </span><span class="s1">n_jobs</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">)</span>


<span class="s2"># These distances require boolean arrays, when using scipy.spatial.distance</span>
<span class="s1">PAIRWISE_BOOLEAN_FUNCTIONS </span><span class="s4">= [</span>
    <span class="s5">&quot;dice&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;jaccard&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;rogerstanimoto&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;russellrao&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;sokalmichener&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;sokalsneath&quot;</span><span class="s4">,</span>
    <span class="s5">&quot;yule&quot;</span><span class="s4">,</span>
<span class="s4">]</span>
<span class="s3">if </span><span class="s1">sp_base_version </span><span class="s4">&lt; </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s5">&quot;1.11&quot;</span><span class="s4">):</span>
    <span class="s2"># Deprecated in SciPy 1.9 and removed in SciPy 1.11</span>
    <span class="s1">PAIRWISE_BOOLEAN_FUNCTIONS </span><span class="s4">+= [</span><span class="s5">&quot;kulsinski&quot;</span><span class="s4">]</span>
<span class="s3">if </span><span class="s1">sp_base_version </span><span class="s4">&lt; </span><span class="s1">parse_version</span><span class="s4">(</span><span class="s5">&quot;1.9&quot;</span><span class="s4">):</span>
    <span class="s2"># Deprecated in SciPy 1.0 and removed in SciPy 1.9</span>
    <span class="s1">PAIRWISE_BOOLEAN_FUNCTIONS </span><span class="s4">+= [</span><span class="s5">&quot;matching&quot;</span><span class="s4">]</span>

<span class="s2"># Helper functions - distance</span>
<span class="s1">PAIRWISE_KERNEL_FUNCTIONS </span><span class="s4">= {</span>
    <span class="s2"># If updating this dictionary, update the doc in both distance_metrics()</span>
    <span class="s2"># and also in pairwise_distances()!</span>
    <span class="s5">&quot;additive_chi2&quot;</span><span class="s4">: </span><span class="s1">additive_chi2_kernel</span><span class="s4">,</span>
    <span class="s5">&quot;chi2&quot;</span><span class="s4">: </span><span class="s1">chi2_kernel</span><span class="s4">,</span>
    <span class="s5">&quot;linear&quot;</span><span class="s4">: </span><span class="s1">linear_kernel</span><span class="s4">,</span>
    <span class="s5">&quot;polynomial&quot;</span><span class="s4">: </span><span class="s1">polynomial_kernel</span><span class="s4">,</span>
    <span class="s5">&quot;poly&quot;</span><span class="s4">: </span><span class="s1">polynomial_kernel</span><span class="s4">,</span>
    <span class="s5">&quot;rbf&quot;</span><span class="s4">: </span><span class="s1">rbf_kernel</span><span class="s4">,</span>
    <span class="s5">&quot;laplacian&quot;</span><span class="s4">: </span><span class="s1">laplacian_kernel</span><span class="s4">,</span>
    <span class="s5">&quot;sigmoid&quot;</span><span class="s4">: </span><span class="s1">sigmoid_kernel</span><span class="s4">,</span>
    <span class="s5">&quot;cosine&quot;</span><span class="s4">: </span><span class="s1">cosine_similarity</span><span class="s4">,</span>
<span class="s4">}</span>


<span class="s3">def </span><span class="s1">kernel_metrics</span><span class="s4">():</span>
    <span class="s0">&quot;&quot;&quot;Valid metrics for pairwise_kernels. 
 
    This function simply returns the valid pairwise distance metrics. 
    It exists, however, to allow for a verbose description of the mapping for 
    each of the valid strings. 
 
    The valid distance metrics, and the function they map to, are: 
      ===============   ======================================== 
      metric            Function 
      ===============   ======================================== 
      'additive_chi2'   sklearn.pairwise.additive_chi2_kernel 
      'chi2'            sklearn.pairwise.chi2_kernel 
      'linear'          sklearn.pairwise.linear_kernel 
      'poly'            sklearn.pairwise.polynomial_kernel 
      'polynomial'      sklearn.pairwise.polynomial_kernel 
      'rbf'             sklearn.pairwise.rbf_kernel 
      'laplacian'       sklearn.pairwise.laplacian_kernel 
      'sigmoid'         sklearn.pairwise.sigmoid_kernel 
      'cosine'          sklearn.pairwise.cosine_similarity 
      ===============   ======================================== 
 
    Read more in the :ref:`User Guide &lt;metrics&gt;`. 
 
    Returns 
    ------- 
    kernel_metrics : dict 
        Returns valid metrics for pairwise_kernels. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">PAIRWISE_KERNEL_FUNCTIONS</span>


<span class="s1">KERNEL_PARAMS </span><span class="s4">= {</span>
    <span class="s5">&quot;additive_chi2&quot;</span><span class="s4">: (),</span>
    <span class="s5">&quot;chi2&quot;</span><span class="s4">: </span><span class="s1">frozenset</span><span class="s4">([</span><span class="s5">&quot;gamma&quot;</span><span class="s4">]),</span>
    <span class="s5">&quot;cosine&quot;</span><span class="s4">: (),</span>
    <span class="s5">&quot;linear&quot;</span><span class="s4">: (),</span>
    <span class="s5">&quot;poly&quot;</span><span class="s4">: </span><span class="s1">frozenset</span><span class="s4">([</span><span class="s5">&quot;gamma&quot;</span><span class="s4">, </span><span class="s5">&quot;degree&quot;</span><span class="s4">, </span><span class="s5">&quot;coef0&quot;</span><span class="s4">]),</span>
    <span class="s5">&quot;polynomial&quot;</span><span class="s4">: </span><span class="s1">frozenset</span><span class="s4">([</span><span class="s5">&quot;gamma&quot;</span><span class="s4">, </span><span class="s5">&quot;degree&quot;</span><span class="s4">, </span><span class="s5">&quot;coef0&quot;</span><span class="s4">]),</span>
    <span class="s5">&quot;rbf&quot;</span><span class="s4">: </span><span class="s1">frozenset</span><span class="s4">([</span><span class="s5">&quot;gamma&quot;</span><span class="s4">]),</span>
    <span class="s5">&quot;laplacian&quot;</span><span class="s4">: </span><span class="s1">frozenset</span><span class="s4">([</span><span class="s5">&quot;gamma&quot;</span><span class="s4">]),</span>
    <span class="s5">&quot;sigmoid&quot;</span><span class="s4">: </span><span class="s1">frozenset</span><span class="s4">([</span><span class="s5">&quot;gamma&quot;</span><span class="s4">, </span><span class="s5">&quot;coef0&quot;</span><span class="s4">]),</span>
<span class="s4">}</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;Y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;metric&quot;</span><span class="s4">: [</span>
            <span class="s1">StrOptions</span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s1">PAIRWISE_KERNEL_FUNCTIONS</span><span class="s4">) | {</span><span class="s5">&quot;precomputed&quot;</span><span class="s4">}),</span>
            <span class="s1">callable</span><span class="s4">,</span>
        <span class="s4">],</span>
        <span class="s5">&quot;filter_params&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;n_jobs&quot;</span><span class="s4">: [</span><span class="s1">Integral</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">pairwise_kernels</span><span class="s4">(</span>
    <span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s5">&quot;linear&quot;</span><span class="s4">, *, </span><span class="s1">filter_params</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kwds</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the kernel between arrays X and optional array Y. 
 
    This method takes either a vector array or a kernel matrix, and returns 
    a kernel matrix. If the input is a vector array, the kernels are 
    computed. If the input is a kernel matrix, it is returned instead. 
 
    This method provides a safe way to take a kernel matrix as input, while 
    preserving compatibility with many other algorithms that take a vector 
    array. 
 
    If Y is given (default is None), then the returned matrix is the pairwise 
    kernel between the arrays from both X and Y. 
 
    Valid values for metric are: 
        ['additive_chi2', 'chi2', 'linear', 'poly', 'polynomial', 'rbf', 
        'laplacian', 'sigmoid', 'cosine'] 
 
    Read more in the :ref:`User Guide &lt;metrics&gt;`. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix}  of shape (n_samples_X, n_samples_X) or \ 
            (n_samples_X, n_features) 
        Array of pairwise kernels between samples, or a feature array. 
        The shape of the array should be (n_samples_X, n_samples_X) if 
        metric == &quot;precomputed&quot; and (n_samples_X, n_features) otherwise. 
 
    Y : {array-like, sparse matrix} of shape (n_samples_Y, n_features), default=None 
        A second feature array only if X has shape (n_samples_X, n_features). 
 
    metric : str or callable, default=&quot;linear&quot; 
        The metric to use when calculating kernel between instances in a 
        feature array. If metric is a string, it must be one of the metrics 
        in ``pairwise.PAIRWISE_KERNEL_FUNCTIONS``. 
        If metric is &quot;precomputed&quot;, X is assumed to be a kernel matrix. 
        Alternatively, if metric is a callable function, it is called on each 
        pair of instances (rows) and the resulting value recorded. The callable 
        should take two rows from X as input and return the corresponding 
        kernel value as a single number. This means that callables from 
        :mod:`sklearn.metrics.pairwise` are not allowed, as they operate on 
        matrices, not single samples. Use the string identifying the kernel 
        instead. 
 
    filter_params : bool, default=False 
        Whether to filter invalid parameters or not. 
 
    n_jobs : int, default=None 
        The number of jobs to use for the computation. This works by breaking 
        down the pairwise matrix into n_jobs even slices and computing them 
        using multithreading. 
 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    **kwds : optional keyword parameters 
        Any further parameters are passed directly to the kernel function. 
 
    Returns 
    ------- 
    K : ndarray of shape (n_samples_X, n_samples_X) or (n_samples_X, n_samples_Y) 
        A kernel matrix K such that K_{i, j} is the kernel between the 
        ith and jth vectors of the given matrix X, if Y is None. 
        If Y is not None, then K_{i, j} is the kernel between the ith array 
        from X and the jth array from Y. 
 
    Notes 
    ----- 
    If metric is 'precomputed', Y is ignored and X is returned. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.metrics.pairwise import pairwise_kernels 
    &gt;&gt;&gt; X = [[0, 0, 0], [1, 1, 1]] 
    &gt;&gt;&gt; Y = [[1, 0, 0], [1, 1, 0]] 
    &gt;&gt;&gt; pairwise_kernels(X, Y, metric='linear') 
    array([[0., 0.], 
           [1., 2.]]) 
    &quot;&quot;&quot;</span>
    <span class="s2"># import GPKernel locally to prevent circular imports</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">gaussian_process</span><span class="s4">.</span><span class="s1">kernels </span><span class="s3">import </span><span class="s1">Kernel </span><span class="s3">as </span><span class="s1">GPKernel</span>

    <span class="s3">if </span><span class="s1">metric </span><span class="s4">== </span><span class="s5">&quot;precomputed&quot;</span><span class="s4">:</span>
        <span class="s1">X</span><span class="s4">, </span><span class="s1">_ </span><span class="s4">= </span><span class="s1">check_pairwise_arrays</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">precomputed</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">X</span>
    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">metric</span><span class="s4">, </span><span class="s1">GPKernel</span><span class="s4">):</span>
        <span class="s1">func </span><span class="s4">= </span><span class="s1">metric</span><span class="s4">.</span><span class="s1">__call__</span>
    <span class="s3">elif </span><span class="s1">metric </span><span class="s3">in </span><span class="s1">PAIRWISE_KERNEL_FUNCTIONS</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">filter_params</span><span class="s4">:</span>
            <span class="s1">kwds </span><span class="s4">= {</span><span class="s1">k</span><span class="s4">: </span><span class="s1">kwds</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">kwds </span><span class="s3">if </span><span class="s1">k </span><span class="s3">in </span><span class="s1">KERNEL_PARAMS</span><span class="s4">[</span><span class="s1">metric</span><span class="s4">]}</span>
        <span class="s1">func </span><span class="s4">= </span><span class="s1">PAIRWISE_KERNEL_FUNCTIONS</span><span class="s4">[</span><span class="s1">metric</span><span class="s4">]</span>
    <span class="s3">elif </span><span class="s1">callable</span><span class="s4">(</span><span class="s1">metric</span><span class="s4">):</span>
        <span class="s1">func </span><span class="s4">= </span><span class="s1">partial</span><span class="s4">(</span><span class="s1">_pairwise_callable</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s1">metric</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">_parallel_pairwise</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">func</span><span class="s4">, </span><span class="s1">n_jobs</span><span class="s4">, **</span><span class="s1">kwds</span><span class="s4">)</span>
</pre>
</body>
</html>