<html>
<head>
<title>_root_scalar.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_root_scalar.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Unified interfaces to root finding algorithms for real or complex 
scalar functions. 
 
Functions 
--------- 
- root : find a root of a scalar function. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_zeros_py </span><span class="s2">as </span><span class="s1">optzeros</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">_numdiff </span><span class="s2">import </span><span class="s1">approx_derivative</span>

<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">'root_scalar'</span><span class="s3">]</span>

<span class="s1">ROOT_SCALAR_METHODS </span><span class="s3">= [</span><span class="s4">'bisect'</span><span class="s3">, </span><span class="s4">'brentq'</span><span class="s3">, </span><span class="s4">'brenth'</span><span class="s3">, </span><span class="s4">'ridder'</span><span class="s3">, </span><span class="s4">'toms748'</span><span class="s3">,</span>
                       <span class="s4">'newton'</span><span class="s3">, </span><span class="s4">'secant'</span><span class="s3">, </span><span class="s4">'halley'</span><span class="s3">]</span>


<span class="s2">class </span><span class="s1">MemoizeDer</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Decorator that caches the value and derivative(s) of function each 
    time it is called. 
 
    This is a simplistic memoizer that calls and caches a single value 
    of `f(x, *args)`. 
    It assumes that `args` does not change between invocations. 
    It supports the use case of a root-finder where `args` is fixed, 
    `x` changes, and only rarely, if at all, does x assume the same value 
    more than once.&quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">fun</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fun </span><span class="s3">= </span><span class="s1">fun</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">vals </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">x </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">n_calls </span><span class="s3">= </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s0">r&quot;&quot;&quot;Calculate f or use cached value if available&quot;&quot;&quot;</span>
        <span class="s6"># Derivative may be requested before the function itself, always check</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vals </span><span class="s2">is None or </span><span class="s1">x </span><span class="s3">!= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">x</span><span class="s3">:</span>
            <span class="s1">fg </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fun</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">x </span><span class="s3">= </span><span class="s1">x</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">n_calls </span><span class="s3">+= </span><span class="s5">1</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">vals </span><span class="s3">= </span><span class="s1">fg</span><span class="s3">[:]</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vals</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">fprime</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s0">r&quot;&quot;&quot;Calculate f' or use a cached value if available&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vals </span><span class="s2">is None or </span><span class="s1">x </span><span class="s3">!= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">x</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vals</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">fprime2</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
        <span class="s0">r&quot;&quot;&quot;Calculate f'' or use a cached value if available&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vals </span><span class="s2">is None or </span><span class="s1">x </span><span class="s3">!= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">x</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">vals</span><span class="s3">[</span><span class="s5">2</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">ncalls</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">n_calls</span>


<span class="s2">def </span><span class="s1">root_scalar</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=(), </span><span class="s1">method</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">bracket</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s1">fprime</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fprime2</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s1">x0</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s1">xtol</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">rtol</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s1">options</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Find a root of a scalar function. 
 
    Parameters 
    ---------- 
    f : callable 
        A function to find a root of. 
    args : tuple, optional 
        Extra arguments passed to the objective function and its derivative(s). 
    method : str, optional 
        Type of solver.  Should be one of 
 
            - 'bisect'    :ref:`(see here) &lt;optimize.root_scalar-bisect&gt;` 
            - 'brentq'    :ref:`(see here) &lt;optimize.root_scalar-brentq&gt;` 
            - 'brenth'    :ref:`(see here) &lt;optimize.root_scalar-brenth&gt;` 
            - 'ridder'    :ref:`(see here) &lt;optimize.root_scalar-ridder&gt;` 
            - 'toms748'    :ref:`(see here) &lt;optimize.root_scalar-toms748&gt;` 
            - 'newton'    :ref:`(see here) &lt;optimize.root_scalar-newton&gt;` 
            - 'secant'    :ref:`(see here) &lt;optimize.root_scalar-secant&gt;` 
            - 'halley'    :ref:`(see here) &lt;optimize.root_scalar-halley&gt;` 
 
    bracket: A sequence of 2 floats, optional 
        An interval bracketing a root.  `f(x, *args)` must have different 
        signs at the two endpoints. 
    x0 : float, optional 
        Initial guess. 
    x1 : float, optional 
        A second guess. 
    fprime : bool or callable, optional 
        If `fprime` is a boolean and is True, `f` is assumed to return the 
        value of the objective function and of the derivative. 
        `fprime` can also be a callable returning the derivative of `f`. In 
        this case, it must accept the same arguments as `f`. 
    fprime2 : bool or callable, optional 
        If `fprime2` is a boolean and is True, `f` is assumed to return the 
        value of the objective function and of the 
        first and second derivatives. 
        `fprime2` can also be a callable returning the second derivative of `f`. 
        In this case, it must accept the same arguments as `f`. 
    xtol : float, optional 
        Tolerance (absolute) for termination. 
    rtol : float, optional 
        Tolerance (relative) for termination. 
    maxiter : int, optional 
        Maximum number of iterations. 
    options : dict, optional 
        A dictionary of solver options. E.g., ``k``, see 
        :obj:`show_options()` for details. 
 
    Returns 
    ------- 
    sol : RootResults 
        The solution represented as a ``RootResults`` object. 
        Important attributes are: ``root`` the solution , ``converged`` a 
        boolean flag indicating if the algorithm exited successfully and 
        ``flag`` which describes the cause of the termination. See 
        `RootResults` for a description of other attributes. 
 
    See also 
    -------- 
    show_options : Additional options accepted by the solvers 
    root : Find a root of a vector function. 
 
    Notes 
    ----- 
    This section describes the available solvers that can be selected by the 
    'method' parameter. 
 
    The default is to use the best method available for the situation 
    presented. 
    If a bracket is provided, it may use one of the bracketing methods. 
    If a derivative and an initial value are specified, it may 
    select one of the derivative-based methods. 
    If no method is judged applicable, it will raise an Exception. 
 
    Arguments for each method are as follows (x=required, o=optional). 
 
    +-----------------------------------------------+---+------+---------+----+----+--------+---------+------+------+---------+---------+ 
    |                    method                     | f | args | bracket | x0 | x1 | fprime | fprime2 | xtol | rtol | maxiter | options | 
    +===============================================+===+======+=========+====+====+========+=========+======+======+=========+=========+ 
    | :ref:`bisect &lt;optimize.root_scalar-bisect&gt;`   | x |  o   |    x    |    |    |        |         |  o   |  o   |    o    |   o     | 
    +-----------------------------------------------+---+------+---------+----+----+--------+---------+------+------+---------+---------+ 
    | :ref:`brentq &lt;optimize.root_scalar-brentq&gt;`   | x |  o   |    x    |    |    |        |         |  o   |  o   |    o    |   o     | 
    +-----------------------------------------------+---+------+---------+----+----+--------+---------+------+------+---------+---------+ 
    | :ref:`brenth &lt;optimize.root_scalar-brenth&gt;`   | x |  o   |    x    |    |    |        |         |  o   |  o   |    o    |   o     | 
    +-----------------------------------------------+---+------+---------+----+----+--------+---------+------+------+---------+---------+ 
    | :ref:`ridder &lt;optimize.root_scalar-ridder&gt;`   | x |  o   |    x    |    |    |        |         |  o   |  o   |    o    |   o     | 
    +-----------------------------------------------+---+------+---------+----+----+--------+---------+------+------+---------+---------+ 
    | :ref:`toms748 &lt;optimize.root_scalar-toms748&gt;` | x |  o   |    x    |    |    |        |         |  o   |  o   |    o    |   o     | 
    +-----------------------------------------------+---+------+---------+----+----+--------+---------+------+------+---------+---------+ 
    | :ref:`secant &lt;optimize.root_scalar-secant&gt;`   | x |  o   |         | x  | o  |        |         |  o   |  o   |    o    |   o     | 
    +-----------------------------------------------+---+------+---------+----+----+--------+---------+------+------+---------+---------+ 
    | :ref:`newton &lt;optimize.root_scalar-newton&gt;`   | x |  o   |         | x  |    |   o    |         |  o   |  o   |    o    |   o     | 
    +-----------------------------------------------+---+------+---------+----+----+--------+---------+------+------+---------+---------+ 
    | :ref:`halley &lt;optimize.root_scalar-halley&gt;`   | x |  o   |         | x  |    |   x    |    x    |  o   |  o   |    o    |   o     | 
    +-----------------------------------------------+---+------+---------+----+----+--------+---------+------+------+---------+---------+ 
 
    Examples 
    -------- 
 
    Find the root of a simple cubic 
 
    &gt;&gt;&gt; from scipy import optimize 
    &gt;&gt;&gt; def f(x): 
    ...     return (x**3 - 1)  # only one real root at x = 1 
 
    &gt;&gt;&gt; def fprime(x): 
    ...     return 3*x**2 
 
    The `brentq` method takes as input a bracket 
 
    &gt;&gt;&gt; sol = optimize.root_scalar(f, bracket=[0, 3], method='brentq') 
    &gt;&gt;&gt; sol.root, sol.iterations, sol.function_calls 
    (1.0, 10, 11) 
 
    The `newton` method takes as input a single point and uses the 
    derivative(s). 
 
    &gt;&gt;&gt; sol = optimize.root_scalar(f, x0=0.2, fprime=fprime, method='newton') 
    &gt;&gt;&gt; sol.root, sol.iterations, sol.function_calls 
    (1.0, 11, 22) 
 
    The function can provide the value and derivative(s) in a single call. 
 
    &gt;&gt;&gt; def f_p_pp(x): 
    ...     return (x**3 - 1), 3*x**2, 6*x 
 
    &gt;&gt;&gt; sol = optimize.root_scalar( 
    ...     f_p_pp, x0=0.2, fprime=True, method='newton' 
    ... ) 
    &gt;&gt;&gt; sol.root, sol.iterations, sol.function_calls 
    (1.0, 11, 11) 
 
    &gt;&gt;&gt; sol = optimize.root_scalar( 
    ...     f_p_pp, x0=0.2, fprime=True, fprime2=True, method='halley' 
    ... ) 
    &gt;&gt;&gt; sol.root, sol.iterations, sol.function_calls 
    (1.0, 7, 8) 
 
 
    &quot;&quot;&quot;  </span><span class="s6"># noqa: E501</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">args</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
        <span class="s1">args </span><span class="s3">= (</span><span class="s1">args</span><span class="s3">,)</span>

    <span class="s2">if </span><span class="s1">options </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">options </span><span class="s3">= {}</span>

    <span class="s6"># fun also returns the derivative(s)</span>
    <span class="s1">is_memoized </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s2">if </span><span class="s1">fprime2 </span><span class="s2">is not None and not </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">fprime2</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">fprime2</span><span class="s3">):</span>
            <span class="s1">f </span><span class="s3">= </span><span class="s1">MemoizeDer</span><span class="s3">(</span><span class="s1">f</span><span class="s3">)</span>
            <span class="s1">is_memoized </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s1">fprime2 </span><span class="s3">= </span><span class="s1">f</span><span class="s3">.</span><span class="s1">fprime2</span>
            <span class="s1">fprime </span><span class="s3">= </span><span class="s1">f</span><span class="s3">.</span><span class="s1">fprime</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">fprime2 </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">fprime </span><span class="s2">is not None and not </span><span class="s1">callable</span><span class="s3">(</span><span class="s1">fprime</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">fprime</span><span class="s3">):</span>
            <span class="s1">f </span><span class="s3">= </span><span class="s1">MemoizeDer</span><span class="s3">(</span><span class="s1">f</span><span class="s3">)</span>
            <span class="s1">is_memoized </span><span class="s3">= </span><span class="s2">True</span>
            <span class="s1">fprime </span><span class="s3">= </span><span class="s1">f</span><span class="s3">.</span><span class="s1">fprime</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">fprime </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s6"># respect solver-specific default tolerances - only pass in if actually set</span>
    <span class="s1">kwargs </span><span class="s3">= {}</span>
    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'xtol'</span><span class="s3">, </span><span class="s4">'rtol'</span><span class="s3">, </span><span class="s4">'maxiter'</span><span class="s3">]:</span>
        <span class="s1">v </span><span class="s3">= </span><span class="s1">locals</span><span class="s3">().</span><span class="s1">get</span><span class="s3">(</span><span class="s1">k</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">v </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">kwargs</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">v</span>

    <span class="s6"># Set any solver-specific options</span>
    <span class="s2">if </span><span class="s1">options</span><span class="s3">:</span>
        <span class="s1">kwargs</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">options</span><span class="s3">)</span>
    <span class="s6"># Always request full_output from the underlying method as _root_scalar</span>
    <span class="s6"># always returns a RootResults object</span>
    <span class="s1">kwargs</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">full_output</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">disp</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s6"># Pick a method if not specified.</span>
    <span class="s6"># Use the &quot;best&quot; method available for the situation.</span>
    <span class="s2">if not </span><span class="s1">method</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">bracket</span><span class="s3">:</span>
            <span class="s1">method </span><span class="s3">= </span><span class="s4">'brentq'</span>
        <span class="s2">elif </span><span class="s1">x0 </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">fprime</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">fprime2</span><span class="s3">:</span>
                    <span class="s1">method </span><span class="s3">= </span><span class="s4">'halley'</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">method </span><span class="s3">= </span><span class="s4">'newton'</span>
            <span class="s2">elif </span><span class="s1">x1 </span><span class="s2">is not None</span><span class="s3">:</span>
                <span class="s1">method </span><span class="s3">= </span><span class="s4">'secant'</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">method </span><span class="s3">= </span><span class="s4">'newton'</span>
    <span class="s2">if not </span><span class="s1">method</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Unable to select a solver as neither bracket '</span>
                         <span class="s4">'nor starting point provided.'</span><span class="s3">)</span>

    <span class="s1">meth </span><span class="s3">= </span><span class="s1">method</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">()</span>
    <span class="s1">map2underlying </span><span class="s3">= {</span><span class="s4">'halley'</span><span class="s3">: </span><span class="s4">'newton'</span><span class="s3">, </span><span class="s4">'secant'</span><span class="s3">: </span><span class="s4">'newton'</span><span class="s3">}</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">methodc </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">optzeros</span><span class="s3">, </span><span class="s1">map2underlying</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">meth</span><span class="s3">, </span><span class="s1">meth</span><span class="s3">))</span>
    <span class="s2">except </span><span class="s1">AttributeError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Unknown solver %s' </span><span class="s3">% </span><span class="s1">meth</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s2">if </span><span class="s1">meth </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'bisect'</span><span class="s3">, </span><span class="s4">'ridder'</span><span class="s3">, </span><span class="s4">'brentq'</span><span class="s3">, </span><span class="s4">'brenth'</span><span class="s3">, </span><span class="s4">'toms748'</span><span class="s3">]:</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">bracket</span><span class="s3">, (</span><span class="s1">list</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Bracket needed for %s' </span><span class="s3">% </span><span class="s1">method</span><span class="s3">)</span>

        <span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s3">= </span><span class="s1">bracket</span><span class="s3">[:</span><span class="s5">2</span><span class="s3">]</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">r</span><span class="s3">, </span><span class="s1">sol </span><span class="s3">= </span><span class="s1">methodc</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s6"># gh-17622 fixed some bugs in low-level solvers by raising an error</span>
            <span class="s6"># (rather than returning incorrect results) when the callable</span>
            <span class="s6"># returns a NaN. It did so by wrapping the callable rather than</span>
            <span class="s6"># modifying compiled code, so the iteration count is not available.</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">e</span><span class="s3">, </span><span class="s4">&quot;_x&quot;</span><span class="s3">):</span>
                <span class="s1">sol </span><span class="s3">= </span><span class="s1">optzeros</span><span class="s3">.</span><span class="s1">RootResults</span><span class="s3">(</span><span class="s1">root</span><span class="s3">=</span><span class="s1">e</span><span class="s3">.</span><span class="s1">_x</span><span class="s3">,</span>
                                           <span class="s1">iterations</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">,</span>
                                           <span class="s1">function_calls</span><span class="s3">=</span><span class="s1">e</span><span class="s3">.</span><span class="s1">_function_calls</span><span class="s3">,</span>
                                           <span class="s1">flag</span><span class="s3">=</span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">), </span><span class="s1">method</span><span class="s3">=</span><span class="s1">method</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">raise</span>

    <span class="s2">elif </span><span class="s1">meth </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'secant'</span><span class="s3">]:</span>
        <span class="s2">if </span><span class="s1">x0 </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'x0 must not be None for %s' </span><span class="s3">% </span><span class="s1">method</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s4">'xtol' </span><span class="s2">in </span><span class="s1">kwargs</span><span class="s3">:</span>
            <span class="s1">kwargs</span><span class="s3">[</span><span class="s4">'tol'</span><span class="s3">] = </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">'xtol'</span><span class="s3">)</span>
        <span class="s1">r</span><span class="s3">, </span><span class="s1">sol </span><span class="s3">= </span><span class="s1">methodc</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=</span><span class="s1">args</span><span class="s3">, </span><span class="s1">fprime</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fprime2</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                         <span class="s1">x1</span><span class="s3">=</span><span class="s1">x1</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">meth </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'newton'</span><span class="s3">]:</span>
        <span class="s2">if </span><span class="s1">x0 </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'x0 must not be None for %s' </span><span class="s3">% </span><span class="s1">method</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">fprime</span><span class="s3">:</span>
            <span class="s6"># approximate fprime with finite differences</span>

            <span class="s2">def </span><span class="s1">fprime</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">):</span>
                <span class="s6"># `root_scalar` doesn't actually seem to support vectorized</span>
                <span class="s6"># use of `newton`. In that case, `approx_derivative` will</span>
                <span class="s6"># always get scalar input. Nonetheless, it always returns an</span>
                <span class="s6"># array, so we extract the element to produce scalar output.</span>
                <span class="s2">return </span><span class="s1">approx_derivative</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">method</span><span class="s3">=</span><span class="s4">'2-point'</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=</span><span class="s1">args</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s4">'xtol' </span><span class="s2">in </span><span class="s1">kwargs</span><span class="s3">:</span>
            <span class="s1">kwargs</span><span class="s3">[</span><span class="s4">'tol'</span><span class="s3">] = </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">'xtol'</span><span class="s3">)</span>
        <span class="s1">r</span><span class="s3">, </span><span class="s1">sol </span><span class="s3">= </span><span class="s1">methodc</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=</span><span class="s1">args</span><span class="s3">, </span><span class="s1">fprime</span><span class="s3">=</span><span class="s1">fprime</span><span class="s3">, </span><span class="s1">fprime2</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                         <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">meth </span><span class="s2">in </span><span class="s3">[</span><span class="s4">'halley'</span><span class="s3">]:</span>
        <span class="s2">if </span><span class="s1">x0 </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'x0 must not be None for %s' </span><span class="s3">% </span><span class="s1">method</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">fprime</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'fprime must be specified for %s' </span><span class="s3">% </span><span class="s1">method</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">fprime2</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'fprime2 must be specified for %s' </span><span class="s3">% </span><span class="s1">method</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s4">'xtol' </span><span class="s2">in </span><span class="s1">kwargs</span><span class="s3">:</span>
            <span class="s1">kwargs</span><span class="s3">[</span><span class="s4">'tol'</span><span class="s3">] = </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">'xtol'</span><span class="s3">)</span>
        <span class="s1">r</span><span class="s3">, </span><span class="s1">sol </span><span class="s3">= </span><span class="s1">methodc</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=</span><span class="s1">args</span><span class="s3">, </span><span class="s1">fprime</span><span class="s3">=</span><span class="s1">fprime</span><span class="s3">, </span><span class="s1">fprime2</span><span class="s3">=</span><span class="s1">fprime2</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Unknown solver %s' </span><span class="s3">% </span><span class="s1">method</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">is_memoized</span><span class="s3">:</span>
        <span class="s6"># Replace the function_calls count with the memoized count.</span>
        <span class="s6"># Avoids double and triple-counting.</span>
        <span class="s1">n_calls </span><span class="s3">= </span><span class="s1">f</span><span class="s3">.</span><span class="s1">n_calls</span>
        <span class="s1">sol</span><span class="s3">.</span><span class="s1">function_calls </span><span class="s3">= </span><span class="s1">n_calls</span>

    <span class="s2">return </span><span class="s1">sol</span>


<span class="s2">def </span><span class="s1">_root_scalar_brentq_doc</span><span class="s3">():</span>
    <span class="s0">r&quot;&quot;&quot; 
    Options 
    ------- 
    args : tuple, optional 
        Extra arguments passed to the objective function. 
    bracket: A sequence of 2 floats, optional 
        An interval bracketing a root.  `f(x, *args)` must have different 
        signs at the two endpoints. 
    xtol : float, optional 
        Tolerance (absolute) for termination. 
    rtol : float, optional 
        Tolerance (relative) for termination. 
    maxiter : int, optional 
        Maximum number of iterations. 
    options: dict, optional 
        Specifies any method-specific options not covered above 
 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">_root_scalar_brenth_doc</span><span class="s3">():</span>
    <span class="s0">r&quot;&quot;&quot; 
    Options 
    ------- 
    args : tuple, optional 
        Extra arguments passed to the objective function. 
    bracket: A sequence of 2 floats, optional 
        An interval bracketing a root.  `f(x, *args)` must have different 
        signs at the two endpoints. 
    xtol : float, optional 
        Tolerance (absolute) for termination. 
    rtol : float, optional 
        Tolerance (relative) for termination. 
    maxiter : int, optional 
        Maximum number of iterations. 
    options: dict, optional 
        Specifies any method-specific options not covered above. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>

<span class="s2">def </span><span class="s1">_root_scalar_toms748_doc</span><span class="s3">():</span>
    <span class="s0">r&quot;&quot;&quot; 
    Options 
    ------- 
    args : tuple, optional 
        Extra arguments passed to the objective function. 
    bracket: A sequence of 2 floats, optional 
        An interval bracketing a root.  `f(x, *args)` must have different 
        signs at the two endpoints. 
    xtol : float, optional 
        Tolerance (absolute) for termination. 
    rtol : float, optional 
        Tolerance (relative) for termination. 
    maxiter : int, optional 
        Maximum number of iterations. 
    options: dict, optional 
        Specifies any method-specific options not covered above. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">_root_scalar_secant_doc</span><span class="s3">():</span>
    <span class="s0">r&quot;&quot;&quot; 
    Options 
    ------- 
    args : tuple, optional 
        Extra arguments passed to the objective function. 
    xtol : float, optional 
        Tolerance (absolute) for termination. 
    rtol : float, optional 
        Tolerance (relative) for termination. 
    maxiter : int, optional 
        Maximum number of iterations. 
    x0 : float, required 
        Initial guess. 
    x1 : float, required 
        A second guess. 
    options: dict, optional 
        Specifies any method-specific options not covered above. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">_root_scalar_newton_doc</span><span class="s3">():</span>
    <span class="s0">r&quot;&quot;&quot; 
    Options 
    ------- 
    args : tuple, optional 
        Extra arguments passed to the objective function and its derivative. 
    xtol : float, optional 
        Tolerance (absolute) for termination. 
    rtol : float, optional 
        Tolerance (relative) for termination. 
    maxiter : int, optional 
        Maximum number of iterations. 
    x0 : float, required 
        Initial guess. 
    fprime : bool or callable, optional 
        If `fprime` is a boolean and is True, `f` is assumed to return the 
        value of derivative along with the objective function. 
        `fprime` can also be a callable returning the derivative of `f`. In 
        this case, it must accept the same arguments as `f`. 
    options: dict, optional 
        Specifies any method-specific options not covered above. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">_root_scalar_halley_doc</span><span class="s3">():</span>
    <span class="s0">r&quot;&quot;&quot; 
    Options 
    ------- 
    args : tuple, optional 
        Extra arguments passed to the objective function and its derivatives. 
    xtol : float, optional 
        Tolerance (absolute) for termination. 
    rtol : float, optional 
        Tolerance (relative) for termination. 
    maxiter : int, optional 
        Maximum number of iterations. 
    x0 : float, required 
        Initial guess. 
    fprime : bool or callable, required 
        If `fprime` is a boolean and is True, `f` is assumed to return the 
        value of derivative along with the objective function. 
        `fprime` can also be a callable returning the derivative of `f`. In 
        this case, it must accept the same arguments as `f`. 
    fprime2 : bool or callable, required 
        If `fprime2` is a boolean and is True, `f` is assumed to return the 
        value of 1st and 2nd derivatives along with the objective function. 
        `fprime2` can also be a callable returning the 2nd derivative of `f`. 
        In this case, it must accept the same arguments as `f`. 
    options: dict, optional 
        Specifies any method-specific options not covered above. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">_root_scalar_ridder_doc</span><span class="s3">():</span>
    <span class="s0">r&quot;&quot;&quot; 
    Options 
    ------- 
    args : tuple, optional 
        Extra arguments passed to the objective function. 
    bracket: A sequence of 2 floats, optional 
        An interval bracketing a root.  `f(x, *args)` must have different 
        signs at the two endpoints. 
    xtol : float, optional 
        Tolerance (absolute) for termination. 
    rtol : float, optional 
        Tolerance (relative) for termination. 
    maxiter : int, optional 
        Maximum number of iterations. 
    options: dict, optional 
        Specifies any method-specific options not covered above. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>


<span class="s2">def </span><span class="s1">_root_scalar_bisect_doc</span><span class="s3">():</span>
    <span class="s0">r&quot;&quot;&quot; 
    Options 
    ------- 
    args : tuple, optional 
        Extra arguments passed to the objective function. 
    bracket: A sequence of 2 floats, optional 
        An interval bracketing a root.  `f(x, *args)` must have different 
        signs at the two endpoints. 
    xtol : float, optional 
        Tolerance (absolute) for termination. 
    rtol : float, optional 
        Tolerance (relative) for termination. 
    maxiter : int, optional 
        Maximum number of iterations. 
    options: dict, optional 
        Specifies any method-specific options not covered above. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>
</pre>
</body>
</html>