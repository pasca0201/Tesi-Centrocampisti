<html>
<head>
<title>test_tree.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_tree.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Testing for the tree module (sklearn.tree). 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">copyreg</span>
<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">pickle</span>
<span class="s2">import </span><span class="s1">struct</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">chain</span><span class="s3">, </span><span class="s1">product</span>

<span class="s2">import </span><span class="s1">joblib</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">joblib</span><span class="s3">.</span><span class="s1">numpy_pickle </span><span class="s2">import </span><span class="s1">NumpyPickler</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">testing </span><span class="s2">import </span><span class="s1">assert_allclose</span>

<span class="s2">from </span><span class="s1">sklearn </span><span class="s2">import </span><span class="s1">clone</span><span class="s3">, </span><span class="s1">datasets</span><span class="s3">, </span><span class="s1">tree</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">dummy </span><span class="s2">import </span><span class="s1">DummyRegressor</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">exceptions </span><span class="s2">import </span><span class="s1">NotFittedError</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">impute </span><span class="s2">import </span><span class="s1">SimpleImputer</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">metrics </span><span class="s2">import </span><span class="s1">accuracy_score</span><span class="s3">, </span><span class="s1">mean_poisson_deviance</span><span class="s3">, </span><span class="s1">mean_squared_error</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">model_selection </span><span class="s2">import </span><span class="s1">train_test_split</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">pipeline </span><span class="s2">import </span><span class="s1">make_pipeline</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">random_projection </span><span class="s2">import </span><span class="s1">_sparse_random_matrix</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">tree </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">DecisionTreeClassifier</span><span class="s3">,</span>
    <span class="s1">DecisionTreeRegressor</span><span class="s3">,</span>
    <span class="s1">ExtraTreeClassifier</span><span class="s3">,</span>
    <span class="s1">ExtraTreeRegressor</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">_classes </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">CRITERIA_CLF</span><span class="s3">,</span>
    <span class="s1">CRITERIA_REG</span><span class="s3">,</span>
    <span class="s1">DENSE_SPLITTERS</span><span class="s3">,</span>
    <span class="s1">SPARSE_SPLITTERS</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">_tree </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">NODE_DTYPE</span><span class="s3">,</span>
    <span class="s1">TREE_LEAF</span><span class="s3">,</span>
    <span class="s1">TREE_UNDEFINED</span><span class="s3">,</span>
    <span class="s1">_check_n_classes</span><span class="s3">,</span>
    <span class="s1">_check_node_ndarray</span><span class="s3">,</span>
    <span class="s1">_check_value_ndarray</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">_tree </span><span class="s2">import </span><span class="s1">Tree </span><span class="s2">as </span><span class="s1">CythonTree</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">utils </span><span class="s2">import </span><span class="s1">compute_sample_weight</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_testing </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">assert_almost_equal</span><span class="s3">,</span>
    <span class="s1">assert_array_almost_equal</span><span class="s3">,</span>
    <span class="s1">assert_array_equal</span><span class="s3">,</span>
    <span class="s1">create_memmap_backed_data</span><span class="s3">,</span>
    <span class="s1">ignore_warnings</span><span class="s3">,</span>
    <span class="s1">skip_if_32bit</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">estimator_checks </span><span class="s2">import </span><span class="s1">check_sample_weights_invariance</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">fixes </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">_IS_32BIT</span><span class="s3">,</span>
    <span class="s1">COO_CONTAINERS</span><span class="s3">,</span>
    <span class="s1">CSC_CONTAINERS</span><span class="s3">,</span>
    <span class="s1">CSR_CONTAINERS</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">validation </span><span class="s2">import </span><span class="s1">check_random_state</span>

<span class="s1">CLF_CRITERIONS </span><span class="s3">= (</span><span class="s4">&quot;gini&quot;</span><span class="s3">, </span><span class="s4">&quot;log_loss&quot;</span><span class="s3">)</span>
<span class="s1">REG_CRITERIONS </span><span class="s3">= (</span><span class="s4">&quot;squared_error&quot;</span><span class="s3">, </span><span class="s4">&quot;absolute_error&quot;</span><span class="s3">, </span><span class="s4">&quot;friedman_mse&quot;</span><span class="s3">, </span><span class="s4">&quot;poisson&quot;</span><span class="s3">)</span>

<span class="s1">CLF_TREES </span><span class="s3">= {</span>
    <span class="s4">&quot;DecisionTreeClassifier&quot;</span><span class="s3">: </span><span class="s1">DecisionTreeClassifier</span><span class="s3">,</span>
    <span class="s4">&quot;ExtraTreeClassifier&quot;</span><span class="s3">: </span><span class="s1">ExtraTreeClassifier</span><span class="s3">,</span>
<span class="s3">}</span>

<span class="s1">REG_TREES </span><span class="s3">= {</span>
    <span class="s4">&quot;DecisionTreeRegressor&quot;</span><span class="s3">: </span><span class="s1">DecisionTreeRegressor</span><span class="s3">,</span>
    <span class="s4">&quot;ExtraTreeRegressor&quot;</span><span class="s3">: </span><span class="s1">ExtraTreeRegressor</span><span class="s3">,</span>
<span class="s3">}</span>

<span class="s1">ALL_TREES</span><span class="s3">: </span><span class="s1">dict </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">()</span>
<span class="s1">ALL_TREES</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">CLF_TREES</span><span class="s3">)</span>
<span class="s1">ALL_TREES</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">REG_TREES</span><span class="s3">)</span>

<span class="s1">SPARSE_TREES </span><span class="s3">= [</span>
    <span class="s4">&quot;DecisionTreeClassifier&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;DecisionTreeRegressor&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;ExtraTreeClassifier&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;ExtraTreeRegressor&quot;</span><span class="s3">,</span>
<span class="s3">]</span>


<span class="s1">X_small </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
    <span class="s3">[</span>
        <span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, -</span><span class="s5">14</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">4</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">4</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, -</span><span class="s5">5</span><span class="s3">, </span><span class="s5">0.2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">4.5</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">2.1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">4.5</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1.2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0.2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, -</span><span class="s5">3</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">3.2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, -</span><span class="s5">4</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">2.11</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">6</span><span class="s3">, -</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">11</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">3.2</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">2.11</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">6</span><span class="s3">, -</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">11</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">3.2</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">2.11</span><span class="s3">, </span><span class="s5">8</span><span class="s3">, -</span><span class="s5">6</span><span class="s3">, -</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">11</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">3.2</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">2.11</span><span class="s3">, </span><span class="s5">8</span><span class="s3">, -</span><span class="s5">6</span><span class="s3">, -</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">11</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">3.2</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">8</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, -</span><span class="s5">4</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, -</span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">0</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">4</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, -</span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">2.11</span><span class="s3">, </span><span class="s5">8</span><span class="s3">, -</span><span class="s5">6</span><span class="s3">, -</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">3.2</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">2.11</span><span class="s3">, </span><span class="s5">8</span><span class="s3">, -</span><span class="s5">6</span><span class="s3">, -</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">3.2</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">1.5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">2.11</span><span class="s3">, </span><span class="s5">8</span><span class="s3">, -</span><span class="s5">6</span><span class="s3">, -</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">3.2</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, -</span><span class="s5">5</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, -</span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, -</span><span class="s5">4</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">],</span>
    <span class="s3">]</span>
<span class="s3">)</span>

<span class="s1">y_small </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>
<span class="s1">y_small_reg </span><span class="s3">= [</span>
    <span class="s5">1.0</span><span class="s3">,</span>
    <span class="s5">2.1</span><span class="s3">,</span>
    <span class="s5">1.2</span><span class="s3">,</span>
    <span class="s5">0.05</span><span class="s3">,</span>
    <span class="s5">10</span><span class="s3">,</span>
    <span class="s5">2.4</span><span class="s3">,</span>
    <span class="s5">3.1</span><span class="s3">,</span>
    <span class="s5">1.01</span><span class="s3">,</span>
    <span class="s5">0.01</span><span class="s3">,</span>
    <span class="s5">2.98</span><span class="s3">,</span>
    <span class="s5">3.1</span><span class="s3">,</span>
    <span class="s5">1.1</span><span class="s3">,</span>
    <span class="s5">0.0</span><span class="s3">,</span>
    <span class="s5">1.2</span><span class="s3">,</span>
    <span class="s5">2</span><span class="s3">,</span>
    <span class="s5">11</span><span class="s3">,</span>
    <span class="s5">0</span><span class="s3">,</span>
    <span class="s5">0</span><span class="s3">,</span>
    <span class="s5">4.5</span><span class="s3">,</span>
    <span class="s5">0.201</span><span class="s3">,</span>
    <span class="s5">1.06</span><span class="s3">,</span>
    <span class="s5">0.9</span><span class="s3">,</span>
    <span class="s5">0</span><span class="s3">,</span>
<span class="s3">]</span>

<span class="s6"># toy sample</span>
<span class="s1">X </span><span class="s3">= [[-</span><span class="s5">2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">], [-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">], [-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">], [</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]]</span>
<span class="s1">y </span><span class="s3">= [-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]</span>
<span class="s1">T </span><span class="s3">= [[-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">], [</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">], [</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s3">]]</span>
<span class="s1">true_result </span><span class="s3">= [-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]</span>

<span class="s6"># also load the iris dataset</span>
<span class="s6"># and randomly permute it</span>
<span class="s1">iris </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">load_iris</span><span class="s3">()</span>
<span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s5">1</span><span class="s3">)</span>
<span class="s1">perm </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">permutation</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
<span class="s1">iris</span><span class="s3">.</span><span class="s1">data </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[</span><span class="s1">perm</span><span class="s3">]</span>
<span class="s1">iris</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">[</span><span class="s1">perm</span><span class="s3">]</span>

<span class="s6"># also load the diabetes dataset</span>
<span class="s6"># and randomly permute it</span>
<span class="s1">diabetes </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">load_diabetes</span><span class="s3">()</span>
<span class="s1">perm </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">permutation</span><span class="s3">(</span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
<span class="s1">diabetes</span><span class="s3">.</span><span class="s1">data </span><span class="s3">= </span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[</span><span class="s1">perm</span><span class="s3">]</span>
<span class="s1">diabetes</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">target</span><span class="s3">[</span><span class="s1">perm</span><span class="s3">]</span>

<span class="s1">digits </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">load_digits</span><span class="s3">()</span>
<span class="s1">perm </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">permutation</span><span class="s3">(</span><span class="s1">digits</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">size</span><span class="s3">)</span>
<span class="s1">digits</span><span class="s3">.</span><span class="s1">data </span><span class="s3">= </span><span class="s1">digits</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[</span><span class="s1">perm</span><span class="s3">]</span>
<span class="s1">digits</span><span class="s3">.</span><span class="s1">target </span><span class="s3">= </span><span class="s1">digits</span><span class="s3">.</span><span class="s1">target</span><span class="s3">[</span><span class="s1">perm</span><span class="s3">]</span>

<span class="s1">random_state </span><span class="s3">= </span><span class="s1">check_random_state</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
<span class="s1">X_multilabel</span><span class="s3">, </span><span class="s1">y_multilabel </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">make_multilabel_classification</span><span class="s3">(</span>
    <span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">=</span><span class="s5">30</span><span class="s3">, </span><span class="s1">n_features</span><span class="s3">=</span><span class="s5">10</span>
<span class="s3">)</span>

<span class="s6"># NB: despite their names X_sparse_* are numpy arrays (and not sparse matrices)</span>
<span class="s1">X_sparse_pos </span><span class="s3">= </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s5">20</span><span class="s3">, </span><span class="s5">5</span><span class="s3">))</span>
<span class="s1">X_sparse_pos</span><span class="s3">[</span><span class="s1">X_sparse_pos </span><span class="s3">&lt;= </span><span class="s5">0.8</span><span class="s3">] = </span><span class="s5">0.0</span>
<span class="s1">y_random </span><span class="s3">= </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s5">20</span><span class="s3">,))</span>
<span class="s1">X_sparse_mix </span><span class="s3">= </span><span class="s1">_sparse_random_matrix</span><span class="s3">(</span><span class="s5">20</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s1">density</span><span class="s3">=</span><span class="s5">0.25</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">).</span><span class="s1">toarray</span><span class="s3">()</span>


<span class="s1">DATASETS </span><span class="s3">= {</span>
    <span class="s4">&quot;iris&quot;</span><span class="s3">: {</span><span class="s4">&quot;X&quot;</span><span class="s3">: </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s4">&quot;y&quot;</span><span class="s3">: </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">},</span>
    <span class="s4">&quot;diabetes&quot;</span><span class="s3">: {</span><span class="s4">&quot;X&quot;</span><span class="s3">: </span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s4">&quot;y&quot;</span><span class="s3">: </span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">target</span><span class="s3">},</span>
    <span class="s4">&quot;digits&quot;</span><span class="s3">: {</span><span class="s4">&quot;X&quot;</span><span class="s3">: </span><span class="s1">digits</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s4">&quot;y&quot;</span><span class="s3">: </span><span class="s1">digits</span><span class="s3">.</span><span class="s1">target</span><span class="s3">},</span>
    <span class="s4">&quot;toy&quot;</span><span class="s3">: {</span><span class="s4">&quot;X&quot;</span><span class="s3">: </span><span class="s1">X</span><span class="s3">, </span><span class="s4">&quot;y&quot;</span><span class="s3">: </span><span class="s1">y</span><span class="s3">},</span>
    <span class="s4">&quot;clf_small&quot;</span><span class="s3">: {</span><span class="s4">&quot;X&quot;</span><span class="s3">: </span><span class="s1">X_small</span><span class="s3">, </span><span class="s4">&quot;y&quot;</span><span class="s3">: </span><span class="s1">y_small</span><span class="s3">},</span>
    <span class="s4">&quot;reg_small&quot;</span><span class="s3">: {</span><span class="s4">&quot;X&quot;</span><span class="s3">: </span><span class="s1">X_small</span><span class="s3">, </span><span class="s4">&quot;y&quot;</span><span class="s3">: </span><span class="s1">y_small_reg</span><span class="s3">},</span>
    <span class="s4">&quot;multilabel&quot;</span><span class="s3">: {</span><span class="s4">&quot;X&quot;</span><span class="s3">: </span><span class="s1">X_multilabel</span><span class="s3">, </span><span class="s4">&quot;y&quot;</span><span class="s3">: </span><span class="s1">y_multilabel</span><span class="s3">},</span>
    <span class="s4">&quot;sparse-pos&quot;</span><span class="s3">: {</span><span class="s4">&quot;X&quot;</span><span class="s3">: </span><span class="s1">X_sparse_pos</span><span class="s3">, </span><span class="s4">&quot;y&quot;</span><span class="s3">: </span><span class="s1">y_random</span><span class="s3">},</span>
    <span class="s4">&quot;sparse-neg&quot;</span><span class="s3">: {</span><span class="s4">&quot;X&quot;</span><span class="s3">: -</span><span class="s1">X_sparse_pos</span><span class="s3">, </span><span class="s4">&quot;y&quot;</span><span class="s3">: </span><span class="s1">y_random</span><span class="s3">},</span>
    <span class="s4">&quot;sparse-mix&quot;</span><span class="s3">: {</span><span class="s4">&quot;X&quot;</span><span class="s3">: </span><span class="s1">X_sparse_mix</span><span class="s3">, </span><span class="s4">&quot;y&quot;</span><span class="s3">: </span><span class="s1">y_random</span><span class="s3">},</span>
    <span class="s4">&quot;zeros&quot;</span><span class="s3">: {</span><span class="s4">&quot;X&quot;</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s5">20</span><span class="s3">, </span><span class="s5">3</span><span class="s3">)), </span><span class="s4">&quot;y&quot;</span><span class="s3">: </span><span class="s1">y_random</span><span class="s3">},</span>
<span class="s3">}</span>


<span class="s2">def </span><span class="s1">assert_tree_equal</span><span class="s3">(</span><span class="s1">d</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">message</span><span class="s3">):</span>
    <span class="s2">assert </span><span class="s3">(</span>
        <span class="s1">s</span><span class="s3">.</span><span class="s1">node_count </span><span class="s3">== </span><span class="s1">d</span><span class="s3">.</span><span class="s1">node_count</span>
    <span class="s3">), </span><span class="s4">&quot;{0}: inequal number of node ({1} != {2})&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
        <span class="s1">message</span><span class="s3">, </span><span class="s1">s</span><span class="s3">.</span><span class="s1">node_count</span><span class="s3">, </span><span class="s1">d</span><span class="s3">.</span><span class="s1">node_count</span>
    <span class="s3">)</span>

    <span class="s1">assert_array_equal</span><span class="s3">(</span>
        <span class="s1">d</span><span class="s3">.</span><span class="s1">children_right</span><span class="s3">, </span><span class="s1">s</span><span class="s3">.</span><span class="s1">children_right</span><span class="s3">, </span><span class="s1">message </span><span class="s3">+ </span><span class="s4">&quot;: inequal children_right&quot;</span>
    <span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span>
        <span class="s1">d</span><span class="s3">.</span><span class="s1">children_left</span><span class="s3">, </span><span class="s1">s</span><span class="s3">.</span><span class="s1">children_left</span><span class="s3">, </span><span class="s1">message </span><span class="s3">+ </span><span class="s4">&quot;: inequal children_left&quot;</span>
    <span class="s3">)</span>

    <span class="s1">external </span><span class="s3">= </span><span class="s1">d</span><span class="s3">.</span><span class="s1">children_right </span><span class="s3">== </span><span class="s1">TREE_LEAF</span>
    <span class="s1">internal </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">logical_not</span><span class="s3">(</span><span class="s1">external</span><span class="s3">)</span>

    <span class="s1">assert_array_equal</span><span class="s3">(</span>
        <span class="s1">d</span><span class="s3">.</span><span class="s1">feature</span><span class="s3">[</span><span class="s1">internal</span><span class="s3">], </span><span class="s1">s</span><span class="s3">.</span><span class="s1">feature</span><span class="s3">[</span><span class="s1">internal</span><span class="s3">], </span><span class="s1">message </span><span class="s3">+ </span><span class="s4">&quot;: inequal features&quot;</span>
    <span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span>
        <span class="s1">d</span><span class="s3">.</span><span class="s1">threshold</span><span class="s3">[</span><span class="s1">internal</span><span class="s3">], </span><span class="s1">s</span><span class="s3">.</span><span class="s1">threshold</span><span class="s3">[</span><span class="s1">internal</span><span class="s3">], </span><span class="s1">message </span><span class="s3">+ </span><span class="s4">&quot;: inequal threshold&quot;</span>
    <span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span>
        <span class="s1">d</span><span class="s3">.</span><span class="s1">n_node_samples</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(),</span>
        <span class="s1">s</span><span class="s3">.</span><span class="s1">n_node_samples</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(),</span>
        <span class="s1">message </span><span class="s3">+ </span><span class="s4">&quot;: inequal sum(n_node_samples)&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span>
        <span class="s1">d</span><span class="s3">.</span><span class="s1">n_node_samples</span><span class="s3">, </span><span class="s1">s</span><span class="s3">.</span><span class="s1">n_node_samples</span><span class="s3">, </span><span class="s1">message </span><span class="s3">+ </span><span class="s4">&quot;: inequal n_node_samples&quot;</span>
    <span class="s3">)</span>

    <span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">d</span><span class="s3">.</span><span class="s1">impurity</span><span class="s3">, </span><span class="s1">s</span><span class="s3">.</span><span class="s1">impurity</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">message </span><span class="s3">+ </span><span class="s4">&quot;: inequal impurity&quot;</span><span class="s3">)</span>

    <span class="s1">assert_array_almost_equal</span><span class="s3">(</span>
        <span class="s1">d</span><span class="s3">.</span><span class="s1">value</span><span class="s3">[</span><span class="s1">external</span><span class="s3">], </span><span class="s1">s</span><span class="s3">.</span><span class="s1">value</span><span class="s3">[</span><span class="s1">external</span><span class="s3">], </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s1">message </span><span class="s3">+ </span><span class="s4">&quot;: inequal value&quot;</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_classification_toy</span><span class="s3">():</span>
    <span class="s6"># Check classification on a toy dataset.</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">Tree </span><span class="s2">in </span><span class="s1">CLF_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">clf </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">T</span><span class="s3">), </span><span class="s1">true_result</span><span class="s3">, </span><span class="s4">&quot;Failed with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">))</span>

        <span class="s1">clf </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">T</span><span class="s3">), </span><span class="s1">true_result</span><span class="s3">, </span><span class="s4">&quot;Failed with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_weighted_classification_toy</span><span class="s3">():</span>
    <span class="s6"># Check classification on a weighted toy dataset.</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">Tree </span><span class="s2">in </span><span class="s1">CLF_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">clf </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)))</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">T</span><span class="s3">), </span><span class="s1">true_result</span><span class="s3">, </span><span class="s4">&quot;Failed with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">))</span>

        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s5">0.5</span><span class="s3">))</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">T</span><span class="s3">), </span><span class="s1">true_result</span><span class="s3">, </span><span class="s4">&quot;Failed with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;Tree&quot;</span><span class="s3">, </span><span class="s1">REG_TREES</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;criterion&quot;</span><span class="s3">, </span><span class="s1">REG_CRITERIONS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_regression_toy</span><span class="s3">(</span><span class="s1">Tree</span><span class="s3">, </span><span class="s1">criterion</span><span class="s3">):</span>
    <span class="s6"># Check regression on a toy dataset.</span>
    <span class="s2">if </span><span class="s1">criterion </span><span class="s3">== </span><span class="s4">&quot;poisson&quot;</span><span class="s3">:</span>
        <span class="s6"># make target positive while not touching the original y and</span>
        <span class="s6"># true_result</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)) + </span><span class="s5">1</span>
        <span class="s1">y_train </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">y</span><span class="s3">) + </span><span class="s1">a</span>
        <span class="s1">y_test </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">true_result</span><span class="s3">) + </span><span class="s1">a</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">y_train </span><span class="s3">= </span><span class="s1">y</span>
        <span class="s1">y_test </span><span class="s3">= </span><span class="s1">true_result</span>

    <span class="s1">reg </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s1">criterion</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">reg</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">reg</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">T</span><span class="s3">), </span><span class="s1">y_test</span><span class="s3">)</span>

    <span class="s1">clf </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s1">criterion</span><span class="s3">, </span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">reg</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">T</span><span class="s3">), </span><span class="s1">y_test</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_xor</span><span class="s3">():</span>
    <span class="s6"># Check on a XOR problem</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s5">10</span><span class="s3">, </span><span class="s5">10</span><span class="s3">))</span>
    <span class="s1">y</span><span class="s3">[:</span><span class="s5">5</span><span class="s3">, :</span><span class="s5">5</span><span class="s3">] = </span><span class="s5">1</span>
    <span class="s1">y</span><span class="s3">[</span><span class="s5">5</span><span class="s3">:, </span><span class="s5">5</span><span class="s3">:] = </span><span class="s5">1</span>

    <span class="s1">gridx</span><span class="s3">, </span><span class="s1">gridy </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">([</span><span class="s1">gridx</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(), </span><span class="s1">gridy</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()]).</span><span class="s1">T</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()</span>

    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">Tree </span><span class="s2">in </span><span class="s1">CLF_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">clf </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">clf</span><span class="s3">.</span><span class="s1">score</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) == </span><span class="s5">1.0</span><span class="s3">, </span><span class="s4">&quot;Failed with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

        <span class="s1">clf </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">clf</span><span class="s3">.</span><span class="s1">score</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) == </span><span class="s5">1.0</span><span class="s3">, </span><span class="s4">&quot;Failed with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_iris</span><span class="s3">():</span>
    <span class="s6"># Check consistency on dataset iris.</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">Tree</span><span class="s3">), </span><span class="s1">criterion </span><span class="s2">in </span><span class="s1">product</span><span class="s3">(</span><span class="s1">CLF_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">(), </span><span class="s1">CLF_CRITERIONS</span><span class="s3">):</span>
        <span class="s1">clf </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s1">criterion</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s1">score </span><span class="s3">= </span><span class="s1">accuracy_score</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">), </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">score </span><span class="s3">&gt; </span><span class="s5">0.9</span><span class="s3">, </span><span class="s4">&quot;Failed with {0}, criterion = {1} and score = {2}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
            <span class="s1">name</span><span class="s3">, </span><span class="s1">criterion</span><span class="s3">, </span><span class="s1">score</span>
        <span class="s3">)</span>

        <span class="s1">clf </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s1">criterion</span><span class="s3">, </span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">2</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s1">score </span><span class="s3">= </span><span class="s1">accuracy_score</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">), </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">score </span><span class="s3">&gt; </span><span class="s5">0.5</span><span class="s3">, </span><span class="s4">&quot;Failed with {0}, criterion = {1} and score = {2}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
            <span class="s1">name</span><span class="s3">, </span><span class="s1">criterion</span><span class="s3">, </span><span class="s1">score</span>
        <span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;name, Tree&quot;</span><span class="s3">, </span><span class="s1">REG_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;criterion&quot;</span><span class="s3">, </span><span class="s1">REG_CRITERIONS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_diabetes_overfit</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">Tree</span><span class="s3">, </span><span class="s1">criterion</span><span class="s3">):</span>
    <span class="s6"># check consistency of overfitted trees on the diabetes dataset</span>
    <span class="s6"># since the trees will overfit, we expect an MSE of 0</span>
    <span class="s1">reg </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s1">criterion</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">reg</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
    <span class="s1">score </span><span class="s3">= </span><span class="s1">mean_squared_error</span><span class="s3">(</span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">reg</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">data</span><span class="s3">))</span>
    <span class="s2">assert </span><span class="s1">score </span><span class="s3">== </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">approx</span><span class="s3">(</span>
        <span class="s5">0</span>
    <span class="s3">), </span><span class="s4">f&quot;Failed with </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">, criterion = </span><span class="s2">{</span><span class="s1">criterion</span><span class="s2">} </span><span class="s4">and score = </span><span class="s2">{</span><span class="s1">score</span><span class="s2">}</span><span class="s4">&quot;</span>


<span class="s3">@</span><span class="s1">skip_if_32bit</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;name, Tree&quot;</span><span class="s3">, </span><span class="s1">REG_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s4">&quot;criterion, max_depth, metric, max_loss&quot;</span><span class="s3">,</span>
    <span class="s3">[</span>
        <span class="s3">(</span><span class="s4">&quot;squared_error&quot;</span><span class="s3">, </span><span class="s5">15</span><span class="s3">, </span><span class="s1">mean_squared_error</span><span class="s3">, </span><span class="s5">60</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">&quot;absolute_error&quot;</span><span class="s3">, </span><span class="s5">20</span><span class="s3">, </span><span class="s1">mean_squared_error</span><span class="s3">, </span><span class="s5">60</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">&quot;friedman_mse&quot;</span><span class="s3">, </span><span class="s5">15</span><span class="s3">, </span><span class="s1">mean_squared_error</span><span class="s3">, </span><span class="s5">60</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s4">&quot;poisson&quot;</span><span class="s3">, </span><span class="s5">15</span><span class="s3">, </span><span class="s1">mean_poisson_deviance</span><span class="s3">, </span><span class="s5">30</span><span class="s3">),</span>
    <span class="s3">],</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_diabetes_underfit</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">Tree</span><span class="s3">, </span><span class="s1">criterion</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">, </span><span class="s1">metric</span><span class="s3">, </span><span class="s1">max_loss</span><span class="s3">):</span>
    <span class="s6"># check consistency of trees when the depth and the number of features are</span>
    <span class="s6"># limited</span>

    <span class="s1">reg </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s1">criterion</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s1">max_depth</span><span class="s3">, </span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">6</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">reg</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
    <span class="s1">loss </span><span class="s3">= </span><span class="s1">metric</span><span class="s3">(</span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">reg</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">data</span><span class="s3">))</span>
    <span class="s2">assert </span><span class="s5">0 </span><span class="s3">&lt; </span><span class="s1">loss </span><span class="s3">&lt; </span><span class="s1">max_loss</span>


<span class="s2">def </span><span class="s1">test_probability</span><span class="s3">():</span>
    <span class="s6"># Predict probabilities using DecisionTreeClassifier.</span>

    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">Tree </span><span class="s2">in </span><span class="s1">CLF_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">clf </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">42</span><span class="s3">)</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>

        <span class="s1">prob_predict </span><span class="s3">= </span><span class="s1">clf</span><span class="s3">.</span><span class="s1">predict_proba</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">)</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">prob_predict</span><span class="s3">, </span><span class="s5">1</span><span class="s3">),</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]),</span>
            <span class="s1">err_msg</span><span class="s3">=</span><span class="s4">&quot;Failed with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">),</span>
        <span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">argmax</span><span class="s3">(</span><span class="s1">prob_predict</span><span class="s3">, </span><span class="s5">1</span><span class="s3">),</span>
            <span class="s1">clf</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">),</span>
            <span class="s1">err_msg</span><span class="s3">=</span><span class="s4">&quot;Failed with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">),</span>
        <span class="s3">)</span>
        <span class="s1">assert_almost_equal</span><span class="s3">(</span>
            <span class="s1">clf</span><span class="s3">.</span><span class="s1">predict_proba</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">),</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">predict_log_proba</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">)),</span>
            <span class="s5">8</span><span class="s3">,</span>
            <span class="s1">err_msg</span><span class="s3">=</span><span class="s4">&quot;Failed with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">),</span>
        <span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_arrayrepr</span><span class="s3">():</span>
    <span class="s6"># Check the array representation.</span>
    <span class="s6"># Check resize</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">10000</span><span class="s3">)[:, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">newaxis</span><span class="s3">]</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">10000</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">Tree </span><span class="s2">in </span><span class="s1">REG_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">reg </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">max_depth</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">reg</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_pure_set</span><span class="s3">():</span>
    <span class="s6"># Check when y is pure.</span>
    <span class="s1">X </span><span class="s3">= [[-</span><span class="s5">2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">], [-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">], [-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">], [</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]]</span>
    <span class="s1">y </span><span class="s3">= [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]</span>

    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">TreeClassifier </span><span class="s2">in </span><span class="s1">CLF_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">clf </span><span class="s3">= </span><span class="s1">TreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">y</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s4">&quot;Failed with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">))</span>

    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">TreeRegressor </span><span class="s2">in </span><span class="s1">REG_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">reg </span><span class="s3">= </span><span class="s1">TreeRegressor</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">reg</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">reg</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">y</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s4">&quot;Failed with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_numerical_stability</span><span class="s3">():</span>
    <span class="s6"># Check numerical stability.</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
        <span class="s3">[</span>
            <span class="s3">[</span><span class="s5">152.08097839</span><span class="s3">, </span><span class="s5">140.40744019</span><span class="s3">, </span><span class="s5">129.75102234</span><span class="s3">, </span><span class="s5">159.90493774</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s5">142.50700378</span><span class="s3">, </span><span class="s5">135.81935120</span><span class="s3">, </span><span class="s5">117.82884979</span><span class="s3">, </span><span class="s5">162.75781250</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s5">127.28772736</span><span class="s3">, </span><span class="s5">140.40744019</span><span class="s3">, </span><span class="s5">129.75102234</span><span class="s3">, </span><span class="s5">159.90493774</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s5">132.37025452</span><span class="s3">, </span><span class="s5">143.71923828</span><span class="s3">, </span><span class="s5">138.35694885</span><span class="s3">, </span><span class="s5">157.84558105</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s5">103.10237122</span><span class="s3">, </span><span class="s5">143.71928406</span><span class="s3">, </span><span class="s5">138.35696411</span><span class="s3">, </span><span class="s5">157.84559631</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s5">127.71276855</span><span class="s3">, </span><span class="s5">143.71923828</span><span class="s3">, </span><span class="s5">138.35694885</span><span class="s3">, </span><span class="s5">157.84558105</span><span class="s3">],</span>
            <span class="s3">[</span><span class="s5">120.91514587</span><span class="s3">, </span><span class="s5">140.40744019</span><span class="s3">, </span><span class="s5">129.75102234</span><span class="s3">, </span><span class="s5">159.90493774</span><span class="s3">],</span>
        <span class="s3">]</span>
    <span class="s3">)</span>

    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">0.70209277</span><span class="s3">, </span><span class="s5">0.53896582</span><span class="s3">, </span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">0.90914464</span><span class="s3">, </span><span class="s5">0.48026916</span><span class="s3">, </span><span class="s5">0.49622521</span><span class="s3">])</span>

    <span class="s2">with </span><span class="s1">np</span><span class="s3">.</span><span class="s1">errstate</span><span class="s3">(</span><span class="s1">all</span><span class="s3">=</span><span class="s4">&quot;raise&quot;</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">Tree </span><span class="s2">in </span><span class="s1">REG_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">reg </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
            <span class="s1">reg</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
            <span class="s1">reg</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, -</span><span class="s1">y</span><span class="s3">)</span>
            <span class="s1">reg</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(-</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
            <span class="s1">reg</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(-</span><span class="s1">X</span><span class="s3">, -</span><span class="s1">y</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_importances</span><span class="s3">():</span>
    <span class="s6"># Check variable importances.</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">make_classification</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s5">5000</span><span class="s3">,</span>
        <span class="s1">n_features</span><span class="s3">=</span><span class="s5">10</span><span class="s3">,</span>
        <span class="s1">n_informative</span><span class="s3">=</span><span class="s5">3</span><span class="s3">,</span>
        <span class="s1">n_redundant</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">n_repeated</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">shuffle</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">Tree </span><span class="s2">in </span><span class="s1">CLF_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">clf </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">importances </span><span class="s3">= </span><span class="s1">clf</span><span class="s3">.</span><span class="s1">feature_importances_</span>
        <span class="s1">n_important </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">importances </span><span class="s3">&gt; </span><span class="s5">0.1</span><span class="s3">)</span>

        <span class="s2">assert </span><span class="s1">importances</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s5">10</span><span class="s3">, </span><span class="s4">&quot;Failed with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">n_important </span><span class="s3">== </span><span class="s5">3</span><span class="s3">, </span><span class="s4">&quot;Failed with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

    <span class="s6"># Check on iris that importances are the same for all builders</span>
    <span class="s1">clf </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
    <span class="s1">clf2 </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">))</span>
    <span class="s1">clf2</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>

    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">feature_importances_</span><span class="s3">, </span><span class="s1">clf2</span><span class="s3">.</span><span class="s1">feature_importances_</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_importances_raises</span><span class="s3">():</span>
    <span class="s6"># Check if variable importance before fit raises ValueError.</span>
    <span class="s1">clf </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">()</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">getattr</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">, </span><span class="s4">&quot;feature_importances_&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_importances_gini_equal_squared_error</span><span class="s3">():</span>
    <span class="s6"># Check that gini is equivalent to squared_error for binary output variable</span>

    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">make_classification</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s5">2000</span><span class="s3">,</span>
        <span class="s1">n_features</span><span class="s3">=</span><span class="s5">10</span><span class="s3">,</span>
        <span class="s1">n_informative</span><span class="s3">=</span><span class="s5">3</span><span class="s3">,</span>
        <span class="s1">n_redundant</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">n_repeated</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">shuffle</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s3">)</span>

    <span class="s6"># The gini index and the mean square error (variance) might differ due</span>
    <span class="s6"># to numerical instability. Since those instabilities mainly occurs at</span>
    <span class="s6"># high tree depth, we restrict this maximal depth.</span>
    <span class="s1">clf </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s4">&quot;gini&quot;</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">5</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span>
    <span class="s3">)</span>
    <span class="s1">reg </span><span class="s3">= </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(</span>
        <span class="s1">criterion</span><span class="s3">=</span><span class="s4">&quot;squared_error&quot;</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">5</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span>
    <span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">feature_importances_</span><span class="s3">, </span><span class="s1">reg</span><span class="s3">.</span><span class="s1">feature_importances_</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">feature</span><span class="s3">, </span><span class="s1">reg</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">feature</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">children_left</span><span class="s3">, </span><span class="s1">reg</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">children_left</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">children_right</span><span class="s3">, </span><span class="s1">reg</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">children_right</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">n_node_samples</span><span class="s3">, </span><span class="s1">reg</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">n_node_samples</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_max_features</span><span class="s3">():</span>
    <span class="s6"># Check max_features.</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">TreeEstimator </span><span class="s2">in </span><span class="s1">ALL_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">max_features</span><span class="s3">=</span><span class="s4">&quot;sqrt&quot;</span><span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">max_features_ </span><span class="s3">== </span><span class="s1">int</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]))</span>

        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">max_features</span><span class="s3">=</span><span class="s4">&quot;log2&quot;</span><span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">max_features_ </span><span class="s3">== </span><span class="s1">int</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">log2</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]))</span>

        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">max_features_ </span><span class="s3">== </span><span class="s5">1</span>

        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">3</span><span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">max_features_ </span><span class="s3">== </span><span class="s5">3</span>

        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">0.01</span><span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">max_features_ </span><span class="s3">== </span><span class="s5">1</span>

        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">0.5</span><span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">max_features_ </span><span class="s3">== </span><span class="s1">int</span><span class="s3">(</span><span class="s5">0.5 </span><span class="s3">* </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">])</span>

        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">max_features_ </span><span class="s3">== </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>

        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">max_features</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">max_features_ </span><span class="s3">== </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">test_error</span><span class="s3">():</span>
    <span class="s6"># Test that it gives proper exception on deficient input.</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">TreeEstimator </span><span class="s2">in </span><span class="s1">CLF_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s6"># predict before fit</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">()</span>
        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">NotFittedError</span><span class="s3">):</span>
            <span class="s1">est</span><span class="s3">.</span><span class="s1">predict_proba</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">X2 </span><span class="s3">= [[-</span><span class="s5">2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]]  </span><span class="s6"># wrong feature shape for sample</span>
        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
            <span class="s1">est</span><span class="s3">.</span><span class="s1">predict_proba</span><span class="s3">(</span><span class="s1">X2</span><span class="s3">)</span>

        <span class="s6"># Wrong dimensions</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">()</span>
        <span class="s1">y2 </span><span class="s3">= </span><span class="s1">y</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]</span>
        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
            <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y2</span><span class="s3">)</span>

        <span class="s6"># Test with arrays that are non-contiguous.</span>
        <span class="s1">Xf </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asfortranarray</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">()</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">Xf</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">est</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">T</span><span class="s3">), </span><span class="s1">true_result</span><span class="s3">)</span>

        <span class="s6"># predict before fitting</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">()</span>
        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">NotFittedError</span><span class="s3">):</span>
            <span class="s1">est</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">T</span><span class="s3">)</span>

        <span class="s6"># predict on vector with different dims</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">t </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">T</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
            <span class="s1">est</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">t</span><span class="s3">[:, </span><span class="s5">1</span><span class="s3">:])</span>

        <span class="s6"># wrong sample shape</span>
        <span class="s1">Xt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">X</span><span class="s3">).</span><span class="s1">T</span>

        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">()</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">Xt</span><span class="s3">), </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
            <span class="s1">est</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
            <span class="s1">est</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s1">clf </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">()</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
            <span class="s1">clf</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">Xt</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
            <span class="s1">clf</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">Xt</span><span class="s3">)</span>

        <span class="s6"># apply before fitting</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">()</span>
        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">NotFittedError</span><span class="s3">):</span>
            <span class="s1">est</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">T</span><span class="s3">)</span>

    <span class="s6"># non positive target for Poisson splitting Criterion</span>
    <span class="s1">est </span><span class="s3">= </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s4">&quot;poisson&quot;</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;y is not positive.*Poisson&quot;</span><span class="s3">):</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">([[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">]], [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">])</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;Some.*y are negative.*Poisson&quot;</span><span class="s3">):</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">([[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">]], [</span><span class="s5">5</span><span class="s3">, -</span><span class="s5">0.1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">])</span>


<span class="s2">def </span><span class="s1">test_min_samples_split</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Test min_samples_split parameter&quot;&quot;&quot;</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asfortranarray</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">_tree</span><span class="s3">.</span><span class="s1">DTYPE</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span>

    <span class="s6"># test both DepthFirstTreeBuilder and BestFirstTreeBuilder</span>
    <span class="s6"># by setting max_leaf_nodes</span>
    <span class="s2">for </span><span class="s1">max_leaf_nodes</span><span class="s3">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">product</span><span class="s3">((</span><span class="s2">None</span><span class="s3">, </span><span class="s5">1000</span><span class="s3">), </span><span class="s1">ALL_TREES</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()):</span>
        <span class="s1">TreeEstimator </span><span class="s3">= </span><span class="s1">ALL_TREES</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>

        <span class="s6"># test for integer parameter</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span>
            <span class="s1">min_samples_split</span><span class="s3">=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s1">max_leaf_nodes</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span>
        <span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s6"># count samples on nodes, -1 means it is a leaf</span>
        <span class="s1">node_samples </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">n_node_samples</span><span class="s3">[</span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">children_left </span><span class="s3">!= -</span><span class="s5">1</span><span class="s3">]</span>

        <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">node_samples</span><span class="s3">) &gt; </span><span class="s5">9</span><span class="s3">, </span><span class="s4">&quot;Failed with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

        <span class="s6"># test for float parameter</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span>
            <span class="s1">min_samples_split</span><span class="s3">=</span><span class="s5">0.2</span><span class="s3">, </span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s1">max_leaf_nodes</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span>
        <span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s6"># count samples on nodes, -1 means it is a leaf</span>
        <span class="s1">node_samples </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">n_node_samples</span><span class="s3">[</span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">children_left </span><span class="s3">!= -</span><span class="s5">1</span><span class="s3">]</span>

        <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">node_samples</span><span class="s3">) &gt; </span><span class="s5">9</span><span class="s3">, </span><span class="s4">&quot;Failed with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_min_samples_leaf</span><span class="s3">():</span>
    <span class="s6"># Test if leaves contain more than leaf_count training examples</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asfortranarray</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">_tree</span><span class="s3">.</span><span class="s1">DTYPE</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span>

    <span class="s6"># test both DepthFirstTreeBuilder and BestFirstTreeBuilder</span>
    <span class="s6"># by setting max_leaf_nodes</span>
    <span class="s2">for </span><span class="s1">max_leaf_nodes</span><span class="s3">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">product</span><span class="s3">((</span><span class="s2">None</span><span class="s3">, </span><span class="s5">1000</span><span class="s3">), </span><span class="s1">ALL_TREES</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()):</span>
        <span class="s1">TreeEstimator </span><span class="s3">= </span><span class="s1">ALL_TREES</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>

        <span class="s6"># test integer parameter</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span>
            <span class="s1">min_samples_leaf</span><span class="s3">=</span><span class="s5">5</span><span class="s3">, </span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s1">max_leaf_nodes</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span>
        <span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">node_counts </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)</span>
        <span class="s6"># drop inner nodes</span>
        <span class="s1">leaf_count </span><span class="s3">= </span><span class="s1">node_counts</span><span class="s3">[</span><span class="s1">node_counts </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">leaf_count</span><span class="s3">) &gt; </span><span class="s5">4</span><span class="s3">, </span><span class="s4">&quot;Failed with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>

        <span class="s6"># test float parameter</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span>
            <span class="s1">min_samples_leaf</span><span class="s3">=</span><span class="s5">0.1</span><span class="s3">, </span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s1">max_leaf_nodes</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span>
        <span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">out </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">node_counts </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)</span>
        <span class="s6"># drop inner nodes</span>
        <span class="s1">leaf_count </span><span class="s3">= </span><span class="s1">node_counts</span><span class="s3">[</span><span class="s1">node_counts </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">leaf_count</span><span class="s3">) &gt; </span><span class="s5">4</span><span class="s3">, </span><span class="s4">&quot;Failed with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_min_weight_fraction_leaf</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">datasets</span><span class="s3">, </span><span class="s1">sparse_container</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Test if leaves contain at least min_weight_fraction_leaf of the 
    training set&quot;&quot;&quot;</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">DATASETS</span><span class="s3">[</span><span class="s1">datasets</span><span class="s3">][</span><span class="s4">&quot;X&quot;</span><span class="s3">].</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">sparse_container </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">sparse_container</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">DATASETS</span><span class="s3">[</span><span class="s1">datasets</span><span class="s3">][</span><span class="s4">&quot;y&quot;</span><span class="s3">]</span>

    <span class="s1">weights </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">rand</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
    <span class="s1">total_weight </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">)</span>

    <span class="s1">TreeEstimator </span><span class="s3">= </span><span class="s1">ALL_TREES</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>

    <span class="s6"># test both DepthFirstTreeBuilder and BestFirstTreeBuilder</span>
    <span class="s6"># by setting max_leaf_nodes</span>
    <span class="s2">for </span><span class="s1">max_leaf_nodes</span><span class="s3">, </span><span class="s1">frac </span><span class="s2">in </span><span class="s1">product</span><span class="s3">((</span><span class="s2">None</span><span class="s3">, </span><span class="s5">1000</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">6</span><span class="s3">)):</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span>
            <span class="s1">min_weight_fraction_leaf</span><span class="s3">=</span><span class="s1">frac</span><span class="s3">, </span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s1">max_leaf_nodes</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span>
        <span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">weights</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">sparse_container </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">tocsr</span><span class="s3">())</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s1">node_weights </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">out</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">=</span><span class="s1">weights</span><span class="s3">)</span>
        <span class="s6"># drop inner nodes</span>
        <span class="s1">leaf_weights </span><span class="s3">= </span><span class="s1">node_weights</span><span class="s3">[</span><span class="s1">node_weights </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">assert </span><span class="s3">(</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">leaf_weights</span><span class="s3">) &gt;= </span><span class="s1">total_weight </span><span class="s3">* </span><span class="s1">est</span><span class="s3">.</span><span class="s1">min_weight_fraction_leaf</span>
        <span class="s3">), </span><span class="s4">&quot;Failed with {0} min_weight_fraction_leaf={1}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
            <span class="s1">name</span><span class="s3">, </span><span class="s1">est</span><span class="s3">.</span><span class="s1">min_weight_fraction_leaf</span>
        <span class="s3">)</span>

    <span class="s6"># test case with no weights passed in</span>
    <span class="s1">total_weight </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s2">for </span><span class="s1">max_leaf_nodes</span><span class="s3">, </span><span class="s1">frac </span><span class="s2">in </span><span class="s1">product</span><span class="s3">((</span><span class="s2">None</span><span class="s3">, </span><span class="s5">1000</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">6</span><span class="s3">)):</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span>
            <span class="s1">min_weight_fraction_leaf</span><span class="s3">=</span><span class="s1">frac</span><span class="s3">, </span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s1">max_leaf_nodes</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span>
        <span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">sparse_container </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">tocsr</span><span class="s3">())</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s1">node_weights </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)</span>
        <span class="s6"># drop inner nodes</span>
        <span class="s1">leaf_weights </span><span class="s3">= </span><span class="s1">node_weights</span><span class="s3">[</span><span class="s1">node_weights </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">assert </span><span class="s3">(</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">leaf_weights</span><span class="s3">) &gt;= </span><span class="s1">total_weight </span><span class="s3">* </span><span class="s1">est</span><span class="s3">.</span><span class="s1">min_weight_fraction_leaf</span>
        <span class="s3">), </span><span class="s4">&quot;Failed with {0} min_weight_fraction_leaf={1}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
            <span class="s1">name</span><span class="s3">, </span><span class="s1">est</span><span class="s3">.</span><span class="s1">min_weight_fraction_leaf</span>
        <span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;name&quot;</span><span class="s3">, </span><span class="s1">ALL_TREES</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_min_weight_fraction_leaf_on_dense_input</span><span class="s3">(</span><span class="s1">name</span><span class="s3">):</span>
    <span class="s1">check_min_weight_fraction_leaf</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s4">&quot;iris&quot;</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;name&quot;</span><span class="s3">, </span><span class="s1">SPARSE_TREES</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;csc_container&quot;</span><span class="s3">, </span><span class="s1">CSC_CONTAINERS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_min_weight_fraction_leaf_on_sparse_input</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">csc_container</span><span class="s3">):</span>
    <span class="s1">check_min_weight_fraction_leaf</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s4">&quot;multilabel&quot;</span><span class="s3">, </span><span class="s1">sparse_container</span><span class="s3">=</span><span class="s1">csc_container</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_min_weight_fraction_leaf_with_min_samples_leaf</span><span class="s3">(</span>
    <span class="s1">name</span><span class="s3">, </span><span class="s1">datasets</span><span class="s3">, </span><span class="s1">sparse_container</span><span class="s3">=</span><span class="s2">None</span>
<span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Test the interaction between min_weight_fraction_leaf and 
    min_samples_leaf when sample_weights is not provided in fit.&quot;&quot;&quot;</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">DATASETS</span><span class="s3">[</span><span class="s1">datasets</span><span class="s3">][</span><span class="s4">&quot;X&quot;</span><span class="s3">].</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">sparse_container </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">sparse_container</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">DATASETS</span><span class="s3">[</span><span class="s1">datasets</span><span class="s3">][</span><span class="s4">&quot;y&quot;</span><span class="s3">]</span>

    <span class="s1">total_weight </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s1">TreeEstimator </span><span class="s3">= </span><span class="s1">ALL_TREES</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>
    <span class="s2">for </span><span class="s1">max_leaf_nodes</span><span class="s3">, </span><span class="s1">frac </span><span class="s2">in </span><span class="s1">product</span><span class="s3">((</span><span class="s2">None</span><span class="s3">, </span><span class="s5">1000</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">3</span><span class="s3">)):</span>
        <span class="s6"># test integer min_samples_leaf</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span>
            <span class="s1">min_weight_fraction_leaf</span><span class="s3">=</span><span class="s1">frac</span><span class="s3">,</span>
            <span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s1">max_leaf_nodes</span><span class="s3">,</span>
            <span class="s1">min_samples_leaf</span><span class="s3">=</span><span class="s5">5</span><span class="s3">,</span>
            <span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">sparse_container </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">tocsr</span><span class="s3">())</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s1">node_weights </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)</span>
        <span class="s6"># drop inner nodes</span>
        <span class="s1">leaf_weights </span><span class="s3">= </span><span class="s1">node_weights</span><span class="s3">[</span><span class="s1">node_weights </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">leaf_weights</span><span class="s3">) &gt;= </span><span class="s1">max</span><span class="s3">(</span>
            <span class="s3">(</span><span class="s1">total_weight </span><span class="s3">* </span><span class="s1">est</span><span class="s3">.</span><span class="s1">min_weight_fraction_leaf</span><span class="s3">), </span><span class="s5">5</span>
        <span class="s3">), </span><span class="s4">&quot;Failed with {0} min_weight_fraction_leaf={1}, min_samples_leaf={2}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
            <span class="s1">name</span><span class="s3">, </span><span class="s1">est</span><span class="s3">.</span><span class="s1">min_weight_fraction_leaf</span><span class="s3">, </span><span class="s1">est</span><span class="s3">.</span><span class="s1">min_samples_leaf</span>
        <span class="s3">)</span>
    <span class="s2">for </span><span class="s1">max_leaf_nodes</span><span class="s3">, </span><span class="s1">frac </span><span class="s2">in </span><span class="s1">product</span><span class="s3">((</span><span class="s2">None</span><span class="s3">, </span><span class="s5">1000</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">3</span><span class="s3">)):</span>
        <span class="s6"># test float min_samples_leaf</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span>
            <span class="s1">min_weight_fraction_leaf</span><span class="s3">=</span><span class="s1">frac</span><span class="s3">,</span>
            <span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s1">max_leaf_nodes</span><span class="s3">,</span>
            <span class="s1">min_samples_leaf</span><span class="s3">=</span><span class="s5">0.1</span><span class="s3">,</span>
            <span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">sparse_container </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">tocsr</span><span class="s3">())</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">out </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s1">node_weights </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">out</span><span class="s3">)</span>
        <span class="s6"># drop inner nodes</span>
        <span class="s1">leaf_weights </span><span class="s3">= </span><span class="s1">node_weights</span><span class="s3">[</span><span class="s1">node_weights </span><span class="s3">!= </span><span class="s5">0</span><span class="s3">]</span>
        <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">leaf_weights</span><span class="s3">) &gt;= </span><span class="s1">max</span><span class="s3">(</span>
            <span class="s3">(</span><span class="s1">total_weight </span><span class="s3">* </span><span class="s1">est</span><span class="s3">.</span><span class="s1">min_weight_fraction_leaf</span><span class="s3">),</span>
            <span class="s3">(</span><span class="s1">total_weight </span><span class="s3">* </span><span class="s1">est</span><span class="s3">.</span><span class="s1">min_samples_leaf</span><span class="s3">),</span>
        <span class="s3">), </span><span class="s4">&quot;Failed with {0} min_weight_fraction_leaf={1}, min_samples_leaf={2}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
            <span class="s1">name</span><span class="s3">, </span><span class="s1">est</span><span class="s3">.</span><span class="s1">min_weight_fraction_leaf</span><span class="s3">, </span><span class="s1">est</span><span class="s3">.</span><span class="s1">min_samples_leaf</span>
        <span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;name&quot;</span><span class="s3">, </span><span class="s1">ALL_TREES</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_min_weight_fraction_leaf_with_min_samples_leaf_on_dense_input</span><span class="s3">(</span><span class="s1">name</span><span class="s3">):</span>
    <span class="s1">check_min_weight_fraction_leaf_with_min_samples_leaf</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s4">&quot;iris&quot;</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;name&quot;</span><span class="s3">, </span><span class="s1">SPARSE_TREES</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;csc_container&quot;</span><span class="s3">, </span><span class="s1">CSC_CONTAINERS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_min_weight_fraction_leaf_with_min_samples_leaf_on_sparse_input</span><span class="s3">(</span>
    <span class="s1">name</span><span class="s3">, </span><span class="s1">csc_container</span>
<span class="s3">):</span>
    <span class="s1">check_min_weight_fraction_leaf_with_min_samples_leaf</span><span class="s3">(</span>
        <span class="s1">name</span><span class="s3">, </span><span class="s4">&quot;multilabel&quot;</span><span class="s3">, </span><span class="s1">sparse_container</span><span class="s3">=</span><span class="s1">csc_container</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_min_impurity_decrease</span><span class="s3">(</span><span class="s1">global_random_seed</span><span class="s3">):</span>
    <span class="s6"># test if min_impurity_decrease ensure that a split is made only if</span>
    <span class="s6"># if the impurity decrease is at least that value</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">make_classification</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">=</span><span class="s5">100</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">global_random_seed</span><span class="s3">)</span>

    <span class="s6"># test both DepthFirstTreeBuilder and BestFirstTreeBuilder</span>
    <span class="s6"># by setting max_leaf_nodes</span>
    <span class="s2">for </span><span class="s1">max_leaf_nodes</span><span class="s3">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">product</span><span class="s3">((</span><span class="s2">None</span><span class="s3">, </span><span class="s5">1000</span><span class="s3">), </span><span class="s1">ALL_TREES</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()):</span>
        <span class="s1">TreeEstimator </span><span class="s3">= </span><span class="s1">ALL_TREES</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>

        <span class="s6"># Check default value of min_impurity_decrease, 1e-7</span>
        <span class="s1">est1 </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s1">max_leaf_nodes</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s6"># Check with explicit value of 0.05</span>
        <span class="s1">est2 </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span>
            <span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s1">max_leaf_nodes</span><span class="s3">, </span><span class="s1">min_impurity_decrease</span><span class="s3">=</span><span class="s5">0.05</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span>
        <span class="s3">)</span>
        <span class="s6"># Check with a much lower value of 0.0001</span>
        <span class="s1">est3 </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span>
            <span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s1">max_leaf_nodes</span><span class="s3">, </span><span class="s1">min_impurity_decrease</span><span class="s3">=</span><span class="s5">0.0001</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span>
        <span class="s3">)</span>
        <span class="s6"># Check with a much lower value of 0.1</span>
        <span class="s1">est4 </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span>
            <span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s1">max_leaf_nodes</span><span class="s3">, </span><span class="s1">min_impurity_decrease</span><span class="s3">=</span><span class="s5">0.1</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span>
        <span class="s3">)</span>

        <span class="s2">for </span><span class="s1">est</span><span class="s3">, </span><span class="s1">expected_decrease </span><span class="s2">in </span><span class="s3">(</span>
            <span class="s3">(</span><span class="s1">est1</span><span class="s3">, </span><span class="s5">1e-7</span><span class="s3">),</span>
            <span class="s3">(</span><span class="s1">est2</span><span class="s3">, </span><span class="s5">0.05</span><span class="s3">),</span>
            <span class="s3">(</span><span class="s1">est3</span><span class="s3">, </span><span class="s5">0.0001</span><span class="s3">),</span>
            <span class="s3">(</span><span class="s1">est4</span><span class="s3">, </span><span class="s5">0.1</span><span class="s3">),</span>
        <span class="s3">):</span>
            <span class="s2">assert </span><span class="s3">(</span>
                <span class="s1">est</span><span class="s3">.</span><span class="s1">min_impurity_decrease </span><span class="s3">&lt;= </span><span class="s1">expected_decrease</span>
            <span class="s3">), </span><span class="s4">&quot;Failed, min_impurity_decrease = {0} &gt; {1}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                <span class="s1">est</span><span class="s3">.</span><span class="s1">min_impurity_decrease</span><span class="s3">, </span><span class="s1">expected_decrease</span>
            <span class="s3">)</span>
            <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">node_count</span><span class="s3">):</span>
                <span class="s6"># If current node is a not leaf node, check if the split was</span>
                <span class="s6"># justified w.r.t the min_impurity_decrease</span>
                <span class="s2">if </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">children_left</span><span class="s3">[</span><span class="s1">node</span><span class="s3">] != </span><span class="s1">TREE_LEAF</span><span class="s3">:</span>
                    <span class="s1">imp_parent </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">impurity</span><span class="s3">[</span><span class="s1">node</span><span class="s3">]</span>
                    <span class="s1">wtd_n_node </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span><span class="s3">[</span><span class="s1">node</span><span class="s3">]</span>

                    <span class="s1">left </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">children_left</span><span class="s3">[</span><span class="s1">node</span><span class="s3">]</span>
                    <span class="s1">wtd_n_left </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span><span class="s3">[</span><span class="s1">left</span><span class="s3">]</span>
                    <span class="s1">imp_left </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">impurity</span><span class="s3">[</span><span class="s1">left</span><span class="s3">]</span>
                    <span class="s1">wtd_imp_left </span><span class="s3">= </span><span class="s1">wtd_n_left </span><span class="s3">* </span><span class="s1">imp_left</span>

                    <span class="s1">right </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">children_right</span><span class="s3">[</span><span class="s1">node</span><span class="s3">]</span>
                    <span class="s1">wtd_n_right </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span><span class="s3">[</span><span class="s1">right</span><span class="s3">]</span>
                    <span class="s1">imp_right </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">impurity</span><span class="s3">[</span><span class="s1">right</span><span class="s3">]</span>
                    <span class="s1">wtd_imp_right </span><span class="s3">= </span><span class="s1">wtd_n_right </span><span class="s3">* </span><span class="s1">imp_right</span>

                    <span class="s1">wtd_avg_left_right_imp </span><span class="s3">= </span><span class="s1">wtd_imp_right </span><span class="s3">+ </span><span class="s1">wtd_imp_left</span>
                    <span class="s1">wtd_avg_left_right_imp </span><span class="s3">/= </span><span class="s1">wtd_n_node</span>

                    <span class="s1">fractional_node_weight </span><span class="s3">= (</span>
                        <span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span><span class="s3">[</span><span class="s1">node</span><span class="s3">] / </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>
                    <span class="s3">)</span>

                    <span class="s1">actual_decrease </span><span class="s3">= </span><span class="s1">fractional_node_weight </span><span class="s3">* (</span>
                        <span class="s1">imp_parent </span><span class="s3">- </span><span class="s1">wtd_avg_left_right_imp</span>
                    <span class="s3">)</span>

                    <span class="s2">assert </span><span class="s3">(</span>
                        <span class="s1">actual_decrease </span><span class="s3">&gt;= </span><span class="s1">expected_decrease</span>
                    <span class="s3">), </span><span class="s4">&quot;Failed with {0} expected min_impurity_decrease={1}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                        <span class="s1">actual_decrease</span><span class="s3">, </span><span class="s1">expected_decrease</span>
                    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_pickle</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Test pickling preserves Tree properties and performance.&quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">TreeEstimator </span><span class="s2">in </span><span class="s1">ALL_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s2">if </span><span class="s4">&quot;Classifier&quot; </span><span class="s2">in </span><span class="s1">name</span><span class="s3">:</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">target</span>

        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">score </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">score</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s6"># test that all class properties are maintained</span>
        <span class="s1">attributes </span><span class="s3">= [</span>
            <span class="s4">&quot;max_depth&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;node_count&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;capacity&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;n_classes&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;children_left&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;children_right&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;n_leaves&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;feature&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;threshold&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;impurity&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;n_node_samples&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;weighted_n_node_samples&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;value&quot;</span><span class="s3">,</span>
        <span class="s3">]</span>
        <span class="s1">fitted_attribute </span><span class="s3">= {</span>
            <span class="s1">attribute</span><span class="s3">: </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">, </span><span class="s1">attribute</span><span class="s3">) </span><span class="s2">for </span><span class="s1">attribute </span><span class="s2">in </span><span class="s1">attributes</span>
        <span class="s3">}</span>

        <span class="s1">serialized_object </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">dumps</span><span class="s3">(</span><span class="s1">est</span><span class="s3">)</span>
        <span class="s1">est2 </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">loads</span><span class="s3">(</span><span class="s1">serialized_object</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">type</span><span class="s3">(</span><span class="s1">est2</span><span class="s3">) == </span><span class="s1">est</span><span class="s3">.</span><span class="s1">__class__</span>

        <span class="s1">score2 </span><span class="s3">= </span><span class="s1">est2</span><span class="s3">.</span><span class="s1">score</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s3">(</span>
            <span class="s1">score </span><span class="s3">== </span><span class="s1">score2</span>
        <span class="s3">), </span><span class="s4">&quot;Failed to generate same score  after pickling with {0}&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">attribute </span><span class="s2">in </span><span class="s1">fitted_attribute</span><span class="s3">:</span>
            <span class="s1">assert_array_equal</span><span class="s3">(</span>
                <span class="s1">getattr</span><span class="s3">(</span><span class="s1">est2</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">, </span><span class="s1">attribute</span><span class="s3">),</span>
                <span class="s1">fitted_attribute</span><span class="s3">[</span><span class="s1">attribute</span><span class="s3">],</span>
                <span class="s1">err_msg</span><span class="s3">=(</span>
                    <span class="s4">f&quot;Failed to generate same attribute </span><span class="s2">{</span><span class="s1">attribute</span><span class="s2">} </span><span class="s4">after pickling with&quot;</span>
                    <span class="s4">f&quot; </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s4">&quot;</span>
                <span class="s3">),</span>
            <span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_multioutput</span><span class="s3">():</span>
    <span class="s6"># Check estimators on multi-output problems.</span>
    <span class="s1">X </span><span class="s3">= [</span>
        <span class="s3">[-</span><span class="s5">2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[-</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">2</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">],</span>
    <span class="s3">]</span>

    <span class="s1">y </span><span class="s3">= [</span>
        <span class="s3">[-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">],</span>
        <span class="s3">[-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">],</span>
        <span class="s3">[-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">],</span>
        <span class="s3">[-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">],</span>
        <span class="s3">[-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">],</span>
        <span class="s3">[-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s3">],</span>
    <span class="s3">]</span>

    <span class="s1">T </span><span class="s3">= [[-</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">], [-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">]]</span>
    <span class="s1">y_true </span><span class="s3">= [[-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">], [-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s3">]]</span>

    <span class="s6"># toy classification problem</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">TreeClassifier </span><span class="s2">in </span><span class="s1">CLF_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">clf </span><span class="s3">= </span><span class="s1">TreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">y_hat </span><span class="s3">= </span><span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">).</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">T</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">y_hat</span><span class="s3">, </span><span class="s1">y_true</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">y_hat</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s5">4</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>

        <span class="s1">proba </span><span class="s3">= </span><span class="s1">clf</span><span class="s3">.</span><span class="s1">predict_proba</span><span class="s3">(</span><span class="s1">T</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">proba</span><span class="s3">) == </span><span class="s5">2</span>
        <span class="s2">assert </span><span class="s1">proba</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">shape </span><span class="s3">== (</span><span class="s5">4</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">proba</span><span class="s3">[</span><span class="s5">1</span><span class="s3">].</span><span class="s1">shape </span><span class="s3">== (</span><span class="s5">4</span><span class="s3">, </span><span class="s5">4</span><span class="s3">)</span>

        <span class="s1">log_proba </span><span class="s3">= </span><span class="s1">clf</span><span class="s3">.</span><span class="s1">predict_log_proba</span><span class="s3">(</span><span class="s1">T</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">log_proba</span><span class="s3">) == </span><span class="s5">2</span>
        <span class="s2">assert </span><span class="s1">log_proba</span><span class="s3">[</span><span class="s5">0</span><span class="s3">].</span><span class="s1">shape </span><span class="s3">== (</span><span class="s5">4</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">log_proba</span><span class="s3">[</span><span class="s5">1</span><span class="s3">].</span><span class="s1">shape </span><span class="s3">== (</span><span class="s5">4</span><span class="s3">, </span><span class="s5">4</span><span class="s3">)</span>

    <span class="s6"># toy regression problem</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">TreeRegressor </span><span class="s2">in </span><span class="s1">REG_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">reg </span><span class="s3">= </span><span class="s1">TreeRegressor</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">y_hat </span><span class="s3">= </span><span class="s1">reg</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">).</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">T</span><span class="s3">)</span>
        <span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">y_hat</span><span class="s3">, </span><span class="s1">y_true</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">y_hat</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s5">4</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_classes_shape</span><span class="s3">():</span>
    <span class="s6"># Test that n_classes_ and classes_ have proper shape.</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">TreeClassifier </span><span class="s2">in </span><span class="s1">CLF_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s6"># Classification, single output</span>
        <span class="s1">clf </span><span class="s3">= </span><span class="s1">TreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s2">assert </span><span class="s1">clf</span><span class="s3">.</span><span class="s1">n_classes_ </span><span class="s3">== </span><span class="s5">2</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">classes_</span><span class="s3">, [-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">])</span>

        <span class="s6"># Classification, multi-output</span>
        <span class="s1">_y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">((</span><span class="s1">y</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">y</span><span class="s3">) * </span><span class="s5">2</span><span class="s3">)).</span><span class="s1">T</span>
        <span class="s1">clf </span><span class="s3">= </span><span class="s1">TreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">_y</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">n_classes_</span><span class="s3">) == </span><span class="s5">2</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">classes_</span><span class="s3">) == </span><span class="s5">2</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">n_classes_</span><span class="s3">, [</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">])</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">classes_</span><span class="s3">, [[-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">], [-</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">]])</span>


<span class="s2">def </span><span class="s1">test_unbalanced_iris</span><span class="s3">():</span>
    <span class="s6"># Check class rebalancing.</span>
    <span class="s1">unbalanced_X </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[:</span><span class="s5">125</span><span class="s3">]</span>
    <span class="s1">unbalanced_y </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">[:</span><span class="s5">125</span><span class="s3">]</span>
    <span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">compute_sample_weight</span><span class="s3">(</span><span class="s4">&quot;balanced&quot;</span><span class="s3">, </span><span class="s1">unbalanced_y</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">TreeClassifier </span><span class="s2">in </span><span class="s1">CLF_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">clf </span><span class="s3">= </span><span class="s1">TreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">unbalanced_X</span><span class="s3">, </span><span class="s1">unbalanced_y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">sample_weight</span><span class="s3">)</span>
        <span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">unbalanced_X</span><span class="s3">), </span><span class="s1">unbalanced_y</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_memory_layout</span><span class="s3">():</span>
    <span class="s6"># Check that it works no matter the memory layout</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">TreeEstimator</span><span class="s3">), </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">product</span><span class="s3">(</span>
        <span class="s1">ALL_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">(), [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">]</span>
    <span class="s3">):</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

        <span class="s6"># Nothing</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">).</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s6"># C-order</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s4">&quot;C&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">).</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s6"># F-order</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s4">&quot;F&quot;</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">).</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s6"># Contiguous</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ascontiguousarray</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">).</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s6"># csr</span>
        <span class="s2">for </span><span class="s1">csr_container </span><span class="s2">in </span><span class="s1">CSR_CONTAINERS</span><span class="s3">:</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">csr_container</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span>
            <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">).</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s6"># csc</span>
        <span class="s2">for </span><span class="s1">csc_container </span><span class="s2">in </span><span class="s1">CSC_CONTAINERS</span><span class="s3">:</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">csc_container</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span>
            <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">).</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s6"># Strided</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[::</span><span class="s5">3</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">[::</span><span class="s5">3</span><span class="s3">]</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">).</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">y</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_sample_weight</span><span class="s3">():</span>
    <span class="s6"># Check sample weighting.</span>
    <span class="s6"># Test that zero-weighted samples are not taken into account</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">100</span><span class="s3">)[:, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">newaxis</span><span class="s3">]</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">100</span><span class="s3">)</span>
    <span class="s1">y</span><span class="s3">[:</span><span class="s5">50</span><span class="s3">] = </span><span class="s5">0.0</span>

    <span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">100</span><span class="s3">)</span>
    <span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">y </span><span class="s3">== </span><span class="s5">0</span><span class="s3">] = </span><span class="s5">0.0</span>

    <span class="s1">clf </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">sample_weight</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">100</span><span class="s3">))</span>

    <span class="s6"># Test that low weighted samples are not taken into account at low depth</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">200</span><span class="s3">)[:, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">newaxis</span><span class="s3">]</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s5">200</span><span class="s3">)</span>
    <span class="s1">y</span><span class="s3">[</span><span class="s5">50</span><span class="s3">:</span><span class="s5">100</span><span class="s3">] = </span><span class="s5">1</span>
    <span class="s1">y</span><span class="s3">[</span><span class="s5">100</span><span class="s3">:</span><span class="s5">200</span><span class="s3">] = </span><span class="s5">2</span>
    <span class="s1">X</span><span class="s3">[</span><span class="s5">100</span><span class="s3">:</span><span class="s5">200</span><span class="s3">, </span><span class="s5">0</span><span class="s3">] = </span><span class="s5">200</span>

    <span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">200</span><span class="s3">)</span>

    <span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">y </span><span class="s3">== </span><span class="s5">2</span><span class="s3">] = </span><span class="s5">0.51  </span><span class="s6"># Samples of class '2' are still weightier</span>
    <span class="s1">clf </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">sample_weight</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">clf</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">threshold</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s5">149.5</span>

    <span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">y </span><span class="s3">== </span><span class="s5">2</span><span class="s3">] = </span><span class="s5">0.5  </span><span class="s6"># Samples of class '2' are no longer weightier</span>
    <span class="s1">clf </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">sample_weight</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">clf</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">threshold</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] == </span><span class="s5">49.5  </span><span class="s6"># Threshold should have moved</span>

    <span class="s6"># Test that sample weighting is the same as having duplicates</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span>

    <span class="s1">duplicates </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s5">100</span><span class="s3">)</span>

    <span class="s1">clf </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">[</span><span class="s1">duplicates</span><span class="s3">], </span><span class="s1">y</span><span class="s3">[</span><span class="s1">duplicates</span><span class="s3">])</span>

    <span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">duplicates</span><span class="s3">, </span><span class="s1">minlength</span><span class="s3">=</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
    <span class="s1">clf2 </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">clf2</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">sample_weight</span><span class="s3">)</span>

    <span class="s1">internal </span><span class="s3">= </span><span class="s1">clf</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">children_left </span><span class="s3">!= </span><span class="s1">tree</span><span class="s3">.</span><span class="s1">_tree</span><span class="s3">.</span><span class="s1">TREE_LEAF</span>
    <span class="s1">assert_array_almost_equal</span><span class="s3">(</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">threshold</span><span class="s3">[</span><span class="s1">internal</span><span class="s3">], </span><span class="s1">clf2</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">threshold</span><span class="s3">[</span><span class="s1">internal</span><span class="s3">]</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_sample_weight_invalid</span><span class="s3">():</span>
    <span class="s6"># Check sample weighting raises errors.</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">100</span><span class="s3">)[:, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">newaxis</span><span class="s3">]</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">100</span><span class="s3">)</span>
    <span class="s1">y</span><span class="s3">[:</span><span class="s5">50</span><span class="s3">] = </span><span class="s5">0.0</span>

    <span class="s1">clf </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">rand</span><span class="s3">(</span><span class="s5">100</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">sample_weight</span><span class="s3">)</span>

    <span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">expected_err </span><span class="s3">= </span><span class="s4">r&quot;Singleton.* cannot be considered a valid collection&quot;</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">expected_err</span><span class="s3">):</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">sample_weight</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;name&quot;</span><span class="s3">, </span><span class="s1">CLF_TREES</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_class_weights</span><span class="s3">(</span><span class="s1">name</span><span class="s3">):</span>
    <span class="s6"># Test that class_weights resemble sample_weights behavior.</span>
    <span class="s1">TreeClassifier </span><span class="s3">= </span><span class="s1">CLF_TREES</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>

    <span class="s6"># Iris is balanced, so no effect expected for using 'balanced' weights</span>
    <span class="s1">clf1 </span><span class="s3">= </span><span class="s1">TreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">clf1</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
    <span class="s1">clf2 </span><span class="s3">= </span><span class="s1">TreeClassifier</span><span class="s3">(</span><span class="s1">class_weight</span><span class="s3">=</span><span class="s4">&quot;balanced&quot;</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">clf2</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
    <span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">clf1</span><span class="s3">.</span><span class="s1">feature_importances_</span><span class="s3">, </span><span class="s1">clf2</span><span class="s3">.</span><span class="s1">feature_importances_</span><span class="s3">)</span>

    <span class="s6"># Make a multi-output problem with three copies of Iris</span>
    <span class="s1">iris_multi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">((</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)).</span><span class="s1">T</span>
    <span class="s6"># Create user-defined weights that should balance over the outputs</span>
    <span class="s1">clf3 </span><span class="s3">= </span><span class="s1">TreeClassifier</span><span class="s3">(</span>
        <span class="s1">class_weight</span><span class="s3">=[</span>
            <span class="s3">{</span><span class="s5">0</span><span class="s3">: </span><span class="s5">2.0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">: </span><span class="s5">2.0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">: </span><span class="s5">1.0</span><span class="s3">},</span>
            <span class="s3">{</span><span class="s5">0</span><span class="s3">: </span><span class="s5">2.0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">: </span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">: </span><span class="s5">2.0</span><span class="s3">},</span>
            <span class="s3">{</span><span class="s5">0</span><span class="s3">: </span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">: </span><span class="s5">2.0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">: </span><span class="s5">2.0</span><span class="s3">},</span>
        <span class="s3">],</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">clf3</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris_multi</span><span class="s3">)</span>
    <span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">clf2</span><span class="s3">.</span><span class="s1">feature_importances_</span><span class="s3">, </span><span class="s1">clf3</span><span class="s3">.</span><span class="s1">feature_importances_</span><span class="s3">)</span>
    <span class="s6"># Check against multi-output &quot;auto&quot; which should also have no effect</span>
    <span class="s1">clf4 </span><span class="s3">= </span><span class="s1">TreeClassifier</span><span class="s3">(</span><span class="s1">class_weight</span><span class="s3">=</span><span class="s4">&quot;balanced&quot;</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">clf4</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris_multi</span><span class="s3">)</span>
    <span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">clf3</span><span class="s3">.</span><span class="s1">feature_importances_</span><span class="s3">, </span><span class="s1">clf4</span><span class="s3">.</span><span class="s1">feature_importances_</span><span class="s3">)</span>

    <span class="s6"># Inflate importance of class 1, check against user-defined weights</span>
    <span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s1">sample_weight</span><span class="s3">[</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target </span><span class="s3">== </span><span class="s5">1</span><span class="s3">] *= </span><span class="s5">100</span>
    <span class="s1">class_weight </span><span class="s3">= {</span><span class="s5">0</span><span class="s3">: </span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">: </span><span class="s5">100.0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">: </span><span class="s5">1.0</span><span class="s3">}</span>
    <span class="s1">clf1 </span><span class="s3">= </span><span class="s1">TreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">clf1</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">)</span>
    <span class="s1">clf2 </span><span class="s3">= </span><span class="s1">TreeClassifier</span><span class="s3">(</span><span class="s1">class_weight</span><span class="s3">=</span><span class="s1">class_weight</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">clf2</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
    <span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">clf1</span><span class="s3">.</span><span class="s1">feature_importances_</span><span class="s3">, </span><span class="s1">clf2</span><span class="s3">.</span><span class="s1">feature_importances_</span><span class="s3">)</span>

    <span class="s6"># Check that sample_weight and class_weight are multiplicative</span>
    <span class="s1">clf1 </span><span class="s3">= </span><span class="s1">TreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">clf1</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">**</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">clf2 </span><span class="s3">= </span><span class="s1">TreeClassifier</span><span class="s3">(</span><span class="s1">class_weight</span><span class="s3">=</span><span class="s1">class_weight</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">clf2</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">)</span>
    <span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">clf1</span><span class="s3">.</span><span class="s1">feature_importances_</span><span class="s3">, </span><span class="s1">clf2</span><span class="s3">.</span><span class="s1">feature_importances_</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;name&quot;</span><span class="s3">, </span><span class="s1">CLF_TREES</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_class_weight_errors</span><span class="s3">(</span><span class="s1">name</span><span class="s3">):</span>
    <span class="s6"># Test if class_weight raises errors and warnings when expected.</span>
    <span class="s1">TreeClassifier </span><span class="s3">= </span><span class="s1">CLF_TREES</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>
    <span class="s1">_y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">((</span><span class="s1">y</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">y</span><span class="s3">) * </span><span class="s5">2</span><span class="s3">)).</span><span class="s1">T</span>

    <span class="s6"># Incorrect length list for multi-output</span>
    <span class="s1">clf </span><span class="s3">= </span><span class="s1">TreeClassifier</span><span class="s3">(</span><span class="s1">class_weight</span><span class="s3">=[{-</span><span class="s5">1</span><span class="s3">: </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">: </span><span class="s5">1.0</span><span class="s3">}], </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">err_msg </span><span class="s3">= </span><span class="s4">&quot;number of elements in class_weight should match number of outputs.&quot;</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">err_msg</span><span class="s3">):</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">_y</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_max_leaf_nodes</span><span class="s3">():</span>
    <span class="s6"># Test greedy trees with max_depth + 1 leafs.</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">make_hastie_10_2</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">=</span><span class="s5">100</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s5">4</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">TreeEstimator </span><span class="s2">in </span><span class="s1">ALL_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">max_depth</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s1">k </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">get_n_leaves</span><span class="s3">() == </span><span class="s1">k </span><span class="s3">+ </span><span class="s5">1</span>


<span class="s2">def </span><span class="s1">test_max_leaf_nodes_max_depth</span><span class="s3">():</span>
    <span class="s6"># Test precedence of max_leaf_nodes over max_depth.</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">make_hastie_10_2</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">=</span><span class="s5">100</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s5">4</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">TreeEstimator </span><span class="s2">in </span><span class="s1">ALL_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s1">k</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">get_depth</span><span class="s3">() == </span><span class="s5">1</span>


<span class="s2">def </span><span class="s1">test_arrays_persist</span><span class="s3">():</span>
    <span class="s6"># Ensure property arrays' memory stays alive when tree disappears</span>
    <span class="s6"># non-regression for #2726</span>
    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s3">[</span>
        <span class="s4">&quot;n_classes&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;value&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;children_left&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;children_right&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;threshold&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;impurity&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;feature&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;n_node_samples&quot;</span><span class="s3">,</span>
    <span class="s3">]:</span>
        <span class="s1">value </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">DecisionTreeClassifier</span><span class="s3">().</span><span class="s1">fit</span><span class="s3">([[</span><span class="s5">0</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">]], [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]).</span><span class="s1">tree_</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">)</span>
        <span class="s6"># if pointing to freed memory, contents may be arbitrary</span>
        <span class="s2">assert </span><span class="s3">-</span><span class="s5">3 </span><span class="s3">&lt;= </span><span class="s1">value</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] &lt; </span><span class="s5">3</span><span class="s3">, </span><span class="s4">&quot;Array points to arbitrary memory&quot;</span>


<span class="s2">def </span><span class="s1">test_only_constant_features</span><span class="s3">():</span>
    <span class="s1">random_state </span><span class="s3">= </span><span class="s1">check_random_state</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s5">10</span><span class="s3">, </span><span class="s5">20</span><span class="s3">))</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, (</span><span class="s5">10</span><span class="s3">,))</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">TreeEstimator </span><span class="s2">in </span><span class="s1">ALL_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">max_depth </span><span class="s3">== </span><span class="s5">0</span>


<span class="s2">def </span><span class="s1">test_behaviour_constant_feature_after_splits</span><span class="s3">():</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">(</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">vstack</span><span class="s3">(([[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">7</span><span class="s3">]], </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">11</span><span class="s3">))))</span>
    <span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">]</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">TreeEstimator </span><span class="s2">in </span><span class="s1">ALL_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s6"># do not check extra random trees</span>
        <span class="s2">if </span><span class="s4">&quot;ExtraTree&quot; </span><span class="s2">not in </span><span class="s1">name</span><span class="s3">:</span>
            <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
            <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
            <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">max_depth </span><span class="s3">== </span><span class="s5">2</span>
            <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">node_count </span><span class="s3">== </span><span class="s5">5</span>


<span class="s2">def </span><span class="s1">test_with_only_one_non_constant_features</span><span class="s3">():</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">([</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s5">1.0</span><span class="s3">], [</span><span class="s5">1.0</span><span class="s3">], [</span><span class="s5">0.0</span><span class="s3">], [</span><span class="s5">0.0</span><span class="s3">]]), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">1000</span><span class="s3">))])</span>

    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">])</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">TreeEstimator </span><span class="s2">in </span><span class="s1">CLF_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">max_depth </span><span class="s3">== </span><span class="s5">1</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">est</span><span class="s3">.</span><span class="s1">predict_proba</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">((</span><span class="s5">4</span><span class="s3">, </span><span class="s5">2</span><span class="s3">), </span><span class="s5">0.5</span><span class="s3">))</span>

    <span class="s2">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">TreeEstimator </span><span class="s2">in </span><span class="s1">REG_TREES</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">max_depth </span><span class="s3">== </span><span class="s5">1</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">est</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">((</span><span class="s5">4</span><span class="s3">,), </span><span class="s5">0.5</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_big_input</span><span class="s3">():</span>
    <span class="s6"># Test if the warning for too large inputs is appropriate.</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">repeat</span><span class="s3">(</span><span class="s5">10</span><span class="s3">**</span><span class="s5">40.0</span><span class="s3">, </span><span class="s5">4</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">clf </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">()</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;float32&quot;</span><span class="s3">):</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">])</span>


<span class="s2">def </span><span class="s1">test_realloc</span><span class="s3">():</span>
    <span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">_utils </span><span class="s2">import </span><span class="s1">_realloc_test</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">MemoryError</span><span class="s3">):</span>
        <span class="s1">_realloc_test</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">test_huge_allocations</span><span class="s3">():</span>
    <span class="s1">n_bits </span><span class="s3">= </span><span class="s5">8 </span><span class="s3">* </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">calcsize</span><span class="s3">(</span><span class="s4">&quot;P&quot;</span><span class="s3">)</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randn</span><span class="s3">(</span><span class="s5">10</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">10</span><span class="s3">)</span>

    <span class="s6"># Sanity check: we cannot request more memory than the size of the address</span>
    <span class="s6"># space. Currently raises OverflowError.</span>
    <span class="s1">huge </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">** (</span><span class="s1">n_bits </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">clf </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">splitter</span><span class="s3">=</span><span class="s4">&quot;best&quot;</span><span class="s3">, </span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s1">huge</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">Exception</span><span class="s3">):</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s6"># Non-regression test: MemoryError used to be dropped by Cython</span>
    <span class="s6"># because of missing &quot;except *&quot;.</span>
    <span class="s1">huge </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">** (</span><span class="s1">n_bits </span><span class="s3">- </span><span class="s5">1</span><span class="s3">) - </span><span class="s5">1</span>
    <span class="s1">clf </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">splitter</span><span class="s3">=</span><span class="s4">&quot;best&quot;</span><span class="s3">, </span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s1">huge</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">MemoryError</span><span class="s3">):</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_sparse_input</span><span class="s3">(</span><span class="s1">tree</span><span class="s3">, </span><span class="s1">dataset</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">TreeEstimator </span><span class="s3">= </span><span class="s1">ALL_TREES</span><span class="s3">[</span><span class="s1">tree</span><span class="s3">]</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">DATASETS</span><span class="s3">[</span><span class="s1">dataset</span><span class="s3">][</span><span class="s4">&quot;X&quot;</span><span class="s3">]</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">DATASETS</span><span class="s3">[</span><span class="s1">dataset</span><span class="s3">][</span><span class="s4">&quot;y&quot;</span><span class="s3">]</span>

    <span class="s6"># Gain testing time</span>
    <span class="s2">if </span><span class="s1">dataset </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;digits&quot;</span><span class="s3">, </span><span class="s4">&quot;diabetes&quot;</span><span class="s3">]:</span>
        <span class="s1">n_samples </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] // </span><span class="s5">5</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[:</span><span class="s1">n_samples</span><span class="s3">]</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">y</span><span class="s3">[:</span><span class="s1">n_samples</span><span class="s3">]</span>

    <span class="s2">for </span><span class="s1">sparse_container </span><span class="s2">in </span><span class="s1">COO_CONTAINERS </span><span class="s3">+ </span><span class="s1">CSC_CONTAINERS </span><span class="s3">+ </span><span class="s1">CSR_CONTAINERS</span><span class="s3">:</span>
        <span class="s1">X_sparse </span><span class="s3">= </span><span class="s1">sparse_container</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s6"># Check the default (depth first search)</span>
        <span class="s1">d </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s1">max_depth</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">s </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s1">max_depth</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_sparse</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

        <span class="s1">assert_tree_equal</span><span class="s3">(</span>
            <span class="s1">d</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
            <span class="s1">s</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
            <span class="s4">&quot;{0} with dense and sparse format gave different trees&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">tree</span><span class="s3">),</span>
        <span class="s3">)</span>

        <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">d</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">tree </span><span class="s2">in </span><span class="s1">CLF_TREES</span><span class="s3">:</span>
            <span class="s1">y_proba </span><span class="s3">= </span><span class="s1">d</span><span class="s3">.</span><span class="s1">predict_proba</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
            <span class="s1">y_log_proba </span><span class="s3">= </span><span class="s1">d</span><span class="s3">.</span><span class="s1">predict_log_proba</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">sparse_container_test </span><span class="s2">in </span><span class="s1">COO_CONTAINERS </span><span class="s3">+ </span><span class="s1">CSR_CONTAINERS </span><span class="s3">+ </span><span class="s1">CSC_CONTAINERS</span><span class="s3">:</span>
            <span class="s1">X_sparse_test </span><span class="s3">= </span><span class="s1">sparse_container_test</span><span class="s3">(</span><span class="s1">X_sparse</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">)</span>

            <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">s</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_sparse_test</span><span class="s3">), </span><span class="s1">y_pred</span><span class="s3">)</span>

            <span class="s2">if </span><span class="s1">tree </span><span class="s2">in </span><span class="s1">CLF_TREES</span><span class="s3">:</span>
                <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">s</span><span class="s3">.</span><span class="s1">predict_proba</span><span class="s3">(</span><span class="s1">X_sparse_test</span><span class="s3">), </span><span class="s1">y_proba</span><span class="s3">)</span>
                <span class="s1">assert_array_almost_equal</span><span class="s3">(</span>
                    <span class="s1">s</span><span class="s3">.</span><span class="s1">predict_log_proba</span><span class="s3">(</span><span class="s1">X_sparse_test</span><span class="s3">), </span><span class="s1">y_log_proba</span>
                <span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;tree_type&quot;</span><span class="s3">, </span><span class="s1">SPARSE_TREES</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s4">&quot;dataset&quot;</span><span class="s3">,</span>
    <span class="s3">(</span>
        <span class="s4">&quot;clf_small&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;toy&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;digits&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;multilabel&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;sparse-pos&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;sparse-neg&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;sparse-mix&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;zeros&quot;</span><span class="s3">,</span>
    <span class="s3">),</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_sparse_input</span><span class="s3">(</span><span class="s1">tree_type</span><span class="s3">, </span><span class="s1">dataset</span><span class="s3">):</span>
    <span class="s1">max_depth </span><span class="s3">= </span><span class="s5">3 </span><span class="s2">if </span><span class="s1">dataset </span><span class="s3">== </span><span class="s4">&quot;digits&quot; </span><span class="s2">else None</span>
    <span class="s1">check_sparse_input</span><span class="s3">(</span><span class="s1">tree_type</span><span class="s3">, </span><span class="s1">dataset</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;tree_type&quot;</span><span class="s3">, </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">SPARSE_TREES</span><span class="s3">).</span><span class="s1">intersection</span><span class="s3">(</span><span class="s1">REG_TREES</span><span class="s3">)))</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;dataset&quot;</span><span class="s3">, [</span><span class="s4">&quot;diabetes&quot;</span><span class="s3">, </span><span class="s4">&quot;reg_small&quot;</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_sparse_input_reg_trees</span><span class="s3">(</span><span class="s1">tree_type</span><span class="s3">, </span><span class="s1">dataset</span><span class="s3">):</span>
    <span class="s6"># Due to numerical instability of MSE and too strict test, we limit the</span>
    <span class="s6"># maximal depth</span>
    <span class="s1">check_sparse_input</span><span class="s3">(</span><span class="s1">tree_type</span><span class="s3">, </span><span class="s1">dataset</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;tree_type&quot;</span><span class="s3">, </span><span class="s1">SPARSE_TREES</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;dataset&quot;</span><span class="s3">, [</span><span class="s4">&quot;sparse-pos&quot;</span><span class="s3">, </span><span class="s4">&quot;sparse-neg&quot;</span><span class="s3">, </span><span class="s4">&quot;sparse-mix&quot;</span><span class="s3">, </span><span class="s4">&quot;zeros&quot;</span><span class="s3">])</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;csc_container&quot;</span><span class="s3">, </span><span class="s1">CSC_CONTAINERS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_sparse_parameters</span><span class="s3">(</span><span class="s1">tree_type</span><span class="s3">, </span><span class="s1">dataset</span><span class="s3">, </span><span class="s1">csc_container</span><span class="s3">):</span>
    <span class="s1">TreeEstimator </span><span class="s3">= </span><span class="s1">ALL_TREES</span><span class="s3">[</span><span class="s1">tree_type</span><span class="s3">]</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">DATASETS</span><span class="s3">[</span><span class="s1">dataset</span><span class="s3">][</span><span class="s4">&quot;X&quot;</span><span class="s3">]</span>
    <span class="s1">X_sparse </span><span class="s3">= </span><span class="s1">csc_container</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">DATASETS</span><span class="s3">[</span><span class="s1">dataset</span><span class="s3">][</span><span class="s4">&quot;y&quot;</span><span class="s3">]</span>

    <span class="s6"># Check max_features</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">2</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">2</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_sparse</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">assert_tree_equal</span><span class="s3">(</span>
        <span class="s1">d</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
        <span class="s1">s</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
        <span class="s4">&quot;{0} with dense and sparse format gave different trees&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">tree_type</span><span class="s3">),</span>
    <span class="s3">)</span>
    <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">s</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">d</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">))</span>

    <span class="s6"># Check min_samples_split</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">min_samples_split</span><span class="s3">=</span><span class="s5">10</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_features</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">min_samples_split</span><span class="s3">=</span><span class="s5">10</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span>
        <span class="s1">X_sparse</span><span class="s3">, </span><span class="s1">y</span>
    <span class="s3">)</span>
    <span class="s1">assert_tree_equal</span><span class="s3">(</span>
        <span class="s1">d</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
        <span class="s1">s</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
        <span class="s4">&quot;{0} with dense and sparse format gave different trees&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">tree_type</span><span class="s3">),</span>
    <span class="s3">)</span>
    <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">s</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">d</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">))</span>

    <span class="s6"># Check min_samples_leaf</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">min_samples_leaf</span><span class="s3">=</span><span class="s1">X_sparse</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] // </span><span class="s5">2</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">min_samples_leaf</span><span class="s3">=</span><span class="s1">X_sparse</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] // </span><span class="s5">2</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span>
        <span class="s1">X_sparse</span><span class="s3">, </span><span class="s1">y</span>
    <span class="s3">)</span>
    <span class="s1">assert_tree_equal</span><span class="s3">(</span>
        <span class="s1">d</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
        <span class="s1">s</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
        <span class="s4">&quot;{0} with dense and sparse format gave different trees&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">tree_type</span><span class="s3">),</span>
    <span class="s3">)</span>
    <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">s</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">d</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">))</span>

    <span class="s6"># Check best-first search</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s5">3</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s5">3</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_sparse</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">assert_tree_equal</span><span class="s3">(</span>
        <span class="s1">d</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
        <span class="s1">s</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
        <span class="s4">&quot;{0} with dense and sparse format gave different trees&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">tree_type</span><span class="s3">),</span>
    <span class="s3">)</span>
    <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">s</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">d</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s4">&quot;tree_type, criterion&quot;</span><span class="s3">,</span>
    <span class="s1">list</span><span class="s3">(</span><span class="s1">product</span><span class="s3">([</span><span class="s1">tree </span><span class="s2">for </span><span class="s1">tree </span><span class="s2">in </span><span class="s1">SPARSE_TREES </span><span class="s2">if </span><span class="s1">tree </span><span class="s2">in </span><span class="s1">REG_TREES</span><span class="s3">], </span><span class="s1">REG_CRITERIONS</span><span class="s3">))</span>
    <span class="s3">+ </span><span class="s1">list</span><span class="s3">(</span>
        <span class="s1">product</span><span class="s3">([</span><span class="s1">tree </span><span class="s2">for </span><span class="s1">tree </span><span class="s2">in </span><span class="s1">SPARSE_TREES </span><span class="s2">if </span><span class="s1">tree </span><span class="s2">in </span><span class="s1">CLF_TREES</span><span class="s3">], </span><span class="s1">CLF_CRITERIONS</span><span class="s3">)</span>
    <span class="s3">),</span>
<span class="s3">)</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;dataset&quot;</span><span class="s3">, [</span><span class="s4">&quot;sparse-pos&quot;</span><span class="s3">, </span><span class="s4">&quot;sparse-neg&quot;</span><span class="s3">, </span><span class="s4">&quot;sparse-mix&quot;</span><span class="s3">, </span><span class="s4">&quot;zeros&quot;</span><span class="s3">])</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;csc_container&quot;</span><span class="s3">, </span><span class="s1">CSC_CONTAINERS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_sparse_criteria</span><span class="s3">(</span><span class="s1">tree_type</span><span class="s3">, </span><span class="s1">dataset</span><span class="s3">, </span><span class="s1">csc_container</span><span class="s3">, </span><span class="s1">criterion</span><span class="s3">):</span>
    <span class="s1">TreeEstimator </span><span class="s3">= </span><span class="s1">ALL_TREES</span><span class="s3">[</span><span class="s1">tree_type</span><span class="s3">]</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">DATASETS</span><span class="s3">[</span><span class="s1">dataset</span><span class="s3">][</span><span class="s4">&quot;X&quot;</span><span class="s3">]</span>
    <span class="s1">X_sparse </span><span class="s3">= </span><span class="s1">csc_container</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">DATASETS</span><span class="s3">[</span><span class="s1">dataset</span><span class="s3">][</span><span class="s4">&quot;y&quot;</span><span class="s3">]</span>

    <span class="s1">d </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">3</span><span class="s3">, </span><span class="s1">criterion</span><span class="s3">=</span><span class="s1">criterion</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">3</span><span class="s3">, </span><span class="s1">criterion</span><span class="s3">=</span><span class="s1">criterion</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_sparse</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">assert_tree_equal</span><span class="s3">(</span>
        <span class="s1">d</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
        <span class="s1">s</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
        <span class="s4">&quot;{0} with dense and sparse format gave different trees&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">tree_type</span><span class="s3">),</span>
    <span class="s3">)</span>
    <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">s</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">d</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;tree_type&quot;</span><span class="s3">, </span><span class="s1">SPARSE_TREES</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s4">&quot;csc_container,csr_container&quot;</span><span class="s3">, </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">CSC_CONTAINERS</span><span class="s3">, </span><span class="s1">CSR_CONTAINERS</span><span class="s3">)</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_explicit_sparse_zeros</span><span class="s3">(</span><span class="s1">tree_type</span><span class="s3">, </span><span class="s1">csc_container</span><span class="s3">, </span><span class="s1">csr_container</span><span class="s3">):</span>
    <span class="s1">TreeEstimator </span><span class="s3">= </span><span class="s1">ALL_TREES</span><span class="s3">[</span><span class="s1">tree_type</span><span class="s3">]</span>
    <span class="s1">max_depth </span><span class="s3">= </span><span class="s5">3</span>
    <span class="s1">n_features </span><span class="s3">= </span><span class="s5">10</span>

    <span class="s6"># n_samples set n_feature to ease construction of a simultaneous</span>
    <span class="s6"># construction of a csr and csc matrix</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s1">n_features</span>
    <span class="s1">samples </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">)</span>

    <span class="s6"># Generate X, y</span>
    <span class="s1">random_state </span><span class="s3">= </span><span class="s1">check_random_state</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">indices </span><span class="s3">= []</span>
    <span class="s1">data </span><span class="s3">= []</span>
    <span class="s1">offset </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s1">indptr </span><span class="s3">= [</span><span class="s1">offset</span><span class="s3">]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_features</span><span class="s3">):</span>
        <span class="s1">n_nonzero_i </span><span class="s3">= </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">binomial</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">)</span>
        <span class="s1">indices_i </span><span class="s3">= </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">permutation</span><span class="s3">(</span><span class="s1">samples</span><span class="s3">)[:</span><span class="s1">n_nonzero_i</span><span class="s3">]</span>
        <span class="s1">indices</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">indices_i</span><span class="s3">)</span>
        <span class="s1">data_i </span><span class="s3">= </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">binomial</span><span class="s3">(</span><span class="s5">3</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_nonzero_i</span><span class="s3">,)) - </span><span class="s5">1</span>
        <span class="s1">data</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">data_i</span><span class="s3">)</span>
        <span class="s1">offset </span><span class="s3">+= </span><span class="s1">n_nonzero_i</span>
        <span class="s1">indptr</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">offset</span><span class="s3">)</span>

    <span class="s1">indices </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
    <span class="s1">indptr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">indptr</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">(</span><span class="s1">data</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">)</span>
    <span class="s1">X_sparse </span><span class="s3">= </span><span class="s1">csc_container</span><span class="s3">((</span><span class="s1">data</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr</span><span class="s3">), </span><span class="s1">shape</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">X_sparse</span><span class="s3">.</span><span class="s1">toarray</span><span class="s3">()</span>
    <span class="s1">X_sparse_test </span><span class="s3">= </span><span class="s1">csr_container</span><span class="s3">(</span>
        <span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr</span><span class="s3">), </span><span class="s1">shape</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features</span><span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s1">X_test </span><span class="s3">= </span><span class="s1">X_sparse_test</span><span class="s3">.</span><span class="s1">toarray</span><span class="s3">()</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">random_state</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">,))</span>

    <span class="s6"># Ensure that X_sparse_test owns its data, indices and indptr array</span>
    <span class="s1">X_sparse_test </span><span class="s3">= </span><span class="s1">X_sparse_test</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

    <span class="s6"># Ensure that we have explicit zeros</span>
    <span class="s2">assert </span><span class="s3">(</span><span class="s1">X_sparse</span><span class="s3">.</span><span class="s1">data </span><span class="s3">== </span><span class="s5">0.0</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">() &gt; </span><span class="s5">0</span>
    <span class="s2">assert </span><span class="s3">(</span><span class="s1">X_sparse_test</span><span class="s3">.</span><span class="s1">data </span><span class="s3">== </span><span class="s5">0.0</span><span class="s3">).</span><span class="s1">sum</span><span class="s3">() &gt; </span><span class="s5">0</span>

    <span class="s6"># Perform the comparison</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s1">max_depth</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s1">max_depth</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_sparse</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">assert_tree_equal</span><span class="s3">(</span>
        <span class="s1">d</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
        <span class="s1">s</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
        <span class="s4">&quot;{0} with dense and sparse format gave different trees&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span><span class="s1">tree</span><span class="s3">),</span>
    <span class="s3">)</span>

    <span class="s1">Xs </span><span class="s3">= (</span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">X_sparse_test</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">X1</span><span class="s3">, </span><span class="s1">X2 </span><span class="s2">in </span><span class="s1">product</span><span class="s3">(</span><span class="s1">Xs</span><span class="s3">, </span><span class="s1">Xs</span><span class="s3">):</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">s</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X1</span><span class="s3">), </span><span class="s1">d</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X2</span><span class="s3">))</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">s</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X1</span><span class="s3">), </span><span class="s1">d</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X2</span><span class="s3">))</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">s</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X1</span><span class="s3">), </span><span class="s1">s</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X1</span><span class="s3">))</span>

        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span>
            <span class="s1">s</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">decision_path</span><span class="s3">(</span><span class="s1">X1</span><span class="s3">).</span><span class="s1">toarray</span><span class="s3">(), </span><span class="s1">d</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">decision_path</span><span class="s3">(</span><span class="s1">X2</span><span class="s3">).</span><span class="s1">toarray</span><span class="s3">()</span>
        <span class="s3">)</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span>
            <span class="s1">s</span><span class="s3">.</span><span class="s1">decision_path</span><span class="s3">(</span><span class="s1">X1</span><span class="s3">).</span><span class="s1">toarray</span><span class="s3">(), </span><span class="s1">d</span><span class="s3">.</span><span class="s1">decision_path</span><span class="s3">(</span><span class="s1">X2</span><span class="s3">).</span><span class="s1">toarray</span><span class="s3">()</span>
        <span class="s3">)</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span>
            <span class="s1">s</span><span class="s3">.</span><span class="s1">decision_path</span><span class="s3">(</span><span class="s1">X1</span><span class="s3">).</span><span class="s1">toarray</span><span class="s3">(), </span><span class="s1">s</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">decision_path</span><span class="s3">(</span><span class="s1">X1</span><span class="s3">).</span><span class="s1">toarray</span><span class="s3">()</span>
        <span class="s3">)</span>

        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">s</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X1</span><span class="s3">), </span><span class="s1">d</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X2</span><span class="s3">))</span>

        <span class="s2">if </span><span class="s1">tree </span><span class="s2">in </span><span class="s1">CLF_TREES</span><span class="s3">:</span>
            <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">s</span><span class="s3">.</span><span class="s1">predict_proba</span><span class="s3">(</span><span class="s1">X1</span><span class="s3">), </span><span class="s1">d</span><span class="s3">.</span><span class="s1">predict_proba</span><span class="s3">(</span><span class="s1">X2</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">check_raise_error_on_1d_input</span><span class="s3">(</span><span class="s1">name</span><span class="s3">):</span>
    <span class="s1">TreeEstimator </span><span class="s3">= </span><span class="s1">ALL_TREES</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[:, </span><span class="s5">0</span><span class="s3">].</span><span class="s1">ravel</span><span class="s3">()</span>
    <span class="s1">X_2d </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[:, </span><span class="s5">0</span><span class="s3">].</span><span class="s1">reshape</span><span class="s3">((-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">))</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_2d</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">([</span><span class="s1">X</span><span class="s3">])</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;name&quot;</span><span class="s3">, </span><span class="s1">ALL_TREES</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_1d_input</span><span class="s3">(</span><span class="s1">name</span><span class="s3">):</span>
    <span class="s2">with </span><span class="s1">ignore_warnings</span><span class="s3">():</span>
        <span class="s1">check_raise_error_on_1d_input</span><span class="s3">(</span><span class="s1">name</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;name&quot;</span><span class="s3">, </span><span class="s1">ALL_TREES</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;sparse_container&quot;</span><span class="s3">, [</span><span class="s2">None</span><span class="s3">] + </span><span class="s1">CSC_CONTAINERS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_min_weight_leaf_split_level</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">sparse_container</span><span class="s3">):</span>
    <span class="s1">TreeEstimator </span><span class="s3">= </span><span class="s1">ALL_TREES</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s5">0</span><span class="s3">], [</span><span class="s5">0</span><span class="s3">], [</span><span class="s5">0</span><span class="s3">], [</span><span class="s5">0</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">]])</span>
    <span class="s1">y </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]</span>
    <span class="s1">sample_weight </span><span class="s3">= [</span><span class="s5">0.2</span><span class="s3">, </span><span class="s5">0.2</span><span class="s3">, </span><span class="s5">0.2</span><span class="s3">, </span><span class="s5">0.2</span><span class="s3">, </span><span class="s5">0.2</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">sparse_container </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">sparse_container</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">sample_weight</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">max_depth </span><span class="s3">== </span><span class="s5">1</span>

    <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">min_weight_fraction_leaf</span><span class="s3">=</span><span class="s5">0.4</span><span class="s3">)</span>
    <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">sample_weight</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">max_depth </span><span class="s3">== </span><span class="s5">0</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;name&quot;</span><span class="s3">, </span><span class="s1">ALL_TREES</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_public_apply_all_trees</span><span class="s3">(</span><span class="s1">name</span><span class="s3">):</span>
    <span class="s1">X_small32 </span><span class="s3">= </span><span class="s1">X_small</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">_tree</span><span class="s3">.</span><span class="s1">DTYPE</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>

    <span class="s1">est </span><span class="s3">= </span><span class="s1">ALL_TREES</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]()</span>
    <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_small</span><span class="s3">, </span><span class="s1">y_small</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">est</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X_small</span><span class="s3">), </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X_small32</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;name&quot;</span><span class="s3">, </span><span class="s1">SPARSE_TREES</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;csr_container&quot;</span><span class="s3">, </span><span class="s1">CSR_CONTAINERS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_public_apply_sparse_trees</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">csr_container</span><span class="s3">):</span>
    <span class="s1">X_small32 </span><span class="s3">= </span><span class="s1">csr_container</span><span class="s3">(</span><span class="s1">X_small</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">_tree</span><span class="s3">.</span><span class="s1">DTYPE</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">))</span>

    <span class="s1">est </span><span class="s3">= </span><span class="s1">ALL_TREES</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]()</span>
    <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_small</span><span class="s3">, </span><span class="s1">y_small</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">est</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X_small</span><span class="s3">), </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X_small32</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_decision_path_hardcoded</span><span class="s3">():</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span>
    <span class="s1">est </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">1</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">node_indicator </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">decision_path</span><span class="s3">(</span><span class="s1">X</span><span class="s3">[:</span><span class="s5">2</span><span class="s3">]).</span><span class="s1">toarray</span><span class="s3">()</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">node_indicator</span><span class="s3">, [[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]])</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;name&quot;</span><span class="s3">, </span><span class="s1">ALL_TREES</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_decision_path</span><span class="s3">(</span><span class="s1">name</span><span class="s3">):</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]</span>

    <span class="s1">TreeEstimator </span><span class="s3">= </span><span class="s1">ALL_TREES</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>
    <span class="s1">est </span><span class="s3">= </span><span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">node_indicator_csr </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">decision_path</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">node_indicator </span><span class="s3">= </span><span class="s1">node_indicator_csr</span><span class="s3">.</span><span class="s1">toarray</span><span class="s3">()</span>
    <span class="s2">assert </span><span class="s1">node_indicator</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">node_count</span><span class="s3">)</span>

    <span class="s6"># Assert that leaves index are correct</span>
    <span class="s1">leaves </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">leave_indicator </span><span class="s3">= [</span><span class="s1">node_indicator</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">] </span><span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">leaves</span><span class="s3">)]</span>
    <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">leave_indicator</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">))</span>

    <span class="s6"># Ensure only one leave node per sample</span>
    <span class="s1">all_leaves </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">children_left </span><span class="s3">== </span><span class="s1">TREE_LEAF</span>
    <span class="s1">assert_array_almost_equal</span><span class="s3">(</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">node_indicator</span><span class="s3">, </span><span class="s1">all_leaves</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s3">)</span>

    <span class="s6"># Ensure max depth is consistent with sum of indicator</span>
    <span class="s1">max_depth </span><span class="s3">= </span><span class="s1">node_indicator</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s5">1</span><span class="s3">).</span><span class="s1">max</span><span class="s3">()</span>
    <span class="s2">assert </span><span class="s1">est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">max_depth </span><span class="s3">&lt;= </span><span class="s1">max_depth</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;name&quot;</span><span class="s3">, </span><span class="s1">ALL_TREES</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;csr_container&quot;</span><span class="s3">, </span><span class="s1">CSR_CONTAINERS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_no_sparse_y_support</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">csr_container</span><span class="s3">):</span>
    <span class="s6"># Currently we don't support sparse y</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">X_multilabel</span><span class="s3">, </span><span class="s1">csr_container</span><span class="s3">(</span><span class="s1">y_multilabel</span><span class="s3">)</span>
    <span class="s1">TreeEstimator </span><span class="s3">= </span><span class="s1">ALL_TREES</span><span class="s3">[</span><span class="s1">name</span><span class="s3">]</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">TypeError</span><span class="s3">):</span>
        <span class="s1">TreeEstimator</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_mae</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Check MAE criterion produces correct results on small toy dataset: 
 
    ------------------ 
    | X | y | weight | 
    ------------------ 
    | 3 | 3 |  0.1   | 
    | 5 | 3 |  0.3   | 
    | 8 | 4 |  1.0   | 
    | 3 | 6 |  0.6   | 
    | 5 | 7 |  0.3   | 
    ------------------ 
    |sum wt:|  2.3   | 
    ------------------ 
 
    Because we are dealing with sample weights, we cannot find the median by 
    simply choosing/averaging the centre value(s), instead we consider the 
    median where 50% of the cumulative weight is found (in a y sorted data set) 
    . Therefore with regards to this test data, the cumulative weight is &gt;= 50% 
    when y = 4.  Therefore: 
    Median = 4 
 
    For all the samples, we can get the total error by summing: 
    Absolute(Median - y) * weight 
 
    I.e., total error = (Absolute(4 - 3) * 0.1) 
                      + (Absolute(4 - 3) * 0.3) 
                      + (Absolute(4 - 4) * 1.0) 
                      + (Absolute(4 - 6) * 0.6) 
                      + (Absolute(4 - 7) * 0.3) 
                      = 2.5 
 
    Impurity = Total error / total weight 
             = 2.5 / 2.3 
             = 1.08695652173913 
             ------------------ 
 
    From this root node, the next best split is between X values of 3 and 5. 
    Thus, we have left and right child nodes: 
 
    LEFT                    RIGHT 
    ------------------      ------------------ 
    | X | y | weight |      | X | y | weight | 
    ------------------      ------------------ 
    | 3 | 3 |  0.1   |      | 5 | 3 |  0.3   | 
    | 3 | 6 |  0.6   |      | 8 | 4 |  1.0   | 
    ------------------      | 5 | 7 |  0.3   | 
    |sum wt:|  0.7   |      ------------------ 
    ------------------      |sum wt:|  1.6   | 
                            ------------------ 
 
    Impurity is found in the same way: 
    Left node Median = 6 
    Total error = (Absolute(6 - 3) * 0.1) 
                + (Absolute(6 - 6) * 0.6) 
                = 0.3 
 
    Left Impurity = Total error / total weight 
            = 0.3 / 0.7 
            = 0.428571428571429 
            ------------------- 
 
    Likewise for Right node: 
    Right node Median = 4 
    Total error = (Absolute(4 - 3) * 0.3) 
                + (Absolute(4 - 4) * 1.0) 
                + (Absolute(4 - 7) * 0.3) 
                = 1.2 
 
    Right Impurity = Total error / total weight 
            = 1.2 / 1.6 
            = 0.75 
            ------ 
    &quot;&quot;&quot;</span>
    <span class="s1">dt_mae </span><span class="s3">= </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">criterion</span><span class="s3">=</span><span class="s4">&quot;absolute_error&quot;</span><span class="s3">, </span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s5">2</span>
    <span class="s3">)</span>

    <span class="s6"># Test MAE where sample weights are non-uniform (as illustrated above):</span>
    <span class="s1">dt_mae</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span>
        <span class="s1">X</span><span class="s3">=[[</span><span class="s5">3</span><span class="s3">], [</span><span class="s5">5</span><span class="s3">], [</span><span class="s5">3</span><span class="s3">], [</span><span class="s5">8</span><span class="s3">], [</span><span class="s5">5</span><span class="s3">]],</span>
        <span class="s1">y</span><span class="s3">=[</span><span class="s5">6</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s3">],</span>
        <span class="s1">sample_weight</span><span class="s3">=[</span><span class="s5">0.6</span><span class="s3">, </span><span class="s5">0.3</span><span class="s3">, </span><span class="s5">0.1</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">0.3</span><span class="s3">],</span>
    <span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">dt_mae</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">impurity</span><span class="s3">, [</span><span class="s5">2.5 </span><span class="s3">/ </span><span class="s5">2.3</span><span class="s3">, </span><span class="s5">0.3 </span><span class="s3">/ </span><span class="s5">0.7</span><span class="s3">, </span><span class="s5">1.2 </span><span class="s3">/ </span><span class="s5">1.6</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">dt_mae</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">, [</span><span class="s5">4.0</span><span class="s3">, </span><span class="s5">6.0</span><span class="s3">, </span><span class="s5">4.0</span><span class="s3">])</span>

    <span class="s6"># Test MAE where all sample weights are uniform:</span>
    <span class="s1">dt_mae</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">=[[</span><span class="s5">3</span><span class="s3">], [</span><span class="s5">5</span><span class="s3">], [</span><span class="s5">3</span><span class="s3">], [</span><span class="s5">8</span><span class="s3">], [</span><span class="s5">5</span><span class="s3">]], </span><span class="s1">y</span><span class="s3">=[</span><span class="s5">6</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s3">], </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">5</span><span class="s3">))</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">dt_mae</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">impurity</span><span class="s3">, [</span><span class="s5">1.4</span><span class="s3">, </span><span class="s5">1.5</span><span class="s3">, </span><span class="s5">4.0 </span><span class="s3">/ </span><span class="s5">3.0</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">dt_mae</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">, [</span><span class="s5">4</span><span class="s3">, </span><span class="s5">4.5</span><span class="s3">, </span><span class="s5">4.0</span><span class="s3">])</span>

    <span class="s6"># Test MAE where a `sample_weight` is not explicitly provided.</span>
    <span class="s6"># This is equivalent to providing uniform sample weights, though</span>
    <span class="s6"># the internal logic is different:</span>
    <span class="s1">dt_mae</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">=[[</span><span class="s5">3</span><span class="s3">], [</span><span class="s5">5</span><span class="s3">], [</span><span class="s5">3</span><span class="s3">], [</span><span class="s5">8</span><span class="s3">], [</span><span class="s5">5</span><span class="s3">]], </span><span class="s1">y</span><span class="s3">=[</span><span class="s5">6</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">dt_mae</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">impurity</span><span class="s3">, [</span><span class="s5">1.4</span><span class="s3">, </span><span class="s5">1.5</span><span class="s3">, </span><span class="s5">4.0 </span><span class="s3">/ </span><span class="s5">3.0</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">dt_mae</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">value</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">, [</span><span class="s5">4</span><span class="s3">, </span><span class="s5">4.5</span><span class="s3">, </span><span class="s5">4.0</span><span class="s3">])</span>


<span class="s2">def </span><span class="s1">test_criterion_copy</span><span class="s3">():</span>
    <span class="s6"># Let's check whether copy of our criterion has the same type</span>
    <span class="s6"># and properties as original</span>
    <span class="s1">n_outputs </span><span class="s3">= </span><span class="s5">3</span>
    <span class="s1">n_classes </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">3</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s5">100</span>

    <span class="s2">def </span><span class="s1">_pickle_copy</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">loads</span><span class="s3">(</span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">dumps</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">))</span>

    <span class="s2">for </span><span class="s1">copy_func </span><span class="s2">in </span><span class="s3">[</span><span class="s1">copy</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">.</span><span class="s1">deepcopy</span><span class="s3">, </span><span class="s1">_pickle_copy</span><span class="s3">]:</span>
        <span class="s2">for </span><span class="s1">_</span><span class="s3">, </span><span class="s1">typename </span><span class="s2">in </span><span class="s1">CRITERIA_CLF</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">criteria </span><span class="s3">= </span><span class="s1">typename</span><span class="s3">(</span><span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">n_classes</span><span class="s3">)</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">copy_func</span><span class="s3">(</span><span class="s1">criteria</span><span class="s3">).</span><span class="s1">__reduce__</span><span class="s3">()</span>
            <span class="s1">typename_</span><span class="s3">, (</span><span class="s1">n_outputs_</span><span class="s3">, </span><span class="s1">n_classes_</span><span class="s3">), </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">result</span>
            <span class="s2">assert </span><span class="s1">typename </span><span class="s3">== </span><span class="s1">typename_</span>
            <span class="s2">assert </span><span class="s1">n_outputs </span><span class="s3">== </span><span class="s1">n_outputs_</span>
            <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">n_classes</span><span class="s3">, </span><span class="s1">n_classes_</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">_</span><span class="s3">, </span><span class="s1">typename </span><span class="s2">in </span><span class="s1">CRITERIA_REG</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
            <span class="s1">criteria </span><span class="s3">= </span><span class="s1">typename</span><span class="s3">(</span><span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">)</span>
            <span class="s1">result </span><span class="s3">= </span><span class="s1">copy_func</span><span class="s3">(</span><span class="s1">criteria</span><span class="s3">).</span><span class="s1">__reduce__</span><span class="s3">()</span>
            <span class="s1">typename_</span><span class="s3">, (</span><span class="s1">n_outputs_</span><span class="s3">, </span><span class="s1">n_samples_</span><span class="s3">), </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">result</span>
            <span class="s2">assert </span><span class="s1">typename </span><span class="s3">== </span><span class="s1">typename_</span>
            <span class="s2">assert </span><span class="s1">n_outputs </span><span class="s3">== </span><span class="s1">n_outputs_</span>
            <span class="s2">assert </span><span class="s1">n_samples </span><span class="s3">== </span><span class="s1">n_samples_</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;sparse_container&quot;</span><span class="s3">, [</span><span class="s2">None</span><span class="s3">] + </span><span class="s1">CSC_CONTAINERS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_empty_leaf_infinite_threshold</span><span class="s3">(</span><span class="s1">sparse_container</span><span class="s3">):</span>
    <span class="s6"># try to make empty leaf by using near infinite value.</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s5">0</span><span class="s3">).</span><span class="s1">randn</span><span class="s3">(</span><span class="s5">100</span><span class="s3">, </span><span class="s5">11</span><span class="s3">) * </span><span class="s5">2e38</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan_to_num</span><span class="s3">(</span><span class="s1">data</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s4">&quot;float32&quot;</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[:, :-</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">sparse_container </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">sparse_container</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[:, -</span><span class="s5">1</span><span class="s3">]</span>

    <span class="s1">tree </span><span class="s3">= </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">terminal_regions </span><span class="s3">= </span><span class="s1">tree</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">left_leaf </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">children_left </span><span class="s3">== </span><span class="s1">TREE_LEAF</span><span class="s3">)[</span><span class="s5">0</span><span class="s3">])</span>
    <span class="s1">empty_leaf </span><span class="s3">= </span><span class="s1">left_leaf</span><span class="s3">.</span><span class="s1">difference</span><span class="s3">(</span><span class="s1">terminal_regions</span><span class="s3">)</span>
    <span class="s1">infinite_threshold </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(~</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">threshold</span><span class="s3">))[</span><span class="s5">0</span><span class="s3">]</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">infinite_threshold</span><span class="s3">) == </span><span class="s5">0</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">empty_leaf</span><span class="s3">) == </span><span class="s5">0</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s4">&quot;dataset&quot;</span><span class="s3">, </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">DATASETS</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()) - {</span><span class="s4">&quot;reg_small&quot;</span><span class="s3">, </span><span class="s4">&quot;diabetes&quot;</span><span class="s3">})</span>
<span class="s3">)</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;tree_cls&quot;</span><span class="s3">, [</span><span class="s1">DecisionTreeClassifier</span><span class="s3">, </span><span class="s1">ExtraTreeClassifier</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_prune_tree_classifier_are_subtrees</span><span class="s3">(</span><span class="s1">dataset</span><span class="s3">, </span><span class="s1">tree_cls</span><span class="s3">):</span>
    <span class="s1">dataset </span><span class="s3">= </span><span class="s1">DATASETS</span><span class="s3">[</span><span class="s1">dataset</span><span class="s3">]</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">dataset</span><span class="s3">[</span><span class="s4">&quot;X&quot;</span><span class="s3">], </span><span class="s1">dataset</span><span class="s3">[</span><span class="s4">&quot;y&quot;</span><span class="s3">]</span>
    <span class="s1">est </span><span class="s3">= </span><span class="s1">tree_cls</span><span class="s3">(</span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s5">20</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">info </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">cost_complexity_pruning_path</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">pruning_path </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">ccp_alphas</span>
    <span class="s1">impurities </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">impurities</span>
    <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">pruning_path</span><span class="s3">) &gt;= </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">impurities</span><span class="s3">) &gt;= </span><span class="s5">0</span><span class="s3">)</span>

    <span class="s1">assert_pruning_creates_subtree</span><span class="s3">(</span><span class="s1">tree_cls</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">pruning_path</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;dataset&quot;</span><span class="s3">, </span><span class="s1">DATASETS</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">())</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;tree_cls&quot;</span><span class="s3">, [</span><span class="s1">DecisionTreeRegressor</span><span class="s3">, </span><span class="s1">ExtraTreeRegressor</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_prune_tree_regression_are_subtrees</span><span class="s3">(</span><span class="s1">dataset</span><span class="s3">, </span><span class="s1">tree_cls</span><span class="s3">):</span>
    <span class="s1">dataset </span><span class="s3">= </span><span class="s1">DATASETS</span><span class="s3">[</span><span class="s1">dataset</span><span class="s3">]</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">dataset</span><span class="s3">[</span><span class="s4">&quot;X&quot;</span><span class="s3">], </span><span class="s1">dataset</span><span class="s3">[</span><span class="s4">&quot;y&quot;</span><span class="s3">]</span>

    <span class="s1">est </span><span class="s3">= </span><span class="s1">tree_cls</span><span class="s3">(</span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s5">20</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">info </span><span class="s3">= </span><span class="s1">est</span><span class="s3">.</span><span class="s1">cost_complexity_pruning_path</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">pruning_path </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">ccp_alphas</span>
    <span class="s1">impurities </span><span class="s3">= </span><span class="s1">info</span><span class="s3">.</span><span class="s1">impurities</span>
    <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">pruning_path</span><span class="s3">) &gt;= </span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">impurities</span><span class="s3">) &gt;= </span><span class="s5">0</span><span class="s3">)</span>

    <span class="s1">assert_pruning_creates_subtree</span><span class="s3">(</span><span class="s1">tree_cls</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">pruning_path</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_prune_single_node_tree</span><span class="s3">():</span>
    <span class="s6"># single node tree</span>
    <span class="s1">clf1 </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">clf1</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">([[</span><span class="s5">0</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">]], [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">])</span>

    <span class="s6"># pruned single node tree</span>
    <span class="s1">clf2 </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">ccp_alpha</span><span class="s3">=</span><span class="s5">10</span><span class="s3">)</span>
    <span class="s1">clf2</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">([[</span><span class="s5">0</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">]], [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">])</span>

    <span class="s1">assert_is_subtree</span><span class="s3">(</span><span class="s1">clf1</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">, </span><span class="s1">clf2</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">assert_pruning_creates_subtree</span><span class="s3">(</span><span class="s1">estimator_cls</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">pruning_path</span><span class="s3">):</span>
    <span class="s6"># generate trees with increasing alphas</span>
    <span class="s1">estimators </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">ccp_alpha </span><span class="s2">in </span><span class="s1">pruning_path</span><span class="s3">:</span>
        <span class="s1">est </span><span class="s3">= </span><span class="s1">estimator_cls</span><span class="s3">(</span><span class="s1">max_leaf_nodes</span><span class="s3">=</span><span class="s5">20</span><span class="s3">, </span><span class="s1">ccp_alpha</span><span class="s3">=</span><span class="s1">ccp_alpha</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span>
        <span class="s3">)</span>
        <span class="s1">estimators</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">est</span><span class="s3">)</span>

    <span class="s6"># A pruned tree must be a subtree of the previous tree (which had a</span>
    <span class="s6"># smaller ccp_alpha)</span>
    <span class="s2">for </span><span class="s1">prev_est</span><span class="s3">, </span><span class="s1">next_est </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">estimators</span><span class="s3">, </span><span class="s1">estimators</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:]):</span>
        <span class="s1">assert_is_subtree</span><span class="s3">(</span><span class="s1">prev_est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">, </span><span class="s1">next_est</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">assert_is_subtree</span><span class="s3">(</span><span class="s1">tree</span><span class="s3">, </span><span class="s1">subtree</span><span class="s3">):</span>
    <span class="s2">assert </span><span class="s1">tree</span><span class="s3">.</span><span class="s1">node_count </span><span class="s3">&gt;= </span><span class="s1">subtree</span><span class="s3">.</span><span class="s1">node_count</span>
    <span class="s2">assert </span><span class="s1">tree</span><span class="s3">.</span><span class="s1">max_depth </span><span class="s3">&gt;= </span><span class="s1">subtree</span><span class="s3">.</span><span class="s1">max_depth</span>

    <span class="s1">tree_c_left </span><span class="s3">= </span><span class="s1">tree</span><span class="s3">.</span><span class="s1">children_left</span>
    <span class="s1">tree_c_right </span><span class="s3">= </span><span class="s1">tree</span><span class="s3">.</span><span class="s1">children_right</span>
    <span class="s1">subtree_c_left </span><span class="s3">= </span><span class="s1">subtree</span><span class="s3">.</span><span class="s1">children_left</span>
    <span class="s1">subtree_c_right </span><span class="s3">= </span><span class="s1">subtree</span><span class="s3">.</span><span class="s1">children_right</span>

    <span class="s1">stack </span><span class="s3">= [(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)]</span>
    <span class="s2">while </span><span class="s1">stack</span><span class="s3">:</span>
        <span class="s1">tree_node_idx</span><span class="s3">, </span><span class="s1">subtree_node_idx </span><span class="s3">= </span><span class="s1">stack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>
        <span class="s1">assert_array_almost_equal</span><span class="s3">(</span>
            <span class="s1">tree</span><span class="s3">.</span><span class="s1">value</span><span class="s3">[</span><span class="s1">tree_node_idx</span><span class="s3">], </span><span class="s1">subtree</span><span class="s3">.</span><span class="s1">value</span><span class="s3">[</span><span class="s1">subtree_node_idx</span><span class="s3">]</span>
        <span class="s3">)</span>
        <span class="s1">assert_almost_equal</span><span class="s3">(</span>
            <span class="s1">tree</span><span class="s3">.</span><span class="s1">impurity</span><span class="s3">[</span><span class="s1">tree_node_idx</span><span class="s3">], </span><span class="s1">subtree</span><span class="s3">.</span><span class="s1">impurity</span><span class="s3">[</span><span class="s1">subtree_node_idx</span><span class="s3">]</span>
        <span class="s3">)</span>
        <span class="s1">assert_almost_equal</span><span class="s3">(</span>
            <span class="s1">tree</span><span class="s3">.</span><span class="s1">n_node_samples</span><span class="s3">[</span><span class="s1">tree_node_idx</span><span class="s3">], </span><span class="s1">subtree</span><span class="s3">.</span><span class="s1">n_node_samples</span><span class="s3">[</span><span class="s1">subtree_node_idx</span><span class="s3">]</span>
        <span class="s3">)</span>
        <span class="s1">assert_almost_equal</span><span class="s3">(</span>
            <span class="s1">tree</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span><span class="s3">[</span><span class="s1">tree_node_idx</span><span class="s3">],</span>
            <span class="s1">subtree</span><span class="s3">.</span><span class="s1">weighted_n_node_samples</span><span class="s3">[</span><span class="s1">subtree_node_idx</span><span class="s3">],</span>
        <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">subtree_c_left</span><span class="s3">[</span><span class="s1">subtree_node_idx</span><span class="s3">] == </span><span class="s1">subtree_c_right</span><span class="s3">[</span><span class="s1">subtree_node_idx</span><span class="s3">]:</span>
            <span class="s6"># is a leaf</span>
            <span class="s1">assert_almost_equal</span><span class="s3">(</span><span class="s1">TREE_UNDEFINED</span><span class="s3">, </span><span class="s1">subtree</span><span class="s3">.</span><span class="s1">threshold</span><span class="s3">[</span><span class="s1">subtree_node_idx</span><span class="s3">])</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s6"># not a leaf</span>
            <span class="s1">assert_almost_equal</span><span class="s3">(</span>
                <span class="s1">tree</span><span class="s3">.</span><span class="s1">threshold</span><span class="s3">[</span><span class="s1">tree_node_idx</span><span class="s3">], </span><span class="s1">subtree</span><span class="s3">.</span><span class="s1">threshold</span><span class="s3">[</span><span class="s1">subtree_node_idx</span><span class="s3">]</span>
            <span class="s3">)</span>
            <span class="s1">stack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">tree_c_left</span><span class="s3">[</span><span class="s1">tree_node_idx</span><span class="s3">], </span><span class="s1">subtree_c_left</span><span class="s3">[</span><span class="s1">subtree_node_idx</span><span class="s3">]))</span>
            <span class="s1">stack</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                <span class="s3">(</span><span class="s1">tree_c_right</span><span class="s3">[</span><span class="s1">tree_node_idx</span><span class="s3">], </span><span class="s1">subtree_c_right</span><span class="s3">[</span><span class="s1">subtree_node_idx</span><span class="s3">])</span>
            <span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;name&quot;</span><span class="s3">, </span><span class="s1">ALL_TREES</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;splitter&quot;</span><span class="s3">, [</span><span class="s4">&quot;best&quot;</span><span class="s3">, </span><span class="s4">&quot;random&quot;</span><span class="s3">])</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;sparse_container&quot;</span><span class="s3">, [</span><span class="s2">None</span><span class="s3">] + </span><span class="s1">CSC_CONTAINERS </span><span class="s3">+ </span><span class="s1">CSR_CONTAINERS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_apply_path_readonly_all_trees</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">splitter</span><span class="s3">, </span><span class="s1">sparse_container</span><span class="s3">):</span>
    <span class="s1">dataset </span><span class="s3">= </span><span class="s1">DATASETS</span><span class="s3">[</span><span class="s4">&quot;clf_small&quot;</span><span class="s3">]</span>
    <span class="s1">X_small </span><span class="s3">= </span><span class="s1">dataset</span><span class="s3">[</span><span class="s4">&quot;X&quot;</span><span class="s3">].</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">_tree</span><span class="s3">.</span><span class="s1">DTYPE</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">sparse_container </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">X_readonly </span><span class="s3">= </span><span class="s1">create_memmap_backed_data</span><span class="s3">(</span><span class="s1">X_small</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">X_readonly </span><span class="s3">= </span><span class="s1">sparse_container</span><span class="s3">(</span><span class="s1">dataset</span><span class="s3">[</span><span class="s4">&quot;X&quot;</span><span class="s3">])</span>

        <span class="s1">X_readonly</span><span class="s3">.</span><span class="s1">data </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">X_readonly</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">_tree</span><span class="s3">.</span><span class="s1">DTYPE</span><span class="s3">)</span>
        <span class="s3">(</span>
            <span class="s1">X_readonly</span><span class="s3">.</span><span class="s1">data</span><span class="s3">,</span>
            <span class="s1">X_readonly</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">,</span>
            <span class="s1">X_readonly</span><span class="s3">.</span><span class="s1">indptr</span><span class="s3">,</span>
        <span class="s3">) = </span><span class="s1">create_memmap_backed_data</span><span class="s3">(</span>
            <span class="s3">(</span><span class="s1">X_readonly</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">X_readonly</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">, </span><span class="s1">X_readonly</span><span class="s3">.</span><span class="s1">indptr</span><span class="s3">)</span>
        <span class="s3">)</span>

    <span class="s1">y_readonly </span><span class="s3">= </span><span class="s1">create_memmap_backed_data</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">y_small</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">_tree</span><span class="s3">.</span><span class="s1">DTYPE</span><span class="s3">))</span>
    <span class="s1">est </span><span class="s3">= </span><span class="s1">ALL_TREES</span><span class="s3">[</span><span class="s1">name</span><span class="s3">](</span><span class="s1">splitter</span><span class="s3">=</span><span class="s1">splitter</span><span class="s3">)</span>
    <span class="s1">est</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_readonly</span><span class="s3">, </span><span class="s1">y_readonly</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">est</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_readonly</span><span class="s3">), </span><span class="s1">est</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_small</span><span class="s3">))</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span>
        <span class="s1">est</span><span class="s3">.</span><span class="s1">decision_path</span><span class="s3">(</span><span class="s1">X_readonly</span><span class="s3">).</span><span class="s1">todense</span><span class="s3">(), </span><span class="s1">est</span><span class="s3">.</span><span class="s1">decision_path</span><span class="s3">(</span><span class="s1">X_small</span><span class="s3">).</span><span class="s1">todense</span><span class="s3">()</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;criterion&quot;</span><span class="s3">, [</span><span class="s4">&quot;squared_error&quot;</span><span class="s3">, </span><span class="s4">&quot;friedman_mse&quot;</span><span class="s3">, </span><span class="s4">&quot;poisson&quot;</span><span class="s3">])</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;Tree&quot;</span><span class="s3">, </span><span class="s1">REG_TREES</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())</span>
<span class="s2">def </span><span class="s1">test_balance_property</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">, </span><span class="s1">Tree</span><span class="s3">):</span>
    <span class="s6"># Test that sum(y_pred)=sum(y_true) on training set.</span>
    <span class="s6"># This works if the mean is predicted (should even be true for each leaf).</span>
    <span class="s6"># MAE predicts the median and is therefore excluded from this test.</span>

    <span class="s6"># Choose a training set with non-negative targets (for poisson)</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">target</span>
    <span class="s1">reg </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s1">criterion</span><span class="s3">)</span>
    <span class="s1">reg</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">reg</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)) == </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">approx</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;seed&quot;</span><span class="s3">, </span><span class="s1">range</span><span class="s3">(</span><span class="s5">3</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">test_poisson_zero_nodes</span><span class="s3">(</span><span class="s1">seed</span><span class="s3">):</span>
    <span class="s6"># Test that sum(y)=0 and therefore y_pred=0 is forbidden on nodes.</span>
    <span class="s1">X </span><span class="s3">= [[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">], [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">], [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">], [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">3</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s3">]]</span>
    <span class="s1">y </span><span class="s3">= [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">]</span>
    <span class="s6"># Note that X[:, 0] == 0 is a 100% indicator for y == 0. The tree can</span>
    <span class="s6"># easily learn that:</span>
    <span class="s1">reg </span><span class="s3">= </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s4">&quot;squared_error&quot;</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">seed</span><span class="s3">)</span>
    <span class="s1">reg</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">amin</span><span class="s3">(</span><span class="s1">reg</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)) == </span><span class="s5">0</span>
    <span class="s6"># whereas Poisson must predict strictly positive numbers</span>
    <span class="s1">reg </span><span class="s3">= </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s4">&quot;poisson&quot;</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">seed</span><span class="s3">)</span>
    <span class="s1">reg</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">reg</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">)</span>

    <span class="s6"># Test additional dataset where something could go wrong.</span>
    <span class="s1">n_features </span><span class="s3">= </span><span class="s5">10</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">make_regression</span><span class="s3">(</span>
        <span class="s1">effective_rank</span><span class="s3">=</span><span class="s1">n_features </span><span class="s3">* </span><span class="s5">2 </span><span class="s3">// </span><span class="s5">3</span><span class="s3">,</span>
        <span class="s1">tail_strength</span><span class="s3">=</span><span class="s5">0.6</span><span class="s3">,</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s5">1_000</span><span class="s3">,</span>
        <span class="s1">n_features</span><span class="s3">=</span><span class="s1">n_features</span><span class="s3">,</span>
        <span class="s1">n_informative</span><span class="s3">=</span><span class="s1">n_features </span><span class="s3">* </span><span class="s5">2 </span><span class="s3">// </span><span class="s5">3</span><span class="s3">,</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s1">seed</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s6"># some excess zeros</span>
    <span class="s1">y</span><span class="s3">[(-</span><span class="s5">1 </span><span class="s3">&lt; </span><span class="s1">y</span><span class="s3">) &amp; (</span><span class="s1">y </span><span class="s3">&lt; </span><span class="s5">0</span><span class="s3">)] = </span><span class="s5">0</span>
    <span class="s6"># make sure the target is positive</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">reg </span><span class="s3">= </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s4">&quot;poisson&quot;</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">seed</span><span class="s3">)</span>
    <span class="s1">reg</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">reg</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">) &gt; </span><span class="s5">0</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_poisson_vs_mse</span><span class="s3">():</span>
    <span class="s6"># For a Poisson distributed target, Poisson loss should give better results</span>
    <span class="s6"># than squared error measured in Poisson deviance as metric.</span>
    <span class="s6"># We have a similar test, test_poisson(), in</span>
    <span class="s6"># sklearn/ensemble/_hist_gradient_boosting/tests/test_gradient_boosting.py</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s5">42</span><span class="s3">)</span>
    <span class="s1">n_train</span><span class="s3">, </span><span class="s1">n_test</span><span class="s3">, </span><span class="s1">n_features </span><span class="s3">= </span><span class="s5">500</span><span class="s3">, </span><span class="s5">500</span><span class="s3">, </span><span class="s5">10</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">make_low_rank_matrix</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s1">n_train </span><span class="s3">+ </span><span class="s1">n_test</span><span class="s3">, </span><span class="s1">n_features</span><span class="s3">=</span><span class="s1">n_features</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">rng</span>
    <span class="s3">)</span>
    <span class="s6"># We create a log-linear Poisson model and downscale coef as it will get</span>
    <span class="s6"># exponentiated.</span>
    <span class="s1">coef </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">uniform</span><span class="s3">(</span><span class="s1">low</span><span class="s3">=-</span><span class="s5">2</span><span class="s3">, </span><span class="s1">high</span><span class="s3">=</span><span class="s5">2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">n_features</span><span class="s3">) / </span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">poisson</span><span class="s3">(</span><span class="s1">lam</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">X </span><span class="s3">@ </span><span class="s1">coef</span><span class="s3">))</span>
    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">y_test </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s1">n_test</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">rng</span>
    <span class="s3">)</span>
    <span class="s6"># We prevent some overfitting by setting min_samples_split=10.</span>
    <span class="s1">tree_poi </span><span class="s3">= </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(</span>
        <span class="s1">criterion</span><span class="s3">=</span><span class="s4">&quot;poisson&quot;</span><span class="s3">, </span><span class="s1">min_samples_split</span><span class="s3">=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">rng</span>
    <span class="s3">)</span>
    <span class="s1">tree_mse </span><span class="s3">= </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(</span>
        <span class="s1">criterion</span><span class="s3">=</span><span class="s4">&quot;squared_error&quot;</span><span class="s3">, </span><span class="s1">min_samples_split</span><span class="s3">=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">rng</span>
    <span class="s3">)</span>

    <span class="s1">tree_poi</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>
    <span class="s1">tree_mse</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>
    <span class="s1">dummy </span><span class="s3">= </span><span class="s1">DummyRegressor</span><span class="s3">(</span><span class="s1">strategy</span><span class="s3">=</span><span class="s4">&quot;mean&quot;</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">val </span><span class="s2">in </span><span class="s3">[(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s4">&quot;train&quot;</span><span class="s3">), (</span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_test</span><span class="s3">, </span><span class="s4">&quot;test&quot;</span><span class="s3">)]:</span>
        <span class="s1">metric_poi </span><span class="s3">= </span><span class="s1">mean_poisson_deviance</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">tree_poi</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">))</span>
        <span class="s6"># squared_error might produce non-positive predictions =&gt; clip</span>
        <span class="s1">metric_mse </span><span class="s3">= </span><span class="s1">mean_poisson_deviance</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">clip</span><span class="s3">(</span><span class="s1">tree_mse</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s5">1e-15</span><span class="s3">, </span><span class="s2">None</span><span class="s3">))</span>
        <span class="s1">metric_dummy </span><span class="s3">= </span><span class="s1">mean_poisson_deviance</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">dummy</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">))</span>
        <span class="s6"># As squared_error might correctly predict 0 in train set, its train</span>
        <span class="s6"># score can be better than Poisson. This is no longer the case for the</span>
        <span class="s6"># test set.</span>
        <span class="s2">if </span><span class="s1">val </span><span class="s3">== </span><span class="s4">&quot;test&quot;</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">metric_poi </span><span class="s3">&lt; </span><span class="s5">0.5 </span><span class="s3">* </span><span class="s1">metric_mse</span>
        <span class="s2">assert </span><span class="s1">metric_poi </span><span class="s3">&lt; </span><span class="s5">0.75 </span><span class="s3">* </span><span class="s1">metric_dummy</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;criterion&quot;</span><span class="s3">, </span><span class="s1">REG_CRITERIONS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_decision_tree_regressor_sample_weight_consistency</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Test that the impact of sample_weight is consistent.&quot;&quot;&quot;</span>
    <span class="s1">tree_params </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s1">criterion</span><span class="s3">)</span>
    <span class="s1">tree </span><span class="s3">= </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(**</span><span class="s1">tree_params</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">42</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">kind </span><span class="s2">in </span><span class="s3">[</span><span class="s4">&quot;zeros&quot;</span><span class="s3">, </span><span class="s4">&quot;ones&quot;</span><span class="s3">]:</span>
        <span class="s1">check_sample_weights_invariance</span><span class="s3">(</span>
            <span class="s4">&quot;DecisionTreeRegressor_&quot; </span><span class="s3">+ </span><span class="s1">criterion</span><span class="s3">, </span><span class="s1">tree</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">=</span><span class="s4">&quot;zeros&quot;</span>
        <span class="s3">)</span>

    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features </span><span class="s3">= </span><span class="s5">10</span><span class="s3">, </span><span class="s5">5</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">rand</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">1</span><span class="s3">) + </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">rand</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s6"># make it positive in order to work also for poisson criterion</span>
    <span class="s1">y </span><span class="s3">+= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">y</span><span class="s3">) + </span><span class="s5">0.1</span>

    <span class="s6"># check that multiplying sample_weight by 2 is equivalent</span>
    <span class="s6"># to repeating corresponding samples twice</span>
    <span class="s1">X2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">([</span><span class="s1">X</span><span class="s3">, </span><span class="s1">X</span><span class="s3">[: </span><span class="s1">n_samples </span><span class="s3">// </span><span class="s5">2</span><span class="s3">]], </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">y2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">([</span><span class="s1">y</span><span class="s3">, </span><span class="s1">y</span><span class="s3">[: </span><span class="s1">n_samples </span><span class="s3">// </span><span class="s5">2</span><span class="s3">]])</span>
    <span class="s1">sample_weight_1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>
    <span class="s1">sample_weight_1</span><span class="s3">[: </span><span class="s1">n_samples </span><span class="s3">// </span><span class="s5">2</span><span class="s3">] = </span><span class="s5">2</span>

    <span class="s1">tree1 </span><span class="s3">= </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(**</span><span class="s1">tree_params</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">sample_weight_1</span>
    <span class="s3">)</span>

    <span class="s1">tree2 </span><span class="s3">= </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(**</span><span class="s1">tree_params</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X2</span><span class="s3">, </span><span class="s1">y2</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>

    <span class="s2">assert </span><span class="s1">tree1</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">node_count </span><span class="s3">== </span><span class="s1">tree2</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">node_count</span>
    <span class="s6"># Thresholds, tree.tree_.threshold, and values, tree.tree_.value, are not</span>
    <span class="s6"># exactly the same, but on the training set, those differences do not</span>
    <span class="s6"># matter and thus predictions are the same.</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">tree1</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">tree2</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;Tree&quot;</span><span class="s3">, [</span><span class="s1">DecisionTreeClassifier</span><span class="s3">, </span><span class="s1">ExtraTreeClassifier</span><span class="s3">])</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;n_classes&quot;</span><span class="s3">, [</span><span class="s5">2</span><span class="s3">, </span><span class="s5">4</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_criterion_entropy_same_as_log_loss</span><span class="s3">(</span><span class="s1">Tree</span><span class="s3">, </span><span class="s1">n_classes</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Test that criterion=entropy gives same as log_loss.&quot;&quot;&quot;</span>
    <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features </span><span class="s3">= </span><span class="s5">50</span><span class="s3">, </span><span class="s5">5</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">make_classification</span><span class="s3">(</span>
        <span class="s1">n_classes</span><span class="s3">=</span><span class="s1">n_classes</span><span class="s3">,</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">,</span>
        <span class="s1">n_features</span><span class="s3">=</span><span class="s1">n_features</span><span class="s3">,</span>
        <span class="s1">n_informative</span><span class="s3">=</span><span class="s1">n_features</span><span class="s3">,</span>
        <span class="s1">n_redundant</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">random_state</span><span class="s3">=</span><span class="s5">42</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">tree_log_loss </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s4">&quot;log_loss&quot;</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">43</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">tree_entropy </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s4">&quot;entropy&quot;</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">43</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">assert_tree_equal</span><span class="s3">(</span>
        <span class="s1">tree_log_loss</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
        <span class="s1">tree_entropy</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">Tree</span><span class="s2">!r} </span><span class="s4">with criterion 'entropy' and 'log_loss' gave different trees.&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">tree_log_loss</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">tree_entropy</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_different_endianness_pickle</span><span class="s3">():</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">make_classification</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s1">clf </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">3</span><span class="s3">)</span>
    <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">score </span><span class="s3">= </span><span class="s1">clf</span><span class="s3">.</span><span class="s1">score</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">reduce_ndarray</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">byteswap</span><span class="s3">().</span><span class="s1">view</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">newbyteorder</span><span class="s3">()).</span><span class="s1">__reduce__</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">get_pickle_non_native_endianness</span><span class="s3">():</span>
        <span class="s1">f </span><span class="s3">= </span><span class="s1">io</span><span class="s3">.</span><span class="s1">BytesIO</span><span class="s3">()</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">Pickler</span><span class="s3">(</span><span class="s1">f</span><span class="s3">)</span>
        <span class="s1">p</span><span class="s3">.</span><span class="s1">dispatch_table </span><span class="s3">= </span><span class="s1">copyreg</span><span class="s3">.</span><span class="s1">dispatch_table</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">p</span><span class="s3">.</span><span class="s1">dispatch_table</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">] = </span><span class="s1">reduce_ndarray</span>

        <span class="s1">p</span><span class="s3">.</span><span class="s1">dump</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">)</span>
        <span class="s1">f</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">f</span>

    <span class="s1">new_clf </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">get_pickle_non_native_endianness</span><span class="s3">())</span>
    <span class="s1">new_score </span><span class="s3">= </span><span class="s1">new_clf</span><span class="s3">.</span><span class="s1">score</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isclose</span><span class="s3">(</span><span class="s1">score</span><span class="s3">, </span><span class="s1">new_score</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_different_endianness_joblib_pickle</span><span class="s3">():</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">make_classification</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s1">clf </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">3</span><span class="s3">)</span>
    <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">score </span><span class="s3">= </span><span class="s1">clf</span><span class="s3">.</span><span class="s1">score</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">class </span><span class="s1">NonNativeEndiannessNumpyPickler</span><span class="s3">(</span><span class="s1">NumpyPickler</span><span class="s3">):</span>
        <span class="s2">def </span><span class="s1">save</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
                <span class="s1">obj </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">byteswap</span><span class="s3">().</span><span class="s1">view</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">newbyteorder</span><span class="s3">())</span>
            <span class="s1">super</span><span class="s3">().</span><span class="s1">save</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">get_joblib_pickle_non_native_endianness</span><span class="s3">():</span>
        <span class="s1">f </span><span class="s3">= </span><span class="s1">io</span><span class="s3">.</span><span class="s1">BytesIO</span><span class="s3">()</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">NonNativeEndiannessNumpyPickler</span><span class="s3">(</span><span class="s1">f</span><span class="s3">)</span>

        <span class="s1">p</span><span class="s3">.</span><span class="s1">dump</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">)</span>
        <span class="s1">f</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">f</span>

    <span class="s1">new_clf </span><span class="s3">= </span><span class="s1">joblib</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">get_joblib_pickle_non_native_endianness</span><span class="s3">())</span>
    <span class="s1">new_score </span><span class="s3">= </span><span class="s1">new_clf</span><span class="s3">.</span><span class="s1">score</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isclose</span><span class="s3">(</span><span class="s1">score</span><span class="s3">, </span><span class="s1">new_score</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">get_different_bitness_node_ndarray</span><span class="s3">(</span><span class="s1">node_ndarray</span><span class="s3">):</span>
    <span class="s1">new_dtype_for_indexing_fields </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64 </span><span class="s2">if </span><span class="s1">_IS_32BIT </span><span class="s2">else </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span>

    <span class="s6"># field names in Node struct with SIZE_t types (see sklearn/tree/_tree.pxd)</span>
    <span class="s1">indexing_field_names </span><span class="s3">= [</span><span class="s4">&quot;left_child&quot;</span><span class="s3">, </span><span class="s4">&quot;right_child&quot;</span><span class="s3">, </span><span class="s4">&quot;feature&quot;</span><span class="s3">, </span><span class="s4">&quot;n_node_samples&quot;</span><span class="s3">]</span>

    <span class="s1">new_dtype_dict </span><span class="s3">= {</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">dtype </span><span class="s2">for </span><span class="s1">name</span><span class="s3">, (</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">_</span><span class="s3">) </span><span class="s2">in </span><span class="s1">node_ndarray</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
    <span class="s3">}</span>
    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">indexing_field_names</span><span class="s3">:</span>
        <span class="s1">new_dtype_dict</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">new_dtype_for_indexing_fields</span>

    <span class="s1">new_dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span>
        <span class="s3">{</span><span class="s4">&quot;names&quot;</span><span class="s3">: </span><span class="s1">list</span><span class="s3">(</span><span class="s1">new_dtype_dict</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()), </span><span class="s4">&quot;formats&quot;</span><span class="s3">: </span><span class="s1">list</span><span class="s3">(</span><span class="s1">new_dtype_dict</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())}</span>
    <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">node_ndarray</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">new_dtype</span><span class="s3">, </span><span class="s1">casting</span><span class="s3">=</span><span class="s4">&quot;same_kind&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">get_different_alignment_node_ndarray</span><span class="s3">(</span><span class="s1">node_ndarray</span><span class="s3">):</span>
    <span class="s1">new_dtype_dict </span><span class="s3">= {</span>
        <span class="s1">name</span><span class="s3">: </span><span class="s1">dtype </span><span class="s2">for </span><span class="s1">name</span><span class="s3">, (</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">_</span><span class="s3">) </span><span class="s2">in </span><span class="s1">node_ndarray</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()</span>
    <span class="s3">}</span>
    <span class="s1">offsets </span><span class="s3">= [</span><span class="s1">offset </span><span class="s2">for </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">offset </span><span class="s2">in </span><span class="s1">node_ndarray</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()]</span>
    <span class="s1">shifted_offsets </span><span class="s3">= [</span><span class="s5">8 </span><span class="s3">+ </span><span class="s1">offset </span><span class="s2">for </span><span class="s1">offset </span><span class="s2">in </span><span class="s1">offsets</span><span class="s3">]</span>

    <span class="s1">new_dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span>
        <span class="s3">{</span>
            <span class="s4">&quot;names&quot;</span><span class="s3">: </span><span class="s1">list</span><span class="s3">(</span><span class="s1">new_dtype_dict</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()),</span>
            <span class="s4">&quot;formats&quot;</span><span class="s3">: </span><span class="s1">list</span><span class="s3">(</span><span class="s1">new_dtype_dict</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()),</span>
            <span class="s4">&quot;offsets&quot;</span><span class="s3">: </span><span class="s1">shifted_offsets</span><span class="s3">,</span>
        <span class="s3">}</span>
    <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">node_ndarray</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">new_dtype</span><span class="s3">, </span><span class="s1">casting</span><span class="s3">=</span><span class="s4">&quot;same_kind&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">reduce_tree_with_different_bitness</span><span class="s3">(</span><span class="s1">tree</span><span class="s3">):</span>
    <span class="s1">new_dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64 </span><span class="s2">if </span><span class="s1">_IS_32BIT </span><span class="s2">else </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span>
    <span class="s1">tree_cls</span><span class="s3">, (</span><span class="s1">n_features</span><span class="s3">, </span><span class="s1">n_classes</span><span class="s3">, </span><span class="s1">n_outputs</span><span class="s3">), </span><span class="s1">state </span><span class="s3">= </span><span class="s1">tree</span><span class="s3">.</span><span class="s1">__reduce__</span><span class="s3">()</span>
    <span class="s1">new_n_classes </span><span class="s3">= </span><span class="s1">n_classes</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">new_dtype</span><span class="s3">, </span><span class="s1">casting</span><span class="s3">=</span><span class="s4">&quot;same_kind&quot;</span><span class="s3">)</span>

    <span class="s1">new_state </span><span class="s3">= </span><span class="s1">state</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">new_state</span><span class="s3">[</span><span class="s4">&quot;nodes&quot;</span><span class="s3">] = </span><span class="s1">get_different_bitness_node_ndarray</span><span class="s3">(</span><span class="s1">new_state</span><span class="s3">[</span><span class="s4">&quot;nodes&quot;</span><span class="s3">])</span>

    <span class="s2">return </span><span class="s3">(</span><span class="s1">tree_cls</span><span class="s3">, (</span><span class="s1">n_features</span><span class="s3">, </span><span class="s1">new_n_classes</span><span class="s3">, </span><span class="s1">n_outputs</span><span class="s3">), </span><span class="s1">new_state</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_different_bitness_pickle</span><span class="s3">():</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">make_classification</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s1">clf </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">3</span><span class="s3">)</span>
    <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">score </span><span class="s3">= </span><span class="s1">clf</span><span class="s3">.</span><span class="s1">score</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">pickle_dump_with_different_bitness</span><span class="s3">():</span>
        <span class="s1">f </span><span class="s3">= </span><span class="s1">io</span><span class="s3">.</span><span class="s1">BytesIO</span><span class="s3">()</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">Pickler</span><span class="s3">(</span><span class="s1">f</span><span class="s3">)</span>
        <span class="s1">p</span><span class="s3">.</span><span class="s1">dispatch_table </span><span class="s3">= </span><span class="s1">copyreg</span><span class="s3">.</span><span class="s1">dispatch_table</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">p</span><span class="s3">.</span><span class="s1">dispatch_table</span><span class="s3">[</span><span class="s1">CythonTree</span><span class="s3">] = </span><span class="s1">reduce_tree_with_different_bitness</span>

        <span class="s1">p</span><span class="s3">.</span><span class="s1">dump</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">)</span>
        <span class="s1">f</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">f</span>

    <span class="s1">new_clf </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">pickle_dump_with_different_bitness</span><span class="s3">())</span>
    <span class="s1">new_score </span><span class="s3">= </span><span class="s1">new_clf</span><span class="s3">.</span><span class="s1">score</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">score </span><span class="s3">== </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">approx</span><span class="s3">(</span><span class="s1">new_score</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_different_bitness_joblib_pickle</span><span class="s3">():</span>
    <span class="s6"># Make sure that a platform specific pickle generated on a 64 bit</span>
    <span class="s6"># platform can be converted at pickle load time into an estimator</span>
    <span class="s6"># with Cython code that works with the host's native integer precision</span>
    <span class="s6"># to index nodes in the tree data structure when the host is a 32 bit</span>
    <span class="s6"># platform (and vice versa).</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">make_classification</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s1">clf </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">3</span><span class="s3">)</span>
    <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">score </span><span class="s3">= </span><span class="s1">clf</span><span class="s3">.</span><span class="s1">score</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">joblib_dump_with_different_bitness</span><span class="s3">():</span>
        <span class="s1">f </span><span class="s3">= </span><span class="s1">io</span><span class="s3">.</span><span class="s1">BytesIO</span><span class="s3">()</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">NumpyPickler</span><span class="s3">(</span><span class="s1">f</span><span class="s3">)</span>
        <span class="s1">p</span><span class="s3">.</span><span class="s1">dispatch_table </span><span class="s3">= </span><span class="s1">copyreg</span><span class="s3">.</span><span class="s1">dispatch_table</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">p</span><span class="s3">.</span><span class="s1">dispatch_table</span><span class="s3">[</span><span class="s1">CythonTree</span><span class="s3">] = </span><span class="s1">reduce_tree_with_different_bitness</span>

        <span class="s1">p</span><span class="s3">.</span><span class="s1">dump</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">)</span>
        <span class="s1">f</span><span class="s3">.</span><span class="s1">seek</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">f</span>

    <span class="s1">new_clf </span><span class="s3">= </span><span class="s1">joblib</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">joblib_dump_with_different_bitness</span><span class="s3">())</span>
    <span class="s1">new_score </span><span class="s3">= </span><span class="s1">new_clf</span><span class="s3">.</span><span class="s1">score</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">score </span><span class="s3">== </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">approx</span><span class="s3">(</span><span class="s1">new_score</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_check_n_classes</span><span class="s3">():</span>
    <span class="s1">expected_dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">) </span><span class="s2">if </span><span class="s1">_IS_32BIT </span><span class="s2">else </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)</span>
    <span class="s1">allowed_dtypes </span><span class="s3">= [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">)]</span>
    <span class="s1">allowed_dtypes </span><span class="s3">+= [</span><span class="s1">dt</span><span class="s3">.</span><span class="s1">newbyteorder</span><span class="s3">() </span><span class="s2">for </span><span class="s1">dt </span><span class="s2">in </span><span class="s1">allowed_dtypes</span><span class="s3">]</span>

    <span class="s1">n_classes </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">expected_dtype</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">dt </span><span class="s2">in </span><span class="s1">allowed_dtypes</span><span class="s3">:</span>
        <span class="s1">_check_n_classes</span><span class="s3">(</span><span class="s1">n_classes</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dt</span><span class="s3">), </span><span class="s1">expected_dtype</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;Wrong dimensions.+n_classes&quot;</span><span class="s3">):</span>
        <span class="s1">wrong_dim_n_classes </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">expected_dtype</span><span class="s3">)</span>
        <span class="s1">_check_n_classes</span><span class="s3">(</span><span class="s1">wrong_dim_n_classes</span><span class="s3">, </span><span class="s1">expected_dtype</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;n_classes.+incompatible dtype&quot;</span><span class="s3">):</span>
        <span class="s1">wrong_dtype_n_classes </span><span class="s3">= </span><span class="s1">n_classes</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
        <span class="s1">_check_n_classes</span><span class="s3">(</span><span class="s1">wrong_dtype_n_classes</span><span class="s3">, </span><span class="s1">expected_dtype</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_check_value_ndarray</span><span class="s3">():</span>
    <span class="s1">expected_dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s1">expected_shape </span><span class="s3">= (</span><span class="s5">5</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">value_ndarray </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">expected_shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">expected_dtype</span><span class="s3">)</span>

    <span class="s1">allowed_dtypes </span><span class="s3">= [</span><span class="s1">expected_dtype</span><span class="s3">, </span><span class="s1">expected_dtype</span><span class="s3">.</span><span class="s1">newbyteorder</span><span class="s3">()]</span>

    <span class="s2">for </span><span class="s1">dt </span><span class="s2">in </span><span class="s1">allowed_dtypes</span><span class="s3">:</span>
        <span class="s1">_check_value_ndarray</span><span class="s3">(</span>
            <span class="s1">value_ndarray</span><span class="s3">, </span><span class="s1">expected_dtype</span><span class="s3">=</span><span class="s1">dt</span><span class="s3">, </span><span class="s1">expected_shape</span><span class="s3">=</span><span class="s1">expected_shape</span>
        <span class="s3">)</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;Wrong shape.+value array&quot;</span><span class="s3">):</span>
        <span class="s1">_check_value_ndarray</span><span class="s3">(</span>
            <span class="s1">value_ndarray</span><span class="s3">, </span><span class="s1">expected_dtype</span><span class="s3">=</span><span class="s1">expected_dtype</span><span class="s3">, </span><span class="s1">expected_shape</span><span class="s3">=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
        <span class="s3">)</span>

    <span class="s2">for </span><span class="s1">problematic_arr </span><span class="s2">in </span><span class="s3">[</span><span class="s1">value_ndarray</span><span class="s3">[:, :, :</span><span class="s5">1</span><span class="s3">], </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asfortranarray</span><span class="s3">(</span><span class="s1">value_ndarray</span><span class="s3">)]:</span>
        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;value array.+C-contiguous&quot;</span><span class="s3">):</span>
            <span class="s1">_check_value_ndarray</span><span class="s3">(</span>
                <span class="s1">problematic_arr</span><span class="s3">,</span>
                <span class="s1">expected_dtype</span><span class="s3">=</span><span class="s1">expected_dtype</span><span class="s3">,</span>
                <span class="s1">expected_shape</span><span class="s3">=</span><span class="s1">problematic_arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">,</span>
            <span class="s3">)</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;value array.+incompatible dtype&quot;</span><span class="s3">):</span>
        <span class="s1">_check_value_ndarray</span><span class="s3">(</span>
            <span class="s1">value_ndarray</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">),</span>
            <span class="s1">expected_dtype</span><span class="s3">=</span><span class="s1">expected_dtype</span><span class="s3">,</span>
            <span class="s1">expected_shape</span><span class="s3">=</span><span class="s1">expected_shape</span><span class="s3">,</span>
        <span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_check_node_ndarray</span><span class="s3">():</span>
    <span class="s1">expected_dtype </span><span class="s3">= </span><span class="s1">NODE_DTYPE</span>

    <span class="s1">node_ndarray </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s5">5</span><span class="s3">,), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">expected_dtype</span><span class="s3">)</span>

    <span class="s1">valid_node_ndarrays </span><span class="s3">= [</span>
        <span class="s1">node_ndarray</span><span class="s3">,</span>
        <span class="s1">get_different_bitness_node_ndarray</span><span class="s3">(</span><span class="s1">node_ndarray</span><span class="s3">),</span>
        <span class="s1">get_different_alignment_node_ndarray</span><span class="s3">(</span><span class="s1">node_ndarray</span><span class="s3">),</span>
    <span class="s3">]</span>
    <span class="s1">valid_node_ndarrays </span><span class="s3">+= [</span>
        <span class="s1">arr</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">newbyteorder</span><span class="s3">()) </span><span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">valid_node_ndarrays</span>
    <span class="s3">]</span>

    <span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">valid_node_ndarrays</span><span class="s3">:</span>
        <span class="s1">_check_node_ndarray</span><span class="s3">(</span><span class="s1">node_ndarray</span><span class="s3">, </span><span class="s1">expected_dtype</span><span class="s3">=</span><span class="s1">expected_dtype</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;Wrong dimensions.+node array&quot;</span><span class="s3">):</span>
        <span class="s1">problematic_node_ndarray </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s5">5</span><span class="s3">, </span><span class="s5">2</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">expected_dtype</span><span class="s3">)</span>
        <span class="s1">_check_node_ndarray</span><span class="s3">(</span><span class="s1">problematic_node_ndarray</span><span class="s3">, </span><span class="s1">expected_dtype</span><span class="s3">=</span><span class="s1">expected_dtype</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;node array.+C-contiguous&quot;</span><span class="s3">):</span>
        <span class="s1">problematic_node_ndarray </span><span class="s3">= </span><span class="s1">node_ndarray</span><span class="s3">[::</span><span class="s5">2</span><span class="s3">]</span>
        <span class="s1">_check_node_ndarray</span><span class="s3">(</span><span class="s1">problematic_node_ndarray</span><span class="s3">, </span><span class="s1">expected_dtype</span><span class="s3">=</span><span class="s1">expected_dtype</span><span class="s3">)</span>

    <span class="s1">dtype_dict </span><span class="s3">= {</span><span class="s1">name</span><span class="s3">: </span><span class="s1">dtype </span><span class="s2">for </span><span class="s1">name</span><span class="s3">, (</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">_</span><span class="s3">) </span><span class="s2">in </span><span class="s1">node_ndarray</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">fields</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()}</span>

    <span class="s6"># array with wrong 'threshold' field dtype (int64 rather than float64)</span>
    <span class="s1">new_dtype_dict </span><span class="s3">= </span><span class="s1">dtype_dict</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">new_dtype_dict</span><span class="s3">[</span><span class="s4">&quot;threshold&quot;</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">int64</span>

    <span class="s1">new_dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span>
        <span class="s3">{</span><span class="s4">&quot;names&quot;</span><span class="s3">: </span><span class="s1">list</span><span class="s3">(</span><span class="s1">new_dtype_dict</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()), </span><span class="s4">&quot;formats&quot;</span><span class="s3">: </span><span class="s1">list</span><span class="s3">(</span><span class="s1">new_dtype_dict</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())}</span>
    <span class="s3">)</span>
    <span class="s1">problematic_node_ndarray </span><span class="s3">= </span><span class="s1">node_ndarray</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">new_dtype</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;node array.+incompatible dtype&quot;</span><span class="s3">):</span>
        <span class="s1">_check_node_ndarray</span><span class="s3">(</span><span class="s1">problematic_node_ndarray</span><span class="s3">, </span><span class="s1">expected_dtype</span><span class="s3">=</span><span class="s1">expected_dtype</span><span class="s3">)</span>

    <span class="s6"># array with wrong 'left_child' field dtype (float64 rather than int64 or int32)</span>
    <span class="s1">new_dtype_dict </span><span class="s3">= </span><span class="s1">dtype_dict</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">new_dtype_dict</span><span class="s3">[</span><span class="s4">&quot;left_child&quot;</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span>
    <span class="s1">new_dtype </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span>
        <span class="s3">{</span><span class="s4">&quot;names&quot;</span><span class="s3">: </span><span class="s1">list</span><span class="s3">(</span><span class="s1">new_dtype_dict</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()), </span><span class="s4">&quot;formats&quot;</span><span class="s3">: </span><span class="s1">list</span><span class="s3">(</span><span class="s1">new_dtype_dict</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())}</span>
    <span class="s3">)</span>

    <span class="s1">problematic_node_ndarray </span><span class="s3">= </span><span class="s1">node_ndarray</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">new_dtype</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;node array.+incompatible dtype&quot;</span><span class="s3">):</span>
        <span class="s1">_check_node_ndarray</span><span class="s3">(</span><span class="s1">problematic_node_ndarray</span><span class="s3">, </span><span class="s1">expected_dtype</span><span class="s3">=</span><span class="s1">expected_dtype</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s4">&quot;Splitter&quot;</span><span class="s3">, </span><span class="s1">chain</span><span class="s3">(</span><span class="s1">DENSE_SPLITTERS</span><span class="s3">.</span><span class="s1">values</span><span class="s3">(), </span><span class="s1">SPARSE_SPLITTERS</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_splitter_serializable</span><span class="s3">(</span><span class="s1">Splitter</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check that splitters are serializable.&quot;&quot;&quot;</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s5">42</span><span class="s3">)</span>
    <span class="s1">max_features </span><span class="s3">= </span><span class="s5">10</span>
    <span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">n_classes </span><span class="s3">= </span><span class="s5">2</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">)</span>

    <span class="s1">criterion </span><span class="s3">= </span><span class="s1">CRITERIA_CLF</span><span class="s3">[</span><span class="s4">&quot;gini&quot;</span><span class="s3">](</span><span class="s1">n_outputs</span><span class="s3">, </span><span class="s1">n_classes</span><span class="s3">)</span>
    <span class="s1">splitter </span><span class="s3">= </span><span class="s1">Splitter</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">, </span><span class="s1">max_features</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">rng</span><span class="s3">, </span><span class="s1">monotonic_cst</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>
    <span class="s1">splitter_serialize </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">dumps</span><span class="s3">(</span><span class="s1">splitter</span><span class="s3">)</span>

    <span class="s1">splitter_back </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">loads</span><span class="s3">(</span><span class="s1">splitter_serialize</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">splitter_back</span><span class="s3">.</span><span class="s1">max_features </span><span class="s3">== </span><span class="s1">max_features</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">splitter_back</span><span class="s3">, </span><span class="s1">Splitter</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_tree_deserialization_from_read_only_buffer</span><span class="s3">(</span><span class="s1">tmpdir</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check that Trees can be deserialized with read only buffers. 
 
    Non-regression test for gh-25584. 
    &quot;&quot;&quot;</span>
    <span class="s1">pickle_path </span><span class="s3">= </span><span class="s1">str</span><span class="s3">(</span><span class="s1">tmpdir</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s4">&quot;clf.joblib&quot;</span><span class="s3">))</span>
    <span class="s1">clf </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">clf</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_small</span><span class="s3">, </span><span class="s1">y_small</span><span class="s3">)</span>

    <span class="s1">joblib</span><span class="s3">.</span><span class="s1">dump</span><span class="s3">(</span><span class="s1">clf</span><span class="s3">, </span><span class="s1">pickle_path</span><span class="s3">)</span>
    <span class="s1">loaded_clf </span><span class="s3">= </span><span class="s1">joblib</span><span class="s3">.</span><span class="s1">load</span><span class="s3">(</span><span class="s1">pickle_path</span><span class="s3">, </span><span class="s1">mmap_mode</span><span class="s3">=</span><span class="s4">&quot;r&quot;</span><span class="s3">)</span>

    <span class="s1">assert_tree_equal</span><span class="s3">(</span>
        <span class="s1">loaded_clf</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
        <span class="s1">clf</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">,</span>
        <span class="s4">&quot;The trees of the original and loaded classifiers are not equal.&quot;</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;Tree&quot;</span><span class="s3">, </span><span class="s1">ALL_TREES</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())</span>
<span class="s2">def </span><span class="s1">test_min_sample_split_1_error</span><span class="s3">(</span><span class="s1">Tree</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check that an error is raised when min_sample_split=1. 
 
    non-regression test for issue gh-25481. 
    &quot;&quot;&quot;</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">], [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">]])</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">])</span>

    <span class="s6"># min_samples_split=1.0 is valid</span>
    <span class="s1">Tree</span><span class="s3">(</span><span class="s1">min_samples_split</span><span class="s3">=</span><span class="s5">1.0</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s6"># min_samples_split=1 is invalid</span>
    <span class="s1">tree </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">min_samples_split</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">msg </span><span class="s3">= (</span>
        <span class="s4">r&quot;'min_samples_split' .* must be an int in the range \[2, inf\) &quot;</span>
        <span class="s4">r&quot;or a float in the range \(0.0, 1.0\]&quot;</span>
    <span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">tree</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;criterion&quot;</span><span class="s3">, [</span><span class="s4">&quot;squared_error&quot;</span><span class="s3">, </span><span class="s4">&quot;friedman_mse&quot;</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_missing_values_on_equal_nodes_no_missing</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check missing values goes to correct node during predictions&quot;&quot;&quot;</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">8</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">11</span><span class="s3">, </span><span class="s5">12</span><span class="s3">, </span><span class="s5">15</span><span class="s3">]]).</span><span class="s1">T</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">0.1</span><span class="s3">, </span><span class="s5">0.2</span><span class="s3">, </span><span class="s5">0.3</span><span class="s3">, </span><span class="s5">0.2</span><span class="s3">, </span><span class="s5">1.4</span><span class="s3">, </span><span class="s5">1.4</span><span class="s3">, </span><span class="s5">1.5</span><span class="s3">, </span><span class="s5">1.6</span><span class="s3">, </span><span class="s5">2.6</span><span class="s3">])</span>

    <span class="s1">dtc </span><span class="s3">= </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">42</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">criterion</span><span class="s3">=</span><span class="s1">criterion</span><span class="s3">)</span>
    <span class="s1">dtc</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s6"># Goes to right node because it has the most data points</span>
    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">dtc</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">([[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">]])</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">, [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[-</span><span class="s5">5</span><span class="s3">:])])</span>

    <span class="s6"># equal number of elements in both nodes</span>
    <span class="s1">X_equal </span><span class="s3">= </span><span class="s1">X</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]</span>
    <span class="s1">y_equal </span><span class="s3">= </span><span class="s1">y</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">]</span>

    <span class="s1">dtc </span><span class="s3">= </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">42</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">criterion</span><span class="s3">=</span><span class="s1">criterion</span><span class="s3">)</span>
    <span class="s1">dtc</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_equal</span><span class="s3">, </span><span class="s1">y_equal</span><span class="s3">)</span>

    <span class="s6"># Goes to right node because the implementation sets:</span>
    <span class="s6"># missing_go_to_left = n_left &gt; n_right, which is False</span>
    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">dtc</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">([[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">]])</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">, [</span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">y_equal</span><span class="s3">[-</span><span class="s5">4</span><span class="s3">:])])</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;criterion&quot;</span><span class="s3">, [</span><span class="s4">&quot;entropy&quot;</span><span class="s3">, </span><span class="s4">&quot;gini&quot;</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_missing_values_best_splitter_three_classes</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Test when missing values are uniquely present in a class among 3 classes.&quot;&quot;&quot;</span>
    <span class="s1">missing_values_class </span><span class="s3">= </span><span class="s5">0</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">] * </span><span class="s5">4 </span><span class="s3">+ [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">8</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">11</span><span class="s3">, </span><span class="s5">12</span><span class="s3">]]).</span><span class="s1">T</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">missing_values_class</span><span class="s3">] * </span><span class="s5">4 </span><span class="s3">+ [</span><span class="s5">1</span><span class="s3">] * </span><span class="s5">4 </span><span class="s3">+ [</span><span class="s5">2</span><span class="s3">] * </span><span class="s5">4</span><span class="s3">)</span>
    <span class="s1">dtc </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">42</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">2</span><span class="s3">, </span><span class="s1">criterion</span><span class="s3">=</span><span class="s1">criterion</span><span class="s3">)</span>
    <span class="s1">dtc</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">X_test </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">12</span><span class="s3">]]).</span><span class="s1">T</span>
    <span class="s1">y_nan_pred </span><span class="s3">= </span><span class="s1">dtc</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">)</span>
    <span class="s6"># Missing values necessarily are associated to the observed class.</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">y_nan_pred</span><span class="s3">, [</span><span class="s1">missing_values_class</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">])</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;criterion&quot;</span><span class="s3">, [</span><span class="s4">&quot;entropy&quot;</span><span class="s3">, </span><span class="s4">&quot;gini&quot;</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_missing_values_best_splitter_to_left</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Missing values spanning only one class at fit-time must make missing 
    values at predict-time be classified has belonging to this class.&quot;&quot;&quot;</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">] * </span><span class="s5">4 </span><span class="s3">+ [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">]]).</span><span class="s1">T</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">0</span><span class="s3">] * </span><span class="s5">4 </span><span class="s3">+ [</span><span class="s5">1</span><span class="s3">] * </span><span class="s5">6</span><span class="s3">)</span>

    <span class="s1">dtc </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">42</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">2</span><span class="s3">, </span><span class="s1">criterion</span><span class="s3">=</span><span class="s1">criterion</span><span class="s3">)</span>
    <span class="s1">dtc</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">X_test </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">]]).</span><span class="s1">T</span>
    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">dtc</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">)</span>

    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">, [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">])</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;criterion&quot;</span><span class="s3">, [</span><span class="s4">&quot;entropy&quot;</span><span class="s3">, </span><span class="s4">&quot;gini&quot;</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_missing_values_best_splitter_to_right</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Missing values and non-missing values sharing one class at fit-time 
    must make missing values at predict-time be classified has belonging 
    to this class.&quot;&quot;&quot;</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">] * </span><span class="s5">4 </span><span class="s3">+ [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">]]).</span><span class="s1">T</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">1</span><span class="s3">] * </span><span class="s5">4 </span><span class="s3">+ [</span><span class="s5">0</span><span class="s3">] * </span><span class="s5">4 </span><span class="s3">+ [</span><span class="s5">1</span><span class="s3">] * </span><span class="s5">2</span><span class="s3">)</span>

    <span class="s1">dtc </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">42</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">2</span><span class="s3">, </span><span class="s1">criterion</span><span class="s3">=</span><span class="s1">criterion</span><span class="s3">)</span>
    <span class="s1">dtc</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">X_test </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s5">1.2</span><span class="s3">, </span><span class="s5">4.8</span><span class="s3">]]).</span><span class="s1">T</span>
    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">dtc</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">)</span>

    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">, [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">])</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;criterion&quot;</span><span class="s3">, [</span><span class="s4">&quot;entropy&quot;</span><span class="s3">, </span><span class="s4">&quot;gini&quot;</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_missing_values_missing_both_classes_has_nan</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check behavior of missing value when there is one missing value in each class.&quot;&quot;&quot;</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">20</span><span class="s3">, </span><span class="s5">30</span><span class="s3">, </span><span class="s5">60</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">]]).</span><span class="s1">T</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">0</span><span class="s3">] * </span><span class="s5">5 </span><span class="s3">+ [</span><span class="s5">1</span><span class="s3">] * </span><span class="s5">5</span><span class="s3">)</span>

    <span class="s1">dtc </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">42</span><span class="s3">, </span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">criterion</span><span class="s3">=</span><span class="s1">criterion</span><span class="s3">)</span>
    <span class="s1">dtc</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">X_test </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s5">2.3</span><span class="s3">, </span><span class="s5">34.2</span><span class="s3">]]).</span><span class="s1">T</span>
    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">dtc</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">)</span>

    <span class="s6"># Missing value goes to the class at the right (here 1) because the implementation</span>
    <span class="s6"># searches right first.</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">y_pred</span><span class="s3">, [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">])</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;sparse_container&quot;</span><span class="s3">, [</span><span class="s2">None</span><span class="s3">] + </span><span class="s1">CSR_CONTAINERS</span><span class="s3">)</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s4">&quot;tree&quot;</span><span class="s3">,</span>
    <span class="s3">[</span>
        <span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">splitter</span><span class="s3">=</span><span class="s4">&quot;random&quot;</span><span class="s3">),</span>
        <span class="s1">DecisionTreeRegressor</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s4">&quot;absolute_error&quot;</span><span class="s3">),</span>
    <span class="s3">],</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_missing_value_errors</span><span class="s3">(</span><span class="s1">sparse_container</span><span class="s3">, </span><span class="s1">tree</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check unsupported configurations for missing values.&quot;&quot;&quot;</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">20</span><span class="s3">, </span><span class="s5">30</span><span class="s3">, </span><span class="s5">60</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">]]).</span><span class="s1">T</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">0</span><span class="s3">] * </span><span class="s5">5 </span><span class="s3">+ [</span><span class="s5">1</span><span class="s3">] * </span><span class="s5">5</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">sparse_container </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">sparse_container</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s4">&quot;Input X contains NaN&quot;</span><span class="s3">):</span>
        <span class="s1">tree</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_missing_values_poisson</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Smoke test for poisson regression and missing values.&quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">data</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(), </span><span class="s1">diabetes</span><span class="s3">.</span><span class="s1">target</span>

    <span class="s6"># Set some values missing</span>
    <span class="s1">X</span><span class="s3">[::</span><span class="s5">5</span><span class="s3">, </span><span class="s5">0</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
    <span class="s1">X</span><span class="s3">[::</span><span class="s5">6</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>

    <span class="s1">reg </span><span class="s3">= </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s4">&quot;poisson&quot;</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">42</span><span class="s3">)</span>
    <span class="s1">reg</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">y_pred </span><span class="s3">= </span><span class="s1">reg</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s3">(</span><span class="s1">y_pred </span><span class="s3">&gt;= </span><span class="s5">0.0</span><span class="s3">).</span><span class="s1">all</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">make_friedman1_classification</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">make_friedman1</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">y </span><span class="s3">&gt; </span><span class="s5">14</span>
    <span class="s2">return </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s4">&quot;make_data,Tree&quot;</span><span class="s3">,</span>
    <span class="s3">[</span>
        <span class="s3">(</span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">make_friedman1</span><span class="s3">, </span><span class="s1">DecisionTreeRegressor</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">make_friedman1_classification</span><span class="s3">, </span><span class="s1">DecisionTreeClassifier</span><span class="s3">),</span>
    <span class="s3">],</span>
<span class="s3">)</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;sample_weight_train&quot;</span><span class="s3">, [</span><span class="s2">None</span><span class="s3">, </span><span class="s4">&quot;ones&quot;</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_missing_values_is_resilience</span><span class="s3">(</span>
    <span class="s1">make_data</span><span class="s3">, </span><span class="s1">Tree</span><span class="s3">, </span><span class="s1">sample_weight_train</span><span class="s3">, </span><span class="s1">global_random_seed</span>
<span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check that trees can deal with missing values have decent performance.&quot;&quot;&quot;</span>
    <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features </span><span class="s3">= </span><span class="s5">5_000</span><span class="s3">, </span><span class="s5">10</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_data</span><span class="s3">(</span>
        <span class="s1">n_samples</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features</span><span class="s3">=</span><span class="s1">n_features</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">global_random_seed</span>
    <span class="s3">)</span>

    <span class="s1">X_missing </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s1">global_random_seed</span><span class="s3">)</span>
    <span class="s1">X_missing</span><span class="s3">[</span><span class="s1">rng</span><span class="s3">.</span><span class="s1">choice</span><span class="s3">([</span><span class="s2">False</span><span class="s3">, </span><span class="s2">True</span><span class="s3">], </span><span class="s1">size</span><span class="s3">=</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">p</span><span class="s3">=[</span><span class="s5">0.9</span><span class="s3">, </span><span class="s5">0.1</span><span class="s3">])] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
    <span class="s1">X_missing_train</span><span class="s3">, </span><span class="s1">X_missing_test</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">y_test </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span>
        <span class="s1">X_missing</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">global_random_seed</span>
    <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">sample_weight_train </span><span class="s3">== </span><span class="s4">&quot;ones&quot;</span><span class="s3">:</span>
        <span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">X_missing_train</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">sample_weight </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s1">native_tree </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">global_random_seed</span><span class="s3">)</span>
    <span class="s1">native_tree</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_missing_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">sample_weight</span><span class="s3">)</span>
    <span class="s1">score_native_tree </span><span class="s3">= </span><span class="s1">native_tree</span><span class="s3">.</span><span class="s1">score</span><span class="s3">(</span><span class="s1">X_missing_test</span><span class="s3">, </span><span class="s1">y_test</span><span class="s3">)</span>

    <span class="s1">tree_with_imputer </span><span class="s3">= </span><span class="s1">make_pipeline</span><span class="s3">(</span>
        <span class="s1">SimpleImputer</span><span class="s3">(), </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">max_depth</span><span class="s3">=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">global_random_seed</span><span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s1">tree_with_imputer</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_missing_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>
    <span class="s1">score_tree_with_imputer </span><span class="s3">= </span><span class="s1">tree_with_imputer</span><span class="s3">.</span><span class="s1">score</span><span class="s3">(</span><span class="s1">X_missing_test</span><span class="s3">, </span><span class="s1">y_test</span><span class="s3">)</span>

    <span class="s2">assert </span><span class="s3">(</span>
        <span class="s1">score_native_tree </span><span class="s3">&gt; </span><span class="s1">score_tree_with_imputer</span>
    <span class="s3">), </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">score_native_tree</span><span class="s3">=</span><span class="s2">} </span><span class="s4">should be strictly greater than </span><span class="s2">{</span><span class="s1">score_tree_with_imputer</span><span class="s2">}</span><span class="s4">&quot;</span>


<span class="s2">def </span><span class="s1">test_missing_value_is_predictive</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Check the tree learns when only the missing value is predictive.&quot;&quot;&quot;</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s5">1000</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">standard_normal</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s5">10</span><span class="s3">))</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">high</span><span class="s3">=</span><span class="s5">2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">)</span>

    <span class="s6"># Create a predictive feature using `y` and with some noise</span>
    <span class="s1">X_random_mask </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">choice</span><span class="s3">([</span><span class="s2">False</span><span class="s3">, </span><span class="s2">True</span><span class="s3">], </span><span class="s1">size</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">p</span><span class="s3">=[</span><span class="s5">0.95</span><span class="s3">, </span><span class="s5">0.05</span><span class="s3">])</span>
    <span class="s1">y_mask </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">().</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s1">y_mask</span><span class="s3">[</span><span class="s1">X_random_mask</span><span class="s3">] = ~</span><span class="s1">y_mask</span><span class="s3">[</span><span class="s1">X_random_mask</span><span class="s3">]</span>

    <span class="s1">X_predictive </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">standard_normal</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s1">X_predictive</span><span class="s3">[</span><span class="s1">y_mask</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>

    <span class="s1">X</span><span class="s3">[:, </span><span class="s5">5</span><span class="s3">] = </span><span class="s1">X_predictive</span>

    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">y_test </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">rng</span><span class="s3">)</span>
    <span class="s1">tree </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">rng</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">)</span>

    <span class="s2">assert </span><span class="s1">tree</span><span class="s3">.</span><span class="s1">score</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">) &gt;= </span><span class="s5">0.85</span>
    <span class="s2">assert </span><span class="s1">tree</span><span class="s3">.</span><span class="s1">score</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_test</span><span class="s3">) &gt;= </span><span class="s5">0.85</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s4">&quot;make_data, Tree&quot;</span><span class="s3">,</span>
    <span class="s3">[</span>
        <span class="s3">(</span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">make_regression</span><span class="s3">, </span><span class="s1">DecisionTreeRegressor</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">make_classification</span><span class="s3">, </span><span class="s1">DecisionTreeClassifier</span><span class="s3">),</span>
    <span class="s3">],</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_sample_weight_non_uniform</span><span class="s3">(</span><span class="s1">make_data</span><span class="s3">, </span><span class="s1">Tree</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check sample weight is correctly handled with missing values.&quot;&quot;&quot;</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features </span><span class="s3">= </span><span class="s5">1000</span><span class="s3">, </span><span class="s5">10</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_data</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">n_features</span><span class="s3">=</span><span class="s1">n_features</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">rng</span><span class="s3">)</span>

    <span class="s6"># Create dataset with missing values</span>
    <span class="s1">X</span><span class="s3">[</span><span class="s1">rng</span><span class="s3">.</span><span class="s1">choice</span><span class="s3">([</span><span class="s2">False</span><span class="s3">, </span><span class="s2">True</span><span class="s3">], </span><span class="s1">size</span><span class="s3">=</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">p</span><span class="s3">=[</span><span class="s5">0.9</span><span class="s3">, </span><span class="s5">0.1</span><span class="s3">])] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>

    <span class="s6"># Zero sample weight is the same as removing the sample</span>
    <span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">])</span>
    <span class="s1">sample_weight</span><span class="s3">[::</span><span class="s5">2</span><span class="s3">] = </span><span class="s5">0.0</span>

    <span class="s1">tree_with_sw </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">tree_with_sw</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s1">sample_weight</span><span class="s3">)</span>

    <span class="s1">tree_samples_removed </span><span class="s3">= </span><span class="s1">Tree</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s1">tree_samples_removed</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">[</span><span class="s5">1</span><span class="s3">::</span><span class="s5">2</span><span class="s3">, :], </span><span class="s1">y</span><span class="s3">[</span><span class="s5">1</span><span class="s3">::</span><span class="s5">2</span><span class="s3">])</span>

    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">tree_samples_removed</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">tree_with_sw</span><span class="s3">.</span><span class="s1">predict</span><span class="s3">(</span><span class="s1">X</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_deterministic_pickle</span><span class="s3">():</span>
    <span class="s6"># Non-regression test for:</span>
    <span class="s6"># https://github.com/scikit-learn/scikit-learn/issues/27268</span>
    <span class="s6"># Uninitialised memory would lead to the two pickle strings being different.</span>
    <span class="s1">tree1 </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>
    <span class="s1">tree2 </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">iris</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">iris</span><span class="s3">.</span><span class="s1">target</span><span class="s3">)</span>

    <span class="s1">pickle1 </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">dumps</span><span class="s3">(</span><span class="s1">tree1</span><span class="s3">)</span>
    <span class="s1">pickle2 </span><span class="s3">= </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">dumps</span><span class="s3">(</span><span class="s1">tree2</span><span class="s3">)</span>

    <span class="s2">assert </span><span class="s1">pickle1 </span><span class="s3">== </span><span class="s1">pickle2</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s4">&quot;X&quot;</span><span class="s3">,</span>
    <span class="s3">[</span>
        <span class="s6"># missing values will go left for greedy splits</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s3">]),</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s3">]),</span>
        <span class="s6"># missing values will go right for greedy splits</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">]),</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">]),</span>
    <span class="s3">],</span>
<span class="s3">)</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s4">&quot;criterion&quot;</span><span class="s3">, [</span><span class="s4">&quot;squared_error&quot;</span><span class="s3">, </span><span class="s4">&quot;friedman_mse&quot;</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_regression_tree_missing_values_toy</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">criterion</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check that we properly handle missing values in regression trees using a toy 
    dataset. 
 
    The regression targeted by this test was that we were not reinitializing the 
    criterion when it comes to the number of missing values. Therefore, the value 
    of the critetion (i.e. MSE) was completely wrong. 
 
    This test check that the MSE is null when there is a single sample in the leaf. 
 
    Non-regression test for: 
    https://github.com/scikit-learn/scikit-learn/issues/28254 
    https://github.com/scikit-learn/scikit-learn/issues/28316 
    &quot;&quot;&quot;</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">6</span><span class="s3">)</span>

    <span class="s1">tree </span><span class="s3">= </span><span class="s1">DecisionTreeRegressor</span><span class="s3">(</span><span class="s1">criterion</span><span class="s3">=</span><span class="s1">criterion</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">0</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">tree_ref </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">tree</span><span class="s3">).</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">all</span><span class="s3">(</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">impurity </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">)  </span><span class="s6"># MSE should always be positive</span>
    <span class="s6"># Check the impurity match after the first split</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">impurity</span><span class="s3">[:</span><span class="s5">2</span><span class="s3">], </span><span class="s1">tree_ref</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">impurity</span><span class="s3">[:</span><span class="s5">2</span><span class="s3">])</span>

    <span class="s6"># Find the leaves with a single sample where the MSE should be 0</span>
    <span class="s1">leaves_idx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">flatnonzero</span><span class="s3">(</span>
        <span class="s3">(</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">children_left </span><span class="s3">== -</span><span class="s5">1</span><span class="s3">) &amp; (</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">n_node_samples </span><span class="s3">== </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">impurity</span><span class="s3">[</span><span class="s1">leaves_idx</span><span class="s3">], </span><span class="s5">0.0</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_classification_tree_missing_values_toy</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Check that we properly handle missing values in clasification trees using a toy 
    dataset. 
 
    The test is more involved because we use a case where we detected a regression 
    in a random forest. We therefore define the seed and bootstrap indices to detect 
    one of the non-frequent regression. 
 
    Here, we check that the impurity is null or positive in the leaves. 
 
    Non-regression test for: 
    https://github.com/scikit-learn/scikit-learn/issues/28254 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">datasets</span><span class="s3">.</span><span class="s1">load_iris</span><span class="s3">(</span><span class="s1">return_X_y</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s5">42</span><span class="s3">)</span>
    <span class="s1">X_missing </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">mask </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">binomial</span><span class="s3">(</span>
        <span class="s1">n</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">=(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">4</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">), </span><span class="s1">p</span><span class="s3">=</span><span class="s1">X</span><span class="s3">[:, [</span><span class="s5">2</span><span class="s3">]] / </span><span class="s5">8</span>
    <span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">bool</span><span class="s3">)</span>
    <span class="s1">X_missing</span><span class="s3">[</span><span class="s1">mask</span><span class="s3">] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">X_missing</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">13</span><span class="s3">)</span>

    <span class="s6"># fmt: off</span>
    <span class="s6"># no black reformatting for this specific array</span>
    <span class="s1">indices </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span>
        <span class="s5">2</span><span class="s3">, </span><span class="s5">81</span><span class="s3">, </span><span class="s5">39</span><span class="s3">, </span><span class="s5">97</span><span class="s3">, </span><span class="s5">91</span><span class="s3">, </span><span class="s5">38</span><span class="s3">, </span><span class="s5">46</span><span class="s3">, </span><span class="s5">31</span><span class="s3">, </span><span class="s5">101</span><span class="s3">, </span><span class="s5">13</span><span class="s3">, </span><span class="s5">89</span><span class="s3">, </span><span class="s5">82</span><span class="s3">, </span><span class="s5">100</span><span class="s3">, </span><span class="s5">42</span><span class="s3">, </span><span class="s5">69</span><span class="s3">, </span><span class="s5">27</span><span class="s3">, </span><span class="s5">81</span><span class="s3">, </span><span class="s5">16</span><span class="s3">, </span><span class="s5">73</span><span class="s3">, </span><span class="s5">74</span><span class="s3">,</span>
        <span class="s5">51</span><span class="s3">, </span><span class="s5">47</span><span class="s3">, </span><span class="s5">107</span><span class="s3">, </span><span class="s5">17</span><span class="s3">, </span><span class="s5">75</span><span class="s3">, </span><span class="s5">110</span><span class="s3">, </span><span class="s5">20</span><span class="s3">, </span><span class="s5">15</span><span class="s3">, </span><span class="s5">104</span><span class="s3">, </span><span class="s5">57</span><span class="s3">, </span><span class="s5">26</span><span class="s3">, </span><span class="s5">15</span><span class="s3">, </span><span class="s5">75</span><span class="s3">, </span><span class="s5">79</span><span class="s3">, </span><span class="s5">35</span><span class="s3">, </span><span class="s5">77</span><span class="s3">, </span><span class="s5">90</span><span class="s3">, </span><span class="s5">51</span><span class="s3">, </span><span class="s5">46</span><span class="s3">,</span>
        <span class="s5">13</span><span class="s3">, </span><span class="s5">94</span><span class="s3">, </span><span class="s5">91</span><span class="s3">, </span><span class="s5">23</span><span class="s3">, </span><span class="s5">8</span><span class="s3">, </span><span class="s5">93</span><span class="s3">, </span><span class="s5">93</span><span class="s3">, </span><span class="s5">73</span><span class="s3">, </span><span class="s5">77</span><span class="s3">, </span><span class="s5">12</span><span class="s3">, </span><span class="s5">13</span><span class="s3">, </span><span class="s5">74</span><span class="s3">, </span><span class="s5">109</span><span class="s3">, </span><span class="s5">110</span><span class="s3">, </span><span class="s5">24</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">23</span><span class="s3">, </span><span class="s5">104</span><span class="s3">, </span><span class="s5">27</span><span class="s3">,</span>
        <span class="s5">92</span><span class="s3">, </span><span class="s5">52</span><span class="s3">, </span><span class="s5">20</span><span class="s3">, </span><span class="s5">109</span><span class="s3">, </span><span class="s5">8</span><span class="s3">, </span><span class="s5">8</span><span class="s3">, </span><span class="s5">28</span><span class="s3">, </span><span class="s5">27</span><span class="s3">, </span><span class="s5">35</span><span class="s3">, </span><span class="s5">12</span><span class="s3">, </span><span class="s5">12</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">43</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">30</span><span class="s3">, </span><span class="s5">31</span><span class="s3">, </span><span class="s5">78</span><span class="s3">, </span><span class="s5">12</span><span class="s3">, </span><span class="s5">24</span><span class="s3">, </span><span class="s5">105</span><span class="s3">,</span>
        <span class="s5">50</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">73</span><span class="s3">, </span><span class="s5">12</span><span class="s3">, </span><span class="s5">102</span><span class="s3">, </span><span class="s5">105</span><span class="s3">, </span><span class="s5">13</span><span class="s3">, </span><span class="s5">31</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">69</span><span class="s3">, </span><span class="s5">11</span><span class="s3">, </span><span class="s5">32</span><span class="s3">, </span><span class="s5">75</span><span class="s3">, </span><span class="s5">90</span><span class="s3">, </span><span class="s5">106</span><span class="s3">, </span><span class="s5">94</span><span class="s3">, </span><span class="s5">60</span><span class="s3">, </span><span class="s5">56</span><span class="s3">, </span><span class="s5">35</span><span class="s3">, </span><span class="s5">17</span><span class="s3">,</span>
        <span class="s5">62</span><span class="s3">, </span><span class="s5">85</span><span class="s3">, </span><span class="s5">81</span><span class="s3">, </span><span class="s5">39</span><span class="s3">, </span><span class="s5">80</span><span class="s3">, </span><span class="s5">16</span><span class="s3">, </span><span class="s5">63</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">80</span><span class="s3">, </span><span class="s5">84</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">76</span><span class="s3">, </span><span class="s5">78</span>
    <span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">)</span>
    <span class="s6"># fmt: on</span>

    <span class="s1">tree </span><span class="s3">= </span><span class="s1">DecisionTreeClassifier</span><span class="s3">(</span>
        <span class="s1">max_depth</span><span class="s3">=</span><span class="s5">3</span><span class="s3">, </span><span class="s1">max_features</span><span class="s3">=</span><span class="s4">&quot;sqrt&quot;</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">1857819720</span>
    <span class="s3">)</span>
    <span class="s1">tree</span><span class="s3">.</span><span class="s1">fit</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">[</span><span class="s1">indices</span><span class="s3">], </span><span class="s1">y_train</span><span class="s3">[</span><span class="s1">indices</span><span class="s3">])</span>
    <span class="s2">assert </span><span class="s1">all</span><span class="s3">(</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">impurity </span><span class="s3">&gt;= </span><span class="s5">0</span><span class="s3">)</span>

    <span class="s1">leaves_idx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">flatnonzero</span><span class="s3">(</span>
        <span class="s3">(</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">children_left </span><span class="s3">== -</span><span class="s5">1</span><span class="s3">) &amp; (</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">n_node_samples </span><span class="s3">== </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">tree</span><span class="s3">.</span><span class="s1">tree_</span><span class="s3">.</span><span class="s1">impurity</span><span class="s3">[</span><span class="s1">leaves_idx</span><span class="s3">], </span><span class="s5">0.0</span><span class="s3">)</span>
</pre>
</body>
</html>