<html>
<head>
<title>test_kernels.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_kernels.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Testing for kernels for Gaussian processes.&quot;&quot;&quot;</span>

<span class="s2"># Author: Jan Hendrik Metzen &lt;jhm@informatik.uni-bremen.de&gt;</span>
<span class="s2"># License: BSD 3 clause</span>

<span class="s3">from </span><span class="s1">inspect </span><span class="s3">import </span><span class="s1">signature</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">pytest</span>

<span class="s3">from </span><span class="s1">sklearn</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">clone</span>
<span class="s3">from </span><span class="s1">sklearn</span><span class="s4">.</span><span class="s1">gaussian_process</span><span class="s4">.</span><span class="s1">kernels </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">RBF</span><span class="s4">,</span>
    <span class="s1">CompoundKernel</span><span class="s4">,</span>
    <span class="s1">ConstantKernel</span><span class="s4">,</span>
    <span class="s1">DotProduct</span><span class="s4">,</span>
    <span class="s1">Exponentiation</span><span class="s4">,</span>
    <span class="s1">ExpSineSquared</span><span class="s4">,</span>
    <span class="s1">KernelOperator</span><span class="s4">,</span>
    <span class="s1">Matern</span><span class="s4">,</span>
    <span class="s1">PairwiseKernel</span><span class="s4">,</span>
    <span class="s1">RationalQuadratic</span><span class="s4">,</span>
    <span class="s1">WhiteKernel</span><span class="s4">,</span>
    <span class="s1">_approx_fprime</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s1">sklearn</span><span class="s4">.</span><span class="s1">metrics</span><span class="s4">.</span><span class="s1">pairwise </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">PAIRWISE_KERNEL_FUNCTIONS</span><span class="s4">,</span>
    <span class="s1">euclidean_distances</span><span class="s4">,</span>
    <span class="s1">pairwise_kernels</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s1">sklearn</span><span class="s4">.</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_testing </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">assert_allclose</span><span class="s4">,</span>
    <span class="s1">assert_almost_equal</span><span class="s4">,</span>
    <span class="s1">assert_array_almost_equal</span><span class="s4">,</span>
    <span class="s1">assert_array_equal</span><span class="s4">,</span>
<span class="s4">)</span>

<span class="s1">X </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s5">0</span><span class="s4">).</span><span class="s1">normal</span><span class="s4">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, (</span><span class="s5">5</span><span class="s4">, </span><span class="s5">2</span><span class="s4">))</span>
<span class="s1">Y </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s5">0</span><span class="s4">).</span><span class="s1">normal</span><span class="s4">(</span><span class="s5">0</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, (</span><span class="s5">6</span><span class="s4">, </span><span class="s5">2</span><span class="s4">))</span>

<span class="s1">kernel_rbf_plus_white </span><span class="s4">= </span><span class="s1">RBF</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">2.0</span><span class="s4">) + </span><span class="s1">WhiteKernel</span><span class="s4">(</span><span class="s1">noise_level</span><span class="s4">=</span><span class="s5">3.0</span><span class="s4">)</span>
<span class="s1">kernels </span><span class="s4">= [</span>
    <span class="s1">RBF</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">2.0</span><span class="s4">),</span>
    <span class="s1">RBF</span><span class="s4">(</span><span class="s1">length_scale_bounds</span><span class="s4">=(</span><span class="s5">0.5</span><span class="s4">, </span><span class="s5">2.0</span><span class="s4">)),</span>
    <span class="s1">ConstantKernel</span><span class="s4">(</span><span class="s1">constant_value</span><span class="s4">=</span><span class="s5">10.0</span><span class="s4">),</span>
    <span class="s5">2.0 </span><span class="s4">* </span><span class="s1">RBF</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">0.33</span><span class="s4">, </span><span class="s1">length_scale_bounds</span><span class="s4">=</span><span class="s6">&quot;fixed&quot;</span><span class="s4">),</span>
    <span class="s5">2.0 </span><span class="s4">* </span><span class="s1">RBF</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">0.5</span><span class="s4">),</span>
    <span class="s1">kernel_rbf_plus_white</span><span class="s4">,</span>
    <span class="s5">2.0 </span><span class="s4">* </span><span class="s1">RBF</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=[</span><span class="s5">0.5</span><span class="s4">, </span><span class="s5">2.0</span><span class="s4">]),</span>
    <span class="s5">2.0 </span><span class="s4">* </span><span class="s1">Matern</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">0.33</span><span class="s4">, </span><span class="s1">length_scale_bounds</span><span class="s4">=</span><span class="s6">&quot;fixed&quot;</span><span class="s4">),</span>
    <span class="s5">2.0 </span><span class="s4">* </span><span class="s1">Matern</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">0.5</span><span class="s4">, </span><span class="s1">nu</span><span class="s4">=</span><span class="s5">0.5</span><span class="s4">),</span>
    <span class="s5">2.0 </span><span class="s4">* </span><span class="s1">Matern</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">1.5</span><span class="s4">, </span><span class="s1">nu</span><span class="s4">=</span><span class="s5">1.5</span><span class="s4">),</span>
    <span class="s5">2.0 </span><span class="s4">* </span><span class="s1">Matern</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">2.5</span><span class="s4">, </span><span class="s1">nu</span><span class="s4">=</span><span class="s5">2.5</span><span class="s4">),</span>
    <span class="s5">2.0 </span><span class="s4">* </span><span class="s1">Matern</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=[</span><span class="s5">0.5</span><span class="s4">, </span><span class="s5">2.0</span><span class="s4">], </span><span class="s1">nu</span><span class="s4">=</span><span class="s5">0.5</span><span class="s4">),</span>
    <span class="s5">3.0 </span><span class="s4">* </span><span class="s1">Matern</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=[</span><span class="s5">2.0</span><span class="s4">, </span><span class="s5">0.5</span><span class="s4">], </span><span class="s1">nu</span><span class="s4">=</span><span class="s5">1.5</span><span class="s4">),</span>
    <span class="s5">4.0 </span><span class="s4">* </span><span class="s1">Matern</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=[</span><span class="s5">0.5</span><span class="s4">, </span><span class="s5">0.5</span><span class="s4">], </span><span class="s1">nu</span><span class="s4">=</span><span class="s5">2.5</span><span class="s4">),</span>
    <span class="s1">RationalQuadratic</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">0.5</span><span class="s4">, </span><span class="s1">alpha</span><span class="s4">=</span><span class="s5">1.5</span><span class="s4">),</span>
    <span class="s1">ExpSineSquared</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">0.5</span><span class="s4">, </span><span class="s1">periodicity</span><span class="s4">=</span><span class="s5">1.5</span><span class="s4">),</span>
    <span class="s1">DotProduct</span><span class="s4">(</span><span class="s1">sigma_0</span><span class="s4">=</span><span class="s5">2.0</span><span class="s4">),</span>
    <span class="s1">DotProduct</span><span class="s4">(</span><span class="s1">sigma_0</span><span class="s4">=</span><span class="s5">2.0</span><span class="s4">) ** </span><span class="s5">2</span><span class="s4">,</span>
    <span class="s1">RBF</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=[</span><span class="s5">2.0</span><span class="s4">]),</span>
    <span class="s1">Matern</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=[</span><span class="s5">2.0</span><span class="s4">]),</span>
<span class="s4">]</span>
<span class="s3">for </span><span class="s1">metric </span><span class="s3">in </span><span class="s1">PAIRWISE_KERNEL_FUNCTIONS</span><span class="s4">:</span>
    <span class="s3">if </span><span class="s1">metric </span><span class="s3">in </span><span class="s4">[</span><span class="s6">&quot;additive_chi2&quot;</span><span class="s4">, </span><span class="s6">&quot;chi2&quot;</span><span class="s4">]:</span>
        <span class="s3">continue</span>
    <span class="s1">kernels</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">PairwiseKernel</span><span class="s4">(</span><span class="s1">gamma</span><span class="s4">=</span><span class="s5">1.0</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s1">metric</span><span class="s4">))</span>


<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;kernel&quot;</span><span class="s4">, </span><span class="s1">kernels</span><span class="s4">)</span>
<span class="s3">def </span><span class="s1">test_kernel_gradient</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">):</span>
    <span class="s2"># Compare analytic and numeric gradient of kernels.</span>
    <span class="s1">K</span><span class="s4">, </span><span class="s1">K_gradient </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">eval_gradient</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

    <span class="s3">assert </span><span class="s1">K_gradient</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] == </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
    <span class="s3">assert </span><span class="s1">K_gradient</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">1</span><span class="s4">] == </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
    <span class="s3">assert </span><span class="s1">K_gradient</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">2</span><span class="s4">] == </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">theta</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">eval_kernel_for_theta</span><span class="s4">(</span><span class="s1">theta</span><span class="s4">):</span>
        <span class="s1">kernel_clone </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">clone_with_theta</span><span class="s4">(</span><span class="s1">theta</span><span class="s4">)</span>
        <span class="s1">K </span><span class="s4">= </span><span class="s1">kernel_clone</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">eval_gradient</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">K</span>

    <span class="s1">K_gradient_approx </span><span class="s4">= </span><span class="s1">_approx_fprime</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">theta</span><span class="s4">, </span><span class="s1">eval_kernel_for_theta</span><span class="s4">, </span><span class="s5">1e-10</span><span class="s4">)</span>

    <span class="s1">assert_almost_equal</span><span class="s4">(</span><span class="s1">K_gradient</span><span class="s4">, </span><span class="s1">K_gradient_approx</span><span class="s4">, </span><span class="s5">4</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span>
    <span class="s6">&quot;kernel&quot;</span><span class="s4">,</span>
    <span class="s4">[</span>
        <span class="s1">kernel</span>
        <span class="s3">for </span><span class="s1">kernel </span><span class="s3">in </span><span class="s1">kernels</span>
        <span class="s2"># skip non-basic kernels</span>
        <span class="s3">if not </span><span class="s4">(</span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">, (</span><span class="s1">KernelOperator</span><span class="s4">, </span><span class="s1">Exponentiation</span><span class="s4">)))</span>
    <span class="s4">],</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">test_kernel_theta</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">):</span>
    <span class="s2"># Check that parameter vector theta of kernel is set correctly.</span>
    <span class="s1">theta </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">theta</span>
    <span class="s1">_</span><span class="s4">, </span><span class="s1">K_gradient </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">eval_gradient</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

    <span class="s2"># Determine kernel parameters that contribute to theta</span>
    <span class="s1">init_sign </span><span class="s4">= </span><span class="s1">signature</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__init__</span><span class="s4">).</span><span class="s1">parameters</span><span class="s4">.</span><span class="s1">values</span><span class="s4">()</span>
    <span class="s1">args </span><span class="s4">= [</span><span class="s1">p</span><span class="s4">.</span><span class="s1">name </span><span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">init_sign </span><span class="s3">if </span><span class="s1">p</span><span class="s4">.</span><span class="s1">name </span><span class="s4">!= </span><span class="s6">&quot;self&quot;</span><span class="s4">]</span>
    <span class="s1">theta_vars </span><span class="s4">= </span><span class="s1">map</span><span class="s4">(</span>
        <span class="s3">lambda </span><span class="s1">s</span><span class="s4">: </span><span class="s1">s</span><span class="s4">[</span><span class="s5">0 </span><span class="s4">: -</span><span class="s1">len</span><span class="s4">(</span><span class="s6">&quot;_bounds&quot;</span><span class="s4">)], </span><span class="s1">filter</span><span class="s4">(</span><span class="s3">lambda </span><span class="s1">s</span><span class="s4">: </span><span class="s1">s</span><span class="s4">.</span><span class="s1">endswith</span><span class="s4">(</span><span class="s6">&quot;_bounds&quot;</span><span class="s4">), </span><span class="s1">args</span><span class="s4">)</span>
    <span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">set</span><span class="s4">(</span><span class="s1">hyperparameter</span><span class="s4">.</span><span class="s1">name </span><span class="s3">for </span><span class="s1">hyperparameter </span><span class="s3">in </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">hyperparameters</span><span class="s4">) == </span><span class="s1">set</span><span class="s4">(</span>
        <span class="s1">theta_vars</span>
    <span class="s4">)</span>

    <span class="s2"># Check that values returned in theta are consistent with</span>
    <span class="s2"># hyperparameter values (being their logarithms)</span>
    <span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">hyperparameter </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">hyperparameters</span><span class="s4">):</span>
        <span class="s3">assert </span><span class="s1">theta</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] == </span><span class="s1">np</span><span class="s4">.</span><span class="s1">log</span><span class="s4">(</span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">, </span><span class="s1">hyperparameter</span><span class="s4">.</span><span class="s1">name</span><span class="s4">))</span>

    <span class="s2"># Fixed kernel parameters must be excluded from theta and gradient.</span>
    <span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">hyperparameter </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">hyperparameters</span><span class="s4">):</span>
        <span class="s2"># create copy with certain hyperparameter fixed</span>
        <span class="s1">params </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">get_params</span><span class="s4">()</span>
        <span class="s1">params</span><span class="s4">[</span><span class="s1">hyperparameter</span><span class="s4">.</span><span class="s1">name </span><span class="s4">+ </span><span class="s6">&quot;_bounds&quot;</span><span class="s4">] = </span><span class="s6">&quot;fixed&quot;</span>
        <span class="s1">kernel_class </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">__class__</span>
        <span class="s1">new_kernel </span><span class="s4">= </span><span class="s1">kernel_class</span><span class="s4">(**</span><span class="s1">params</span><span class="s4">)</span>
        <span class="s2"># Check that theta and K_gradient are identical with the fixed</span>
        <span class="s2"># dimension left out</span>
        <span class="s1">_</span><span class="s4">, </span><span class="s1">K_gradient_new </span><span class="s4">= </span><span class="s1">new_kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">eval_gradient</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">theta</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] == </span><span class="s1">new_kernel</span><span class="s4">.</span><span class="s1">theta</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] + </span><span class="s5">1</span>
        <span class="s3">assert </span><span class="s1">K_gradient</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">2</span><span class="s4">] == </span><span class="s1">K_gradient_new</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">2</span><span class="s4">] + </span><span class="s5">1</span>
        <span class="s3">if </span><span class="s1">i </span><span class="s4">&gt; </span><span class="s5">0</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">theta</span><span class="s4">[:</span><span class="s1">i</span><span class="s4">] == </span><span class="s1">new_kernel</span><span class="s4">.</span><span class="s1">theta</span><span class="s4">[:</span><span class="s1">i</span><span class="s4">]</span>
            <span class="s1">assert_array_equal</span><span class="s4">(</span><span class="s1">K_gradient</span><span class="s4">[..., :</span><span class="s1">i</span><span class="s4">], </span><span class="s1">K_gradient_new</span><span class="s4">[..., :</span><span class="s1">i</span><span class="s4">])</span>
        <span class="s3">if </span><span class="s1">i </span><span class="s4">+ </span><span class="s5">1 </span><span class="s4">&lt; </span><span class="s1">len</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">hyperparameters</span><span class="s4">):</span>
            <span class="s3">assert </span><span class="s1">theta</span><span class="s4">[</span><span class="s1">i </span><span class="s4">+ </span><span class="s5">1 </span><span class="s4">:] == </span><span class="s1">new_kernel</span><span class="s4">.</span><span class="s1">theta</span><span class="s4">[</span><span class="s1">i</span><span class="s4">:]</span>
            <span class="s1">assert_array_equal</span><span class="s4">(</span><span class="s1">K_gradient</span><span class="s4">[..., </span><span class="s1">i </span><span class="s4">+ </span><span class="s5">1 </span><span class="s4">:], </span><span class="s1">K_gradient_new</span><span class="s4">[..., </span><span class="s1">i</span><span class="s4">:])</span>

    <span class="s2"># Check that values of theta are modified correctly</span>
    <span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">hyperparameter </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">hyperparameters</span><span class="s4">):</span>
        <span class="s1">theta</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s1">np</span><span class="s4">.</span><span class="s1">log</span><span class="s4">(</span><span class="s5">42</span><span class="s4">)</span>
        <span class="s1">kernel</span><span class="s4">.</span><span class="s1">theta </span><span class="s4">= </span><span class="s1">theta</span>
        <span class="s1">assert_almost_equal</span><span class="s4">(</span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">, </span><span class="s1">hyperparameter</span><span class="s4">.</span><span class="s1">name</span><span class="s4">), </span><span class="s5">42</span><span class="s4">)</span>

        <span class="s1">setattr</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">, </span><span class="s1">hyperparameter</span><span class="s4">.</span><span class="s1">name</span><span class="s4">, </span><span class="s5">43</span><span class="s4">)</span>
        <span class="s1">assert_almost_equal</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">theta</span><span class="s4">[</span><span class="s1">i</span><span class="s4">], </span><span class="s1">np</span><span class="s4">.</span><span class="s1">log</span><span class="s4">(</span><span class="s5">43</span><span class="s4">))</span>


<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span>
    <span class="s6">&quot;kernel&quot;</span><span class="s4">,</span>
    <span class="s4">[</span>
        <span class="s1">kernel</span>
        <span class="s3">for </span><span class="s1">kernel </span><span class="s3">in </span><span class="s1">kernels</span>
        <span class="s2"># Identity is not satisfied on diagonal</span>
        <span class="s3">if </span><span class="s1">kernel </span><span class="s4">!= </span><span class="s1">kernel_rbf_plus_white</span>
    <span class="s4">],</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">test_auto_vs_cross</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">):</span>
    <span class="s2"># Auto-correlation and cross-correlation should be consistent.</span>
    <span class="s1">K_auto </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">K_cross </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">assert_almost_equal</span><span class="s4">(</span><span class="s1">K_auto</span><span class="s4">, </span><span class="s1">K_cross</span><span class="s4">, </span><span class="s5">5</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;kernel&quot;</span><span class="s4">, </span><span class="s1">kernels</span><span class="s4">)</span>
<span class="s3">def </span><span class="s1">test_kernel_diag</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">):</span>
    <span class="s2"># Test that diag method of kernel returns consistent results.</span>
    <span class="s1">K_call_diag </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">diag</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">))</span>
    <span class="s1">K_diag </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">diag</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">assert_almost_equal</span><span class="s4">(</span><span class="s1">K_call_diag</span><span class="s4">, </span><span class="s1">K_diag</span><span class="s4">, </span><span class="s5">5</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_kernel_operator_commutative</span><span class="s4">():</span>
    <span class="s2"># Adding kernels and multiplying kernels should be commutative.</span>
    <span class="s2"># Check addition</span>
    <span class="s1">assert_almost_equal</span><span class="s4">((</span><span class="s1">RBF</span><span class="s4">(</span><span class="s5">2.0</span><span class="s4">) + </span><span class="s5">1.0</span><span class="s4">)(</span><span class="s1">X</span><span class="s4">), (</span><span class="s5">1.0 </span><span class="s4">+ </span><span class="s1">RBF</span><span class="s4">(</span><span class="s5">2.0</span><span class="s4">))(</span><span class="s1">X</span><span class="s4">))</span>

    <span class="s2"># Check multiplication</span>
    <span class="s1">assert_almost_equal</span><span class="s4">((</span><span class="s5">3.0 </span><span class="s4">* </span><span class="s1">RBF</span><span class="s4">(</span><span class="s5">2.0</span><span class="s4">))(</span><span class="s1">X</span><span class="s4">), (</span><span class="s1">RBF</span><span class="s4">(</span><span class="s5">2.0</span><span class="s4">) * </span><span class="s5">3.0</span><span class="s4">)(</span><span class="s1">X</span><span class="s4">))</span>


<span class="s3">def </span><span class="s1">test_kernel_anisotropic</span><span class="s4">():</span>
    <span class="s2"># Anisotropic kernel should be consistent with isotropic kernels.</span>
    <span class="s1">kernel </span><span class="s4">= </span><span class="s5">3.0 </span><span class="s4">* </span><span class="s1">RBF</span><span class="s4">([</span><span class="s5">0.5</span><span class="s4">, </span><span class="s5">2.0</span><span class="s4">])</span>

    <span class="s1">K </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">X1 </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">X1</span><span class="s4">[:, </span><span class="s5">0</span><span class="s4">] *= </span><span class="s5">4</span>
    <span class="s1">K1 </span><span class="s4">= </span><span class="s5">3.0 </span><span class="s4">* </span><span class="s1">RBF</span><span class="s4">(</span><span class="s5">2.0</span><span class="s4">)(</span><span class="s1">X1</span><span class="s4">)</span>
    <span class="s1">assert_almost_equal</span><span class="s4">(</span><span class="s1">K</span><span class="s4">, </span><span class="s1">K1</span><span class="s4">)</span>

    <span class="s1">X2 </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">X2</span><span class="s4">[:, </span><span class="s5">1</span><span class="s4">] /= </span><span class="s5">4</span>
    <span class="s1">K2 </span><span class="s4">= </span><span class="s5">3.0 </span><span class="s4">* </span><span class="s1">RBF</span><span class="s4">(</span><span class="s5">0.5</span><span class="s4">)(</span><span class="s1">X2</span><span class="s4">)</span>
    <span class="s1">assert_almost_equal</span><span class="s4">(</span><span class="s1">K</span><span class="s4">, </span><span class="s1">K2</span><span class="s4">)</span>

    <span class="s2"># Check getting and setting via theta</span>
    <span class="s1">kernel</span><span class="s4">.</span><span class="s1">theta </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">theta </span><span class="s4">+ </span><span class="s1">np</span><span class="s4">.</span><span class="s1">log</span><span class="s4">(</span><span class="s5">2</span><span class="s4">)</span>
    <span class="s1">assert_array_equal</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">theta</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">log</span><span class="s4">([</span><span class="s5">6.0</span><span class="s4">, </span><span class="s5">1.0</span><span class="s4">, </span><span class="s5">4.0</span><span class="s4">]))</span>
    <span class="s1">assert_array_equal</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">k2</span><span class="s4">.</span><span class="s1">length_scale</span><span class="s4">, [</span><span class="s5">1.0</span><span class="s4">, </span><span class="s5">4.0</span><span class="s4">])</span>


<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span>
    <span class="s6">&quot;kernel&quot;</span><span class="s4">, [</span><span class="s1">kernel </span><span class="s3">for </span><span class="s1">kernel </span><span class="s3">in </span><span class="s1">kernels </span><span class="s3">if </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">is_stationary</span><span class="s4">()]</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">test_kernel_stationary</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">):</span>
    <span class="s2"># Test stationarity of kernels.</span>
    <span class="s1">K </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">X </span><span class="s4">+ </span><span class="s5">1</span><span class="s4">)</span>
    <span class="s1">assert_almost_equal</span><span class="s4">(</span><span class="s1">K</span><span class="s4">[</span><span class="s5">0</span><span class="s4">, </span><span class="s5">0</span><span class="s4">], </span><span class="s1">np</span><span class="s4">.</span><span class="s1">diag</span><span class="s4">(</span><span class="s1">K</span><span class="s4">))</span>


<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;kernel&quot;</span><span class="s4">, </span><span class="s1">kernels</span><span class="s4">)</span>
<span class="s3">def </span><span class="s1">test_kernel_input_type</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">):</span>
    <span class="s2"># Test whether kernels is for vectors or structured data</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">, </span><span class="s1">Exponentiation</span><span class="s4">):</span>
        <span class="s3">assert </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">requires_vector_input </span><span class="s4">== </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">requires_vector_input</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">, </span><span class="s1">KernelOperator</span><span class="s4">):</span>
        <span class="s3">assert </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">requires_vector_input </span><span class="s4">== (</span>
            <span class="s1">kernel</span><span class="s4">.</span><span class="s1">k1</span><span class="s4">.</span><span class="s1">requires_vector_input </span><span class="s3">or </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">k2</span><span class="s4">.</span><span class="s1">requires_vector_input</span>
        <span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_compound_kernel_input_type</span><span class="s4">():</span>
    <span class="s1">kernel </span><span class="s4">= </span><span class="s1">CompoundKernel</span><span class="s4">([</span><span class="s1">WhiteKernel</span><span class="s4">(</span><span class="s1">noise_level</span><span class="s4">=</span><span class="s5">3.0</span><span class="s4">)])</span>
    <span class="s3">assert not </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">requires_vector_input</span>

    <span class="s1">kernel </span><span class="s4">= </span><span class="s1">CompoundKernel</span><span class="s4">([</span><span class="s1">WhiteKernel</span><span class="s4">(</span><span class="s1">noise_level</span><span class="s4">=</span><span class="s5">3.0</span><span class="s4">), </span><span class="s1">RBF</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">2.0</span><span class="s4">)])</span>
    <span class="s3">assert </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">requires_vector_input</span>


<span class="s3">def </span><span class="s1">check_hyperparameters_equal</span><span class="s4">(</span><span class="s1">kernel1</span><span class="s4">, </span><span class="s1">kernel2</span><span class="s4">):</span>
    <span class="s2"># Check that hyperparameters of two kernels are equal</span>
    <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s1">set</span><span class="s4">(</span><span class="s1">dir</span><span class="s4">(</span><span class="s1">kernel1</span><span class="s4">) + </span><span class="s1">dir</span><span class="s4">(</span><span class="s1">kernel2</span><span class="s4">)):</span>
        <span class="s3">if </span><span class="s1">attr</span><span class="s4">.</span><span class="s1">startswith</span><span class="s4">(</span><span class="s6">&quot;hyperparameter_&quot;</span><span class="s4">):</span>
            <span class="s1">attr_value1 </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">kernel1</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">)</span>
            <span class="s1">attr_value2 </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">kernel2</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">)</span>
            <span class="s3">assert </span><span class="s1">attr_value1 </span><span class="s4">== </span><span class="s1">attr_value2</span>


<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;kernel&quot;</span><span class="s4">, </span><span class="s1">kernels</span><span class="s4">)</span>
<span class="s3">def </span><span class="s1">test_kernel_clone</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">):</span>
    <span class="s2"># Test that sklearn's clone works correctly on kernels.</span>
    <span class="s1">kernel_cloned </span><span class="s4">= </span><span class="s1">clone</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">)</span>

    <span class="s2"># XXX: Should this be fixed?</span>
    <span class="s2"># This differs from the sklearn's estimators equality check.</span>
    <span class="s3">assert </span><span class="s1">kernel </span><span class="s4">== </span><span class="s1">kernel_cloned</span>
    <span class="s3">assert </span><span class="s1">id</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">) != </span><span class="s1">id</span><span class="s4">(</span><span class="s1">kernel_cloned</span><span class="s4">)</span>

    <span class="s2"># Check that all constructor parameters are equal.</span>
    <span class="s3">assert </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">get_params</span><span class="s4">() == </span><span class="s1">kernel_cloned</span><span class="s4">.</span><span class="s1">get_params</span><span class="s4">()</span>

    <span class="s2"># Check that all hyperparameters are equal.</span>
    <span class="s1">check_hyperparameters_equal</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">, </span><span class="s1">kernel_cloned</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;kernel&quot;</span><span class="s4">, </span><span class="s1">kernels</span><span class="s4">)</span>
<span class="s3">def </span><span class="s1">test_kernel_clone_after_set_params</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">):</span>
    <span class="s2"># This test is to verify that using set_params does not</span>
    <span class="s2"># break clone on kernels.</span>
    <span class="s2"># This used to break because in kernels such as the RBF, non-trivial</span>
    <span class="s2"># logic that modified the length scale used to be in the constructor</span>
    <span class="s2"># See https://github.com/scikit-learn/scikit-learn/issues/6961</span>
    <span class="s2"># for more details.</span>
    <span class="s1">bounds </span><span class="s4">= (</span><span class="s5">1e-5</span><span class="s4">, </span><span class="s5">1e5</span><span class="s4">)</span>
    <span class="s1">kernel_cloned </span><span class="s4">= </span><span class="s1">clone</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">)</span>
    <span class="s1">params </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">get_params</span><span class="s4">()</span>
    <span class="s2"># RationalQuadratic kernel is isotropic.</span>
    <span class="s1">isotropic_kernels </span><span class="s4">= (</span><span class="s1">ExpSineSquared</span><span class="s4">, </span><span class="s1">RationalQuadratic</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s6">&quot;length_scale&quot; </span><span class="s3">in </span><span class="s1">params </span><span class="s3">and not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">, </span><span class="s1">isotropic_kernels</span><span class="s4">):</span>
        <span class="s1">length_scale </span><span class="s4">= </span><span class="s1">params</span><span class="s4">[</span><span class="s6">&quot;length_scale&quot;</span><span class="s4">]</span>
        <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">iterable</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">):</span>
            <span class="s2"># XXX unreached code as of v0.22</span>
            <span class="s1">params</span><span class="s4">[</span><span class="s6">&quot;length_scale&quot;</span><span class="s4">] = </span><span class="s1">length_scale</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]</span>
            <span class="s1">params</span><span class="s4">[</span><span class="s6">&quot;length_scale_bounds&quot;</span><span class="s4">] = </span><span class="s1">bounds</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">params</span><span class="s4">[</span><span class="s6">&quot;length_scale&quot;</span><span class="s4">] = [</span><span class="s1">length_scale</span><span class="s4">] * </span><span class="s5">2</span>
            <span class="s1">params</span><span class="s4">[</span><span class="s6">&quot;length_scale_bounds&quot;</span><span class="s4">] = </span><span class="s1">bounds </span><span class="s4">* </span><span class="s5">2</span>
        <span class="s1">kernel_cloned</span><span class="s4">.</span><span class="s1">set_params</span><span class="s4">(**</span><span class="s1">params</span><span class="s4">)</span>
        <span class="s1">kernel_cloned_clone </span><span class="s4">= </span><span class="s1">clone</span><span class="s4">(</span><span class="s1">kernel_cloned</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">kernel_cloned_clone</span><span class="s4">.</span><span class="s1">get_params</span><span class="s4">() == </span><span class="s1">kernel_cloned</span><span class="s4">.</span><span class="s1">get_params</span><span class="s4">()</span>
        <span class="s3">assert </span><span class="s1">id</span><span class="s4">(</span><span class="s1">kernel_cloned_clone</span><span class="s4">) != </span><span class="s1">id</span><span class="s4">(</span><span class="s1">kernel_cloned</span><span class="s4">)</span>
        <span class="s1">check_hyperparameters_equal</span><span class="s4">(</span><span class="s1">kernel_cloned</span><span class="s4">, </span><span class="s1">kernel_cloned_clone</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_matern_kernel</span><span class="s4">():</span>
    <span class="s2"># Test consistency of Matern kernel for special values of nu.</span>
    <span class="s1">K </span><span class="s4">= </span><span class="s1">Matern</span><span class="s4">(</span><span class="s1">nu</span><span class="s4">=</span><span class="s5">1.5</span><span class="s4">, </span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">1.0</span><span class="s4">)(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s2"># the diagonal elements of a matern kernel are 1</span>
    <span class="s1">assert_array_almost_equal</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">diag</span><span class="s4">(</span><span class="s1">K</span><span class="s4">), </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]))</span>
    <span class="s2"># matern kernel for coef0==0.5 is equal to absolute exponential kernel</span>
    <span class="s1">K_absexp </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(-</span><span class="s1">euclidean_distances</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">squared</span><span class="s4">=</span><span class="s3">False</span><span class="s4">))</span>
    <span class="s1">K </span><span class="s4">= </span><span class="s1">Matern</span><span class="s4">(</span><span class="s1">nu</span><span class="s4">=</span><span class="s5">0.5</span><span class="s4">, </span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">1.0</span><span class="s4">)(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">assert_array_almost_equal</span><span class="s4">(</span><span class="s1">K</span><span class="s4">, </span><span class="s1">K_absexp</span><span class="s4">)</span>
    <span class="s2"># matern kernel with coef0==inf is equal to RBF kernel</span>
    <span class="s1">K_rbf </span><span class="s4">= </span><span class="s1">RBF</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">1.0</span><span class="s4">)(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">K </span><span class="s4">= </span><span class="s1">Matern</span><span class="s4">(</span><span class="s1">nu</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span><span class="s4">, </span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">1.0</span><span class="s4">)(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">assert_array_almost_equal</span><span class="s4">(</span><span class="s1">K</span><span class="s4">, </span><span class="s1">K_rbf</span><span class="s4">)</span>
    <span class="s1">assert_allclose</span><span class="s4">(</span><span class="s1">K</span><span class="s4">, </span><span class="s1">K_rbf</span><span class="s4">)</span>
    <span class="s2"># test that special cases of matern kernel (coef0 in [0.5, 1.5, 2.5])</span>
    <span class="s2"># result in nearly identical results as the general case for coef0 in</span>
    <span class="s2"># [0.5 + tiny, 1.5 + tiny, 2.5 + tiny]</span>
    <span class="s1">tiny </span><span class="s4">= </span><span class="s5">1e-10</span>
    <span class="s3">for </span><span class="s1">nu </span><span class="s3">in </span><span class="s4">[</span><span class="s5">0.5</span><span class="s4">, </span><span class="s5">1.5</span><span class="s4">, </span><span class="s5">2.5</span><span class="s4">]:</span>
        <span class="s1">K1 </span><span class="s4">= </span><span class="s1">Matern</span><span class="s4">(</span><span class="s1">nu</span><span class="s4">=</span><span class="s1">nu</span><span class="s4">, </span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">1.0</span><span class="s4">)(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s1">K2 </span><span class="s4">= </span><span class="s1">Matern</span><span class="s4">(</span><span class="s1">nu</span><span class="s4">=</span><span class="s1">nu </span><span class="s4">+ </span><span class="s1">tiny</span><span class="s4">, </span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">1.0</span><span class="s4">)(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s1">assert_array_almost_equal</span><span class="s4">(</span><span class="s1">K1</span><span class="s4">, </span><span class="s1">K2</span><span class="s4">)</span>
    <span class="s2"># test that coef0==large is close to RBF</span>
    <span class="s1">large </span><span class="s4">= </span><span class="s5">100</span>
    <span class="s1">K1 </span><span class="s4">= </span><span class="s1">Matern</span><span class="s4">(</span><span class="s1">nu</span><span class="s4">=</span><span class="s1">large</span><span class="s4">, </span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">1.0</span><span class="s4">)(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">K2 </span><span class="s4">= </span><span class="s1">RBF</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=</span><span class="s5">1.0</span><span class="s4">)(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">assert_array_almost_equal</span><span class="s4">(</span><span class="s1">K1</span><span class="s4">, </span><span class="s1">K2</span><span class="s4">, </span><span class="s1">decimal</span><span class="s4">=</span><span class="s5">2</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;kernel&quot;</span><span class="s4">, </span><span class="s1">kernels</span><span class="s4">)</span>
<span class="s3">def </span><span class="s1">test_kernel_versus_pairwise</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">):</span>
    <span class="s2"># Check that GP kernels can also be used as pairwise kernels.</span>

    <span class="s2"># Test auto-kernel</span>
    <span class="s3">if </span><span class="s1">kernel </span><span class="s4">!= </span><span class="s1">kernel_rbf_plus_white</span><span class="s4">:</span>
        <span class="s2"># For WhiteKernel: k(X) != k(X,X). This is assumed by</span>
        <span class="s2"># pairwise_kernels</span>
        <span class="s1">K1 </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
        <span class="s1">K2 </span><span class="s4">= </span><span class="s1">pairwise_kernels</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s1">kernel</span><span class="s4">)</span>
        <span class="s1">assert_array_almost_equal</span><span class="s4">(</span><span class="s1">K1</span><span class="s4">, </span><span class="s1">K2</span><span class="s4">)</span>

    <span class="s2"># Test cross-kernel</span>
    <span class="s1">K1 </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">)</span>
    <span class="s1">K2 </span><span class="s4">= </span><span class="s1">pairwise_kernels</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">Y</span><span class="s4">, </span><span class="s1">metric</span><span class="s4">=</span><span class="s1">kernel</span><span class="s4">)</span>
    <span class="s1">assert_array_almost_equal</span><span class="s4">(</span><span class="s1">K1</span><span class="s4">, </span><span class="s1">K2</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;kernel&quot;</span><span class="s4">, </span><span class="s1">kernels</span><span class="s4">)</span>
<span class="s3">def </span><span class="s1">test_set_get_params</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">):</span>
    <span class="s2"># Check that set_params()/get_params() is consistent with kernel.theta.</span>

    <span class="s2"># Test get_params()</span>
    <span class="s1">index </span><span class="s4">= </span><span class="s5">0</span>
    <span class="s1">params </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">get_params</span><span class="s4">()</span>
    <span class="s3">for </span><span class="s1">hyperparameter </span><span class="s3">in </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">hyperparameters</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s6">&quot;string&quot;</span><span class="s4">, </span><span class="s1">type</span><span class="s4">(</span><span class="s1">hyperparameter</span><span class="s4">.</span><span class="s1">bounds</span><span class="s4">)):</span>
            <span class="s3">if </span><span class="s1">hyperparameter</span><span class="s4">.</span><span class="s1">bounds </span><span class="s4">== </span><span class="s6">&quot;fixed&quot;</span><span class="s4">:</span>
                <span class="s3">continue</span>
        <span class="s1">size </span><span class="s4">= </span><span class="s1">hyperparameter</span><span class="s4">.</span><span class="s1">n_elements</span>
        <span class="s3">if </span><span class="s1">size </span><span class="s4">&gt; </span><span class="s5">1</span><span class="s4">:  </span><span class="s2"># anisotropic kernels</span>
            <span class="s1">assert_almost_equal</span><span class="s4">(</span>
                <span class="s1">np</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">theta</span><span class="s4">[</span><span class="s1">index </span><span class="s4">: </span><span class="s1">index </span><span class="s4">+ </span><span class="s1">size</span><span class="s4">]), </span><span class="s1">params</span><span class="s4">[</span><span class="s1">hyperparameter</span><span class="s4">.</span><span class="s1">name</span><span class="s4">]</span>
            <span class="s4">)</span>
            <span class="s1">index </span><span class="s4">+= </span><span class="s1">size</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">assert_almost_equal</span><span class="s4">(</span>
                <span class="s1">np</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">theta</span><span class="s4">[</span><span class="s1">index</span><span class="s4">]), </span><span class="s1">params</span><span class="s4">[</span><span class="s1">hyperparameter</span><span class="s4">.</span><span class="s1">name</span><span class="s4">]</span>
            <span class="s4">)</span>
            <span class="s1">index </span><span class="s4">+= </span><span class="s5">1</span>
    <span class="s2"># Test set_params()</span>
    <span class="s1">index </span><span class="s4">= </span><span class="s5">0</span>
    <span class="s1">value </span><span class="s4">= </span><span class="s5">10  </span><span class="s2"># arbitrary value</span>
    <span class="s3">for </span><span class="s1">hyperparameter </span><span class="s3">in </span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">hyperparameters</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s6">&quot;string&quot;</span><span class="s4">, </span><span class="s1">type</span><span class="s4">(</span><span class="s1">hyperparameter</span><span class="s4">.</span><span class="s1">bounds</span><span class="s4">)):</span>
            <span class="s3">if </span><span class="s1">hyperparameter</span><span class="s4">.</span><span class="s1">bounds </span><span class="s4">== </span><span class="s6">&quot;fixed&quot;</span><span class="s4">:</span>
                <span class="s3">continue</span>
        <span class="s1">size </span><span class="s4">= </span><span class="s1">hyperparameter</span><span class="s4">.</span><span class="s1">n_elements</span>
        <span class="s3">if </span><span class="s1">size </span><span class="s4">&gt; </span><span class="s5">1</span><span class="s4">:  </span><span class="s2"># anisotropic kernels</span>
            <span class="s1">kernel</span><span class="s4">.</span><span class="s1">set_params</span><span class="s4">(**{</span><span class="s1">hyperparameter</span><span class="s4">.</span><span class="s1">name</span><span class="s4">: [</span><span class="s1">value</span><span class="s4">] * </span><span class="s1">size</span><span class="s4">})</span>
            <span class="s1">assert_almost_equal</span><span class="s4">(</span>
                <span class="s1">np</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">theta</span><span class="s4">[</span><span class="s1">index </span><span class="s4">: </span><span class="s1">index </span><span class="s4">+ </span><span class="s1">size</span><span class="s4">]), [</span><span class="s1">value</span><span class="s4">] * </span><span class="s1">size</span>
            <span class="s4">)</span>
            <span class="s1">index </span><span class="s4">+= </span><span class="s1">size</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">kernel</span><span class="s4">.</span><span class="s1">set_params</span><span class="s4">(**{</span><span class="s1">hyperparameter</span><span class="s4">.</span><span class="s1">name</span><span class="s4">: </span><span class="s1">value</span><span class="s4">})</span>
            <span class="s1">assert_almost_equal</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">theta</span><span class="s4">[</span><span class="s1">index</span><span class="s4">]), </span><span class="s1">value</span><span class="s4">)</span>
            <span class="s1">index </span><span class="s4">+= </span><span class="s5">1</span>


<span class="s4">@</span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">mark</span><span class="s4">.</span><span class="s1">parametrize</span><span class="s4">(</span><span class="s6">&quot;kernel&quot;</span><span class="s4">, </span><span class="s1">kernels</span><span class="s4">)</span>
<span class="s3">def </span><span class="s1">test_repr_kernels</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">):</span>
    <span class="s2"># Smoke-test for repr in kernels.</span>

    <span class="s1">repr</span><span class="s4">(</span><span class="s1">kernel</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">test_rational_quadratic_kernel</span><span class="s4">():</span>
    <span class="s1">kernel </span><span class="s4">= </span><span class="s1">RationalQuadratic</span><span class="s4">(</span><span class="s1">length_scale</span><span class="s4">=[</span><span class="s5">1.0</span><span class="s4">, </span><span class="s5">1.0</span><span class="s4">])</span>
    <span class="s1">message </span><span class="s4">= (</span>
        <span class="s6">&quot;RationalQuadratic kernel only supports isotropic &quot;</span>
        <span class="s6">&quot;version, please use a single &quot;</span>
        <span class="s6">&quot;scalar for length_scale&quot;</span>
    <span class="s4">)</span>
    <span class="s3">with </span><span class="s1">pytest</span><span class="s4">.</span><span class="s1">raises</span><span class="s4">(</span><span class="s1">AttributeError</span><span class="s4">, </span><span class="s1">match</span><span class="s4">=</span><span class="s1">message</span><span class="s4">):</span>
        <span class="s1">kernel</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
</pre>
</body>
</html>