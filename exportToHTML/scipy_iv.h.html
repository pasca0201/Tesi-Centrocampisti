<html>
<head>
<title>scipy_iv.h</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #6aab73;}
.s4 { color: #c77dbb;}
.s5 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
scipy_iv.h</font>
</center></td></tr></table>
<pre><span class="s0">/* Translated into C++ by SciPy developers in 2024. 
 * Original header with Copyright information appears below. 
 */</span>

<span class="s0">/*                                                     iv.c 
 * 
 *     Modified Bessel function of noninteger order 
 * 
 * 
 * 
 * SYNOPSIS: 
 * 
 * double v, x, y, iv(); 
 * 
 * y = iv( v, x ); 
 * 
 * 
 * 
 * DESCRIPTION: 
 * 
 * Returns modified Bessel function of order v of the 
 * argument.  If x is negative, v must be integer valued. 
 * 
 */</span>
<span class="s0">/*                                                     iv.c    */</span>
<span class="s0">/*     Modified Bessel function of noninteger order            */</span>
<span class="s0">/* If x &lt; 0, then v must be an integer. */</span>

<span class="s0">/* 
 * Parts of the code are copyright: 
 * 
 *     Cephes Math Library Release 2.8:  June, 2000 
 *     Copyright 1984, 1987, 1988, 2000 by Stephen L. Moshier 
 * 
 * And other parts: 
 * 
 *     Copyright (c) 2006 Xiaogang Zhang 
 *     Use, modification and distribution are subject to the 
 *     Boost Software License, Version 1.0. 
 * 
 *     Boost Software License - Version 1.0 - August 17th, 2003 
 * 
 *     Permission is hereby granted, free of charge, to any person or 
 *     organization obtaining a copy of the software and accompanying 
 *     documentation covered by this license (the &quot;Software&quot;) to use, reproduce, 
 *     display, distribute, execute, and transmit the Software, and to prepare 
 *     derivative works of the Software, and to permit third-parties to whom the 
 *     Software is furnished to do so, all subject to the following: 
 * 
 *     The copyright notices in the Software and this entire statement, 
 *     including the above license grant, this restriction and the following 
 *     disclaimer, must be included in all copies of the Software, in whole or 
 *     in part, and all derivative works of the Software, unless such copies or 
 *     derivative works are solely in the form of machine-executable object code 
 *     generated by a source language processor. 
 * 
 *     THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS 
 *     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
 *     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND 
 *     NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE 
 *     DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, 
 *     WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 
 *     CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
 *     SOFTWARE. 
 * 
 * And the rest are: 
 * 
 *     Copyright (C) 2009 Pauli Virtanen 
 *     Distributed under the same license as Scipy. 
 * 
 */</span>
<span class="s1">#pragma once</span>

<span class="s2">#include </span><span class="s3">&quot;../config.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;../error.h&quot;</span>

<span class="s2">#include </span><span class="s3">&quot;const.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;gamma.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;trig.h&quot;</span>

<span class="s4">namespace </span><span class="s1">special {</span>
<span class="s4">namespace </span><span class="s1">cephes {</span>

    <span class="s4">namespace </span><span class="s1">detail {</span>

        <span class="s0">/* 
         * Compute Iv from (AMS5 9.7.1), asymptotic expansion for large |z| 
         * Iv ~ exp(x)/sqrt(2 pi x) ( 1 + (4*v*v-1)/8x + (4*v*v-1)(4*v*v-9)/8x/2! + ...) 
         */</span>
        <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s4">inline </span><span class="s2">double </span><span class="s1">iv_asymptotic(</span><span class="s2">double </span><span class="s1">v, </span><span class="s2">double </span><span class="s1">x) {</span>
            <span class="s2">double </span><span class="s1">mu;</span>
            <span class="s2">double </span><span class="s1">sum, term, prefactor, factor;</span>
            <span class="s2">int </span><span class="s1">k;</span>

            <span class="s1">prefactor = std::exp(x) / std::sqrt(</span><span class="s5">2 </span><span class="s1">* M_PI * x);</span>

            <span class="s2">if </span><span class="s1">(prefactor == std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::infinity()) {</span>
                <span class="s2">return </span><span class="s1">prefactor;</span>
            <span class="s1">}</span>

            <span class="s1">mu = </span><span class="s5">4 </span><span class="s1">* v * v;</span>
            <span class="s1">sum = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">term = </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">k = </span><span class="s5">1</span><span class="s1">;</span>

            <span class="s2">do </span><span class="s1">{</span>
                <span class="s1">factor = (mu - (</span><span class="s5">2 </span><span class="s1">* k - </span><span class="s5">1</span><span class="s1">) * (</span><span class="s5">2 </span><span class="s1">* k - </span><span class="s5">1</span><span class="s1">)) / (</span><span class="s5">8 </span><span class="s1">* x) / k;</span>
                <span class="s2">if </span><span class="s1">(k &gt; </span><span class="s5">100</span><span class="s1">) {</span>
                    <span class="s0">/* didn't converge */</span>
                    <span class="s1">set_error(</span><span class="s3">&quot;iv(iv_asymptotic)&quot;</span><span class="s1">, SF_ERROR_NO_RESULT, NULL);</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">term *= -factor;</span>
                <span class="s1">sum += term;</span>
                <span class="s1">++k;</span>
            <span class="s1">} </span><span class="s2">while </span><span class="s1">(std::abs(term) &gt; MACHEP * std::abs(sum));</span>
            <span class="s2">return </span><span class="s1">sum * prefactor;</span>
        <span class="s1">}</span>

        <span class="s0">/* 
         * Uniform asymptotic expansion factors, (AMS5 9.3.9; AMS5 9.3.10) 
         * 
         * Computed with: 
         * -------------------- 
         import numpy as np 
         t = np.poly1d([1,0]) 
         def up1(p): 
         return .5*t*t*(1-t*t)*p.deriv() + 1/8. * ((1-5*t*t)*p).integ() 
         us = [np.poly1d([1])] 
         for k in range(10): 
         us.append(up1(us[-1])) 
         n = us[-1].order 
         for p in us: 
         print &quot;{&quot; + &quot;, &quot;.join([&quot;0&quot;]*(n-p.order) + map(repr, p)) + &quot;},&quot; 
         print &quot;N_UFACTORS&quot;, len(us) 
         print &quot;N_UFACTOR_TERMS&quot;, us[-1].order + 1 
         * -------------------- 
         */</span>
        <span class="s1">constexpr </span><span class="s2">int </span><span class="s1">iv_N_UFACTORS = </span><span class="s5">11</span><span class="s1">;</span>
        <span class="s1">constexpr </span><span class="s2">int </span><span class="s1">iv_N_UFACTOR_TERMS = </span><span class="s5">31</span><span class="s1">;</span>

        <span class="s1">constexpr </span><span class="s2">double </span><span class="s1">iv_asymptotic_ufactors[iv_N_UFACTORS][iv_N_UFACTOR_TERMS] = {</span>
            <span class="s1">{</span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">1</span><span class="s1">},</span>
            <span class="s1">{</span><span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,     </span><span class="s5">0</span><span class="s1">,  </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,     </span><span class="s5">0</span><span class="s1">,  </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, -</span><span class="s5">0.20833333333333334</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">0.125</span><span class="s1">, </span><span class="s5">0.0</span><span class="s1">},</span>
            <span class="s1">{</span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0.3342013888888889</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s1">-</span><span class="s5">0.40104166666666669</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0703125</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">},</span>
            <span class="s1">{</span><span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   -</span><span class="s5">1.0258125964506173</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">1.8464626736111112</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, -</span><span class="s5">0.89121093750000002</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">0.0732421875</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">},</span>
            <span class="s1">{</span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">4.6695844234262474</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s1">-</span><span class="s5">11.207002616222995</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">8.78912353515625</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s1">-</span><span class="s5">2.3640869140624998</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.112152099609375</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">},</span>
            <span class="s1">{</span><span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   -</span><span class="s5">28.212072558200244</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">84.636217674600744</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, -</span><span class="s5">91.818241543240035</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">42.534998745388457</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, -</span><span class="s5">7.3687943594796312</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">0.22710800170898438</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">},</span>
            <span class="s1">{</span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">212.5701300392171</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s1">-</span><span class="s5">765.25246814118157</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">1059.9904525279999</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s1">-</span><span class="s5">699.57962737613275</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">218.19051174421159</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s1">-</span><span class="s5">26.491430486951554</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.57250142097473145</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">},</span>
            <span class="s1">{</span><span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   -</span><span class="s5">1919.4576623184068</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">8061.7221817373083</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, -</span><span class="s5">13586.550006434136</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">11655.393336864536</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, -</span><span class="s5">5305.6469786134048</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">1200.9029132163525</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, -</span><span class="s5">108.09091978839464</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">1.7277275025844574</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">},</span>
            <span class="s1">{</span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,</span>
             <span class="s5">20204.291330966149</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s1">-</span><span class="s5">96980.598388637503</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">192547.0012325315</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s1">-</span><span class="s5">203400.17728041555</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">122200.46498301747</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s1">-</span><span class="s5">41192.654968897557</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">7109.5143024893641</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s1">-</span><span class="s5">493.915304773088</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">6.074042001273483</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">},</span>
            <span class="s1">{</span><span class="s5">0</span><span class="s1">,   </span><span class="s5">0</span><span class="s1">,</span>
             <span class="s5">0</span><span class="s1">,   -</span><span class="s5">242919.18790055133</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">1311763.6146629769</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, -</span><span class="s5">2998015.9185381061</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">3763271.2976564039</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, -</span><span class="s5">2813563.2265865342</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">1268365.2733216248</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, -</span><span class="s5">331645.17248456361</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">45218.768981362737</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, -</span><span class="s5">2499.8304818112092</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">24.380529699556064</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">, </span><span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">},</span>
            <span class="s1">{</span><span class="s5">3284469.8530720375</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s1">-</span><span class="s5">19706819.11843222</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">50952602.492664628</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s1">-</span><span class="s5">74105148.211532637</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">66344512.274729028</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s1">-</span><span class="s5">37567176.660763353</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">13288767.166421819</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s1">-</span><span class="s5">2785618.1280864552</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">308186.40461266245</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s1">-</span><span class="s5">13886.089753717039</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">110.01714026924674</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">,</span>
             <span class="s5">0.0</span><span class="s1">}};</span>

        <span class="s0">/* 
         * Compute Iv, Kv from (AMS5 9.7.7 + 9.7.8), asymptotic expansion for large v 
         */</span>
        <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s4">inline </span><span class="s2">void </span><span class="s1">ikv_asymptotic_uniform(</span><span class="s2">double </span><span class="s1">v, </span><span class="s2">double </span><span class="s1">x, </span><span class="s2">double </span><span class="s1">*i_value, </span><span class="s2">double </span><span class="s1">*k_value) {</span>
            <span class="s2">double </span><span class="s1">i_prefactor, k_prefactor;</span>
            <span class="s2">double </span><span class="s1">t, t2, eta, z;</span>
            <span class="s2">double </span><span class="s1">i_sum, k_sum, term, divisor;</span>
            <span class="s2">int </span><span class="s1">k, n;</span>
            <span class="s2">int </span><span class="s1">sign = </span><span class="s5">1</span><span class="s1">;</span>

            <span class="s2">if </span><span class="s1">(v &lt; </span><span class="s5">0</span><span class="s1">) {</span>
                <span class="s0">/* Negative v; compute I_{-v} and K_{-v} and use (AMS 9.6.2) */</span>
                <span class="s1">sign = -</span><span class="s5">1</span><span class="s1">;</span>
                <span class="s1">v = -v;</span>
            <span class="s1">}</span>

            <span class="s1">z = x / v;</span>
            <span class="s1">t = </span><span class="s5">1 </span><span class="s1">/ std::sqrt(</span><span class="s5">1 </span><span class="s1">+ z * z);</span>
            <span class="s1">t2 = t * t;</span>
            <span class="s1">eta = std::sqrt(</span><span class="s5">1 </span><span class="s1">+ z * z) + std::log(z / (</span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">1 </span><span class="s1">/ t));</span>

            <span class="s1">i_prefactor = std::sqrt(t / (</span><span class="s5">2 </span><span class="s1">* M_PI * v)) * std::exp(v * eta);</span>
            <span class="s1">i_sum = </span><span class="s5">1.0</span><span class="s1">;</span>

            <span class="s1">k_prefactor = std::sqrt(M_PI * t / (</span><span class="s5">2 </span><span class="s1">* v)) * std::exp(-v * eta);</span>
            <span class="s1">k_sum = </span><span class="s5">1.0</span><span class="s1">;</span>

            <span class="s1">divisor = v;</span>
            <span class="s2">for </span><span class="s1">(n = </span><span class="s5">1</span><span class="s1">; n &lt; iv_N_UFACTORS; ++n) {</span>
                <span class="s0">/* 
                 * Evaluate u_k(t) with Horner's scheme; 
                 * (using the knowledge about which coefficients are zero) 
                 */</span>
                <span class="s1">term = </span><span class="s5">0</span><span class="s1">;</span>
                <span class="s2">for </span><span class="s1">(k = iv_N_UFACTOR_TERMS - </span><span class="s5">1 </span><span class="s1">- </span><span class="s5">3 </span><span class="s1">* n; k &lt; iv_N_UFACTOR_TERMS - n; k += </span><span class="s5">2</span><span class="s1">) {</span>
                    <span class="s1">term *= t2;</span>
                    <span class="s1">term += iv_asymptotic_ufactors[n][k];</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(k = </span><span class="s5">1</span><span class="s1">; k &lt; n; k += </span><span class="s5">2</span><span class="s1">) {</span>
                    <span class="s1">term *= t2;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(n % </span><span class="s5">2 </span><span class="s1">== </span><span class="s5">1</span><span class="s1">) {</span>
                    <span class="s1">term *= t;</span>
                <span class="s1">}</span>

                <span class="s0">/* Sum terms */</span>
                <span class="s1">term /= divisor;</span>
                <span class="s1">i_sum += term;</span>
                <span class="s1">k_sum += (n % </span><span class="s5">2 </span><span class="s1">== </span><span class="s5">0</span><span class="s1">) ? term : -term;</span>

                <span class="s0">/* Check convergence */</span>
                <span class="s2">if </span><span class="s1">(std::abs(term) &lt; MACHEP) {</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s1">divisor *= v;</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(std::abs(term) &gt; </span><span class="s5">1</span><span class="s1">e-3 * std::abs(i_sum)) {</span>
                <span class="s0">/* Didn't converge */</span>
                <span class="s1">set_error(</span><span class="s3">&quot;ikv_asymptotic_uniform&quot;</span><span class="s1">, SF_ERROR_NO_RESULT, NULL);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(std::abs(term) &gt; MACHEP * std::abs(i_sum)) {</span>
                <span class="s0">/* Some precision lost */</span>
                <span class="s1">set_error(</span><span class="s3">&quot;ikv_asymptotic_uniform&quot;</span><span class="s1">, SF_ERROR_LOSS, NULL);</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(k_value != NULL) {</span>
                <span class="s0">/* symmetric in v */</span>
                <span class="s1">*k_value = k_prefactor * k_sum;</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(i_value != NULL) {</span>
                <span class="s2">if </span><span class="s1">(sign == </span><span class="s5">1</span><span class="s1">) {</span>
                    <span class="s1">*i_value = i_prefactor * i_sum;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s0">/* (AMS 9.6.2) */</span>
                    <span class="s1">*i_value = (i_prefactor * i_sum + (</span><span class="s5">2 </span><span class="s1">/ M_PI) * special::cephes::sinpi(v) * k_prefactor * k_sum);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">/* 
         * The following code originates from the Boost C++ library, 
         * from file `boost/math/special_functions/detail/bessel_ik.hpp`, 
         * converted from C++ to C. 
         */</span>

        <span class="s0">/* 
         * Modified Bessel functions of the first and second kind of fractional order 
         * 
         * Calculate K(v, x) and K(v+1, x) by method analogous to 
         * Temme, Journal of Computational Physics, vol 21, 343 (1976) 
         */</span>
        <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s4">inline </span><span class="s2">int </span><span class="s1">temme_ik_series(</span><span class="s2">double </span><span class="s1">v, </span><span class="s2">double </span><span class="s1">x, </span><span class="s2">double </span><span class="s1">*K, </span><span class="s2">double </span><span class="s1">*K1) {</span>
            <span class="s2">double </span><span class="s1">f, h, p, q, coef, sum, sum1, tolerance;</span>
            <span class="s2">double </span><span class="s1">a, b, c, d, sigma, gamma1, gamma2;</span>
            <span class="s1">std::uint64_t k;</span>
            <span class="s2">double </span><span class="s1">gp;</span>
            <span class="s2">double </span><span class="s1">gm;</span>

            <span class="s0">/* 
             * |x| &lt;= 2, Temme series converge rapidly 
             * |x| &gt; 2, the larger the |x|, the slower the convergence 
             */</span>
            <span class="s1">SPECFUN_ASSERT(std::abs(x) &lt;= </span><span class="s5">2</span><span class="s1">);</span>
            <span class="s1">SPECFUN_ASSERT(std::abs(v) &lt;= </span><span class="s5">0</span><span class="s1">.</span><span class="s5">5</span><span class="s1">f);</span>

            <span class="s1">gp = special::cephes::Gamma(v + </span><span class="s5">1</span><span class="s1">) - </span><span class="s5">1</span><span class="s1">;</span>
            <span class="s1">gm = special::cephes::Gamma(-v + </span><span class="s5">1</span><span class="s1">) - </span><span class="s5">1</span><span class="s1">;</span>

            <span class="s1">a = std::log(x / </span><span class="s5">2</span><span class="s1">);</span>
            <span class="s1">b = std::exp(v * a);</span>
            <span class="s1">sigma = -a * v;</span>
            <span class="s1">c = std::abs(v) &lt; MACHEP ? </span><span class="s5">1 </span><span class="s1">: special::cephes::sinpi(v) / (v * M_PI);</span>
            <span class="s1">d = std::abs(sigma) &lt; MACHEP ? </span><span class="s5">1 </span><span class="s1">: std::sinh(sigma) / sigma;</span>
            <span class="s1">gamma1 = std::abs(v) &lt; MACHEP ? -SCIPY_EULER : (</span><span class="s5">0.5 </span><span class="s1">/ v) * (gp - gm) * c;</span>
            <span class="s1">gamma2 = (</span><span class="s5">2 </span><span class="s1">+ gp + gm) * c / </span><span class="s5">2</span><span class="s1">;</span>

            <span class="s0">/* initial values */</span>
            <span class="s1">p = (gp + </span><span class="s5">1</span><span class="s1">) / (</span><span class="s5">2 </span><span class="s1">* b);</span>
            <span class="s1">q = (</span><span class="s5">1 </span><span class="s1">+ gm) * b / </span><span class="s5">2</span><span class="s1">;</span>
            <span class="s1">f = (std::cosh(sigma) * gamma1 + d * (-a) * gamma2) / c;</span>
            <span class="s1">h = p;</span>
            <span class="s1">coef = </span><span class="s5">1</span><span class="s1">;</span>
            <span class="s1">sum = coef * f;</span>
            <span class="s1">sum1 = coef * h;</span>

            <span class="s0">/* series summation */</span>
            <span class="s1">tolerance = MACHEP;</span>
            <span class="s2">for </span><span class="s1">(k = </span><span class="s5">1</span><span class="s1">; k &lt; MAXITER; k++) {</span>
                <span class="s1">f = (k * f + p + q) / (k * k - v * v);</span>
                <span class="s1">p /= k - v;</span>
                <span class="s1">q /= k + v;</span>
                <span class="s1">h = p - k * f;</span>
                <span class="s1">coef *= x * x / (</span><span class="s5">4 </span><span class="s1">* k);</span>
                <span class="s1">sum += coef * f;</span>
                <span class="s1">sum1 += coef * h;</span>
                <span class="s2">if </span><span class="s1">(std::abs(coef * f) &lt; std::abs(sum) * tolerance) {</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(k == MAXITER) {</span>
                <span class="s1">set_error(</span><span class="s3">&quot;ikv_temme(temme_ik_series)&quot;</span><span class="s1">, SF_ERROR_NO_RESULT, NULL);</span>
            <span class="s1">}</span>

            <span class="s1">*K = sum;</span>
            <span class="s1">*K1 = </span><span class="s5">2 </span><span class="s1">* sum1 / x;</span>

            <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s0">/* Evaluate continued fraction fv = I_(v+1) / I_v, derived from 
         * Abramowitz and Stegun, Handbook of Mathematical Functions, 1972, 9.1.73 */</span>
        <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s4">inline </span><span class="s2">int </span><span class="s1">CF1_ik(</span><span class="s2">double </span><span class="s1">v, </span><span class="s2">double </span><span class="s1">x, </span><span class="s2">double </span><span class="s1">*fv) {</span>
            <span class="s2">double </span><span class="s1">C, D, f, a, b, delta, tiny, tolerance;</span>
            <span class="s1">std::uint64_t k;</span>

            <span class="s0">/* 
             * |x| &lt;= |v|, CF1_ik converges rapidly 
             * |x| &gt; |v|, CF1_ik needs O(|x|) iterations to converge 
             */</span>

            <span class="s0">/* 
             * modified Lentz's method, see 
             * Lentz, Applied Optics, vol 15, 668 (1976) 
             */</span>
            <span class="s1">tolerance = </span><span class="s5">2 </span><span class="s1">* MACHEP;</span>
            <span class="s1">tiny = </span><span class="s5">1 </span><span class="s1">/ std::sqrt(std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::max());</span>
            <span class="s1">C = f = tiny; </span><span class="s0">/* b0 = 0, replace with tiny */</span>
            <span class="s1">D = </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s2">for </span><span class="s1">(k = </span><span class="s5">1</span><span class="s1">; k &lt; MAXITER; k++) {</span>
                <span class="s1">a = </span><span class="s5">1</span><span class="s1">;</span>
                <span class="s1">b = </span><span class="s5">2 </span><span class="s1">* (v + k) / x;</span>
                <span class="s1">C = b + a / C;</span>
                <span class="s1">D = b + a * D;</span>
                <span class="s2">if </span><span class="s1">(C == </span><span class="s5">0</span><span class="s1">) {</span>
                    <span class="s1">C = tiny;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(D == </span><span class="s5">0</span><span class="s1">) {</span>
                    <span class="s1">D = tiny;</span>
                <span class="s1">}</span>
                <span class="s1">D = </span><span class="s5">1 </span><span class="s1">/ D;</span>
                <span class="s1">delta = C * D;</span>
                <span class="s1">f *= delta;</span>
                <span class="s2">if </span><span class="s1">(std::abs(delta - </span><span class="s5">1</span><span class="s1">) &lt;= tolerance) {</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(k == MAXITER) {</span>
                <span class="s1">set_error(</span><span class="s3">&quot;ikv_temme(CF1_ik)&quot;</span><span class="s1">, SF_ERROR_NO_RESULT, NULL);</span>
            <span class="s1">}</span>

            <span class="s1">*fv = f;</span>

            <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s0">/* 
         * Calculate K(v, x) and K(v+1, x) by evaluating continued fraction 
         * z1 / z0 = U(v+1.5, 2v+1, 2x) / U(v+0.5, 2v+1, 2x), see 
         * Thompson and Barnett, Computer Physics Communications, vol 47, 245 (1987) 
         */</span>
        <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s4">inline </span><span class="s2">int </span><span class="s1">CF2_ik(</span><span class="s2">double </span><span class="s1">v, </span><span class="s2">double </span><span class="s1">x, </span><span class="s2">double </span><span class="s1">*Kv, </span><span class="s2">double </span><span class="s1">*Kv1) {</span>

            <span class="s2">double </span><span class="s1">S, C, Q, D, f, a, b, q, delta, tolerance, current, prev;</span>
            <span class="s1">std::uint64_t k;</span>

            <span class="s0">/* 
             * |x| &gt;= |v|, CF2_ik converges rapidly 
             * |x| -&gt; 0, CF2_ik fails to converge 
             */</span>

            <span class="s1">SPECFUN_ASSERT(std::abs(x) &gt; </span><span class="s5">1</span><span class="s1">);</span>

            <span class="s0">/* 
             * Steed's algorithm, see Thompson and Barnett, 
             * Journal of Computational Physics, vol 64, 490 (1986) 
             */</span>
            <span class="s1">tolerance = MACHEP;</span>
            <span class="s1">a = v * v - </span><span class="s5">0.25</span><span class="s1">;</span>
            <span class="s1">b = </span><span class="s5">2 </span><span class="s1">* (x + </span><span class="s5">1</span><span class="s1">);                </span><span class="s0">/* b1 */</span>
            <span class="s1">D = </span><span class="s5">1 </span><span class="s1">/ b;                      </span><span class="s0">/* D1 = 1 / b1 */</span>
            <span class="s1">f = delta = D;                  </span><span class="s0">/* f1 = delta1 = D1, coincidence */</span>
            <span class="s1">prev = </span><span class="s5">0</span><span class="s1">;                       </span><span class="s0">/* q0 */</span>
            <span class="s1">current = </span><span class="s5">1</span><span class="s1">;                    </span><span class="s0">/* q1 */</span>
            <span class="s1">Q = C = -a;                     </span><span class="s0">/* Q1 = C1 because q1 = 1 */</span>
            <span class="s1">S = </span><span class="s5">1 </span><span class="s1">+ Q * delta;              </span><span class="s0">/* S1 */</span>
            <span class="s2">for </span><span class="s1">(k = </span><span class="s5">2</span><span class="s1">; k &lt; MAXITER; k++) { </span><span class="s0">/* starting from 2 */</span>
                <span class="s0">/* continued fraction f = z1 / z0 */</span>
                <span class="s1">a -= </span><span class="s5">2 </span><span class="s1">* (k - </span><span class="s5">1</span><span class="s1">);</span>
                <span class="s1">b += </span><span class="s5">2</span><span class="s1">;</span>
                <span class="s1">D = </span><span class="s5">1 </span><span class="s1">/ (b + a * D);</span>
                <span class="s1">delta *= b * D - </span><span class="s5">1</span><span class="s1">;</span>
                <span class="s1">f += delta;</span>

                <span class="s0">/* series summation S = 1 + \sum_{n=1}^{\infty} C_n * z_n / z_0 */</span>
                <span class="s1">q = (prev - (b - </span><span class="s5">2</span><span class="s1">) * current) / a;</span>
                <span class="s1">prev = current;</span>
                <span class="s1">current = q; </span><span class="s0">/* forward recurrence for q */</span>
                <span class="s1">C *= -a / k;</span>
                <span class="s1">Q += C * q;</span>
                <span class="s1">S += Q * delta;</span>

                <span class="s0">/* S converges slower than f */</span>
                <span class="s2">if </span><span class="s1">(std::abs(Q * delta) &lt; std::abs(S) * tolerance) {</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(k == MAXITER) {</span>
                <span class="s1">set_error(</span><span class="s3">&quot;ikv_temme(CF2_ik)&quot;</span><span class="s1">, SF_ERROR_NO_RESULT, NULL);</span>
            <span class="s1">}</span>

            <span class="s1">*Kv = std::sqrt(M_PI / (</span><span class="s5">2 </span><span class="s1">* x)) * std::exp(-x) / S;</span>
            <span class="s1">*Kv1 = *Kv * (</span><span class="s5">0.5 </span><span class="s1">+ v + x + (v * v - </span><span class="s5">0.25</span><span class="s1">) * f) / x;</span>

            <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s0">/* Flags for what to compute */</span>
        <span class="s2">enum </span><span class="s1">{ ikv_temme_need_i = </span><span class="s5">0x1</span><span class="s1">, ikv_temme_need_k = </span><span class="s5">0x2 </span><span class="s1">};</span>

        <span class="s0">/* 
         * Compute I(v, x) and K(v, x) simultaneously by Temme's method, see 
         * Temme, Journal of Computational Physics, vol 19, 324 (1975) 
         */</span>
        <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s4">inline </span><span class="s2">void </span><span class="s1">ikv_temme(</span><span class="s2">double </span><span class="s1">v, </span><span class="s2">double </span><span class="s1">x, </span><span class="s2">double </span><span class="s1">*Iv_p, </span><span class="s2">double </span><span class="s1">*Kv_p) {</span>
            <span class="s0">/* Kv1 = K_(v+1), fv = I_(v+1) / I_v */</span>
            <span class="s0">/* Ku1 = K_(u+1), fu = I_(u+1) / I_u */</span>
            <span class="s2">double </span><span class="s1">u, Iv, Kv, Kv1, Ku, Ku1, fv;</span>
            <span class="s2">double </span><span class="s1">W, current, prev, next;</span>
            <span class="s2">int </span><span class="s1">reflect = </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s2">unsigned </span><span class="s1">n, k;</span>
            <span class="s2">int </span><span class="s1">kind;</span>

            <span class="s1">kind = </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(Iv_p != NULL) {</span>
                <span class="s1">kind |= ikv_temme_need_i;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(Kv_p != NULL) {</span>
                <span class="s1">kind |= ikv_temme_need_k;</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(v &lt; </span><span class="s5">0</span><span class="s1">) {</span>
                <span class="s1">reflect = </span><span class="s5">1</span><span class="s1">;</span>
                <span class="s1">v = -v; </span><span class="s0">/* v is non-negative from here */</span>
                <span class="s1">kind |= ikv_temme_need_k;</span>
            <span class="s1">}</span>
            <span class="s1">n = std::round(v);</span>
            <span class="s1">u = v - n; </span><span class="s0">/* -1/2 &lt;= u &lt; 1/2 */</span>

            <span class="s2">if </span><span class="s1">(x &lt; </span><span class="s5">0</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(Iv_p != NULL)</span>
                    <span class="s1">*Iv_p = std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::quiet_NaN();</span>
                <span class="s2">if </span><span class="s1">(Kv_p != NULL)</span>
                    <span class="s1">*Kv_p = std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::quiet_NaN();</span>
                <span class="s1">set_error(</span><span class="s3">&quot;ikv_temme&quot;</span><span class="s1">, SF_ERROR_DOMAIN, NULL);</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(x == </span><span class="s5">0</span><span class="s1">) {</span>
                <span class="s1">Iv = (v == </span><span class="s5">0</span><span class="s1">) ? </span><span class="s5">1 </span><span class="s1">: </span><span class="s5">0</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(kind &amp; ikv_temme_need_k) {</span>
                    <span class="s1">set_error(</span><span class="s3">&quot;ikv_temme&quot;</span><span class="s1">, SF_ERROR_OVERFLOW, NULL);</span>
                    <span class="s1">Kv = std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::infinity();</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">Kv = std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::quiet_NaN(); </span><span class="s0">/* any value will do */</span>
                <span class="s1">}</span>

                <span class="s2">if </span><span class="s1">(reflect &amp;&amp; (kind &amp; ikv_temme_need_i)) {</span>
                    <span class="s2">double </span><span class="s1">z = (u + n % </span><span class="s5">2</span><span class="s1">);</span>

                    <span class="s1">Iv = special::cephes::sinpi(z) == </span><span class="s5">0 </span><span class="s1">? Iv : std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::infinity();</span>
                    <span class="s2">if </span><span class="s1">(std::isinf(Iv)) {</span>
                        <span class="s1">set_error(</span><span class="s3">&quot;ikv_temme&quot;</span><span class="s1">, SF_ERROR_OVERFLOW, NULL);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>

                <span class="s2">if </span><span class="s1">(Iv_p != NULL) {</span>
                    <span class="s1">*Iv_p = Iv;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(Kv_p != NULL) {</span>
                    <span class="s1">*Kv_p = Kv;</span>
                <span class="s1">}</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">/* x is positive until reflection */</span>
            <span class="s1">W = </span><span class="s5">1 </span><span class="s1">/ x;                            </span><span class="s0">/* Wronskian */</span>
            <span class="s2">if </span><span class="s1">(x &lt;= </span><span class="s5">2</span><span class="s1">) {                         </span><span class="s0">/* x in (0, 2] */</span>
                <span class="s1">temme_ik_series(u, x, &amp;Ku, &amp;Ku1); </span><span class="s0">/* Temme series */</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{                              </span><span class="s0">/* x in (2, \infty) */</span>
                <span class="s1">CF2_ik(u, x, &amp;Ku, &amp;Ku1);          </span><span class="s0">/* continued fraction CF2_ik */</span>
            <span class="s1">}</span>
            <span class="s1">prev = Ku;</span>
            <span class="s1">current = Ku1;</span>
            <span class="s2">for </span><span class="s1">(k = </span><span class="s5">1</span><span class="s1">; k &lt;= n; k++) { </span><span class="s0">/* forward recurrence for K */</span>
                <span class="s1">next = </span><span class="s5">2 </span><span class="s1">* (u + k) * current / x + prev;</span>
                <span class="s1">prev = current;</span>
                <span class="s1">current = next;</span>
            <span class="s1">}</span>
            <span class="s1">Kv = prev;</span>
            <span class="s1">Kv1 = current;</span>
            <span class="s2">if </span><span class="s1">(kind &amp; ikv_temme_need_i) {</span>
                <span class="s2">double </span><span class="s1">lim = (</span><span class="s5">4 </span><span class="s1">* v * v + </span><span class="s5">10</span><span class="s1">) / (</span><span class="s5">8 </span><span class="s1">* x);</span>

                <span class="s1">lim *= lim;</span>
                <span class="s1">lim *= lim;</span>
                <span class="s1">lim /= </span><span class="s5">24</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">((lim &lt; MACHEP * </span><span class="s5">10</span><span class="s1">) &amp;&amp; (x &gt; </span><span class="s5">100</span><span class="s1">)) {</span>
                    <span class="s0">/* 
                     * x is huge compared to v, CF1 may be very slow 
                     * to converge so use asymptotic expansion for large 
                     * x case instead.  Note that the asymptotic expansion 
                     * isn't very accurate - so it's deliberately very hard 
                     * to get here - probably we're going to overflow: 
                     */</span>
                    <span class="s1">Iv = iv_asymptotic(v, x);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">CF1_ik(v, x, &amp;fv);        </span><span class="s0">/* continued fraction CF1_ik */</span>
                    <span class="s1">Iv = W / (Kv * fv + Kv1); </span><span class="s0">/* Wronskian relation */</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">Iv = std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::quiet_NaN(); </span><span class="s0">/* any value will do */</span>
            <span class="s1">}</span>

            <span class="s2">if </span><span class="s1">(reflect) {</span>
                <span class="s2">double </span><span class="s1">z = (u + n % </span><span class="s5">2</span><span class="s1">);</span>

                <span class="s2">if </span><span class="s1">(Iv_p != NULL) {</span>
                    <span class="s1">*Iv_p = Iv + (</span><span class="s5">2 </span><span class="s1">/ M_PI) * special::cephes::sinpi(z) * Kv; </span><span class="s0">/* reflection formula */</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(Kv_p != NULL) {</span>
                    <span class="s1">*Kv_p = Kv;</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s2">if </span><span class="s1">(Iv_p != NULL) {</span>
                    <span class="s1">*Iv_p = Iv;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(Kv_p != NULL) {</span>
                    <span class="s1">*Kv_p = Kv;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

    <span class="s1">} </span><span class="s0">// namespace detail</span>

    <span class="s1">SPECFUN_HOST_DEVICE </span><span class="s4">inline </span><span class="s2">double </span><span class="s1">iv(</span><span class="s2">double </span><span class="s1">v, </span><span class="s2">double </span><span class="s1">x) {</span>
        <span class="s2">int </span><span class="s1">sign;</span>
        <span class="s2">double </span><span class="s1">t, ax, res;</span>

        <span class="s2">if </span><span class="s1">(std::isnan(v) || std::isnan(x)) {</span>
            <span class="s2">return </span><span class="s1">std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::quiet_NaN();</span>
        <span class="s1">}</span>

        <span class="s0">/* If v is a negative integer, invoke symmetry */</span>
        <span class="s1">t = std::floor(v);</span>
        <span class="s2">if </span><span class="s1">(v &lt; </span><span class="s5">0.0</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(t == v) {</span>
                <span class="s1">v = -v; </span><span class="s0">/* symmetry */</span>
                <span class="s1">t = -t;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">/* If x is negative, require v to be an integer */</span>
        <span class="s1">sign = </span><span class="s5">1</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(x &lt; </span><span class="s5">0.0</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(t != v) {</span>
                <span class="s1">set_error(</span><span class="s3">&quot;iv&quot;</span><span class="s1">, SF_ERROR_DOMAIN, NULL);</span>
                <span class="s2">return </span><span class="s1">(std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::quiet_NaN());</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(v != </span><span class="s5">2.0 </span><span class="s1">* std::floor(v / </span><span class="s5">2.0</span><span class="s1">)) {</span>
                <span class="s1">sign = -</span><span class="s5">1</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">/* Avoid logarithm singularity */</span>
        <span class="s2">if </span><span class="s1">(x == </span><span class="s5">0.0</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(v == </span><span class="s5">0.0</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s5">1.0</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(v &lt; </span><span class="s5">0.0</span><span class="s1">) {</span>
                <span class="s1">set_error(</span><span class="s3">&quot;iv&quot;</span><span class="s1">, SF_ERROR_OVERFLOW, NULL);</span>
                <span class="s2">return </span><span class="s1">std::numeric_limits&lt;</span><span class="s2">double</span><span class="s1">&gt;::infinity();</span>
            <span class="s1">} </span><span class="s2">else</span>
                <span class="s2">return </span><span class="s5">0.0</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">ax = std::abs(x);</span>
        <span class="s2">if </span><span class="s1">(std::abs(v) &gt; </span><span class="s5">50</span><span class="s1">) {</span>
            <span class="s0">/* 
             * Uniform asymptotic expansion for large orders. 
             * 
             * This appears to overflow slightly later than the Boost 
             * implementation of Temme's method. 
             */</span>
            <span class="s1">detail::ikv_asymptotic_uniform(v, ax, &amp;res, NULL);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s0">/* Otherwise: Temme's method */</span>
            <span class="s1">detail::ikv_temme(v, ax, &amp;res, NULL);</span>
        <span class="s1">}</span>
        <span class="s1">res *= sign;</span>
        <span class="s2">return </span><span class="s1">res;</span>
    <span class="s1">}</span>

<span class="s1">} </span><span class="s0">// namespace cephes</span>
<span class="s1">} </span><span class="s0">// namespace special</span>
</pre>
</body>
</html>