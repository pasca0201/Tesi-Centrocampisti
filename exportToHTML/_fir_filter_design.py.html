<html>
<head>
<title>_fir_filter_design.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_fir_filter_design.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Functions for FIR filter design.&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">math </span><span class="s2">import </span><span class="s1">ceil</span><span class="s3">, </span><span class="s1">log</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Literal</span><span class="s3">, </span><span class="s1">Optional</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">fft </span><span class="s2">import </span><span class="s1">irfft</span><span class="s3">, </span><span class="s1">fft</span><span class="s3">, </span><span class="s1">ifft</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special </span><span class="s2">import </span><span class="s1">sinc</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">linalg </span><span class="s2">import </span><span class="s3">(</span><span class="s1">toeplitz</span><span class="s3">, </span><span class="s1">hankel</span><span class="s3">, </span><span class="s1">solve</span><span class="s3">, </span><span class="s1">LinAlgError</span><span class="s3">, </span><span class="s1">LinAlgWarning</span><span class="s3">,</span>
                          <span class="s1">lstsq</span><span class="s3">)</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">signal</span><span class="s3">.</span><span class="s1">_arraytools </span><span class="s2">import </span><span class="s1">_validate_fs</span>

<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">_sigtools</span>

<span class="s1">__all__ </span><span class="s3">= [</span><span class="s4">'kaiser_beta'</span><span class="s3">, </span><span class="s4">'kaiser_atten'</span><span class="s3">, </span><span class="s4">'kaiserord'</span><span class="s3">,</span>
           <span class="s4">'firwin'</span><span class="s3">, </span><span class="s4">'firwin2'</span><span class="s3">, </span><span class="s4">'remez'</span><span class="s3">, </span><span class="s4">'firls'</span><span class="s3">, </span><span class="s4">'minimum_phase'</span><span class="s3">]</span>


<span class="s5"># Some notes on function parameters:</span>
<span class="s5">#</span>
<span class="s5"># `cutoff` and `width` are given as numbers between 0 and 1.  These are</span>
<span class="s5"># relative frequencies, expressed as a fraction of the Nyquist frequency.</span>
<span class="s5"># For example, if the Nyquist frequency is 2 KHz, then width=0.15 is a width</span>
<span class="s5"># of 300 Hz.</span>
<span class="s5">#</span>
<span class="s5"># The `order` of a FIR filter is one less than the number of taps.</span>
<span class="s5"># This is a potential source of confusion, so in the following code,</span>
<span class="s5"># we will always use the number of taps as the parameterization of</span>
<span class="s5"># the 'size' of the filter. The &quot;number of taps&quot; means the number</span>
<span class="s5"># of coefficients, which is the same as the length of the impulse</span>
<span class="s5"># response of the filter.</span>


<span class="s2">def </span><span class="s1">kaiser_beta</span><span class="s3">(</span><span class="s1">a</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the Kaiser parameter `beta`, given the attenuation `a`. 
 
    Parameters 
    ---------- 
    a : float 
        The desired attenuation in the stopband and maximum ripple in 
        the passband, in dB.  This should be a *positive* number. 
 
    Returns 
    ------- 
    beta : float 
        The `beta` parameter to be used in the formula for a Kaiser window. 
 
    References 
    ---------- 
    Oppenheim, Schafer, &quot;Discrete-Time Signal Processing&quot;, p.475-476. 
 
    Examples 
    -------- 
    Suppose we want to design a lowpass filter, with 65 dB attenuation 
    in the stop band.  The Kaiser window parameter to be used in the 
    window method is computed by ``kaiser_beta(65)``: 
 
    &gt;&gt;&gt; from scipy.signal import kaiser_beta 
    &gt;&gt;&gt; kaiser_beta(65) 
    6.20426 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">a </span><span class="s3">&gt; </span><span class="s6">50</span><span class="s3">:</span>
        <span class="s1">beta </span><span class="s3">= </span><span class="s6">0.1102 </span><span class="s3">* (</span><span class="s1">a </span><span class="s3">- </span><span class="s6">8.7</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">a </span><span class="s3">&gt; </span><span class="s6">21</span><span class="s3">:</span>
        <span class="s1">beta </span><span class="s3">= </span><span class="s6">0.5842 </span><span class="s3">* (</span><span class="s1">a </span><span class="s3">- </span><span class="s6">21</span><span class="s3">) ** </span><span class="s6">0.4 </span><span class="s3">+ </span><span class="s6">0.07886 </span><span class="s3">* (</span><span class="s1">a </span><span class="s3">- </span><span class="s6">21</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">beta </span><span class="s3">= </span><span class="s6">0.0</span>
    <span class="s2">return </span><span class="s1">beta</span>


<span class="s2">def </span><span class="s1">kaiser_atten</span><span class="s3">(</span><span class="s1">numtaps</span><span class="s3">, </span><span class="s1">width</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the attenuation of a Kaiser FIR filter. 
 
    Given the number of taps `N` and the transition width `width`, compute the 
    attenuation `a` in dB, given by Kaiser's formula: 
 
        a = 2.285 * (N - 1) * pi * width + 7.95 
 
    Parameters 
    ---------- 
    numtaps : int 
        The number of taps in the FIR filter. 
    width : float 
        The desired width of the transition region between passband and 
        stopband (or, in general, at any discontinuity) for the filter, 
        expressed as a fraction of the Nyquist frequency. 
 
    Returns 
    ------- 
    a : float 
        The attenuation of the ripple, in dB. 
 
    See Also 
    -------- 
    kaiserord, kaiser_beta 
 
    Examples 
    -------- 
    Suppose we want to design a FIR filter using the Kaiser window method 
    that will have 211 taps and a transition width of 9 Hz for a signal that 
    is sampled at 480 Hz. Expressed as a fraction of the Nyquist frequency, 
    the width is 9/(0.5*480) = 0.0375. The approximate attenuation (in dB) 
    is computed as follows: 
 
    &gt;&gt;&gt; from scipy.signal import kaiser_atten 
    &gt;&gt;&gt; kaiser_atten(211, 0.0375) 
    64.48099630593983 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s6">2.285 </span><span class="s3">* (</span><span class="s1">numtaps </span><span class="s3">- </span><span class="s6">1</span><span class="s3">) * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">width </span><span class="s3">+ </span><span class="s6">7.95</span>
    <span class="s2">return </span><span class="s1">a</span>


<span class="s2">def </span><span class="s1">kaiserord</span><span class="s3">(</span><span class="s1">ripple</span><span class="s3">, </span><span class="s1">width</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Determine the filter window parameters for the Kaiser window method. 
 
    The parameters returned by this function are generally used to create 
    a finite impulse response filter using the window method, with either 
    `firwin` or `firwin2`. 
 
    Parameters 
    ---------- 
    ripple : float 
        Upper bound for the deviation (in dB) of the magnitude of the 
        filter's frequency response from that of the desired filter (not 
        including frequencies in any transition intervals). That is, if w 
        is the frequency expressed as a fraction of the Nyquist frequency, 
        A(w) is the actual frequency response of the filter and D(w) is the 
        desired frequency response, the design requirement is that:: 
 
            abs(A(w) - D(w))) &lt; 10**(-ripple/20) 
 
        for 0 &lt;= w &lt;= 1 and w not in a transition interval. 
    width : float 
        Width of transition region, normalized so that 1 corresponds to pi 
        radians / sample. That is, the frequency is expressed as a fraction 
        of the Nyquist frequency. 
 
    Returns 
    ------- 
    numtaps : int 
        The length of the Kaiser window. 
    beta : float 
        The beta parameter for the Kaiser window. 
 
    See Also 
    -------- 
    kaiser_beta, kaiser_atten 
 
    Notes 
    ----- 
    There are several ways to obtain the Kaiser window: 
 
    - ``signal.windows.kaiser(numtaps, beta, sym=True)`` 
    - ``signal.get_window(beta, numtaps)`` 
    - ``signal.get_window(('kaiser', beta), numtaps)`` 
 
    The empirical equations discovered by Kaiser are used. 
 
    References 
    ---------- 
    Oppenheim, Schafer, &quot;Discrete-Time Signal Processing&quot;, pp.475-476. 
 
    Examples 
    -------- 
    We will use the Kaiser window method to design a lowpass FIR filter 
    for a signal that is sampled at 1000 Hz. 
 
    We want at least 65 dB rejection in the stop band, and in the pass 
    band the gain should vary no more than 0.5%. 
 
    We want a cutoff frequency of 175 Hz, with a transition between the 
    pass band and the stop band of 24 Hz. That is, in the band [0, 163], 
    the gain varies no more than 0.5%, and in the band [187, 500], the 
    signal is attenuated by at least 65 dB. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal import kaiserord, firwin, freqz 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fs = 1000.0 
    &gt;&gt;&gt; cutoff = 175 
    &gt;&gt;&gt; width = 24 
 
    The Kaiser method accepts just a single parameter to control the pass 
    band ripple and the stop band rejection, so we use the more restrictive 
    of the two. In this case, the pass band ripple is 0.005, or 46.02 dB, 
    so we will use 65 dB as the design parameter. 
 
    Use `kaiserord` to determine the length of the filter and the 
    parameter for the Kaiser window. 
 
    &gt;&gt;&gt; numtaps, beta = kaiserord(65, width/(0.5*fs)) 
    &gt;&gt;&gt; numtaps 
    167 
    &gt;&gt;&gt; beta 
    6.20426 
 
    Use `firwin` to create the FIR filter. 
 
    &gt;&gt;&gt; taps = firwin(numtaps, cutoff, window=('kaiser', beta), 
    ...               scale=False, fs=fs) 
 
    Compute the frequency response of the filter.  ``w`` is the array of 
    frequencies, and ``h`` is the corresponding complex array of frequency 
    responses. 
 
    &gt;&gt;&gt; w, h = freqz(taps, worN=8000) 
    &gt;&gt;&gt; w *= 0.5*fs/np.pi  # Convert w to Hz. 
 
    Compute the deviation of the magnitude of the filter's response from 
    that of the ideal lowpass filter. Values in the transition region are 
    set to ``nan``, so they won't appear in the plot. 
 
    &gt;&gt;&gt; ideal = w &lt; cutoff  # The &quot;ideal&quot; frequency response. 
    &gt;&gt;&gt; deviation = np.abs(np.abs(h) - ideal) 
    &gt;&gt;&gt; deviation[(w &gt; cutoff - 0.5*width) &amp; (w &lt; cutoff + 0.5*width)] = np.nan 
 
    Plot the deviation. A close look at the left end of the stop band shows 
    that the requirement for 65 dB attenuation is violated in the first lobe 
    by about 0.125 dB. This is not unusual for the Kaiser window method. 
 
    &gt;&gt;&gt; plt.plot(w, 20*np.log10(np.abs(deviation))) 
    &gt;&gt;&gt; plt.xlim(0, 0.5*fs) 
    &gt;&gt;&gt; plt.ylim(-90, -60) 
    &gt;&gt;&gt; plt.grid(alpha=0.25) 
    &gt;&gt;&gt; plt.axhline(-65, color='r', ls='--', alpha=0.3) 
    &gt;&gt;&gt; plt.xlabel('Frequency (Hz)') 
    &gt;&gt;&gt; plt.ylabel('Deviation from ideal (dB)') 
    &gt;&gt;&gt; plt.title('Lowpass Filter Frequency Response') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">A </span><span class="s3">= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">ripple</span><span class="s3">)  </span><span class="s5"># in case somebody is confused as to what's meant</span>
    <span class="s2">if </span><span class="s1">A </span><span class="s3">&lt; </span><span class="s6">8</span><span class="s3">:</span>
        <span class="s5"># Formula for N is not valid in this range.</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Requested maximum ripple attenuation %f is too &quot;</span>
                         <span class="s4">&quot;small for the Kaiser formula.&quot; </span><span class="s3">% </span><span class="s1">A</span><span class="s3">)</span>
    <span class="s1">beta </span><span class="s3">= </span><span class="s1">kaiser_beta</span><span class="s3">(</span><span class="s1">A</span><span class="s3">)</span>

    <span class="s5"># Kaiser's formula (as given in Oppenheim and Schafer) is for the filter</span>
    <span class="s5"># order, so we have to add 1 to get the number of taps.</span>
    <span class="s1">numtaps </span><span class="s3">= (</span><span class="s1">A </span><span class="s3">- </span><span class="s6">7.95</span><span class="s3">) / </span><span class="s6">2.285 </span><span class="s3">/ (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">width</span><span class="s3">) + </span><span class="s6">1</span>

    <span class="s2">return </span><span class="s1">int</span><span class="s3">(</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">numtaps</span><span class="s3">)), </span><span class="s1">beta</span>


<span class="s2">def </span><span class="s1">firwin</span><span class="s3">(</span><span class="s1">numtaps</span><span class="s3">, </span><span class="s1">cutoff</span><span class="s3">, *, </span><span class="s1">width</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">window</span><span class="s3">=</span><span class="s4">'hamming'</span><span class="s3">, </span><span class="s1">pass_zero</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
           <span class="s1">scale</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    FIR filter design using the window method. 
 
    This function computes the coefficients of a finite impulse response 
    filter. The filter will have linear phase; it will be Type I if 
    `numtaps` is odd and Type II if `numtaps` is even. 
 
    Type II filters always have zero response at the Nyquist frequency, so a 
    ValueError exception is raised if firwin is called with `numtaps` even and 
    having a passband whose right end is at the Nyquist frequency. 
 
    Parameters 
    ---------- 
    numtaps : int 
        Length of the filter (number of coefficients, i.e. the filter 
        order + 1).  `numtaps` must be odd if a passband includes the 
        Nyquist frequency. 
    cutoff : float or 1-D array_like 
        Cutoff frequency of filter (expressed in the same units as `fs`) 
        OR an array of cutoff frequencies (that is, band edges). In the 
        latter case, the frequencies in `cutoff` should be positive and 
        monotonically increasing between 0 and `fs/2`. The values 0 and 
        `fs/2` must not be included in `cutoff`. 
    width : float or None, optional 
        If `width` is not None, then assume it is the approximate width 
        of the transition region (expressed in the same units as `fs`) 
        for use in Kaiser FIR filter design. In this case, the `window` 
        argument is ignored. 
    window : string or tuple of string and parameter values, optional 
        Desired window to use. See `scipy.signal.get_window` for a list 
        of windows and required parameters. 
    pass_zero : {True, False, 'bandpass', 'lowpass', 'highpass', 'bandstop'}, optional 
        If True, the gain at the frequency 0 (i.e., the &quot;DC gain&quot;) is 1. 
        If False, the DC gain is 0. Can also be a string argument for the 
        desired filter type (equivalent to ``btype`` in IIR design functions). 
 
        .. versionadded:: 1.3.0 
           Support for string arguments. 
    scale : bool, optional 
        Set to True to scale the coefficients so that the frequency 
        response is exactly unity at a certain frequency. 
        That frequency is either: 
 
        - 0 (DC) if the first passband starts at 0 (i.e. pass_zero 
          is True) 
        - `fs/2` (the Nyquist frequency) if the first passband ends at 
          `fs/2` (i.e the filter is a single band highpass filter); 
          center of first passband otherwise 
 
    fs : float, optional 
        The sampling frequency of the signal. Each frequency in `cutoff` 
        must be between 0 and ``fs/2``.  Default is 2. 
 
    Returns 
    ------- 
    h : (numtaps,) ndarray 
        Coefficients of length `numtaps` FIR filter. 
 
    Raises 
    ------ 
    ValueError 
        If any value in `cutoff` is less than or equal to 0 or greater 
        than or equal to ``fs/2``, if the values in `cutoff` are not strictly 
        monotonically increasing, or if `numtaps` is even but a passband 
        includes the Nyquist frequency. 
 
    See Also 
    -------- 
    firwin2 
    firls 
    minimum_phase 
    remez 
 
    Examples 
    -------- 
    Low-pass from 0 to f: 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; numtaps = 3 
    &gt;&gt;&gt; f = 0.1 
    &gt;&gt;&gt; signal.firwin(numtaps, f) 
    array([ 0.06799017,  0.86401967,  0.06799017]) 
 
    Use a specific window function: 
 
    &gt;&gt;&gt; signal.firwin(numtaps, f, window='nuttall') 
    array([  3.56607041e-04,   9.99286786e-01,   3.56607041e-04]) 
 
    High-pass ('stop' from 0 to f): 
 
    &gt;&gt;&gt; signal.firwin(numtaps, f, pass_zero=False) 
    array([-0.00859313,  0.98281375, -0.00859313]) 
 
    Band-pass: 
 
    &gt;&gt;&gt; f1, f2 = 0.1, 0.2 
    &gt;&gt;&gt; signal.firwin(numtaps, [f1, f2], pass_zero=False) 
    array([ 0.06301614,  0.88770441,  0.06301614]) 
 
    Band-stop: 
 
    &gt;&gt;&gt; signal.firwin(numtaps, [f1, f2]) 
    array([-0.00801395,  1.0160279 , -0.00801395]) 
 
    Multi-band (passbands are [0, f1], [f2, f3] and [f4, 1]): 
 
    &gt;&gt;&gt; f3, f4 = 0.3, 0.4 
    &gt;&gt;&gt; signal.firwin(numtaps, [f1, f2, f3, f4]) 
    array([-0.01376344,  1.02752689, -0.01376344]) 
 
    Multi-band (passbands are [f1, f2] and [f3,f4]): 
 
    &gt;&gt;&gt; signal.firwin(numtaps, [f1, f2, f3, f4], pass_zero=False) 
    array([ 0.04890915,  0.91284326,  0.04890915]) 
 
    &quot;&quot;&quot;</span>
    <span class="s5"># The major enhancements to this function added in November 2010 were</span>
    <span class="s5"># developed by Tom Krauss (see ticket #902).</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s6">2 </span><span class="s2">if </span><span class="s1">fs </span><span class="s2">is None else </span><span class="s1">fs</span>

    <span class="s1">nyq </span><span class="s3">= </span><span class="s6">0.5 </span><span class="s3">* </span><span class="s1">fs</span>

    <span class="s1">cutoff </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">atleast_1d</span><span class="s3">(</span><span class="s1">cutoff</span><span class="s3">) / </span><span class="s1">float</span><span class="s3">(</span><span class="s1">nyq</span><span class="s3">)</span>

    <span class="s5"># Check for invalid input.</span>
    <span class="s2">if </span><span class="s1">cutoff</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&gt; </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;The cutoff argument must be at most &quot;</span>
                         <span class="s4">&quot;one-dimensional.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">cutoff</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;At least one cutoff frequency must be given.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">cutoff</span><span class="s3">.</span><span class="s1">min</span><span class="s3">() &lt;= </span><span class="s6">0 </span><span class="s2">or </span><span class="s1">cutoff</span><span class="s3">.</span><span class="s1">max</span><span class="s3">() &gt;= </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Invalid cutoff frequency: frequencies must be &quot;</span>
                         <span class="s4">&quot;greater than 0 and less than fs/2.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">cutoff</span><span class="s3">) &lt;= </span><span class="s6">0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Invalid cutoff frequencies: the frequencies &quot;</span>
                         <span class="s4">&quot;must be strictly increasing.&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">width </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s5"># A width was given.  Find the beta parameter of the Kaiser window</span>
        <span class="s5"># and set `window`.  This overrides the value of `window` passed in.</span>
        <span class="s1">atten </span><span class="s3">= </span><span class="s1">kaiser_atten</span><span class="s3">(</span><span class="s1">numtaps</span><span class="s3">, </span><span class="s1">float</span><span class="s3">(</span><span class="s1">width</span><span class="s3">) / </span><span class="s1">nyq</span><span class="s3">)</span>
        <span class="s1">beta </span><span class="s3">= </span><span class="s1">kaiser_beta</span><span class="s3">(</span><span class="s1">atten</span><span class="s3">)</span>
        <span class="s1">window </span><span class="s3">= (</span><span class="s4">'kaiser'</span><span class="s3">, </span><span class="s1">beta</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">pass_zero</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">pass_zero </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'bandstop'</span><span class="s3">, </span><span class="s4">'lowpass'</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">pass_zero </span><span class="s3">== </span><span class="s4">'lowpass'</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">cutoff</span><span class="s3">.</span><span class="s1">size </span><span class="s3">!= </span><span class="s6">1</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'cutoff must have one element if '</span>
                                     <span class="s4">f'pass_zero==&quot;lowpass&quot;, got </span><span class="s2">{</span><span class="s1">cutoff</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">cutoff</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&lt;= </span><span class="s6">1</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'cutoff must have at least two elements if '</span>
                                 <span class="s4">f'pass_zero==&quot;bandstop&quot;, got </span><span class="s2">{</span><span class="s1">cutoff</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
            <span class="s1">pass_zero </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">pass_zero </span><span class="s2">in </span><span class="s3">(</span><span class="s4">'bandpass'</span><span class="s3">, </span><span class="s4">'highpass'</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">pass_zero </span><span class="s3">== </span><span class="s4">'highpass'</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">cutoff</span><span class="s3">.</span><span class="s1">size </span><span class="s3">!= </span><span class="s6">1</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'cutoff must have one element if '</span>
                                     <span class="s4">f'pass_zero==&quot;highpass&quot;, got </span><span class="s2">{</span><span class="s1">cutoff</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">cutoff</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&lt;= </span><span class="s6">1</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'cutoff must have at least two elements if '</span>
                                 <span class="s4">f'pass_zero==&quot;bandpass&quot;, got </span><span class="s2">{</span><span class="s1">cutoff</span><span class="s3">.</span><span class="s1">shape</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
            <span class="s1">pass_zero </span><span class="s3">= </span><span class="s2">False</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'pass_zero must be True, False, &quot;bandpass&quot;, '</span>
                             <span class="s4">'&quot;lowpass&quot;, &quot;highpass&quot;, or &quot;bandstop&quot;, got '</span>
                             <span class="s4">f'</span><span class="s2">{</span><span class="s1">pass_zero</span><span class="s2">}</span><span class="s4">'</span><span class="s3">)</span>
    <span class="s1">pass_zero </span><span class="s3">= </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">operator</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">pass_zero</span><span class="s3">))  </span><span class="s5"># ensure bool-like</span>

    <span class="s1">pass_nyquist </span><span class="s3">= </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">cutoff</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&amp; </span><span class="s6">1</span><span class="s3">) ^ </span><span class="s1">pass_zero</span>
    <span class="s2">if </span><span class="s1">pass_nyquist </span><span class="s2">and </span><span class="s1">numtaps </span><span class="s3">% </span><span class="s6">2 </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;A filter with an even number of coefficients must &quot;</span>
                         <span class="s4">&quot;have zero response at the Nyquist frequency.&quot;</span><span class="s3">)</span>

    <span class="s5"># Insert 0 and/or 1 at the ends of cutoff so that the length of cutoff</span>
    <span class="s5"># is even, and each pair in cutoff corresponds to passband.</span>
    <span class="s1">cutoff </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">(([</span><span class="s6">0.0</span><span class="s3">] * </span><span class="s1">pass_zero</span><span class="s3">, </span><span class="s1">cutoff</span><span class="s3">, [</span><span class="s6">1.0</span><span class="s3">] * </span><span class="s1">pass_nyquist</span><span class="s3">))</span>

    <span class="s5"># `bands` is a 2-D array; each row gives the left and right edges of</span>
    <span class="s5"># a passband.</span>
    <span class="s1">bands </span><span class="s3">= </span><span class="s1">cutoff</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">)</span>

    <span class="s5"># Build up the coefficients.</span>
    <span class="s1">alpha </span><span class="s3">= </span><span class="s6">0.5 </span><span class="s3">* (</span><span class="s1">numtaps </span><span class="s3">- </span><span class="s6">1</span><span class="s3">)</span>
    <span class="s1">m </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">numtaps</span><span class="s3">) - </span><span class="s1">alpha</span>
    <span class="s1">h </span><span class="s3">= </span><span class="s6">0</span>
    <span class="s2">for </span><span class="s1">left</span><span class="s3">, </span><span class="s1">right </span><span class="s2">in </span><span class="s1">bands</span><span class="s3">:</span>
        <span class="s1">h </span><span class="s3">+= </span><span class="s1">right </span><span class="s3">* </span><span class="s1">sinc</span><span class="s3">(</span><span class="s1">right </span><span class="s3">* </span><span class="s1">m</span><span class="s3">)</span>
        <span class="s1">h </span><span class="s3">-= </span><span class="s1">left </span><span class="s3">* </span><span class="s1">sinc</span><span class="s3">(</span><span class="s1">left </span><span class="s3">* </span><span class="s1">m</span><span class="s3">)</span>

    <span class="s5"># Get and apply the window function.</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">windows </span><span class="s2">import </span><span class="s1">get_window</span>
    <span class="s1">win </span><span class="s3">= </span><span class="s1">get_window</span><span class="s3">(</span><span class="s1">window</span><span class="s3">, </span><span class="s1">numtaps</span><span class="s3">, </span><span class="s1">fftbins</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">h </span><span class="s3">*= </span><span class="s1">win</span>

    <span class="s5"># Now handle scaling if desired.</span>
    <span class="s2">if </span><span class="s1">scale</span><span class="s3">:</span>
        <span class="s5"># Get the first passband.</span>
        <span class="s1">left</span><span class="s3">, </span><span class="s1">right </span><span class="s3">= </span><span class="s1">bands</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s1">left </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">scale_frequency </span><span class="s3">= </span><span class="s6">0.0</span>
        <span class="s2">elif </span><span class="s1">right </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s1">scale_frequency </span><span class="s3">= </span><span class="s6">1.0</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">scale_frequency </span><span class="s3">= </span><span class="s6">0.5 </span><span class="s3">* (</span><span class="s1">left </span><span class="s3">+ </span><span class="s1">right</span><span class="s3">)</span>
        <span class="s1">c </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">m </span><span class="s3">* </span><span class="s1">scale_frequency</span><span class="s3">)</span>
        <span class="s1">s </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">h </span><span class="s3">* </span><span class="s1">c</span><span class="s3">)</span>
        <span class="s1">h </span><span class="s3">/= </span><span class="s1">s</span>

    <span class="s2">return </span><span class="s1">h</span>


<span class="s5"># Original version of firwin2 from scipy ticket #457, submitted by &quot;tash&quot;.</span>
<span class="s5">#</span>
<span class="s5"># Rewritten by Warren Weckesser, 2010.</span>
<span class="s2">def </span><span class="s1">firwin2</span><span class="s3">(</span><span class="s1">numtaps</span><span class="s3">, </span><span class="s1">freq</span><span class="s3">, </span><span class="s1">gain</span><span class="s3">, *, </span><span class="s1">nfreqs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">window</span><span class="s3">=</span><span class="s4">'hamming'</span><span class="s3">,</span>
            <span class="s1">antisymmetric</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    FIR filter design using the window method. 
 
    From the given frequencies `freq` and corresponding gains `gain`, 
    this function constructs an FIR filter with linear phase and 
    (approximately) the given frequency response. 
 
    Parameters 
    ---------- 
    numtaps : int 
        The number of taps in the FIR filter.  `numtaps` must be less than 
        `nfreqs`. 
    freq : array_like, 1-D 
        The frequency sampling points. Typically 0.0 to 1.0 with 1.0 being 
        Nyquist.  The Nyquist frequency is half `fs`. 
        The values in `freq` must be nondecreasing. A value can be repeated 
        once to implement a discontinuity. The first value in `freq` must 
        be 0, and the last value must be ``fs/2``. Values 0 and ``fs/2`` must 
        not be repeated. 
    gain : array_like 
        The filter gains at the frequency sampling points. Certain 
        constraints to gain values, depending on the filter type, are applied, 
        see Notes for details. 
    nfreqs : int, optional 
        The size of the interpolation mesh used to construct the filter. 
        For most efficient behavior, this should be a power of 2 plus 1 
        (e.g, 129, 257, etc). The default is one more than the smallest 
        power of 2 that is not less than `numtaps`. `nfreqs` must be greater 
        than `numtaps`. 
    window : string or (string, float) or float, or None, optional 
        Window function to use. Default is &quot;hamming&quot;. See 
        `scipy.signal.get_window` for the complete list of possible values. 
        If None, no window function is applied. 
    antisymmetric : bool, optional 
        Whether resulting impulse response is symmetric/antisymmetric. 
        See Notes for more details. 
    fs : float, optional 
        The sampling frequency of the signal. Each frequency in `cutoff` 
        must be between 0 and ``fs/2``. Default is 2. 
 
    Returns 
    ------- 
    taps : ndarray 
        The filter coefficients of the FIR filter, as a 1-D array of length 
        `numtaps`. 
 
    See Also 
    -------- 
    firls 
    firwin 
    minimum_phase 
    remez 
 
    Notes 
    ----- 
    From the given set of frequencies and gains, the desired response is 
    constructed in the frequency domain. The inverse FFT is applied to the 
    desired response to create the associated convolution kernel, and the 
    first `numtaps` coefficients of this kernel, scaled by `window`, are 
    returned. 
 
    The FIR filter will have linear phase. The type of filter is determined by 
    the value of 'numtaps` and `antisymmetric` flag. 
    There are four possible combinations: 
 
       - odd  `numtaps`, `antisymmetric` is False, type I filter is produced 
       - even `numtaps`, `antisymmetric` is False, type II filter is produced 
       - odd  `numtaps`, `antisymmetric` is True, type III filter is produced 
       - even `numtaps`, `antisymmetric` is True, type IV filter is produced 
 
    Magnitude response of all but type I filters are subjects to following 
    constraints: 
 
       - type II  -- zero at the Nyquist frequency 
       - type III -- zero at zero and Nyquist frequencies 
       - type IV  -- zero at zero frequency 
 
    .. versionadded:: 0.9.0 
 
    References 
    ---------- 
    .. [1] Oppenheim, A. V. and Schafer, R. W., &quot;Discrete-Time Signal 
       Processing&quot;, Prentice-Hall, Englewood Cliffs, New Jersey (1989). 
       (See, for example, Section 7.4.) 
 
    .. [2] Smith, Steven W., &quot;The Scientist and Engineer's Guide to Digital 
       Signal Processing&quot;, Ch. 17. http://www.dspguide.com/ch17/1.htm 
 
    Examples 
    -------- 
    A lowpass FIR filter with a response that is 1 on [0.0, 0.5], and 
    that decreases linearly on [0.5, 1.0] from 1 to 0: 
 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; taps = signal.firwin2(150, [0.0, 0.5, 1.0], [1.0, 1.0, 0.0]) 
    &gt;&gt;&gt; print(taps[72:78]) 
    [-0.02286961 -0.06362756  0.57310236  0.57310236 -0.06362756 -0.02286961] 
 
    &quot;&quot;&quot;</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s6">2 </span><span class="s2">if </span><span class="s1">fs </span><span class="s2">is None else </span><span class="s1">fs</span>
    <span class="s1">nyq </span><span class="s3">= </span><span class="s6">0.5 </span><span class="s3">* </span><span class="s1">fs</span>

    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">freq</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">gain</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'freq and gain must be of same length.'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">nfreqs </span><span class="s2">is not None and </span><span class="s1">numtaps </span><span class="s3">&gt;= </span><span class="s1">nfreqs</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">((</span><span class="s4">'ntaps must be less than nfreqs, but firwin2 was '</span>
                          <span class="s4">'called with ntaps=%d and nfreqs=%s'</span><span class="s3">) %</span>
                         <span class="s3">(</span><span class="s1">numtaps</span><span class="s3">, </span><span class="s1">nfreqs</span><span class="s3">))</span>

    <span class="s2">if </span><span class="s1">freq</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] != </span><span class="s6">0 </span><span class="s2">or </span><span class="s1">freq</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">] != </span><span class="s1">nyq</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'freq must start with 0 and end with fs/2.'</span><span class="s3">)</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">freq</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">d </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">).</span><span class="s1">any</span><span class="s3">():</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'The values in freq must be nondecreasing.'</span><span class="s3">)</span>
    <span class="s1">d2 </span><span class="s3">= </span><span class="s1">d</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">] + </span><span class="s1">d</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:]</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">d2 </span><span class="s3">== </span><span class="s6">0</span><span class="s3">).</span><span class="s1">any</span><span class="s3">():</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'A value in freq must not occur more than twice.'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">freq</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] == </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Value 0 must not be repeated in freq'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">freq</span><span class="s3">[-</span><span class="s6">2</span><span class="s3">] == </span><span class="s1">nyq</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Value fs/2 must not be repeated in freq'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">antisymmetric</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">numtaps </span><span class="s3">% </span><span class="s6">2 </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">ftype </span><span class="s3">= </span><span class="s6">4</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">ftype </span><span class="s3">= </span><span class="s6">3</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">numtaps </span><span class="s3">% </span><span class="s6">2 </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">ftype </span><span class="s3">= </span><span class="s6">2</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">ftype </span><span class="s3">= </span><span class="s6">1</span>

    <span class="s2">if </span><span class="s1">ftype </span><span class="s3">== </span><span class="s6">2 </span><span class="s2">and </span><span class="s1">gain</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">] != </span><span class="s6">0.0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;A Type II filter must have zero gain at the &quot;</span>
                         <span class="s4">&quot;Nyquist frequency.&quot;</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">ftype </span><span class="s3">== </span><span class="s6">3 </span><span class="s2">and </span><span class="s3">(</span><span class="s1">gain</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] != </span><span class="s6">0.0 </span><span class="s2">or </span><span class="s1">gain</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">] != </span><span class="s6">0.0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;A Type III filter must have zero gain at zero &quot;</span>
                         <span class="s4">&quot;and Nyquist frequencies.&quot;</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">ftype </span><span class="s3">== </span><span class="s6">4 </span><span class="s2">and </span><span class="s1">gain</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] != </span><span class="s6">0.0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;A Type IV filter must have zero gain at zero &quot;</span>
                         <span class="s4">&quot;frequency.&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">nfreqs </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">nfreqs </span><span class="s3">= </span><span class="s6">1 </span><span class="s3">+ </span><span class="s6">2 </span><span class="s3">** </span><span class="s1">int</span><span class="s3">(</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">log</span><span class="s3">(</span><span class="s1">numtaps</span><span class="s3">, </span><span class="s6">2</span><span class="s3">)))</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">d </span><span class="s3">== </span><span class="s6">0</span><span class="s3">).</span><span class="s1">any</span><span class="s3">():</span>
        <span class="s5"># Tweak any repeated values in freq so that interp works.</span>
        <span class="s1">freq </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">freq</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
        <span class="s1">eps </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">float</span><span class="s3">).</span><span class="s1">eps </span><span class="s3">* </span><span class="s1">nyq</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">freq</span><span class="s3">) - </span><span class="s6">1</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">freq</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] == </span><span class="s1">freq</span><span class="s3">[</span><span class="s1">k </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">]:</span>
                <span class="s1">freq</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] = </span><span class="s1">freq</span><span class="s3">[</span><span class="s1">k</span><span class="s3">] - </span><span class="s1">eps</span>
                <span class="s1">freq</span><span class="s3">[</span><span class="s1">k </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">] = </span><span class="s1">freq</span><span class="s3">[</span><span class="s1">k </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">] + </span><span class="s1">eps</span>
        <span class="s5"># Check if freq is strictly increasing after tweak</span>
        <span class="s1">d </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">freq</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s3">(</span><span class="s1">d </span><span class="s3">&lt;= </span><span class="s6">0</span><span class="s3">).</span><span class="s1">any</span><span class="s3">():</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;freq cannot contain numbers that are too close &quot;</span>
                             <span class="s4">&quot;(within eps * (fs/2): &quot;</span>
                             <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">eps</span><span class="s2">}</span><span class="s4">) to a repeated value&quot;</span><span class="s3">)</span>

    <span class="s5"># Linearly interpolate the desired response on a uniform mesh `x`.</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s6">0.0</span><span class="s3">, </span><span class="s1">nyq</span><span class="s3">, </span><span class="s1">nfreqs</span><span class="s3">)</span>
    <span class="s1">fx </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">interp</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">freq</span><span class="s3">, </span><span class="s1">gain</span><span class="s3">)</span>

    <span class="s5"># Adjust the phases of the coefficients so that the first `ntaps` of the</span>
    <span class="s5"># inverse FFT are the desired filter coefficients.</span>
    <span class="s1">shift </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(-(</span><span class="s1">numtaps </span><span class="s3">- </span><span class="s6">1</span><span class="s3">) / </span><span class="s6">2. </span><span class="s3">* </span><span class="s6">1.j </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">x </span><span class="s3">/ </span><span class="s1">nyq</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">ftype </span><span class="s3">&gt; </span><span class="s6">2</span><span class="s3">:</span>
        <span class="s1">shift </span><span class="s3">*= </span><span class="s6">1j</span>

    <span class="s1">fx2 </span><span class="s3">= </span><span class="s1">fx </span><span class="s3">* </span><span class="s1">shift</span>

    <span class="s5"># Use irfft to compute the inverse FFT.</span>
    <span class="s1">out_full </span><span class="s3">= </span><span class="s1">irfft</span><span class="s3">(</span><span class="s1">fx2</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">window </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s5"># Create the window to apply to the filter coefficients.</span>
        <span class="s2">from </span><span class="s3">.</span><span class="s1">windows </span><span class="s2">import </span><span class="s1">get_window</span>
        <span class="s1">wind </span><span class="s3">= </span><span class="s1">get_window</span><span class="s3">(</span><span class="s1">window</span><span class="s3">, </span><span class="s1">numtaps</span><span class="s3">, </span><span class="s1">fftbins</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">wind </span><span class="s3">= </span><span class="s6">1</span>

    <span class="s5"># Keep only the first `numtaps` coefficients in `out`, and multiply by</span>
    <span class="s5"># the window.</span>
    <span class="s1">out </span><span class="s3">= </span><span class="s1">out_full</span><span class="s3">[:</span><span class="s1">numtaps</span><span class="s3">] * </span><span class="s1">wind</span>

    <span class="s2">if </span><span class="s1">ftype </span><span class="s3">== </span><span class="s6">3</span><span class="s3">:</span>
        <span class="s1">out</span><span class="s3">[</span><span class="s1">out</span><span class="s3">.</span><span class="s1">size </span><span class="s3">// </span><span class="s6">2</span><span class="s3">] = </span><span class="s6">0.0</span>

    <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">remez</span><span class="s3">(</span><span class="s1">numtaps</span><span class="s3">, </span><span class="s1">bands</span><span class="s3">, </span><span class="s1">desired</span><span class="s3">, *, </span><span class="s1">weight</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">type</span><span class="s3">=</span><span class="s4">'bandpass'</span><span class="s3">,</span>
          <span class="s1">maxiter</span><span class="s3">=</span><span class="s6">25</span><span class="s3">, </span><span class="s1">grid_density</span><span class="s3">=</span><span class="s6">16</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate the minimax optimal filter using the Remez exchange algorithm. 
 
    Calculate the filter-coefficients for the finite impulse response 
    (FIR) filter whose transfer function minimizes the maximum error 
    between the desired gain and the realized gain in the specified 
    frequency bands using the Remez exchange algorithm. 
 
    Parameters 
    ---------- 
    numtaps : int 
        The desired number of taps in the filter. The number of taps is 
        the number of terms in the filter, or the filter order plus one. 
    bands : array_like 
        A monotonic sequence containing the band edges. 
        All elements must be non-negative and less than half the sampling 
        frequency as given by `fs`. 
    desired : array_like 
        A sequence half the size of bands containing the desired gain 
        in each of the specified bands. 
    weight : array_like, optional 
        A relative weighting to give to each band region. The length of 
        `weight` has to be half the length of `bands`. 
    type : {'bandpass', 'differentiator', 'hilbert'}, optional 
        The type of filter: 
 
          * 'bandpass' : flat response in bands. This is the default. 
 
          * 'differentiator' : frequency proportional response in bands. 
 
          * 'hilbert' : filter with odd symmetry, that is, type III 
                        (for even order) or type IV (for odd order) 
                        linear phase filters. 
 
    maxiter : int, optional 
        Maximum number of iterations of the algorithm. Default is 25. 
    grid_density : int, optional 
        Grid density. The dense grid used in `remez` is of size 
        ``(numtaps + 1) * grid_density``. Default is 16. 
    fs : float, optional 
        The sampling frequency of the signal.  Default is 1. 
 
    Returns 
    ------- 
    out : ndarray 
        A rank-1 array containing the coefficients of the optimal 
        (in a minimax sense) filter. 
 
    See Also 
    -------- 
    firls 
    firwin 
    firwin2 
    minimum_phase 
 
    References 
    ---------- 
    .. [1] J. H. McClellan and T. W. Parks, &quot;A unified approach to the 
           design of optimum FIR linear phase digital filters&quot;, 
           IEEE Trans. Circuit Theory, vol. CT-20, pp. 697-701, 1973. 
    .. [2] J. H. McClellan, T. W. Parks and L. R. Rabiner, &quot;A Computer 
           Program for Designing Optimum FIR Linear Phase Digital 
           Filters&quot;, IEEE Trans. Audio Electroacoust., vol. AU-21, 
           pp. 506-525, 1973. 
 
    Examples 
    -------- 
    In these examples, `remez` is used to design low-pass, high-pass, 
    band-pass and band-stop filters.  The parameters that define each filter 
    are the filter order, the band boundaries, the transition widths of the 
    boundaries, the desired gains in each band, and the sampling frequency. 
 
    We'll use a sample frequency of 22050 Hz in all the examples.  In each 
    example, the desired gain in each band is either 0 (for a stop band) 
    or 1 (for a pass band). 
 
    `freqz` is used to compute the frequency response of each filter, and 
    the utility function ``plot_response`` defined below is used to plot 
    the response. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; fs = 22050   # Sample rate, Hz 
 
    &gt;&gt;&gt; def plot_response(w, h, title): 
    ...     &quot;Utility function to plot response functions&quot; 
    ...     fig = plt.figure() 
    ...     ax = fig.add_subplot(111) 
    ...     ax.plot(w, 20*np.log10(np.abs(h))) 
    ...     ax.set_ylim(-40, 5) 
    ...     ax.grid(True) 
    ...     ax.set_xlabel('Frequency (Hz)') 
    ...     ax.set_ylabel('Gain (dB)') 
    ...     ax.set_title(title) 
 
    The first example is a low-pass filter, with cutoff frequency 8 kHz. 
    The filter length is 325, and the transition width from pass to stop 
    is 100 Hz. 
 
    &gt;&gt;&gt; cutoff = 8000.0    # Desired cutoff frequency, Hz 
    &gt;&gt;&gt; trans_width = 100  # Width of transition from pass to stop, Hz 
    &gt;&gt;&gt; numtaps = 325      # Size of the FIR filter. 
    &gt;&gt;&gt; taps = signal.remez(numtaps, [0, cutoff, cutoff + trans_width, 0.5*fs], 
    ...                     [1, 0], fs=fs) 
    &gt;&gt;&gt; w, h = signal.freqz(taps, [1], worN=2000, fs=fs) 
    &gt;&gt;&gt; plot_response(w, h, &quot;Low-pass Filter&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    This example shows a high-pass filter: 
 
    &gt;&gt;&gt; cutoff = 2000.0    # Desired cutoff frequency, Hz 
    &gt;&gt;&gt; trans_width = 250  # Width of transition from pass to stop, Hz 
    &gt;&gt;&gt; numtaps = 125      # Size of the FIR filter. 
    &gt;&gt;&gt; taps = signal.remez(numtaps, [0, cutoff - trans_width, cutoff, 0.5*fs], 
    ...                     [0, 1], fs=fs) 
    &gt;&gt;&gt; w, h = signal.freqz(taps, [1], worN=2000, fs=fs) 
    &gt;&gt;&gt; plot_response(w, h, &quot;High-pass Filter&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    This example shows a band-pass filter with a pass-band from 2 kHz to 
    5 kHz.  The transition width is 260 Hz and the length of the filter 
    is 63, which is smaller than in the other examples: 
 
    &gt;&gt;&gt; band = [2000, 5000]  # Desired pass band, Hz 
    &gt;&gt;&gt; trans_width = 260    # Width of transition from pass to stop, Hz 
    &gt;&gt;&gt; numtaps = 63         # Size of the FIR filter. 
    &gt;&gt;&gt; edges = [0, band[0] - trans_width, band[0], band[1], 
    ...          band[1] + trans_width, 0.5*fs] 
    &gt;&gt;&gt; taps = signal.remez(numtaps, edges, [0, 1, 0], fs=fs) 
    &gt;&gt;&gt; w, h = signal.freqz(taps, [1], worN=2000, fs=fs) 
    &gt;&gt;&gt; plot_response(w, h, &quot;Band-pass Filter&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    The low order leads to higher ripple and less steep transitions. 
 
    The next example shows a band-stop filter. 
 
    &gt;&gt;&gt; band = [6000, 8000]  # Desired stop band, Hz 
    &gt;&gt;&gt; trans_width = 200    # Width of transition from pass to stop, Hz 
    &gt;&gt;&gt; numtaps = 175        # Size of the FIR filter. 
    &gt;&gt;&gt; edges = [0, band[0] - trans_width, band[0], band[1], 
    ...          band[1] + trans_width, 0.5*fs] 
    &gt;&gt;&gt; taps = signal.remez(numtaps, edges, [1, 0, 1], fs=fs) 
    &gt;&gt;&gt; w, h = signal.freqz(taps, [1], worN=2000, fs=fs) 
    &gt;&gt;&gt; plot_response(w, h, &quot;Band-stop Filter&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s6">1.0 </span><span class="s2">if </span><span class="s1">fs </span><span class="s2">is None else </span><span class="s1">fs</span>

    <span class="s5"># Convert type</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">tnum </span><span class="s3">= {</span><span class="s4">'bandpass'</span><span class="s3">: </span><span class="s6">1</span><span class="s3">, </span><span class="s4">'differentiator'</span><span class="s3">: </span><span class="s6">2</span><span class="s3">, </span><span class="s4">'hilbert'</span><span class="s3">: </span><span class="s6">3</span><span class="s3">}[</span><span class="s1">type</span><span class="s3">]</span>
    <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Type must be 'bandpass', 'differentiator', &quot;</span>
                         <span class="s4">&quot;or 'hilbert'&quot;</span><span class="s3">) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s5"># Convert weight</span>
    <span class="s2">if </span><span class="s1">weight </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">weight </span><span class="s3">= [</span><span class="s6">1</span><span class="s3">] * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">desired</span><span class="s3">)</span>

    <span class="s1">bands </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">bands</span><span class="s3">).</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s2">return </span><span class="s1">_sigtools</span><span class="s3">.</span><span class="s1">_remez</span><span class="s3">(</span><span class="s1">numtaps</span><span class="s3">, </span><span class="s1">bands</span><span class="s3">, </span><span class="s1">desired</span><span class="s3">, </span><span class="s1">weight</span><span class="s3">, </span><span class="s1">tnum</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">,</span>
                            <span class="s1">maxiter</span><span class="s3">, </span><span class="s1">grid_density</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">firls</span><span class="s3">(</span><span class="s1">numtaps</span><span class="s3">, </span><span class="s1">bands</span><span class="s3">, </span><span class="s1">desired</span><span class="s3">, *, </span><span class="s1">weight</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    FIR filter design using least-squares error minimization. 
 
    Calculate the filter coefficients for the linear-phase finite 
    impulse response (FIR) filter which has the best approximation 
    to the desired frequency response described by `bands` and 
    `desired` in the least squares sense (i.e., the integral of the 
    weighted mean-squared error within the specified bands is 
    minimized). 
 
    Parameters 
    ---------- 
    numtaps : int 
        The number of taps in the FIR filter. `numtaps` must be odd. 
    bands : array_like 
        A monotonic nondecreasing sequence containing the band edges in 
        Hz. All elements must be non-negative and less than or equal to 
        the Nyquist frequency given by `nyq`. The bands are specified as 
        frequency pairs, thus, if using a 1D array, its length must be 
        even, e.g., `np.array([0, 1, 2, 3, 4, 5])`. Alternatively, the 
        bands can be specified as an nx2 sized 2D array, where n is the 
        number of bands, e.g, `np.array([[0, 1], [2, 3], [4, 5]])`. 
    desired : array_like 
        A sequence the same size as `bands` containing the desired gain 
        at the start and end point of each band. 
    weight : array_like, optional 
        A relative weighting to give to each band region when solving 
        the least squares problem. `weight` has to be half the size of 
        `bands`. 
    fs : float, optional 
        The sampling frequency of the signal. Each frequency in `bands` 
        must be between 0 and ``fs/2`` (inclusive). Default is 2. 
 
    Returns 
    ------- 
    coeffs : ndarray 
        Coefficients of the optimal (in a least squares sense) FIR filter. 
 
    See Also 
    -------- 
    firwin 
    firwin2 
    minimum_phase 
    remez 
 
    Notes 
    ----- 
    This implementation follows the algorithm given in [1]_. 
    As noted there, least squares design has multiple advantages: 
 
        1. Optimal in a least-squares sense. 
        2. Simple, non-iterative method. 
        3. The general solution can obtained by solving a linear 
           system of equations. 
        4. Allows the use of a frequency dependent weighting function. 
 
    This function constructs a Type I linear phase FIR filter, which 
    contains an odd number of `coeffs` satisfying for :math:`n &lt; numtaps`: 
 
    .. math:: coeffs(n) = coeffs(numtaps - 1 - n) 
 
    The odd number of coefficients and filter symmetry avoid boundary 
    conditions that could otherwise occur at the Nyquist and 0 frequencies 
    (e.g., for Type II, III, or IV variants). 
 
    .. versionadded:: 0.18 
 
    References 
    ---------- 
    .. [1] Ivan Selesnick, Linear-Phase Fir Filter Design By Least Squares. 
           OpenStax CNX. Aug 9, 2005. 
           http://cnx.org/contents/eb1ecb35-03a9-4610-ba87-41cd771c95f2@7 
 
    Examples 
    -------- 
    We want to construct a band-pass filter. Note that the behavior in the 
    frequency ranges between our stop bands and pass bands is unspecified, 
    and thus may overshoot depending on the parameters of our filter: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import signal 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig, axs = plt.subplots(2) 
    &gt;&gt;&gt; fs = 10.0  # Hz 
    &gt;&gt;&gt; desired = (0, 0, 1, 1, 0, 0) 
    &gt;&gt;&gt; for bi, bands in enumerate(((0, 1, 2, 3, 4, 5), (0, 1, 2, 4, 4.5, 5))): 
    ...     fir_firls = signal.firls(73, bands, desired, fs=fs) 
    ...     fir_remez = signal.remez(73, bands, desired[::2], fs=fs) 
    ...     fir_firwin2 = signal.firwin2(73, bands, desired, fs=fs) 
    ...     hs = list() 
    ...     ax = axs[bi] 
    ...     for fir in (fir_firls, fir_remez, fir_firwin2): 
    ...         freq, response = signal.freqz(fir) 
    ...         hs.append(ax.semilogy(0.5*fs*freq/np.pi, np.abs(response))[0]) 
    ...     for band, gains in zip(zip(bands[::2], bands[1::2]), 
    ...                            zip(desired[::2], desired[1::2])): 
    ...         ax.semilogy(band, np.maximum(gains, 1e-7), 'k--', linewidth=2) 
    ...     if bi == 0: 
    ...         ax.legend(hs, ('firls', 'remez', 'firwin2'), 
    ...                   loc='lower center', frameon=False) 
    ...     else: 
    ...         ax.set_xlabel('Frequency (Hz)') 
    ...     ax.grid(True) 
    ...     ax.set(title='Band-pass %d-%d Hz' % bands[2:4], ylabel='Magnitude') 
    ... 
    &gt;&gt;&gt; fig.tight_layout() 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s1">_validate_fs</span><span class="s3">(</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">allow_none</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">fs </span><span class="s3">= </span><span class="s6">2 </span><span class="s2">if </span><span class="s1">fs </span><span class="s2">is None else </span><span class="s1">fs</span>
    <span class="s1">nyq </span><span class="s3">= </span><span class="s6">0.5 </span><span class="s3">* </span><span class="s1">fs</span>

    <span class="s1">numtaps </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">numtaps</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">numtaps </span><span class="s3">% </span><span class="s6">2 </span><span class="s3">== </span><span class="s6">0 </span><span class="s2">or </span><span class="s1">numtaps </span><span class="s3">&lt; </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;numtaps must be odd and &gt;= 1&quot;</span><span class="s3">)</span>
    <span class="s1">M </span><span class="s3">= (</span><span class="s1">numtaps</span><span class="s3">-</span><span class="s6">1</span><span class="s3">) // </span><span class="s6">2</span>

    <span class="s5"># normalize bands 0-&gt;1 and make it 2 columns</span>
    <span class="s1">nyq </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">nyq</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">nyq </span><span class="s3">&lt;= </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'nyq must be positive, got %s &lt;= 0.' </span><span class="s3">% </span><span class="s1">nyq</span><span class="s3">)</span>
    <span class="s1">bands </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">bands</span><span class="s3">).</span><span class="s1">flatten</span><span class="s3">() / </span><span class="s1">nyq</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">bands</span><span class="s3">) % </span><span class="s6">2 </span><span class="s3">!= </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;bands must contain frequency pairs.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">bands </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">).</span><span class="s1">any</span><span class="s3">() </span><span class="s2">or </span><span class="s3">(</span><span class="s1">bands </span><span class="s3">&gt; </span><span class="s6">1</span><span class="s3">).</span><span class="s1">any</span><span class="s3">():</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;bands must be between 0 and 1 relative to Nyquist&quot;</span><span class="s3">)</span>
    <span class="s1">bands</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">= (-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">)</span>

    <span class="s5"># check remaining params</span>
    <span class="s1">desired </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">desired</span><span class="s3">).</span><span class="s1">flatten</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s1">bands</span><span class="s3">.</span><span class="s1">size </span><span class="s3">!= </span><span class="s1">desired</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
            <span class="s4">f&quot;desired must have one entry per frequency, got </span><span class="s2">{</span><span class="s1">desired</span><span class="s3">.</span><span class="s1">size</span><span class="s2">} </span><span class="s4">&quot;</span>
            <span class="s4">f&quot;gains for </span><span class="s2">{</span><span class="s1">bands</span><span class="s3">.</span><span class="s1">size</span><span class="s2">} </span><span class="s4">frequencies.&quot;</span>
        <span class="s3">)</span>
    <span class="s1">desired</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">= (-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">bands</span><span class="s3">) &lt;= </span><span class="s6">0</span><span class="s3">).</span><span class="s1">any</span><span class="s3">() </span><span class="s2">or </span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">bands</span><span class="s3">[:, </span><span class="s6">0</span><span class="s3">]) &lt; </span><span class="s6">0</span><span class="s3">).</span><span class="s1">any</span><span class="s3">():</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;bands must be monotonically nondecreasing and have &quot;</span>
                         <span class="s4">&quot;width &gt; 0.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">bands</span><span class="s3">[:-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">] &gt; </span><span class="s1">bands</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:, </span><span class="s6">0</span><span class="s3">]).</span><span class="s1">any</span><span class="s3">():</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;bands must not overlap.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">desired </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">).</span><span class="s1">any</span><span class="s3">():</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;desired must be non-negative.&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">weight </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">weight </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">desired</span><span class="s3">))</span>
    <span class="s1">weight </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">weight</span><span class="s3">).</span><span class="s1">flatten</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">weight</span><span class="s3">) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">desired</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;weight must be the same size as the number of &quot;</span>
                         <span class="s4">f&quot;band pairs (</span><span class="s2">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">bands</span><span class="s3">)</span><span class="s2">}</span><span class="s4">).&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">weight </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">).</span><span class="s1">any</span><span class="s3">():</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;weight must be non-negative.&quot;</span><span class="s3">)</span>

    <span class="s5"># Set up the linear matrix equation to be solved, Qa = b</span>

    <span class="s5"># We can express Q(k,n) = 0.5 Q1(k,n) + 0.5 Q2(k,n)</span>
    <span class="s5"># where Q1(k,n)=q(k-n) and Q2(k,n)=q(k+n), i.e. a Toeplitz plus Hankel.</span>

    <span class="s5"># We omit the factor of 0.5 above, instead adding it during coefficient</span>
    <span class="s5"># calculation.</span>

    <span class="s5"># We also omit the 1/π from both Q and b equations, as they cancel</span>
    <span class="s5"># during solving.</span>

    <span class="s5"># We have that:</span>
    <span class="s5">#     q(n) = 1/π ∫W(ω)cos(nω)dω (over 0-&gt;π)</span>
    <span class="s5"># Using our normalization ω=πf and with a constant weight W over each</span>
    <span class="s5"># interval f1-&gt;f2 we get:</span>
    <span class="s5">#     q(n) = W∫cos(πnf)df (0-&gt;1) = Wf sin(πnf)/πnf</span>
    <span class="s5"># integrated over each f1-&gt;f2 pair (i.e., value at f2 - value at f1).</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">numtaps</span><span class="s3">)[:, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">newaxis</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">newaxis</span><span class="s3">]</span>
    <span class="s1">q </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sinc</span><span class="s3">(</span><span class="s1">bands </span><span class="s3">* </span><span class="s1">n</span><span class="s3">) * </span><span class="s1">bands</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">2</span><span class="s3">)[:, :, </span><span class="s6">0</span><span class="s3">], </span><span class="s1">weight</span><span class="s3">)</span>

    <span class="s5"># Now we assemble our sum of Toeplitz and Hankel</span>
    <span class="s1">Q1 </span><span class="s3">= </span><span class="s1">toeplitz</span><span class="s3">(</span><span class="s1">q</span><span class="s3">[:</span><span class="s1">M</span><span class="s3">+</span><span class="s6">1</span><span class="s3">])</span>
    <span class="s1">Q2 </span><span class="s3">= </span><span class="s1">hankel</span><span class="s3">(</span><span class="s1">q</span><span class="s3">[:</span><span class="s1">M</span><span class="s3">+</span><span class="s6">1</span><span class="s3">], </span><span class="s1">q</span><span class="s3">[</span><span class="s1">M</span><span class="s3">:])</span>
    <span class="s1">Q </span><span class="s3">= </span><span class="s1">Q1 </span><span class="s3">+ </span><span class="s1">Q2</span>

    <span class="s5"># Now for b(n) we have that:</span>
    <span class="s5">#     b(n) = 1/π ∫ W(ω)D(ω)cos(nω)dω (over 0-&gt;π)</span>
    <span class="s5"># Using our normalization ω=πf and with a constant weight W over each</span>
    <span class="s5"># interval and a linear term for D(ω) we get (over each f1-&gt;f2 interval):</span>
    <span class="s5">#     b(n) = W ∫ (mf+c)cos(πnf)df</span>
    <span class="s5">#          = f(mf+c)sin(πnf)/πnf + mf**2 cos(nπf)/(πnf)**2</span>
    <span class="s5"># integrated over each f1-&gt;f2 pair (i.e., value at f2 - value at f1).</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">n</span><span class="s3">[:</span><span class="s1">M </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">]  </span><span class="s5"># only need this many coefficients here</span>
    <span class="s5"># Choose m and c such that we are at the start and end weights</span>
    <span class="s1">m </span><span class="s3">= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">desired</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">1</span><span class="s3">) / </span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">bands</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">1</span><span class="s3">))</span>
    <span class="s1">c </span><span class="s3">= </span><span class="s1">desired</span><span class="s3">[:, [</span><span class="s6">0</span><span class="s3">]] - </span><span class="s1">bands</span><span class="s3">[:, [</span><span class="s6">0</span><span class="s3">]] * </span><span class="s1">m</span>
    <span class="s1">b </span><span class="s3">= </span><span class="s1">bands </span><span class="s3">* (</span><span class="s1">m</span><span class="s3">*</span><span class="s1">bands </span><span class="s3">+ </span><span class="s1">c</span><span class="s3">) * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sinc</span><span class="s3">(</span><span class="s1">bands </span><span class="s3">* </span><span class="s1">n</span><span class="s3">)</span>
    <span class="s5"># Use L'Hospital's rule here for cos(nπf)/(πnf)**2 @ n=0</span>
    <span class="s1">b</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] -= </span><span class="s1">m </span><span class="s3">* </span><span class="s1">bands </span><span class="s3">* </span><span class="s1">bands </span><span class="s3">/ </span><span class="s6">2.</span>
    <span class="s1">b</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:] += </span><span class="s1">m </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">cos</span><span class="s3">(</span><span class="s1">n</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:] * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">bands</span><span class="s3">) / (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">n</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:]) ** </span><span class="s6">2</span>
    <span class="s1">b </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">2</span><span class="s3">)[:, :, </span><span class="s6">0</span><span class="s3">], </span><span class="s1">weight</span><span class="s3">)</span>

    <span class="s5"># Now we can solve the equation</span>
    <span class="s2">try</span><span class="s3">:  </span><span class="s5"># try the fast way</span>
        <span class="s2">with </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">(</span><span class="s1">record</span><span class="s3">=</span><span class="s2">True</span><span class="s3">) </span><span class="s2">as </span><span class="s1">w</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">simplefilter</span><span class="s3">(</span><span class="s4">'always'</span><span class="s3">)</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">solve</span><span class="s3">(</span><span class="s1">Q</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">assume_a</span><span class="s3">=</span><span class="s4">&quot;pos&quot;</span><span class="s3">, </span><span class="s1">check_finite</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">ww </span><span class="s2">in </span><span class="s1">w</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s1">ww</span><span class="s3">.</span><span class="s1">category </span><span class="s3">== </span><span class="s1">LinAlgWarning </span><span class="s2">and</span>
                    <span class="s1">str</span><span class="s3">(</span><span class="s1">ww</span><span class="s3">.</span><span class="s1">message</span><span class="s3">).</span><span class="s1">startswith</span><span class="s3">(</span><span class="s4">'Ill-conditioned matrix'</span><span class="s3">)):</span>
                <span class="s2">raise </span><span class="s1">LinAlgError</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">ww</span><span class="s3">.</span><span class="s1">message</span><span class="s3">))</span>
    <span class="s2">except </span><span class="s1">LinAlgError</span><span class="s3">:  </span><span class="s5"># in case Q is rank deficient</span>
        <span class="s5"># This is faster than pinvh, even though we don't explicitly use</span>
        <span class="s5"># the symmetry here. gelsy was faster than gelsd and gelss in</span>
        <span class="s5"># some non-exhaustive tests.</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">lstsq</span><span class="s3">(</span><span class="s1">Q</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">lapack_driver</span><span class="s3">=</span><span class="s4">'gelsy'</span><span class="s3">)[</span><span class="s6">0</span><span class="s3">]</span>

    <span class="s5"># make coefficients symmetric (linear phase)</span>
    <span class="s1">coeffs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">((</span><span class="s1">a</span><span class="s3">[:</span><span class="s6">0</span><span class="s3">:-</span><span class="s6">1</span><span class="s3">], </span><span class="s6">2 </span><span class="s3">* </span><span class="s1">a</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s1">a</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:]))</span>
    <span class="s2">return </span><span class="s1">coeffs</span>


<span class="s2">def </span><span class="s1">_dhtm</span><span class="s3">(</span><span class="s1">mag</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the modified 1-D discrete Hilbert transform 
 
    Parameters 
    ---------- 
    mag : ndarray 
        The magnitude spectrum. Should be 1-D with an even length, and 
        preferably a fast length for FFT/IFFT. 
    &quot;&quot;&quot;</span>
    <span class="s5"># Adapted based on code by Niranjan Damera-Venkata,</span>
    <span class="s5"># Brian L. Evans and Shawn R. McCaslin (see refs for `minimum_phase`)</span>
    <span class="s1">sig </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">mag</span><span class="s3">))</span>
    <span class="s5"># Leave Nyquist and DC at 0, knowing np.abs(fftfreq(N)[midpt]) == 0.5</span>
    <span class="s1">midpt </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">mag</span><span class="s3">) // </span><span class="s6">2</span>
    <span class="s1">sig</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:</span><span class="s1">midpt</span><span class="s3">] = </span><span class="s6">1</span>
    <span class="s1">sig</span><span class="s3">[</span><span class="s1">midpt</span><span class="s3">+</span><span class="s6">1</span><span class="s3">:] = -</span><span class="s6">1</span>
    <span class="s5"># eventually if we want to support complex filters, we will need a</span>
    <span class="s5"># np.abs() on the mag inside the log, and should remove the .real</span>
    <span class="s1">recon </span><span class="s3">= </span><span class="s1">ifft</span><span class="s3">(</span><span class="s1">mag </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">fft</span><span class="s3">(</span><span class="s1">sig </span><span class="s3">* </span><span class="s1">ifft</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">mag</span><span class="s3">))))).</span><span class="s1">real</span>
    <span class="s2">return </span><span class="s1">recon</span>


<span class="s2">def </span><span class="s1">minimum_phase</span><span class="s3">(</span><span class="s1">h</span><span class="s3">: </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">,</span>
                  <span class="s1">method</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s4">'homomorphic'</span><span class="s3">, </span><span class="s4">'hilbert'</span><span class="s3">] = </span><span class="s4">'homomorphic'</span><span class="s3">,</span>
                  <span class="s1">n_fft</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">int</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">, *, </span><span class="s1">half</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">) </span><span class="s1">-&gt; np</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Convert a linear-phase FIR filter to minimum phase 
 
    Parameters 
    ---------- 
    h : array 
        Linear-phase FIR filter coefficients. 
    method : {'hilbert', 'homomorphic'} 
        The provided methods are: 
 
            'homomorphic' (default) 
                This method [4]_ [5]_ works best with filters with an 
                odd number of taps, and the resulting minimum phase filter 
                will have a magnitude response that approximates the square 
                root of the original filter's magnitude response using half 
                the number of taps when ``half=True`` (default), or the 
                original magnitude spectrum using the same number of taps 
                when ``half=False``. 
 
            'hilbert' 
                This method [1]_ is designed to be used with equiripple 
                filters (e.g., from `remez`) with unity or zero gain 
                regions. 
 
    n_fft : int 
        The number of points to use for the FFT. Should be at least a 
        few times larger than the signal length (see Notes). 
    half : bool 
        If ``True``, create a filter that is half the length of the original, with a 
        magnitude spectrum that is the square root of the original. If ``False``, 
        create a filter that is the same length as the original, with a magnitude 
        spectrum that is designed to match the original (only supported when 
        ``method='homomorphic'``). 
 
        .. versionadded:: 1.14.0 
 
    Returns 
    ------- 
    h_minimum : array 
        The minimum-phase version of the filter, with length 
        ``(len(h) + 1) // 2`` when ``half is True`` or ``len(h)`` otherwise. 
 
    See Also 
    -------- 
    firwin 
    firwin2 
    remez 
 
    Notes 
    ----- 
    Both the Hilbert [1]_ or homomorphic [4]_ [5]_ methods require selection 
    of an FFT length to estimate the complex cepstrum of the filter. 
 
    In the case of the Hilbert method, the deviation from the ideal 
    spectrum ``epsilon`` is related to the number of stopband zeros 
    ``n_stop`` and FFT length ``n_fft`` as:: 
 
        epsilon = 2. * n_stop / n_fft 
 
    For example, with 100 stopband zeros and a FFT length of 2048, 
    ``epsilon = 0.0976``. If we conservatively assume that the number of 
    stopband zeros is one less than the filter length, we can take the FFT 
    length to be the next power of 2 that satisfies ``epsilon=0.01`` as:: 
 
        n_fft = 2 ** int(np.ceil(np.log2(2 * (len(h) - 1) / 0.01))) 
 
    This gives reasonable results for both the Hilbert and homomorphic 
    methods, and gives the value used when ``n_fft=None``. 
 
    Alternative implementations exist for creating minimum-phase filters, 
    including zero inversion [2]_ and spectral factorization [3]_ [4]_. 
    For more information, see `this DSPGuru page 
    &lt;http://dspguru.com/dsp/howtos/how-to-design-minimum-phase-fir-filters&gt;`__. 
 
    References 
    ---------- 
    .. [1] N. Damera-Venkata and B. L. Evans, &quot;Optimal design of real and 
           complex minimum phase digital FIR filters,&quot; Acoustics, Speech, 
           and Signal Processing, 1999. Proceedings., 1999 IEEE International 
           Conference on, Phoenix, AZ, 1999, pp. 1145-1148 vol.3. 
           :doi:`10.1109/ICASSP.1999.756179` 
    .. [2] X. Chen and T. W. Parks, &quot;Design of optimal minimum phase FIR 
           filters by direct factorization,&quot; Signal Processing, 
           vol. 10, no. 4, pp. 369-383, Jun. 1986. 
    .. [3] T. Saramaki, &quot;Finite Impulse Response Filter Design,&quot; in 
           Handbook for Digital Signal Processing, chapter 4, 
           New York: Wiley-Interscience, 1993. 
    .. [4] J. S. Lim, Advanced Topics in Signal Processing. 
           Englewood Cliffs, N.J.: Prentice Hall, 1988. 
    .. [5] A. V. Oppenheim, R. W. Schafer, and J. R. Buck, 
           &quot;Discrete-Time Signal Processing,&quot; 3rd edition. 
           Upper Saddle River, N.J.: Pearson, 2009. 
 
    Examples 
    -------- 
    Create an optimal linear-phase low-pass filter `h` with a transition band of 
    [0.2, 0.3] (assuming a Nyquist frequency of 1): 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal import remez, minimum_phase, freqz, group_delay 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; freq = [0, 0.2, 0.3, 1.0] 
    &gt;&gt;&gt; desired = [1, 0] 
    &gt;&gt;&gt; h_linear = remez(151, freq, desired, fs=2) 
 
    Convert it to minimum phase: 
 
    &gt;&gt;&gt; h_hil = minimum_phase(h_linear, method='hilbert') 
    &gt;&gt;&gt; h_hom = minimum_phase(h_linear, method='homomorphic') 
    &gt;&gt;&gt; h_hom_full = minimum_phase(h_linear, method='homomorphic', half=False) 
 
    Compare the impulse and frequency response of the four filters: 
 
    &gt;&gt;&gt; fig0, ax0 = plt.subplots(figsize=(6, 3), tight_layout=True) 
    &gt;&gt;&gt; fig1, axs = plt.subplots(3, sharex='all', figsize=(6, 6), tight_layout=True) 
    &gt;&gt;&gt; ax0.set_title(&quot;Impulse response&quot;) 
    &gt;&gt;&gt; ax0.set(xlabel='Samples', ylabel='Amplitude', xlim=(0, len(h_linear) - 1)) 
    &gt;&gt;&gt; axs[0].set_title(&quot;Frequency Response&quot;) 
    &gt;&gt;&gt; axs[0].set(xlim=(0, .65), ylabel=&quot;Magnitude / dB&quot;) 
    &gt;&gt;&gt; axs[1].set(ylabel=&quot;Phase / rad&quot;) 
    &gt;&gt;&gt; axs[2].set(ylabel=&quot;Group Delay / samples&quot;, ylim=(-31, 81), 
    ...             xlabel='Normalized Frequency (Nyqist frequency: 1)') 
    &gt;&gt;&gt; for h, lb in ((h_linear,   f'Linear ({len(h_linear)})'), 
    ...               (h_hil,      f'Min-Hilbert ({len(h_hil)})'), 
    ...               (h_hom,      f'Min-Homomorphic ({len(h_hom)})'), 
    ...               (h_hom_full, f'Min-Homom. Full ({len(h_hom_full)})')): 
    ...     w_H, H = freqz(h, fs=2) 
    ...     w_gd, gd = group_delay((h, 1), fs=2) 
    ... 
    ...     alpha = 1.0 if lb == 'linear' else 0.5  # full opacity for 'linear' line 
    ...     ax0.plot(h, '.-', alpha=alpha, label=lb) 
    ...     axs[0].plot(w_H, 20 * np.log10(np.abs(H)), alpha=alpha) 
    ...     axs[1].plot(w_H, np.unwrap(np.angle(H)), alpha=alpha, label=lb) 
    ...     axs[2].plot(w_gd, gd, alpha=alpha) 
    &gt;&gt;&gt; ax0.grid(True) 
    &gt;&gt;&gt; ax0.legend(title='Filter Phase (Order)') 
    &gt;&gt;&gt; axs[1].legend(title='Filter Phase (Order)', loc='lower right') 
    &gt;&gt;&gt; for ax_ in axs:  # shade transition band: 
    ...     ax_.axvspan(freq[1], freq[2], color='y', alpha=.25) 
    ...     ax_.grid(True) 
    &gt;&gt;&gt; plt.show() 
 
    The impulse response and group delay plot depict the 75 sample delay of the linear 
    phase filter `h`. The phase should also be linear in the stop band--due to the small 
    magnitude, numeric noise dominates there. Furthermore, the plots show that the 
    minimum phase filters clearly show a reduced (negative) phase slope in the pass and 
    transition band. The plots also illustrate that the filter with parameters 
    ``method='homomorphic', half=False`` has same order and magnitude response as the 
    linear filter `h` wheras the other minimum phase filters have only half the order 
    and the square root  of the magnitude response. 
    &quot;&quot;&quot;</span>
    <span class="s1">h </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">h</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iscomplexobj</span><span class="s3">(</span><span class="s1">h</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Complex filters not supported'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">h</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">!= </span><span class="s6">1 </span><span class="s2">or </span><span class="s1">h</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&lt;= </span><span class="s6">2</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'h must be 1-D and at least 2 samples long'</span><span class="s3">)</span>
    <span class="s1">n_half </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">h</span><span class="s3">) // </span><span class="s6">2</span>
    <span class="s2">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">allclose</span><span class="s3">(</span><span class="s1">h</span><span class="s3">[-</span><span class="s1">n_half</span><span class="s3">:][::-</span><span class="s6">1</span><span class="s3">], </span><span class="s1">h</span><span class="s3">[:</span><span class="s1">n_half</span><span class="s3">]):</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">'h does not appear to by symmetric, conversion may fail'</span><span class="s3">,</span>
                      <span class="s1">RuntimeWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s6">2</span><span class="s3">)</span>
    <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">method</span><span class="s3">, </span><span class="s1">str</span><span class="s3">) </span><span class="s2">or </span><span class="s1">method </span><span class="s2">not in </span><span class="s1">\</span>
            <span class="s3">(</span><span class="s4">'homomorphic'</span><span class="s3">, </span><span class="s4">'hilbert'</span><span class="s3">,):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f'method must be &quot;homomorphic&quot; or &quot;hilbert&quot;, got </span><span class="s2">{</span><span class="s1">method</span><span class="s2">!r}</span><span class="s4">'</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">method </span><span class="s3">== </span><span class="s4">&quot;hilbert&quot; </span><span class="s2">and not </span><span class="s1">half</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;`half=False` is only supported when `method='homomorphic'`&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">n_fft </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">n_fft </span><span class="s3">= </span><span class="s6">2 </span><span class="s3">** </span><span class="s1">int</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">log2</span><span class="s3">(</span><span class="s6">2 </span><span class="s3">* (</span><span class="s1">len</span><span class="s3">(</span><span class="s1">h</span><span class="s3">) - </span><span class="s6">1</span><span class="s3">) / </span><span class="s6">0.01</span><span class="s3">)))</span>
    <span class="s1">n_fft </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">n_fft</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">n_fft </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">h</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'n_fft must be at least len(h)==%s' </span><span class="s3">% </span><span class="s1">len</span><span class="s3">(</span><span class="s1">h</span><span class="s3">))</span>
    <span class="s2">if </span><span class="s1">method </span><span class="s3">== </span><span class="s4">'hilbert'</span><span class="s3">:</span>
        <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n_fft</span><span class="s3">) * (</span><span class="s6">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">/ </span><span class="s1">n_fft </span><span class="s3">* </span><span class="s1">n_half</span><span class="s3">)</span>
        <span class="s1">H </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">real</span><span class="s3">(</span><span class="s1">fft</span><span class="s3">(</span><span class="s1">h</span><span class="s3">, </span><span class="s1">n_fft</span><span class="s3">) * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s6">1j </span><span class="s3">* </span><span class="s1">w</span><span class="s3">))</span>
        <span class="s1">dp </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">H</span><span class="s3">) - </span><span class="s6">1</span>
        <span class="s1">ds </span><span class="s3">= </span><span class="s6">0 </span><span class="s3">- </span><span class="s1">min</span><span class="s3">(</span><span class="s1">H</span><span class="s3">)</span>
        <span class="s1">S </span><span class="s3">= </span><span class="s6">4. </span><span class="s3">/ (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s6">1</span><span class="s3">+</span><span class="s1">dp</span><span class="s3">+</span><span class="s1">ds</span><span class="s3">) + </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s6">1</span><span class="s3">-</span><span class="s1">dp</span><span class="s3">+</span><span class="s1">ds</span><span class="s3">)) ** </span><span class="s6">2</span>
        <span class="s1">H </span><span class="s3">+= </span><span class="s1">ds</span>
        <span class="s1">H </span><span class="s3">*= </span><span class="s1">S</span>
        <span class="s1">H </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">H</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">H</span><span class="s3">)</span>
        <span class="s1">H </span><span class="s3">+= </span><span class="s6">1e-10  </span><span class="s5"># ensure that the log does not explode</span>
        <span class="s1">h_minimum </span><span class="s3">= </span><span class="s1">_dhtm</span><span class="s3">(</span><span class="s1">H</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:  </span><span class="s5"># method == 'homomorphic'</span>
        <span class="s5"># zero-pad; calculate the DFT</span>
        <span class="s1">h_temp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">fft</span><span class="s3">(</span><span class="s1">h</span><span class="s3">, </span><span class="s1">n_fft</span><span class="s3">))</span>
        <span class="s5"># take 0.25*log(|H|**2) = 0.5*log(|H|)</span>
        <span class="s1">h_temp </span><span class="s3">+= </span><span class="s6">1e-7 </span><span class="s3">* </span><span class="s1">h_temp</span><span class="s3">[</span><span class="s1">h_temp </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">].</span><span class="s1">min</span><span class="s3">()  </span><span class="s5"># don't let log blow up</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">h_temp</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">h_temp</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">half</span><span class="s3">:  </span><span class="s5"># halving of magnitude spectrum optional</span>
            <span class="s1">h_temp </span><span class="s3">*= </span><span class="s6">0.5</span>
        <span class="s5"># IDFT</span>
        <span class="s1">h_temp </span><span class="s3">= </span><span class="s1">ifft</span><span class="s3">(</span><span class="s1">h_temp</span><span class="s3">).</span><span class="s1">real</span>
        <span class="s5"># multiply pointwise by the homomorphic filter</span>
        <span class="s5"># lmin[n] = 2u[n] - d[n]</span>
        <span class="s5"># i.e., double the positive frequencies and zero out the negative ones;</span>
        <span class="s5"># Oppenheim+Shafer 3rd ed p991 eq13.42b and p1004 fig13.7</span>
        <span class="s1">win </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_fft</span><span class="s3">)</span>
        <span class="s1">win</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s6">1</span>
        <span class="s1">stop </span><span class="s3">= </span><span class="s1">n_fft </span><span class="s3">// </span><span class="s6">2</span>
        <span class="s1">win</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:</span><span class="s1">stop</span><span class="s3">] = </span><span class="s6">2</span>
        <span class="s2">if </span><span class="s1">n_fft </span><span class="s3">% </span><span class="s6">2</span><span class="s3">:</span>
            <span class="s1">win</span><span class="s3">[</span><span class="s1">stop</span><span class="s3">] = </span><span class="s6">1</span>
        <span class="s1">h_temp </span><span class="s3">*= </span><span class="s1">win</span>
        <span class="s1">h_temp </span><span class="s3">= </span><span class="s1">ifft</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">fft</span><span class="s3">(</span><span class="s1">h_temp</span><span class="s3">)))</span>
        <span class="s1">h_minimum </span><span class="s3">= </span><span class="s1">h_temp</span><span class="s3">.</span><span class="s1">real</span>
    <span class="s1">n_out </span><span class="s3">= (</span><span class="s1">n_half </span><span class="s3">+ </span><span class="s1">len</span><span class="s3">(</span><span class="s1">h</span><span class="s3">) % </span><span class="s6">2</span><span class="s3">) </span><span class="s2">if </span><span class="s1">half </span><span class="s2">else </span><span class="s1">len</span><span class="s3">(</span><span class="s1">h</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">h_minimum</span><span class="s3">[:</span><span class="s1">n_out</span><span class="s3">]</span>
</pre>
</body>
</html>