<html>
<head>
<title>test_split.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #7a7e85;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_split.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Test the split module&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">combinations</span><span class="s3">, </span><span class="s1">combinations_with_replacement</span><span class="s3">, </span><span class="s1">permutations</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">stats</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">sparse </span><span class="s2">import </span><span class="s1">issparse</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special </span><span class="s2">import </span><span class="s1">comb</span>

<span class="s2">from </span><span class="s1">sklearn </span><span class="s2">import </span><span class="s1">config_context</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">datasets </span><span class="s2">import </span><span class="s1">load_digits</span><span class="s3">, </span><span class="s1">make_classification</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">dummy </span><span class="s2">import </span><span class="s1">DummyClassifier</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">model_selection </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">GridSearchCV</span><span class="s3">,</span>
    <span class="s1">GroupKFold</span><span class="s3">,</span>
    <span class="s1">GroupShuffleSplit</span><span class="s3">,</span>
    <span class="s1">KFold</span><span class="s3">,</span>
    <span class="s1">LeaveOneGroupOut</span><span class="s3">,</span>
    <span class="s1">LeaveOneOut</span><span class="s3">,</span>
    <span class="s1">LeavePGroupsOut</span><span class="s3">,</span>
    <span class="s1">LeavePOut</span><span class="s3">,</span>
    <span class="s1">PredefinedSplit</span><span class="s3">,</span>
    <span class="s1">RepeatedKFold</span><span class="s3">,</span>
    <span class="s1">RepeatedStratifiedKFold</span><span class="s3">,</span>
    <span class="s1">ShuffleSplit</span><span class="s3">,</span>
    <span class="s1">StratifiedGroupKFold</span><span class="s3">,</span>
    <span class="s1">StratifiedKFold</span><span class="s3">,</span>
    <span class="s1">StratifiedShuffleSplit</span><span class="s3">,</span>
    <span class="s1">TimeSeriesSplit</span><span class="s3">,</span>
    <span class="s1">check_cv</span><span class="s3">,</span>
    <span class="s1">cross_val_score</span><span class="s3">,</span>
    <span class="s1">train_test_split</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">model_selection</span><span class="s3">.</span><span class="s1">_split </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">_build_repr</span><span class="s3">,</span>
    <span class="s1">_validate_shuffle_split</span><span class="s3">,</span>
    <span class="s1">_yields_constant_splits</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">svm </span><span class="s2">import </span><span class="s1">SVC</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">tests</span><span class="s3">.</span><span class="s1">metadata_routing_common </span><span class="s2">import </span><span class="s1">assert_request_is_empty</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_array_api </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">_convert_to_numpy</span><span class="s3">,</span>
    <span class="s1">get_namespace</span><span class="s3">,</span>
    <span class="s1">yield_namespace_device_dtype_combinations</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_array_api </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">device </span><span class="s2">as </span><span class="s1">array_api_device</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_mocking </span><span class="s2">import </span><span class="s1">MockDataFrame</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">_testing </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">assert_allclose</span><span class="s3">,</span>
    <span class="s1">assert_array_almost_equal</span><span class="s3">,</span>
    <span class="s1">assert_array_equal</span><span class="s3">,</span>
    <span class="s1">ignore_warnings</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">estimator_checks </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">_array_api_for_tests</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">fixes </span><span class="s2">import </span><span class="s1">COO_CONTAINERS</span><span class="s3">, </span><span class="s1">CSC_CONTAINERS</span><span class="s3">, </span><span class="s1">CSR_CONTAINERS</span>
<span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">utils</span><span class="s3">.</span><span class="s1">validation </span><span class="s2">import </span><span class="s1">_num_samples</span>

<span class="s1">NO_GROUP_SPLITTERS </span><span class="s3">= [</span>
    <span class="s1">KFold</span><span class="s3">(),</span>
    <span class="s1">StratifiedKFold</span><span class="s3">(),</span>
    <span class="s1">TimeSeriesSplit</span><span class="s3">(),</span>
    <span class="s1">LeaveOneOut</span><span class="s3">(),</span>
    <span class="s1">LeavePOut</span><span class="s3">(</span><span class="s1">p</span><span class="s3">=</span><span class="s4">2</span><span class="s3">),</span>
    <span class="s1">ShuffleSplit</span><span class="s3">(),</span>
    <span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">0.5</span><span class="s3">),</span>
    <span class="s1">PredefinedSplit</span><span class="s3">([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">]),</span>
    <span class="s1">RepeatedKFold</span><span class="s3">(),</span>
    <span class="s1">RepeatedStratifiedKFold</span><span class="s3">(),</span>
<span class="s3">]</span>

<span class="s1">GROUP_SPLITTERS </span><span class="s3">= [</span>
    <span class="s1">GroupKFold</span><span class="s3">(),</span>
    <span class="s1">LeavePGroupsOut</span><span class="s3">(</span><span class="s1">n_groups</span><span class="s3">=</span><span class="s4">1</span><span class="s3">),</span>
    <span class="s1">StratifiedGroupKFold</span><span class="s3">(),</span>
    <span class="s1">LeaveOneGroupOut</span><span class="s3">(),</span>
    <span class="s1">GroupShuffleSplit</span><span class="s3">(),</span>
<span class="s3">]</span>
<span class="s1">GROUP_SPLITTER_NAMES </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s2">for </span><span class="s1">splitter </span><span class="s2">in </span><span class="s1">GROUP_SPLITTERS</span><span class="s3">)</span>

<span class="s1">ALL_SPLITTERS </span><span class="s3">= </span><span class="s1">NO_GROUP_SPLITTERS </span><span class="s3">+ </span><span class="s1">GROUP_SPLITTERS  </span><span class="s5"># type: ignore</span>

<span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
<span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">) // </span><span class="s4">2</span>
<span class="s1">test_groups </span><span class="s3">= (</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">]),</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">]),</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">]),</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">]),</span>
    <span class="s3">[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">],</span>
    <span class="s3">[</span><span class="s6">&quot;1&quot;</span><span class="s3">, </span><span class="s6">&quot;1&quot;</span><span class="s3">, </span><span class="s6">&quot;1&quot;</span><span class="s3">, </span><span class="s6">&quot;1&quot;</span><span class="s3">, </span><span class="s6">&quot;2&quot;</span><span class="s3">, </span><span class="s6">&quot;2&quot;</span><span class="s3">, </span><span class="s6">&quot;2&quot;</span><span class="s3">, </span><span class="s6">&quot;3&quot;</span><span class="s3">, </span><span class="s6">&quot;3&quot;</span><span class="s3">, </span><span class="s6">&quot;3&quot;</span><span class="s3">, </span><span class="s6">&quot;3&quot;</span><span class="s3">, </span><span class="s6">&quot;3&quot;</span><span class="s3">],</span>
<span class="s3">)</span>
<span class="s1">digits </span><span class="s3">= </span><span class="s1">load_digits</span><span class="s3">()</span>

<span class="s1">pytestmark </span><span class="s3">= </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">filterwarnings</span><span class="s3">(</span>
    <span class="s6">&quot;error:The groups parameter:UserWarning:sklearn.*&quot;</span>
<span class="s3">)</span>


<span class="s2">def </span><span class="s1">_split</span><span class="s3">(</span><span class="s1">splitter</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s2">in </span><span class="s1">GROUP_SPLITTER_NAMES</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">splitter</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">test_cross_validator_with_default_params</span><span class="s3">():</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s4">4</span>
    <span class="s1">n_unique_groups </span><span class="s3">= </span><span class="s4">4</span>
    <span class="s1">n_splits </span><span class="s3">= </span><span class="s4">2</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s4">2</span>
    <span class="s1">n_shuffle_splits </span><span class="s3">= </span><span class="s4">10  </span><span class="s5"># (the default value)</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">], [</span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">], [</span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">], [</span><span class="s4">7</span><span class="s3">, </span><span class="s4">8</span><span class="s3">]])</span>
    <span class="s1">X_1d </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">])</span>
    <span class="s1">groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>
    <span class="s1">loo </span><span class="s3">= </span><span class="s1">LeaveOneOut</span><span class="s3">()</span>
    <span class="s1">lpo </span><span class="s3">= </span><span class="s1">LeavePOut</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
    <span class="s1">kf </span><span class="s3">= </span><span class="s1">KFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">)</span>
    <span class="s1">skf </span><span class="s3">= </span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">)</span>
    <span class="s1">lolo </span><span class="s3">= </span><span class="s1">LeaveOneGroupOut</span><span class="s3">()</span>
    <span class="s1">lopo </span><span class="s3">= </span><span class="s1">LeavePGroupsOut</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
    <span class="s1">ss </span><span class="s3">= </span><span class="s1">ShuffleSplit</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">ps </span><span class="s3">= </span><span class="s1">PredefinedSplit</span><span class="s3">([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">])  </span><span class="s5"># n_splits = np of unique folds = 2</span>
    <span class="s1">sgkf </span><span class="s3">= </span><span class="s1">StratifiedGroupKFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">)</span>

    <span class="s1">loo_repr </span><span class="s3">= </span><span class="s6">&quot;LeaveOneOut()&quot;</span>
    <span class="s1">lpo_repr </span><span class="s3">= </span><span class="s6">&quot;LeavePOut(p=2)&quot;</span>
    <span class="s1">kf_repr </span><span class="s3">= </span><span class="s6">&quot;KFold(n_splits=2, random_state=None, shuffle=False)&quot;</span>
    <span class="s1">skf_repr </span><span class="s3">= </span><span class="s6">&quot;StratifiedKFold(n_splits=2, random_state=None, shuffle=False)&quot;</span>
    <span class="s1">lolo_repr </span><span class="s3">= </span><span class="s6">&quot;LeaveOneGroupOut()&quot;</span>
    <span class="s1">lopo_repr </span><span class="s3">= </span><span class="s6">&quot;LeavePGroupsOut(n_groups=2)&quot;</span>
    <span class="s1">ss_repr </span><span class="s3">= (</span>
        <span class="s6">&quot;ShuffleSplit(n_splits=10, random_state=0, test_size=None, train_size=None)&quot;</span>
    <span class="s3">)</span>
    <span class="s1">ps_repr </span><span class="s3">= </span><span class="s6">&quot;PredefinedSplit(test_fold=array([1, 1, 2, 2]))&quot;</span>
    <span class="s1">sgkf_repr </span><span class="s3">= </span><span class="s6">&quot;StratifiedGroupKFold(n_splits=2, random_state=None, shuffle=False)&quot;</span>

    <span class="s1">n_splits_expected </span><span class="s3">= [</span>
        <span class="s1">n_samples</span><span class="s3">,</span>
        <span class="s1">comb</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">p</span><span class="s3">),</span>
        <span class="s1">n_splits</span><span class="s3">,</span>
        <span class="s1">n_splits</span><span class="s3">,</span>
        <span class="s1">n_unique_groups</span><span class="s3">,</span>
        <span class="s1">comb</span><span class="s3">(</span><span class="s1">n_unique_groups</span><span class="s3">, </span><span class="s1">p</span><span class="s3">),</span>
        <span class="s1">n_shuffle_splits</span><span class="s3">,</span>
        <span class="s4">2</span><span class="s3">,</span>
        <span class="s1">n_splits</span><span class="s3">,</span>
    <span class="s3">]</span>

    <span class="s2">for </span><span class="s1">i</span><span class="s3">, (</span><span class="s1">cv</span><span class="s3">, </span><span class="s1">cv_repr</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span>
        <span class="s1">zip</span><span class="s3">(</span>
            <span class="s3">[</span><span class="s1">loo</span><span class="s3">, </span><span class="s1">lpo</span><span class="s3">, </span><span class="s1">kf</span><span class="s3">, </span><span class="s1">skf</span><span class="s3">, </span><span class="s1">lolo</span><span class="s3">, </span><span class="s1">lopo</span><span class="s3">, </span><span class="s1">ss</span><span class="s3">, </span><span class="s1">ps</span><span class="s3">, </span><span class="s1">sgkf</span><span class="s3">],</span>
            <span class="s3">[</span>
                <span class="s1">loo_repr</span><span class="s3">,</span>
                <span class="s1">lpo_repr</span><span class="s3">,</span>
                <span class="s1">kf_repr</span><span class="s3">,</span>
                <span class="s1">skf_repr</span><span class="s3">,</span>
                <span class="s1">lolo_repr</span><span class="s3">,</span>
                <span class="s1">lopo_repr</span><span class="s3">,</span>
                <span class="s1">ss_repr</span><span class="s3">,</span>
                <span class="s1">ps_repr</span><span class="s3">,</span>
                <span class="s1">sgkf_repr</span><span class="s3">,</span>
            <span class="s3">],</span>
        <span class="s3">)</span>
    <span class="s3">):</span>
        <span class="s5"># Test if get_n_splits works correctly</span>
        <span class="s2">assert </span><span class="s1">n_splits_expected</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] == </span><span class="s1">cv</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">)</span>

        <span class="s5"># Test if the cross-validator works as expected even if</span>
        <span class="s5"># the data is 1d</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span>
            <span class="s1">list</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">)), </span><span class="s1">list</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X_1d</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">))</span>
        <span class="s3">)</span>
        <span class="s5"># Test that train, test indices returned are integers</span>
        <span class="s2">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">cv</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">):</span>
            <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">train</span><span class="s3">).</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s6">&quot;i&quot;</span>
            <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">test</span><span class="s3">).</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s3">== </span><span class="s6">&quot;i&quot;</span>

        <span class="s5"># Test if the repr works without any errors</span>
        <span class="s2">assert </span><span class="s1">cv_repr </span><span class="s3">== </span><span class="s1">repr</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">)</span>

    <span class="s5"># ValueError for get_n_splits methods</span>
    <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;The 'X' parameter should not be None.&quot;</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">loo</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">lpo</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_2d_y</span><span class="s3">():</span>
    <span class="s5"># smoke test for 2d y and multi-label</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s4">30</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s4">2</span><span class="s3">))</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">,))</span>
    <span class="s1">y_2d </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">y_multilabel </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s4">3</span><span class="s3">))</span>
    <span class="s1">groups </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">,))</span>
    <span class="s1">splitters </span><span class="s3">= [</span>
        <span class="s1">LeaveOneOut</span><span class="s3">(),</span>
        <span class="s1">LeavePOut</span><span class="s3">(</span><span class="s1">p</span><span class="s3">=</span><span class="s4">2</span><span class="s3">),</span>
        <span class="s1">KFold</span><span class="s3">(),</span>
        <span class="s1">StratifiedKFold</span><span class="s3">(),</span>
        <span class="s1">RepeatedKFold</span><span class="s3">(),</span>
        <span class="s1">RepeatedStratifiedKFold</span><span class="s3">(),</span>
        <span class="s1">StratifiedGroupKFold</span><span class="s3">(),</span>
        <span class="s1">ShuffleSplit</span><span class="s3">(),</span>
        <span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">0.5</span><span class="s3">),</span>
        <span class="s1">GroupShuffleSplit</span><span class="s3">(),</span>
        <span class="s1">LeaveOneGroupOut</span><span class="s3">(),</span>
        <span class="s1">LeavePGroupsOut</span><span class="s3">(</span><span class="s1">n_groups</span><span class="s3">=</span><span class="s4">2</span><span class="s3">),</span>
        <span class="s1">GroupKFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">3</span><span class="s3">),</span>
        <span class="s1">TimeSeriesSplit</span><span class="s3">(),</span>
        <span class="s1">PredefinedSplit</span><span class="s3">(</span><span class="s1">test_fold</span><span class="s3">=</span><span class="s1">groups</span><span class="s3">),</span>
    <span class="s3">]</span>
    <span class="s2">for </span><span class="s1">splitter </span><span class="s2">in </span><span class="s1">splitters</span><span class="s3">:</span>
        <span class="s1">list</span><span class="s3">(</span><span class="s1">_split</span><span class="s3">(</span><span class="s1">splitter</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups</span><span class="s3">))</span>
        <span class="s1">list</span><span class="s3">(</span><span class="s1">_split</span><span class="s3">(</span><span class="s1">splitter</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_2d</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups</span><span class="s3">))</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">list</span><span class="s3">(</span><span class="s1">_split</span><span class="s3">(</span><span class="s1">splitter</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_multilabel</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups</span><span class="s3">))</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s1">allowed_target_types </span><span class="s3">= (</span><span class="s6">&quot;binary&quot;</span><span class="s3">, </span><span class="s6">&quot;multiclass&quot;</span><span class="s3">)</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;Supported target types are: {}. Got 'multilabel&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
                <span class="s1">allowed_target_types</span>
            <span class="s3">)</span>
            <span class="s2">assert </span><span class="s1">msg </span><span class="s2">in </span><span class="s1">str</span><span class="s3">(</span><span class="s1">e</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">check_valid_split</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5"># Use python sets to get more informative assertion failure messages</span>
    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">set</span><span class="s3">(</span><span class="s1">train</span><span class="s3">), </span><span class="s1">set</span><span class="s3">(</span><span class="s1">test</span><span class="s3">)</span>

    <span class="s5"># Train and test split should not overlap</span>
    <span class="s2">assert </span><span class="s1">train</span><span class="s3">.</span><span class="s1">intersection</span><span class="s3">(</span><span class="s1">test</span><span class="s3">) == </span><span class="s1">set</span><span class="s3">()</span>

    <span class="s2">if </span><span class="s1">n_samples </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s5"># Check that the union of train an test split cover all the indices</span>
        <span class="s2">assert </span><span class="s1">train</span><span class="s3">.</span><span class="s1">union</span><span class="s3">(</span><span class="s1">test</span><span class="s3">) == </span><span class="s1">set</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">check_cv_coverage</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">, </span><span class="s1">expected_n_splits</span><span class="s3">):</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s1">_num_samples</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s5"># Check that a all the samples appear at least once in a test fold</span>
    <span class="s2">assert </span><span class="s1">cv</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">) == </span><span class="s1">expected_n_splits</span>

    <span class="s1">collected_test_samples </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
    <span class="s1">iterations </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s2">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">cv</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">):</span>
        <span class="s1">check_valid_split</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">=</span><span class="s1">n_samples</span><span class="s3">)</span>
        <span class="s1">iterations </span><span class="s3">+= </span><span class="s4">1</span>
        <span class="s1">collected_test_samples</span><span class="s3">.</span><span class="s1">update</span><span class="s3">(</span><span class="s1">test</span><span class="s3">)</span>

    <span class="s5"># Check that the accumulated test samples cover the whole dataset</span>
    <span class="s2">assert </span><span class="s1">iterations </span><span class="s3">== </span><span class="s1">expected_n_splits</span>
    <span class="s2">if </span><span class="s1">n_samples </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">collected_test_samples </span><span class="s3">== </span><span class="s1">set</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_kfold_valueerrors</span><span class="s3">():</span>
    <span class="s1">X1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">], [</span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">], [</span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">]])</span>
    <span class="s1">X2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">], [</span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">], [</span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">], [</span><span class="s4">7</span><span class="s3">, </span><span class="s4">8</span><span class="s3">], [</span><span class="s4">9</span><span class="s3">, </span><span class="s4">10</span><span class="s3">]])</span>
    <span class="s5"># Check that errors are raised if there is not enough samples</span>
    <span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">next</span><span class="s3">, </span><span class="s1">KFold</span><span class="s3">(</span><span class="s4">4</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X1</span><span class="s3">))</span>

    <span class="s5"># Check that a warning is raised if the least populated class has too few</span>
    <span class="s5"># members.</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">, </span><span class="s4">3</span><span class="s3">])</span>

    <span class="s1">skf_3 </span><span class="s3">= </span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">warns</span><span class="s3">(</span><span class="s1">Warning</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;The least populated class&quot;</span><span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">skf_3</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X2</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>

    <span class="s1">sgkf_3 </span><span class="s3">= </span><span class="s1">StratifiedGroupKFold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">)</span>
    <span class="s1">naive_groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">warns</span><span class="s3">(</span><span class="s1">Warning</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;The least populated class&quot;</span><span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">sgkf_3</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X2</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">naive_groups</span><span class="s3">))</span>

    <span class="s5"># Check that despite the warning the folds are still computed even</span>
    <span class="s5"># though all the classes are not necessarily represented at on each</span>
    <span class="s5"># side of the split at each split</span>
    <span class="s2">with </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">():</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">simplefilter</span><span class="s3">(</span><span class="s6">&quot;ignore&quot;</span><span class="s3">)</span>
        <span class="s1">check_cv_coverage</span><span class="s3">(</span><span class="s1">skf_3</span><span class="s3">, </span><span class="s1">X2</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">expected_n_splits</span><span class="s3">=</span><span class="s4">3</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">():</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">simplefilter</span><span class="s3">(</span><span class="s6">&quot;ignore&quot;</span><span class="s3">)</span>
        <span class="s1">check_cv_coverage</span><span class="s3">(</span><span class="s1">sgkf_3</span><span class="s3">, </span><span class="s1">X2</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">naive_groups</span><span class="s3">, </span><span class="s1">expected_n_splits</span><span class="s3">=</span><span class="s4">3</span><span class="s3">)</span>

    <span class="s5"># Check that errors are raised if all n_groups for individual</span>
    <span class="s5"># classes are less than n_splits.</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">])</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">skf_3</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X2</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">sgkf_3</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X2</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>

    <span class="s5"># Error when number of folds is &lt;= 1</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">KFold</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">KFold</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">error_string </span><span class="s3">= </span><span class="s6">&quot;k-fold cross-validation requires at least one train/test split&quot;</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">error_string</span><span class="s3">):</span>
        <span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">error_string</span><span class="s3">):</span>
        <span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">error_string</span><span class="s3">):</span>
        <span class="s1">StratifiedGroupKFold</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">error_string</span><span class="s3">):</span>
        <span class="s1">StratifiedGroupKFold</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>

    <span class="s5"># When n_splits is not integer:</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">KFold</span><span class="s3">(</span><span class="s4">1.5</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">KFold</span><span class="s3">(</span><span class="s4">2.0</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">1.5</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">2.0</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">StratifiedGroupKFold</span><span class="s3">(</span><span class="s4">1.5</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">StratifiedGroupKFold</span><span class="s3">(</span><span class="s4">2.0</span><span class="s3">)</span>

    <span class="s5"># When shuffle is not  a bool:</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">TypeError</span><span class="s3">):</span>
        <span class="s1">KFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">4</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_kfold_indices</span><span class="s3">():</span>
    <span class="s5"># Check all indices are returned in the test folds</span>
    <span class="s1">X1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">18</span><span class="s3">)</span>
    <span class="s1">kf </span><span class="s3">= </span><span class="s1">KFold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">)</span>
    <span class="s1">check_cv_coverage</span><span class="s3">(</span><span class="s1">kf</span><span class="s3">, </span><span class="s1">X1</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">expected_n_splits</span><span class="s3">=</span><span class="s4">3</span><span class="s3">)</span>

    <span class="s5"># Check all indices are returned in the test folds even when equal-sized</span>
    <span class="s5"># folds are not possible</span>
    <span class="s1">X2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">17</span><span class="s3">)</span>
    <span class="s1">kf </span><span class="s3">= </span><span class="s1">KFold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">)</span>
    <span class="s1">check_cv_coverage</span><span class="s3">(</span><span class="s1">kf</span><span class="s3">, </span><span class="s1">X2</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">expected_n_splits</span><span class="s3">=</span><span class="s4">3</span><span class="s3">)</span>

    <span class="s5"># Check if get_n_splits returns the number of folds</span>
    <span class="s2">assert </span><span class="s4">5 </span><span class="s3">== </span><span class="s1">KFold</span><span class="s3">(</span><span class="s4">5</span><span class="s3">).</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s1">X2</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_kfold_no_shuffle</span><span class="s3">():</span>
    <span class="s5"># Manually check that KFold preserves the data ordering on toy datasets</span>
    <span class="s1">X2 </span><span class="s3">= [[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">], [</span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">], [</span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">], [</span><span class="s4">7</span><span class="s3">, </span><span class="s4">8</span><span class="s3">], [</span><span class="s4">9</span><span class="s3">, </span><span class="s4">10</span><span class="s3">]]</span>

    <span class="s1">splits </span><span class="s3">= </span><span class="s1">KFold</span><span class="s3">(</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X2</span><span class="s3">[:-</span><span class="s4">1</span><span class="s3">])</span>
    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">])</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">])</span>

    <span class="s1">splits </span><span class="s3">= </span><span class="s1">KFold</span><span class="s3">(</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X2</span><span class="s3">)</span>
    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">])</span>


<span class="s2">def </span><span class="s1">test_stratified_kfold_no_shuffle</span><span class="s3">():</span>
    <span class="s5"># Manually check that StratifiedKFold preserves the data ordering as much</span>
    <span class="s5"># as possible on toy datasets in order to avoid hiding sample dependencies</span>
    <span class="s5"># when possible</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">4</span><span class="s3">), [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">]</span>
    <span class="s1">splits </span><span class="s3">= </span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">2</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">3</span><span class="s3">])</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">3</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">2</span><span class="s3">])</span>

    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">7</span><span class="s3">), [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">]</span>
    <span class="s1">splits </span><span class="s3">= </span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">])</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>

    <span class="s5"># Check if get_n_splits returns the number of folds</span>
    <span class="s2">assert </span><span class="s4">5 </span><span class="s3">== </span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">5</span><span class="s3">).</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s5"># Make sure string labels are also supported</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">7</span><span class="s3">)</span>
    <span class="s1">y1 </span><span class="s3">= [</span><span class="s6">&quot;1&quot;</span><span class="s3">, </span><span class="s6">&quot;1&quot;</span><span class="s3">, </span><span class="s6">&quot;1&quot;</span><span class="s3">, </span><span class="s6">&quot;0&quot;</span><span class="s3">, </span><span class="s6">&quot;0&quot;</span><span class="s3">, </span><span class="s6">&quot;0&quot;</span><span class="s3">, </span><span class="s6">&quot;0&quot;</span><span class="s3">]</span>
    <span class="s1">y2 </span><span class="s3">= [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">]</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span>
        <span class="s1">list</span><span class="s3">(</span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y1</span><span class="s3">)), </span><span class="s1">list</span><span class="s3">(</span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y2</span><span class="s3">))</span>
    <span class="s3">)</span>

    <span class="s5"># Check equivalence to KFold</span>
    <span class="s1">y </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">]</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones_like</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span>
        <span class="s1">list</span><span class="s3">(</span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)), </span><span class="s1">list</span><span class="s3">(</span><span class="s1">KFold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;shuffle&quot;</span><span class="s3">, [</span><span class="s2">False</span><span class="s3">, </span><span class="s2">True</span><span class="s3">])</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;k&quot;</span><span class="s3">, [</span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">, </span><span class="s4">7</span><span class="s3">, </span><span class="s4">8</span><span class="s3">, </span><span class="s4">9</span><span class="s3">, </span><span class="s4">10</span><span class="s3">])</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;kfold&quot;</span><span class="s3">, [</span><span class="s1">StratifiedKFold</span><span class="s3">, </span><span class="s1">StratifiedGroupKFold</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_stratified_kfold_ratios</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">, </span><span class="s1">kfold</span><span class="s3">):</span>
    <span class="s5"># Check that stratified kfold preserves class ratios in individual splits</span>
    <span class="s5"># Repeat with shuffling turned off and on</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s4">1000</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
        <span class="s3">[</span><span class="s4">4</span><span class="s3">] * </span><span class="s1">int</span><span class="s3">(</span><span class="s4">0.10 </span><span class="s3">* </span><span class="s1">n_samples</span><span class="s3">)</span>
        <span class="s3">+ [</span><span class="s4">0</span><span class="s3">] * </span><span class="s1">int</span><span class="s3">(</span><span class="s4">0.89 </span><span class="s3">* </span><span class="s1">n_samples</span><span class="s3">)</span>
        <span class="s3">+ [</span><span class="s4">1</span><span class="s3">] * </span><span class="s1">int</span><span class="s3">(</span><span class="s4">0.01 </span><span class="s3">* </span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s5"># ensure perfect stratification with StratifiedGroupKFold</span>
    <span class="s1">groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>
    <span class="s1">distr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">y</span><span class="s3">) / </span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">test_sizes </span><span class="s3">= []</span>
    <span class="s1">random_state </span><span class="s3">= </span><span class="s2">None if not </span><span class="s1">shuffle </span><span class="s2">else </span><span class="s4">0</span>
    <span class="s1">skf </span><span class="s3">= </span><span class="s1">kfold</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">random_state</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s1">shuffle</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">_split</span><span class="s3">(</span><span class="s1">skf</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups</span><span class="s3">):</span>
        <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[</span><span class="s1">train</span><span class="s3">]) / </span><span class="s1">len</span><span class="s3">(</span><span class="s1">train</span><span class="s3">), </span><span class="s1">distr</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s4">0.02</span><span class="s3">)</span>
        <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[</span><span class="s1">test</span><span class="s3">]) / </span><span class="s1">len</span><span class="s3">(</span><span class="s1">test</span><span class="s3">), </span><span class="s1">distr</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s4">0.02</span><span class="s3">)</span>
        <span class="s1">test_sizes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">test</span><span class="s3">))</span>
    <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ptp</span><span class="s3">(</span><span class="s1">test_sizes</span><span class="s3">) &lt;= </span><span class="s4">1</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;shuffle&quot;</span><span class="s3">, [</span><span class="s2">False</span><span class="s3">, </span><span class="s2">True</span><span class="s3">])</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;k&quot;</span><span class="s3">, [</span><span class="s4">4</span><span class="s3">, </span><span class="s4">6</span><span class="s3">, </span><span class="s4">7</span><span class="s3">])</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;kfold&quot;</span><span class="s3">, [</span><span class="s1">StratifiedKFold</span><span class="s3">, </span><span class="s1">StratifiedGroupKFold</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_stratified_kfold_label_invariance</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">, </span><span class="s1">kfold</span><span class="s3">):</span>
    <span class="s5"># Check that stratified kfold gives the same indices regardless of labels</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s4">100</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
        <span class="s3">[</span><span class="s4">2</span><span class="s3">] * </span><span class="s1">int</span><span class="s3">(</span><span class="s4">0.10 </span><span class="s3">* </span><span class="s1">n_samples</span><span class="s3">)</span>
        <span class="s3">+ [</span><span class="s4">0</span><span class="s3">] * </span><span class="s1">int</span><span class="s3">(</span><span class="s4">0.89 </span><span class="s3">* </span><span class="s1">n_samples</span><span class="s3">)</span>
        <span class="s3">+ [</span><span class="s4">1</span><span class="s3">] * </span><span class="s1">int</span><span class="s3">(</span><span class="s4">0.01 </span><span class="s3">* </span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>
    <span class="s5"># ensure perfect stratification with StratifiedGroupKFold</span>
    <span class="s1">groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">get_splits</span><span class="s3">(</span><span class="s1">y</span><span class="s3">):</span>
        <span class="s1">random_state </span><span class="s3">= </span><span class="s2">None if not </span><span class="s1">shuffle </span><span class="s2">else </span><span class="s4">0</span>
        <span class="s2">return </span><span class="s3">[</span>
            <span class="s3">(</span><span class="s1">list</span><span class="s3">(</span><span class="s1">train</span><span class="s3">), </span><span class="s1">list</span><span class="s3">(</span><span class="s1">test</span><span class="s3">))</span>
            <span class="s2">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">_split</span><span class="s3">(</span>
                <span class="s1">kfold</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">random_state</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s1">shuffle</span><span class="s3">),</span>
                <span class="s1">X</span><span class="s3">,</span>
                <span class="s1">y</span><span class="s3">,</span>
                <span class="s1">groups</span><span class="s3">=</span><span class="s1">groups</span><span class="s3">,</span>
            <span class="s3">)</span>
        <span class="s3">]</span>

    <span class="s1">splits_base </span><span class="s3">= </span><span class="s1">get_splits</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">perm </span><span class="s2">in </span><span class="s1">permutations</span><span class="s3">([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">]):</span>
        <span class="s1">y_perm </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">take</span><span class="s3">(</span><span class="s1">perm</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">splits_perm </span><span class="s3">= </span><span class="s1">get_splits</span><span class="s3">(</span><span class="s1">y_perm</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">splits_perm </span><span class="s3">== </span><span class="s1">splits_base</span>


<span class="s2">def </span><span class="s1">test_kfold_balance</span><span class="s3">():</span>
    <span class="s5"># Check that KFold returns folds with balanced sizes</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">11</span><span class="s3">, </span><span class="s4">17</span><span class="s3">):</span>
        <span class="s1">kf </span><span class="s3">= </span><span class="s1">KFold</span><span class="s3">(</span><span class="s4">5</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">i</span><span class="s3">))</span>
        <span class="s1">sizes </span><span class="s3">= [</span><span class="s1">len</span><span class="s3">(</span><span class="s1">test</span><span class="s3">) </span><span class="s2">for </span><span class="s1">_</span><span class="s3">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">kf</span><span class="s3">]</span>

        <span class="s2">assert </span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">sizes</span><span class="s3">) - </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">sizes</span><span class="s3">)) &lt;= </span><span class="s4">1</span>
        <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">sizes</span><span class="s3">) == </span><span class="s1">i</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;kfold&quot;</span><span class="s3">, [</span><span class="s1">StratifiedKFold</span><span class="s3">, </span><span class="s1">StratifiedGroupKFold</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_stratifiedkfold_balance</span><span class="s3">(</span><span class="s1">kfold</span><span class="s3">):</span>
    <span class="s5"># Check that KFold returns folds with balanced sizes (only when</span>
    <span class="s5"># stratification is possible)</span>
    <span class="s5"># Repeat with shuffling turned off and on</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">17</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">] * </span><span class="s4">3 </span><span class="s3">+ [</span><span class="s4">1</span><span class="s3">] * </span><span class="s4">14</span>
    <span class="s5"># ensure perfect stratification with StratifiedGroupKFold</span>
    <span class="s1">groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>

    <span class="s2">for </span><span class="s1">shuffle </span><span class="s2">in </span><span class="s3">(</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">):</span>
        <span class="s1">cv </span><span class="s3">= </span><span class="s1">kfold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s1">shuffle</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">11</span><span class="s3">, </span><span class="s4">17</span><span class="s3">):</span>
            <span class="s1">skf </span><span class="s3">= </span><span class="s1">_split</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">, </span><span class="s1">X</span><span class="s3">[:</span><span class="s1">i</span><span class="s3">], </span><span class="s1">y</span><span class="s3">[:</span><span class="s1">i</span><span class="s3">], </span><span class="s1">groups</span><span class="s3">[:</span><span class="s1">i</span><span class="s3">])</span>
            <span class="s1">sizes </span><span class="s3">= [</span><span class="s1">len</span><span class="s3">(</span><span class="s1">test</span><span class="s3">) </span><span class="s2">for </span><span class="s1">_</span><span class="s3">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">skf</span><span class="s3">]</span>

            <span class="s2">assert </span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">sizes</span><span class="s3">) - </span><span class="s1">np</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">sizes</span><span class="s3">)) &lt;= </span><span class="s4">1</span>
            <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">sizes</span><span class="s3">) == </span><span class="s1">i</span>


<span class="s2">def </span><span class="s1">test_shuffle_kfold</span><span class="s3">():</span>
    <span class="s5"># Check the indices are shuffled properly</span>
    <span class="s1">kf </span><span class="s3">= </span><span class="s1">KFold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">)</span>
    <span class="s1">kf2 </span><span class="s3">= </span><span class="s1">KFold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">kf3 </span><span class="s3">= </span><span class="s1">KFold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">1</span><span class="s3">)</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">300</span><span class="s3">)</span>

    <span class="s1">all_folds </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">300</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">tr1</span><span class="s3">, </span><span class="s1">te1</span><span class="s3">), (</span><span class="s1">tr2</span><span class="s3">, </span><span class="s1">te2</span><span class="s3">), (</span><span class="s1">tr3</span><span class="s3">, </span><span class="s1">te3</span><span class="s3">) </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span>
        <span class="s1">kf</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">kf2</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">), </span><span class="s1">kf3</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s3">):</span>
        <span class="s2">for </span><span class="s1">tr_a</span><span class="s3">, </span><span class="s1">tr_b </span><span class="s2">in </span><span class="s1">combinations</span><span class="s3">((</span><span class="s1">tr1</span><span class="s3">, </span><span class="s1">tr2</span><span class="s3">, </span><span class="s1">tr3</span><span class="s3">), </span><span class="s4">2</span><span class="s3">):</span>
            <span class="s5"># Assert that there is no complete overlap</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intersect1d</span><span class="s3">(</span><span class="s1">tr_a</span><span class="s3">, </span><span class="s1">tr_b</span><span class="s3">)) != </span><span class="s1">len</span><span class="s3">(</span><span class="s1">tr1</span><span class="s3">)</span>

        <span class="s5"># Set all test indices in successive iterations of kf2 to 1</span>
        <span class="s1">all_folds</span><span class="s3">[</span><span class="s1">te2</span><span class="s3">] = </span><span class="s4">1</span>

    <span class="s5"># Check that all indices are returned in the different test folds</span>
    <span class="s2">assert </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">all_folds</span><span class="s3">) == </span><span class="s4">300</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;kfold&quot;</span><span class="s3">, [</span><span class="s1">KFold</span><span class="s3">, </span><span class="s1">StratifiedKFold</span><span class="s3">, </span><span class="s1">StratifiedGroupKFold</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_shuffle_kfold_stratifiedkfold_reproducibility</span><span class="s3">(</span><span class="s1">kfold</span><span class="s3">):</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">15</span><span class="s3">)  </span><span class="s5"># Divisible by 3</span>
    <span class="s1">y </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">] * </span><span class="s4">7 </span><span class="s3">+ [</span><span class="s4">1</span><span class="s3">] * </span><span class="s4">8</span>
    <span class="s1">groups_1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>
    <span class="s1">X2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">16</span><span class="s3">)  </span><span class="s5"># Not divisible by 3</span>
    <span class="s1">y2 </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">] * </span><span class="s4">8 </span><span class="s3">+ [</span><span class="s4">1</span><span class="s3">] * </span><span class="s4">8</span>
    <span class="s1">groups_2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y2</span><span class="s3">))</span>

    <span class="s5"># Check that when the shuffle is True, multiple split calls produce the</span>
    <span class="s5"># same split when random_state is int</span>
    <span class="s1">kf </span><span class="s3">= </span><span class="s1">kfold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>

    <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span>
        <span class="s1">list</span><span class="s3">(</span><span class="s1">_split</span><span class="s3">(</span><span class="s1">kf</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups_1</span><span class="s3">)), </span><span class="s1">list</span><span class="s3">(</span><span class="s1">_split</span><span class="s3">(</span><span class="s1">kf</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups_1</span><span class="s3">))</span>
    <span class="s3">)</span>

    <span class="s5"># Check that when the shuffle is True, multiple split calls often</span>
    <span class="s5"># (not always) produce different splits when random_state is</span>
    <span class="s5"># RandomState instance or None</span>
    <span class="s1">kf </span><span class="s3">= </span><span class="s1">kfold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s4">0</span><span class="s3">))</span>
    <span class="s2">for </span><span class="s1">data </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">((</span><span class="s1">X</span><span class="s3">, </span><span class="s1">X2</span><span class="s3">), (</span><span class="s1">y</span><span class="s3">, </span><span class="s1">y2</span><span class="s3">), (</span><span class="s1">groups_1</span><span class="s3">, </span><span class="s1">groups_2</span><span class="s3">)):</span>
        <span class="s5"># Test if the two splits are different cv</span>
        <span class="s2">for </span><span class="s3">(</span><span class="s1">_</span><span class="s3">, </span><span class="s1">test_a</span><span class="s3">), (</span><span class="s1">_</span><span class="s3">, </span><span class="s1">test_b</span><span class="s3">) </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">_split</span><span class="s3">(</span><span class="s1">kf</span><span class="s3">, *</span><span class="s1">data</span><span class="s3">), </span><span class="s1">_split</span><span class="s3">(</span><span class="s1">kf</span><span class="s3">, *</span><span class="s1">data</span><span class="s3">)):</span>
            <span class="s5"># cv.split(...) returns an array of tuples, each tuple</span>
            <span class="s5"># consisting of an array with train indices and test indices</span>
            <span class="s5"># Ensure that the splits for data are not same</span>
            <span class="s5"># when random state is not set</span>
            <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">AssertionError</span><span class="s3">):</span>
                <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test_a</span><span class="s3">, </span><span class="s1">test_b</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_shuffle_stratifiedkfold</span><span class="s3">():</span>
    <span class="s5"># Check that shuffling is happening when requested, and for proper</span>
    <span class="s5"># sample coverage</span>
    <span class="s1">X_40 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">40</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">] * </span><span class="s4">20 </span><span class="s3">+ [</span><span class="s4">1</span><span class="s3">] * </span><span class="s4">20</span>
    <span class="s1">kf0 </span><span class="s3">= </span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">5</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">kf1 </span><span class="s3">= </span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">5</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">1</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">_</span><span class="s3">, </span><span class="s1">test0</span><span class="s3">), (</span><span class="s1">_</span><span class="s3">, </span><span class="s1">test1</span><span class="s3">) </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">kf0</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X_40</span><span class="s3">, </span><span class="s1">y</span><span class="s3">), </span><span class="s1">kf1</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X_40</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)):</span>
        <span class="s2">assert </span><span class="s1">set</span><span class="s3">(</span><span class="s1">test0</span><span class="s3">) != </span><span class="s1">set</span><span class="s3">(</span><span class="s1">test1</span><span class="s3">)</span>
    <span class="s1">check_cv_coverage</span><span class="s3">(</span><span class="s1">kf0</span><span class="s3">, </span><span class="s1">X_40</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">expected_n_splits</span><span class="s3">=</span><span class="s4">5</span><span class="s3">)</span>

    <span class="s5"># Ensure that we shuffle each class's samples with different</span>
    <span class="s5"># random_state in StratifiedKFold</span>
    <span class="s5"># See https://github.com/scikit-learn/scikit-learn/pull/13124</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">] * </span><span class="s4">5 </span><span class="s3">+ [</span><span class="s4">1</span><span class="s3">] * </span><span class="s4">5</span>
    <span class="s1">kf1 </span><span class="s3">= </span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">5</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">kf2 </span><span class="s3">= </span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">5</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">test_set1 </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">([</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">s</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">kf1</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)])</span>
    <span class="s1">test_set2 </span><span class="s3">= </span><span class="s1">sorted</span><span class="s3">([</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">s</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]) </span><span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">kf2</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)])</span>
    <span class="s2">assert </span><span class="s1">test_set1 </span><span class="s3">!= </span><span class="s1">test_set2</span>


<span class="s2">def </span><span class="s1">test_kfold_can_detect_dependent_samples_on_digits</span><span class="s3">():  </span><span class="s5"># see #2372</span>
    <span class="s5"># The digits samples are dependent: they are apparently grouped by authors</span>
    <span class="s5"># although we don't have any information on the groups segment locations</span>
    <span class="s5"># for this data. We can highlight this fact by computing k-fold cross-</span>
    <span class="s5"># validation with and without shuffling: we observe that the shuffling case</span>
    <span class="s5"># wrongly makes the IID assumption and is therefore too optimistic: it</span>
    <span class="s5"># estimates a much higher accuracy (around 0.93) than that the non</span>
    <span class="s5"># shuffling variant (around 0.81).</span>

    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">digits</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[:</span><span class="s4">600</span><span class="s3">], </span><span class="s1">digits</span><span class="s3">.</span><span class="s1">target</span><span class="s3">[:</span><span class="s4">600</span><span class="s3">]</span>
    <span class="s1">model </span><span class="s3">= </span><span class="s1">SVC</span><span class="s3">(</span><span class="s1">C</span><span class="s3">=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">gamma</span><span class="s3">=</span><span class="s4">0.005</span><span class="s3">)</span>

    <span class="s1">n_splits </span><span class="s3">= </span><span class="s4">3</span>

    <span class="s1">cv </span><span class="s3">= </span><span class="s1">KFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s1">n_splits</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s1">mean_score </span><span class="s3">= </span><span class="s1">cross_val_score</span><span class="s3">(</span><span class="s1">model</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">cv</span><span class="s3">=</span><span class="s1">cv</span><span class="s3">).</span><span class="s1">mean</span><span class="s3">()</span>
    <span class="s2">assert </span><span class="s4">0.92 </span><span class="s3">&gt; </span><span class="s1">mean_score</span>
    <span class="s2">assert </span><span class="s1">mean_score </span><span class="s3">&gt; </span><span class="s4">0.80</span>

    <span class="s5"># Shuffling the data artificially breaks the dependency and hides the</span>
    <span class="s5"># overfitting of the model with regards to the writing style of the authors</span>
    <span class="s5"># by yielding a seriously overestimated score:</span>

    <span class="s1">cv </span><span class="s3">= </span><span class="s1">KFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">mean_score </span><span class="s3">= </span><span class="s1">cross_val_score</span><span class="s3">(</span><span class="s1">model</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">cv</span><span class="s3">=</span><span class="s1">cv</span><span class="s3">).</span><span class="s1">mean</span><span class="s3">()</span>
    <span class="s2">assert </span><span class="s1">mean_score </span><span class="s3">&gt; </span><span class="s4">0.92</span>

    <span class="s1">cv </span><span class="s3">= </span><span class="s1">KFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">mean_score </span><span class="s3">= </span><span class="s1">cross_val_score</span><span class="s3">(</span><span class="s1">model</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">cv</span><span class="s3">=</span><span class="s1">cv</span><span class="s3">).</span><span class="s1">mean</span><span class="s3">()</span>
    <span class="s2">assert </span><span class="s1">mean_score </span><span class="s3">&gt; </span><span class="s4">0.92</span>

    <span class="s5"># Similarly, StratifiedKFold should try to shuffle the data as little</span>
    <span class="s5"># as possible (while respecting the balanced class constraints)</span>
    <span class="s5"># and thus be able to detect the dependency by not overestimating</span>
    <span class="s5"># the CV score either. As the digits dataset is approximately balanced</span>
    <span class="s5"># the estimated mean score is close to the score measured with</span>
    <span class="s5"># non-shuffled KFold</span>

    <span class="s1">cv </span><span class="s3">= </span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">)</span>
    <span class="s1">mean_score </span><span class="s3">= </span><span class="s1">cross_val_score</span><span class="s3">(</span><span class="s1">model</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">cv</span><span class="s3">=</span><span class="s1">cv</span><span class="s3">).</span><span class="s1">mean</span><span class="s3">()</span>
    <span class="s2">assert </span><span class="s4">0.94 </span><span class="s3">&gt; </span><span class="s1">mean_score</span>
    <span class="s2">assert </span><span class="s1">mean_score </span><span class="s3">&gt; </span><span class="s4">0.80</span>


<span class="s2">def </span><span class="s1">test_stratified_group_kfold_trivial</span><span class="s3">():</span>
    <span class="s1">sgkf </span><span class="s3">= </span><span class="s1">StratifiedGroupKFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">3</span><span class="s3">)</span>
    <span class="s5"># Trivial example - groups with the same distribution</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">] * </span><span class="s4">6 </span><span class="s3">+ [</span><span class="s4">0</span><span class="s3">] * </span><span class="s4">12</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones_like</span><span class="s3">(</span><span class="s1">y</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">((</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">, </span><span class="s4">6</span><span class="s3">))</span>
    <span class="s1">distr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">y</span><span class="s3">) / </span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">test_sizes </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">sgkf</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">):</span>
        <span class="s5"># check group constraint</span>
        <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">intersect1d</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">[</span><span class="s1">train</span><span class="s3">], </span><span class="s1">groups</span><span class="s3">[</span><span class="s1">test</span><span class="s3">]).</span><span class="s1">size </span><span class="s3">== </span><span class="s4">0</span>
        <span class="s5"># check y distribution</span>
        <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[</span><span class="s1">train</span><span class="s3">]) / </span><span class="s1">len</span><span class="s3">(</span><span class="s1">train</span><span class="s3">), </span><span class="s1">distr</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s4">0.02</span><span class="s3">)</span>
        <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[</span><span class="s1">test</span><span class="s3">]) / </span><span class="s1">len</span><span class="s3">(</span><span class="s1">test</span><span class="s3">), </span><span class="s1">distr</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s4">0.02</span><span class="s3">)</span>
        <span class="s1">test_sizes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">test</span><span class="s3">))</span>
    <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ptp</span><span class="s3">(</span><span class="s1">test_sizes</span><span class="s3">) &lt;= </span><span class="s4">1</span>


<span class="s2">def </span><span class="s1">test_stratified_group_kfold_approximate</span><span class="s3">():</span>
    <span class="s5"># Not perfect stratification (even though it is possible) because of</span>
    <span class="s5"># iteration over groups</span>
    <span class="s1">sgkf </span><span class="s3">= </span><span class="s1">StratifiedGroupKFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">3</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">] * </span><span class="s4">6 </span><span class="s3">+ [</span><span class="s4">0</span><span class="s3">] * </span><span class="s4">12</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones_like</span><span class="s3">(</span><span class="s1">y</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">, </span><span class="s4">6</span><span class="s3">, </span><span class="s4">6</span><span class="s3">])</span>
    <span class="s1">expected </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">([[</span><span class="s4">0.833</span><span class="s3">, </span><span class="s4">0.166</span><span class="s3">], [</span><span class="s4">0.666</span><span class="s3">, </span><span class="s4">0.333</span><span class="s3">], [</span><span class="s4">0.5</span><span class="s3">, </span><span class="s4">0.5</span><span class="s3">]])</span>
    <span class="s1">test_sizes </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span><span class="s3">), </span><span class="s1">expect_dist </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">sgkf</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">), </span><span class="s1">expected</span><span class="s3">):</span>
        <span class="s5"># check group constraint</span>
        <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">intersect1d</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">[</span><span class="s1">train</span><span class="s3">], </span><span class="s1">groups</span><span class="s3">[</span><span class="s1">test</span><span class="s3">]).</span><span class="s1">size </span><span class="s3">== </span><span class="s4">0</span>
        <span class="s1">split_dist </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[</span><span class="s1">test</span><span class="s3">]) / </span><span class="s1">len</span><span class="s3">(</span><span class="s1">test</span><span class="s3">)</span>
        <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">split_dist</span><span class="s3">, </span><span class="s1">expect_dist</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s4">0.001</span><span class="s3">)</span>
        <span class="s1">test_sizes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">test</span><span class="s3">))</span>
    <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ptp</span><span class="s3">(</span><span class="s1">test_sizes</span><span class="s3">) &lt;= </span><span class="s4">1</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s6">&quot;y, groups, expected&quot;</span><span class="s3">,</span>
    <span class="s3">[</span>
        <span class="s3">(</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">0</span><span class="s3">] * </span><span class="s4">6 </span><span class="s3">+ [</span><span class="s4">1</span><span class="s3">] * </span><span class="s4">6</span><span class="s3">),</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">, </span><span class="s4">6</span><span class="s3">]),</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">([[</span><span class="s4">0.5</span><span class="s3">, </span><span class="s4">0.5</span><span class="s3">], [</span><span class="s4">0.5</span><span class="s3">, </span><span class="s4">0.5</span><span class="s3">], [</span><span class="s4">0.5</span><span class="s3">, </span><span class="s4">0.5</span><span class="s3">]]),</span>
        <span class="s3">),</span>
        <span class="s3">(</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">0</span><span class="s3">] * </span><span class="s4">9 </span><span class="s3">+ [</span><span class="s4">1</span><span class="s3">] * </span><span class="s4">3</span><span class="s3">),</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">]),</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">([[</span><span class="s4">0.75</span><span class="s3">, </span><span class="s4">0.25</span><span class="s3">], [</span><span class="s4">0.75</span><span class="s3">, </span><span class="s4">0.25</span><span class="s3">], [</span><span class="s4">0.75</span><span class="s3">, </span><span class="s4">0.25</span><span class="s3">]]),</span>
        <span class="s3">),</span>
    <span class="s3">],</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_stratified_group_kfold_homogeneous_groups</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">):</span>
    <span class="s1">sgkf </span><span class="s3">= </span><span class="s1">StratifiedGroupKFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">3</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones_like</span><span class="s3">(</span><span class="s1">y</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span><span class="s3">), </span><span class="s1">expect_dist </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">sgkf</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">), </span><span class="s1">expected</span><span class="s3">):</span>
        <span class="s5"># check group constraint</span>
        <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">intersect1d</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">[</span><span class="s1">train</span><span class="s3">], </span><span class="s1">groups</span><span class="s3">[</span><span class="s1">test</span><span class="s3">]).</span><span class="s1">size </span><span class="s3">== </span><span class="s4">0</span>
        <span class="s1">split_dist </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[</span><span class="s1">test</span><span class="s3">]) / </span><span class="s1">len</span><span class="s3">(</span><span class="s1">test</span><span class="s3">)</span>
        <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">split_dist</span><span class="s3">, </span><span class="s1">expect_dist</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s4">0.001</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;cls_distr&quot;</span><span class="s3">, [(</span><span class="s4">0.4</span><span class="s3">, </span><span class="s4">0.6</span><span class="s3">), (</span><span class="s4">0.3</span><span class="s3">, </span><span class="s4">0.7</span><span class="s3">), (</span><span class="s4">0.2</span><span class="s3">, </span><span class="s4">0.8</span><span class="s3">), (</span><span class="s4">0.8</span><span class="s3">, </span><span class="s4">0.2</span><span class="s3">)])</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;n_groups&quot;</span><span class="s3">, [</span><span class="s4">5</span><span class="s3">, </span><span class="s4">30</span><span class="s3">, </span><span class="s4">70</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_stratified_group_kfold_against_group_kfold</span><span class="s3">(</span><span class="s1">cls_distr</span><span class="s3">, </span><span class="s1">n_groups</span><span class="s3">):</span>
    <span class="s5"># Check that given sufficient amount of samples StratifiedGroupKFold</span>
    <span class="s5"># produces better stratified folds than regular GroupKFold</span>
    <span class="s1">n_splits </span><span class="s3">= </span><span class="s4">5</span>
    <span class="s1">sgkf </span><span class="s3">= </span><span class="s1">StratifiedGroupKFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s1">n_splits</span><span class="s3">)</span>
    <span class="s1">gkf </span><span class="s3">= </span><span class="s1">GroupKFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s1">n_splits</span><span class="s3">)</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">n_points </span><span class="s3">= </span><span class="s4">1000</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">choice</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">n_points</span><span class="s3">, </span><span class="s1">p</span><span class="s3">=</span><span class="s1">cls_distr</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones_like</span><span class="s3">(</span><span class="s1">y</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">g </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">choice</span><span class="s3">(</span><span class="s1">n_groups</span><span class="s3">, </span><span class="s1">n_points</span><span class="s3">)</span>
    <span class="s1">sgkf_folds </span><span class="s3">= </span><span class="s1">sgkf</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">g</span><span class="s3">)</span>
    <span class="s1">gkf_folds </span><span class="s3">= </span><span class="s1">gkf</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">g</span><span class="s3">)</span>
    <span class="s1">sgkf_entr </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s1">gkf_entr </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">sgkf_train</span><span class="s3">, </span><span class="s1">sgkf_test</span><span class="s3">), (</span><span class="s1">_</span><span class="s3">, </span><span class="s1">gkf_test</span><span class="s3">) </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">sgkf_folds</span><span class="s3">, </span><span class="s1">gkf_folds</span><span class="s3">):</span>
        <span class="s5"># check group constraint</span>
        <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">intersect1d</span><span class="s3">(</span><span class="s1">g</span><span class="s3">[</span><span class="s1">sgkf_train</span><span class="s3">], </span><span class="s1">g</span><span class="s3">[</span><span class="s1">sgkf_test</span><span class="s3">]).</span><span class="s1">size </span><span class="s3">== </span><span class="s4">0</span>
        <span class="s1">sgkf_distr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[</span><span class="s1">sgkf_test</span><span class="s3">]) / </span><span class="s1">len</span><span class="s3">(</span><span class="s1">sgkf_test</span><span class="s3">)</span>
        <span class="s1">gkf_distr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[</span><span class="s1">gkf_test</span><span class="s3">]) / </span><span class="s1">len</span><span class="s3">(</span><span class="s1">gkf_test</span><span class="s3">)</span>
        <span class="s1">sgkf_entr </span><span class="s3">+= </span><span class="s1">stats</span><span class="s3">.</span><span class="s1">entropy</span><span class="s3">(</span><span class="s1">sgkf_distr</span><span class="s3">, </span><span class="s1">qk</span><span class="s3">=</span><span class="s1">cls_distr</span><span class="s3">)</span>
        <span class="s1">gkf_entr </span><span class="s3">+= </span><span class="s1">stats</span><span class="s3">.</span><span class="s1">entropy</span><span class="s3">(</span><span class="s1">gkf_distr</span><span class="s3">, </span><span class="s1">qk</span><span class="s3">=</span><span class="s1">cls_distr</span><span class="s3">)</span>
    <span class="s1">sgkf_entr </span><span class="s3">/= </span><span class="s1">n_splits</span>
    <span class="s1">gkf_entr </span><span class="s3">/= </span><span class="s1">n_splits</span>
    <span class="s2">assert </span><span class="s1">sgkf_entr </span><span class="s3">&lt;= </span><span class="s1">gkf_entr</span>


<span class="s2">def </span><span class="s1">test_shuffle_split</span><span class="s3">():</span>
    <span class="s1">ss1 </span><span class="s3">= </span><span class="s1">ShuffleSplit</span><span class="s3">(</span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">0.2</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">ss2 </span><span class="s3">= </span><span class="s1">ShuffleSplit</span><span class="s3">(</span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">ss3 </span><span class="s3">= </span><span class="s1">ShuffleSplit</span><span class="s3">(</span><span class="s1">test_size</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">(</span><span class="s4">2</span><span class="s3">), </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">ss4 </span><span class="s3">= </span><span class="s1">ShuffleSplit</span><span class="s3">(</span><span class="s1">test_size</span><span class="s3">=</span><span class="s1">int</span><span class="s3">(</span><span class="s4">2</span><span class="s3">), </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">t1</span><span class="s3">, </span><span class="s1">t2</span><span class="s3">, </span><span class="s1">t3</span><span class="s3">, </span><span class="s1">t4 </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">ss1</span><span class="s3">, </span><span class="s1">ss2</span><span class="s3">, </span><span class="s1">ss3</span><span class="s3">, </span><span class="s1">ss4</span><span class="s3">):</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">t1</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">t2</span><span class="s3">[</span><span class="s4">0</span><span class="s3">])</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">t2</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">t3</span><span class="s3">[</span><span class="s4">0</span><span class="s3">])</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">t3</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">t4</span><span class="s3">[</span><span class="s4">0</span><span class="s3">])</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">t1</span><span class="s3">[</span><span class="s4">1</span><span class="s3">], </span><span class="s1">t2</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">t2</span><span class="s3">[</span><span class="s4">1</span><span class="s3">], </span><span class="s1">t3</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">t3</span><span class="s3">[</span><span class="s4">1</span><span class="s3">], </span><span class="s1">t4</span><span class="s3">[</span><span class="s4">1</span><span class="s3">])</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;split_class&quot;</span><span class="s3">, [</span><span class="s1">ShuffleSplit</span><span class="s3">, </span><span class="s1">StratifiedShuffleSplit</span><span class="s3">])</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s6">&quot;train_size, exp_train, exp_test&quot;</span><span class="s3">, [(</span><span class="s2">None</span><span class="s3">, </span><span class="s4">9</span><span class="s3">, </span><span class="s4">1</span><span class="s3">), (</span><span class="s4">8</span><span class="s3">, </span><span class="s4">8</span><span class="s3">, </span><span class="s4">2</span><span class="s3">), (</span><span class="s4">0.8</span><span class="s3">, </span><span class="s4">8</span><span class="s3">, </span><span class="s4">2</span><span class="s3">)]</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_shuffle_split_default_test_size</span><span class="s3">(</span><span class="s1">split_class</span><span class="s3">, </span><span class="s1">train_size</span><span class="s3">, </span><span class="s1">exp_train</span><span class="s3">, </span><span class="s1">exp_test</span><span class="s3">):</span>
    <span class="s5"># Check that the default value has the expected behavior, i.e. 0.1 if both</span>
    <span class="s5"># unspecified or complement train_size unless both are specified.</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>

    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">split_class</span><span class="s3">(</span><span class="s1">train_size</span><span class="s3">=</span><span class="s1">train_size</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>

    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">) == </span><span class="s1">exp_train</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">) == </span><span class="s1">exp_test</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s6">&quot;train_size, exp_train, exp_test&quot;</span><span class="s3">, [(</span><span class="s2">None</span><span class="s3">, </span><span class="s4">8</span><span class="s3">, </span><span class="s4">2</span><span class="s3">), (</span><span class="s4">7</span><span class="s3">, </span><span class="s4">7</span><span class="s3">, </span><span class="s4">3</span><span class="s3">), (</span><span class="s4">0.7</span><span class="s3">, </span><span class="s4">7</span><span class="s3">, </span><span class="s4">3</span><span class="s3">)]</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_group_shuffle_split_default_test_size</span><span class="s3">(</span><span class="s1">train_size</span><span class="s3">, </span><span class="s1">exp_train</span><span class="s3">, </span><span class="s1">exp_test</span><span class="s3">):</span>
    <span class="s5"># Check that the default value has the expected behavior, i.e. 0.2 if both</span>
    <span class="s5"># unspecified or complement train_size unless both are specified.</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
    <span class="s1">groups </span><span class="s3">= </span><span class="s1">range</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>

    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">GroupShuffleSplit</span><span class="s3">(</span><span class="s1">train_size</span><span class="s3">=</span><span class="s1">train_size</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">))</span>

    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">) == </span><span class="s1">exp_train</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">) == </span><span class="s1">exp_test</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">test_stratified_shuffle_split_init</span><span class="s3">():</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">7</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">])</span>
    <span class="s5"># Check that error is raised if there is a class with only one sample</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">0.2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>

    <span class="s5"># Check that error is raised if the test set size is smaller than n_classes</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>
    <span class="s5"># Check that error is raised if the train set size is smaller than</span>
    <span class="s5"># n_classes</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">3</span><span class="s3">, </span><span class="s1">train_size</span><span class="s3">=</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">9</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">])</span>

    <span class="s5"># Train size or test size too small</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span><span class="s1">train_size</span><span class="s3">=</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_stratified_shuffle_split_respects_test_size</span><span class="s3">():</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">])</span>
    <span class="s1">test_size </span><span class="s3">= </span><span class="s4">5</span>
    <span class="s1">train_size </span><span class="s3">= </span><span class="s4">10</span>
    <span class="s1">sss </span><span class="s3">= </span><span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span>
        <span class="s4">6</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s1">test_size</span><span class="s3">, </span><span class="s1">train_size</span><span class="s3">=</span><span class="s1">train_size</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span>
    <span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)), </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">sss</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">train</span><span class="s3">) == </span><span class="s1">train_size</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">test</span><span class="s3">) == </span><span class="s1">test_size</span>


<span class="s2">def </span><span class="s1">test_stratified_shuffle_split_iter</span><span class="s3">():</span>
    <span class="s1">ys </span><span class="s3">= [</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">]),</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">]),</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">] * </span><span class="s4">2</span><span class="s3">),</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">4</span><span class="s3">]),</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([-</span><span class="s4">1</span><span class="s3">] * </span><span class="s4">800 </span><span class="s3">+ [</span><span class="s4">1</span><span class="s3">] * </span><span class="s4">50</span><span class="s3">),</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">([[</span><span class="s1">i</span><span class="s3">] * (</span><span class="s4">100 </span><span class="s3">+ </span><span class="s1">i</span><span class="s3">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">11</span><span class="s3">)]),</span>
        <span class="s3">[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">3</span><span class="s3">],</span>
        <span class="s3">[</span><span class="s6">&quot;1&quot;</span><span class="s3">, </span><span class="s6">&quot;1&quot;</span><span class="s3">, </span><span class="s6">&quot;1&quot;</span><span class="s3">, </span><span class="s6">&quot;1&quot;</span><span class="s3">, </span><span class="s6">&quot;2&quot;</span><span class="s3">, </span><span class="s6">&quot;2&quot;</span><span class="s3">, </span><span class="s6">&quot;2&quot;</span><span class="s3">, </span><span class="s6">&quot;3&quot;</span><span class="s3">, </span><span class="s6">&quot;3&quot;</span><span class="s3">, </span><span class="s6">&quot;3&quot;</span><span class="s3">, </span><span class="s6">&quot;3&quot;</span><span class="s3">, </span><span class="s6">&quot;3&quot;</span><span class="s3">],</span>
    <span class="s3">]</span>

    <span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s1">ys</span><span class="s3">:</span>
        <span class="s1">sss </span><span class="s3">= </span><span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span><span class="s4">6</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">0.33</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span>
            <span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)), </span><span class="s1">y</span>
        <span class="s3">)</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)  </span><span class="s5"># To make it indexable for y[train]</span>
        <span class="s5"># this is how test-size is computed internally</span>
        <span class="s5"># in _validate_shuffle_split</span>
        <span class="s1">test_size </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s4">0.33 </span><span class="s3">* </span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">))</span>
        <span class="s1">train_size </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">) - </span><span class="s1">test_size</span>
        <span class="s2">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">sss</span><span class="s3">:</span>
            <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[</span><span class="s1">train</span><span class="s3">]), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[</span><span class="s1">test</span><span class="s3">]))</span>
            <span class="s5"># Checks if folds keep classes proportions</span>
            <span class="s1">p_train </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[</span><span class="s1">train</span><span class="s3">], </span><span class="s1">return_inverse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)[</span><span class="s4">1</span><span class="s3">]) / </span><span class="s1">float</span><span class="s3">(</span>
                <span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[</span><span class="s1">train</span><span class="s3">])</span>
            <span class="s3">)</span>
            <span class="s1">p_test </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bincount</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[</span><span class="s1">test</span><span class="s3">], </span><span class="s1">return_inverse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)[</span><span class="s4">1</span><span class="s3">]) / </span><span class="s1">float</span><span class="s3">(</span>
                <span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[</span><span class="s1">test</span><span class="s3">])</span>
            <span class="s3">)</span>
            <span class="s1">assert_array_almost_equal</span><span class="s3">(</span><span class="s1">p_train</span><span class="s3">, </span><span class="s1">p_test</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">train</span><span class="s3">) + </span><span class="s1">len</span><span class="s3">(</span><span class="s1">test</span><span class="s3">) == </span><span class="s1">y</span><span class="s3">.</span><span class="s1">size</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">train</span><span class="s3">) == </span><span class="s1">train_size</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">test</span><span class="s3">) == </span><span class="s1">test_size</span>
            <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intersect1d</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span><span class="s3">), [])</span>


<span class="s2">def </span><span class="s1">test_stratified_shuffle_split_even</span><span class="s3">():</span>
    <span class="s5"># Test the StratifiedShuffleSplit, indices are drawn with a</span>
    <span class="s5"># equal chance</span>
    <span class="s1">n_folds </span><span class="s3">= </span><span class="s4">5</span>
    <span class="s1">n_splits </span><span class="s3">= </span><span class="s4">1000</span>

    <span class="s2">def </span><span class="s1">assert_counts_are_ok</span><span class="s3">(</span><span class="s1">idx_counts</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s5"># Here we test that the distribution of the counts</span>
        <span class="s5"># per index is close enough to a binomial</span>
        <span class="s1">threshold </span><span class="s3">= </span><span class="s4">0.05 </span><span class="s3">/ </span><span class="s1">n_splits</span>
        <span class="s1">bf </span><span class="s3">= </span><span class="s1">stats</span><span class="s3">.</span><span class="s1">binom</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">, </span><span class="s1">p</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">count </span><span class="s2">in </span><span class="s1">idx_counts</span><span class="s3">:</span>
            <span class="s1">prob </span><span class="s3">= </span><span class="s1">bf</span><span class="s3">.</span><span class="s1">pmf</span><span class="s3">(</span><span class="s1">count</span><span class="s3">)</span>
            <span class="s2">assert </span><span class="s3">(</span>
                <span class="s1">prob </span><span class="s3">&gt; </span><span class="s1">threshold</span>
            <span class="s3">), </span><span class="s6">&quot;An index is not drawn with chance corresponding to even draws&quot;</span>

    <span class="s2">for </span><span class="s1">n_samples </span><span class="s2">in </span><span class="s3">(</span><span class="s4">6</span><span class="s3">, </span><span class="s4">22</span><span class="s3">):</span>
        <span class="s1">groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">((</span><span class="s1">n_samples </span><span class="s3">// </span><span class="s4">2</span><span class="s3">) * [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">])</span>
        <span class="s1">splits </span><span class="s3">= </span><span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span>
            <span class="s1">n_splits</span><span class="s3">=</span><span class="s1">n_splits</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">1.0 </span><span class="s3">/ </span><span class="s1">n_folds</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span>
        <span class="s3">)</span>

        <span class="s1">train_counts </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">] * </span><span class="s1">n_samples</span>
        <span class="s1">test_counts </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">] * </span><span class="s1">n_samples</span>
        <span class="s1">n_splits_actual </span><span class="s3">= </span><span class="s4">0</span>
        <span class="s2">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">splits</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">), </span><span class="s1">y</span><span class="s3">=</span><span class="s1">groups</span><span class="s3">):</span>
            <span class="s1">n_splits_actual </span><span class="s3">+= </span><span class="s4">1</span>
            <span class="s2">for </span><span class="s1">counter</span><span class="s3">, </span><span class="s1">ids </span><span class="s2">in </span><span class="s3">[(</span><span class="s1">train_counts</span><span class="s3">, </span><span class="s1">train</span><span class="s3">), (</span><span class="s1">test_counts</span><span class="s3">, </span><span class="s1">test</span><span class="s3">)]:</span>
                <span class="s2">for </span><span class="s1">id </span><span class="s2">in </span><span class="s1">ids</span><span class="s3">:</span>
                    <span class="s1">counter</span><span class="s3">[</span><span class="s1">id</span><span class="s3">] += </span><span class="s4">1</span>
        <span class="s2">assert </span><span class="s1">n_splits_actual </span><span class="s3">== </span><span class="s1">n_splits</span>

        <span class="s1">n_train</span><span class="s3">, </span><span class="s1">n_test </span><span class="s3">= </span><span class="s1">_validate_shuffle_split</span><span class="s3">(</span>
            <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">1.0 </span><span class="s3">/ </span><span class="s1">n_folds</span><span class="s3">, </span><span class="s1">train_size</span><span class="s3">=</span><span class="s4">1.0 </span><span class="s3">- (</span><span class="s4">1.0 </span><span class="s3">/ </span><span class="s1">n_folds</span><span class="s3">)</span>
        <span class="s3">)</span>

        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">train</span><span class="s3">) == </span><span class="s1">n_train</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">test</span><span class="s3">) == </span><span class="s1">n_test</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">set</span><span class="s3">(</span><span class="s1">train</span><span class="s3">).</span><span class="s1">intersection</span><span class="s3">(</span><span class="s1">test</span><span class="s3">)) == </span><span class="s4">0</span>

        <span class="s1">group_counts </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">splits</span><span class="s3">.</span><span class="s1">test_size </span><span class="s3">== </span><span class="s4">1.0 </span><span class="s3">/ </span><span class="s1">n_folds</span>
        <span class="s2">assert </span><span class="s1">n_train </span><span class="s3">+ </span><span class="s1">n_test </span><span class="s3">== </span><span class="s1">len</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">group_counts</span><span class="s3">) == </span><span class="s4">2</span>
        <span class="s1">ex_test_p </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">n_test</span><span class="s3">) / </span><span class="s1">n_samples</span>
        <span class="s1">ex_train_p </span><span class="s3">= </span><span class="s1">float</span><span class="s3">(</span><span class="s1">n_train</span><span class="s3">) / </span><span class="s1">n_samples</span>

        <span class="s1">assert_counts_are_ok</span><span class="s3">(</span><span class="s1">train_counts</span><span class="s3">, </span><span class="s1">ex_train_p</span><span class="s3">)</span>
        <span class="s1">assert_counts_are_ok</span><span class="s3">(</span><span class="s1">test_counts</span><span class="s3">, </span><span class="s1">ex_test_p</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_stratified_shuffle_split_overlap_train_test_bug</span><span class="s3">():</span>
    <span class="s5"># See https://github.com/scikit-learn/scikit-learn/issues/6121 for</span>
    <span class="s5"># the original bug report</span>
    <span class="s1">y </span><span class="s3">= [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">] * </span><span class="s4">3 </span><span class="s3">+ [</span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">] * </span><span class="s4">5</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones_like</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">sss </span><span class="s3">= </span><span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">0.5</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">sss</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">=</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s1">y</span><span class="s3">))</span>

    <span class="s5"># no overlap</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intersect1d</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span><span class="s3">), [])</span>

    <span class="s5"># complete partition</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">union1d</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)))</span>


<span class="s2">def </span><span class="s1">test_stratified_shuffle_split_multilabel</span><span class="s3">():</span>
    <span class="s5"># fix for issue 9037</span>
    <span class="s2">for </span><span class="s1">y </span><span class="s2">in </span><span class="s3">[</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">], [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">]]),</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">], [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">], [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">], [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">]]),</span>
    <span class="s3">]:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones_like</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">sss </span><span class="s3">= </span><span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">0.5</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
        <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">sss</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">=</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s1">y</span><span class="s3">))</span>
        <span class="s1">y_train </span><span class="s3">= </span><span class="s1">y</span><span class="s3">[</span><span class="s1">train</span><span class="s3">]</span>
        <span class="s1">y_test </span><span class="s3">= </span><span class="s1">y</span><span class="s3">[</span><span class="s1">test</span><span class="s3">]</span>

        <span class="s5"># no overlap</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intersect1d</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span><span class="s3">), [])</span>

        <span class="s5"># complete partition</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">union1d</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)))</span>

        <span class="s5"># correct stratification of entire rows</span>
        <span class="s5"># (by design, here y[:, 0] uniquely determines the entire row of y)</span>
        <span class="s1">expected_ratio </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[:, </span><span class="s4">0</span><span class="s3">])</span>
        <span class="s2">assert </span><span class="s1">expected_ratio </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">y_train</span><span class="s3">[:, </span><span class="s4">0</span><span class="s3">])</span>
        <span class="s2">assert </span><span class="s1">expected_ratio </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">y_test</span><span class="s3">[:, </span><span class="s4">0</span><span class="s3">])</span>


<span class="s2">def </span><span class="s1">test_stratified_shuffle_split_multilabel_many_labels</span><span class="s3">():</span>
    <span class="s5"># fix in PR #9922: for multilabel data with &gt; 1000 labels, str(row)</span>
    <span class="s5"># truncates with an ellipsis for elements in positions 4 through</span>
    <span class="s5"># len(row) - 4, so labels were not being correctly split using the powerset</span>
    <span class="s5"># method for transforming a multilabel problem to a multiclass one; this</span>
    <span class="s5"># test checks that this problem is fixed.</span>
    <span class="s1">row_with_many_zeros </span><span class="s3">= [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">] + [</span><span class="s4">0</span><span class="s3">] * </span><span class="s4">1000 </span><span class="s3">+ [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">]</span>
    <span class="s1">row_with_many_ones </span><span class="s3">= [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">] + [</span><span class="s4">1</span><span class="s3">] * </span><span class="s4">1000 </span><span class="s3">+ [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">]</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">row_with_many_zeros</span><span class="s3">] * </span><span class="s4">10 </span><span class="s3">+ [</span><span class="s1">row_with_many_ones</span><span class="s3">] * </span><span class="s4">100</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones_like</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>

    <span class="s1">sss </span><span class="s3">= </span><span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">0.5</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">sss</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">=</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s1">y</span><span class="s3">))</span>
    <span class="s1">y_train </span><span class="s3">= </span><span class="s1">y</span><span class="s3">[</span><span class="s1">train</span><span class="s3">]</span>
    <span class="s1">y_test </span><span class="s3">= </span><span class="s1">y</span><span class="s3">[</span><span class="s1">test</span><span class="s3">]</span>

    <span class="s5"># correct stratification of entire rows</span>
    <span class="s5"># (by design, here y[:, 4] uniquely determines the entire row of y)</span>
    <span class="s1">expected_ratio </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">y</span><span class="s3">[:, </span><span class="s4">4</span><span class="s3">])</span>
    <span class="s2">assert </span><span class="s1">expected_ratio </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">y_train</span><span class="s3">[:, </span><span class="s4">4</span><span class="s3">])</span>
    <span class="s2">assert </span><span class="s1">expected_ratio </span><span class="s3">== </span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">y_test</span><span class="s3">[:, </span><span class="s4">4</span><span class="s3">])</span>


<span class="s2">def </span><span class="s1">test_predefinedsplit_with_kfold_split</span><span class="s3">():</span>
    <span class="s5"># Check that PredefinedSplit can reproduce a split generated by Kfold.</span>
    <span class="s1">folds </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, -</span><span class="s4">1.0</span><span class="s3">)</span>
    <span class="s1">kf_train </span><span class="s3">= []</span>
    <span class="s1">kf_test </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s3">, (</span><span class="s1">train_ind</span><span class="s3">, </span><span class="s1">test_ind</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">KFold</span><span class="s3">(</span><span class="s4">5</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)):</span>
        <span class="s1">kf_train</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">train_ind</span><span class="s3">)</span>
        <span class="s1">kf_test</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">test_ind</span><span class="s3">)</span>
        <span class="s1">folds</span><span class="s3">[</span><span class="s1">test_ind</span><span class="s3">] = </span><span class="s1">i</span>
    <span class="s1">ps </span><span class="s3">= </span><span class="s1">PredefinedSplit</span><span class="s3">(</span><span class="s1">folds</span><span class="s3">)</span>
    <span class="s5"># n_splits is simply the no of unique folds</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">folds</span><span class="s3">)) == </span><span class="s1">ps</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">()</span>
    <span class="s1">ps_train</span><span class="s3">, </span><span class="s1">ps_test </span><span class="s3">= </span><span class="s1">zip</span><span class="s3">(*</span><span class="s1">ps</span><span class="s3">.</span><span class="s1">split</span><span class="s3">())</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">ps_train</span><span class="s3">, </span><span class="s1">kf_train</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">ps_test</span><span class="s3">, </span><span class="s1">kf_test</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_group_shuffle_split</span><span class="s3">():</span>
    <span class="s2">for </span><span class="s1">groups_i </span><span class="s2">in </span><span class="s1">test_groups</span><span class="s3">:</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">groups_i</span><span class="s3">))</span>
        <span class="s1">n_splits </span><span class="s3">= </span><span class="s4">6</span>
        <span class="s1">test_size </span><span class="s3">= </span><span class="s4">1.0 </span><span class="s3">/ </span><span class="s4">3</span>
        <span class="s1">slo </span><span class="s3">= </span><span class="s1">GroupShuffleSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s1">test_size</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>

        <span class="s5"># Make sure the repr works</span>
        <span class="s1">repr</span><span class="s3">(</span><span class="s1">slo</span><span class="s3">)</span>

        <span class="s5"># Test that the length is correct</span>
        <span class="s2">assert </span><span class="s1">slo</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups_i</span><span class="s3">) == </span><span class="s1">n_splits</span>

        <span class="s1">l_unique </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">groups_i</span><span class="s3">)</span>
        <span class="s1">l </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">groups_i</span><span class="s3">)</span>

        <span class="s2">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">slo</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups_i</span><span class="s3">):</span>
            <span class="s5"># First test: no train group is in the test set and vice versa</span>
            <span class="s1">l_train_unique </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">l</span><span class="s3">[</span><span class="s1">train</span><span class="s3">])</span>
            <span class="s1">l_test_unique </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">l</span><span class="s3">[</span><span class="s1">test</span><span class="s3">])</span>
            <span class="s2">assert not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isin</span><span class="s3">(</span><span class="s1">l</span><span class="s3">[</span><span class="s1">train</span><span class="s3">], </span><span class="s1">l_test_unique</span><span class="s3">))</span>
            <span class="s2">assert not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">isin</span><span class="s3">(</span><span class="s1">l</span><span class="s3">[</span><span class="s1">test</span><span class="s3">], </span><span class="s1">l_train_unique</span><span class="s3">))</span>

            <span class="s5"># Second test: train and test add up to all the data</span>
            <span class="s2">assert </span><span class="s1">l</span><span class="s3">[</span><span class="s1">train</span><span class="s3">].</span><span class="s1">size </span><span class="s3">+ </span><span class="s1">l</span><span class="s3">[</span><span class="s1">test</span><span class="s3">].</span><span class="s1">size </span><span class="s3">== </span><span class="s1">l</span><span class="s3">.</span><span class="s1">size</span>

            <span class="s5"># Third test: train and test are disjoint</span>
            <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intersect1d</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span><span class="s3">), [])</span>

            <span class="s5"># Fourth test:</span>
            <span class="s5"># unique train and test groups are correct, +- 1 for rounding error</span>
            <span class="s2">assert </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">l_test_unique</span><span class="s3">) - </span><span class="s1">round</span><span class="s3">(</span><span class="s1">test_size </span><span class="s3">* </span><span class="s1">len</span><span class="s3">(</span><span class="s1">l_unique</span><span class="s3">))) &lt;= </span><span class="s4">1</span>
            <span class="s2">assert </span><span class="s3">(</span>
                <span class="s1">abs</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">l_train_unique</span><span class="s3">) - </span><span class="s1">round</span><span class="s3">((</span><span class="s4">1.0 </span><span class="s3">- </span><span class="s1">test_size</span><span class="s3">) * </span><span class="s1">len</span><span class="s3">(</span><span class="s1">l_unique</span><span class="s3">))) &lt;= </span><span class="s4">1</span>
            <span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_leave_one_p_group_out</span><span class="s3">():</span>
    <span class="s1">logo </span><span class="s3">= </span><span class="s1">LeaveOneGroupOut</span><span class="s3">()</span>
    <span class="s1">lpgo_1 </span><span class="s3">= </span><span class="s1">LeavePGroupsOut</span><span class="s3">(</span><span class="s1">n_groups</span><span class="s3">=</span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">lpgo_2 </span><span class="s3">= </span><span class="s1">LeavePGroupsOut</span><span class="s3">(</span><span class="s1">n_groups</span><span class="s3">=</span><span class="s4">2</span><span class="s3">)</span>

    <span class="s5"># Make sure the repr works</span>
    <span class="s2">assert </span><span class="s1">repr</span><span class="s3">(</span><span class="s1">logo</span><span class="s3">) == </span><span class="s6">&quot;LeaveOneGroupOut()&quot;</span>
    <span class="s2">assert </span><span class="s1">repr</span><span class="s3">(</span><span class="s1">lpgo_1</span><span class="s3">) == </span><span class="s6">&quot;LeavePGroupsOut(n_groups=1)&quot;</span>
    <span class="s2">assert </span><span class="s1">repr</span><span class="s3">(</span><span class="s1">lpgo_2</span><span class="s3">) == </span><span class="s6">&quot;LeavePGroupsOut(n_groups=2)&quot;</span>
    <span class="s2">assert </span><span class="s1">repr</span><span class="s3">(</span><span class="s1">LeavePGroupsOut</span><span class="s3">(</span><span class="s1">n_groups</span><span class="s3">=</span><span class="s4">3</span><span class="s3">)) == </span><span class="s6">&quot;LeavePGroupsOut(n_groups=3)&quot;</span>

    <span class="s2">for </span><span class="s1">j</span><span class="s3">, (</span><span class="s1">cv</span><span class="s3">, </span><span class="s1">p_groups_out</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(((</span><span class="s1">logo</span><span class="s3">, </span><span class="s4">1</span><span class="s3">), (</span><span class="s1">lpgo_1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">), (</span><span class="s1">lpgo_2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">))):</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">groups_i </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">test_groups</span><span class="s3">):</span>
            <span class="s1">n_groups </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">groups_i</span><span class="s3">))</span>
            <span class="s1">n_splits </span><span class="s3">= </span><span class="s1">n_groups </span><span class="s2">if </span><span class="s1">p_groups_out </span><span class="s3">== </span><span class="s4">1 </span><span class="s2">else </span><span class="s1">n_groups </span><span class="s3">* (</span><span class="s1">n_groups </span><span class="s3">- </span><span class="s4">1</span><span class="s3">) / </span><span class="s4">2</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">groups_i</span><span class="s3">))</span>

            <span class="s5"># Test that the length is correct</span>
            <span class="s2">assert </span><span class="s1">cv</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups_i</span><span class="s3">) == </span><span class="s1">n_splits</span>

            <span class="s1">groups_arr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">groups_i</span><span class="s3">)</span>

            <span class="s5"># Split using the original list / array / list of string groups_i</span>
            <span class="s2">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">cv</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups_i</span><span class="s3">):</span>
                <span class="s5"># First test: no train group is in the test set and vice versa</span>
                <span class="s1">assert_array_equal</span><span class="s3">(</span>
                    <span class="s1">np</span><span class="s3">.</span><span class="s1">intersect1d</span><span class="s3">(</span><span class="s1">groups_arr</span><span class="s3">[</span><span class="s1">train</span><span class="s3">], </span><span class="s1">groups_arr</span><span class="s3">[</span><span class="s1">test</span><span class="s3">]).</span><span class="s1">tolist</span><span class="s3">(), []</span>
                <span class="s3">)</span>

                <span class="s5"># Second test: train and test add up to all the data</span>
                <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">train</span><span class="s3">) + </span><span class="s1">len</span><span class="s3">(</span><span class="s1">test</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">groups_i</span><span class="s3">)</span>

                <span class="s5"># Third test:</span>
                <span class="s5"># The number of groups in test must be equal to p_groups_out</span>
                <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">groups_arr</span><span class="s3">[</span><span class="s1">test</span><span class="s3">]).</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">], </span><span class="s1">p_groups_out</span>

    <span class="s5"># check get_n_splits() with dummy parameters</span>
    <span class="s2">assert </span><span class="s1">logo</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, [</span><span class="s6">&quot;a&quot;</span><span class="s3">, </span><span class="s6">&quot;b&quot;</span><span class="s3">, </span><span class="s6">&quot;c&quot;</span><span class="s3">, </span><span class="s6">&quot;b&quot;</span><span class="s3">, </span><span class="s6">&quot;c&quot;</span><span class="s3">]) == </span><span class="s4">3</span>
    <span class="s2">assert </span><span class="s1">logo</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">=[</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">1.1</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">1.2</span><span class="s3">]) == </span><span class="s4">3</span>
    <span class="s2">assert </span><span class="s1">lpgo_2</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">4</span><span class="s3">)) == </span><span class="s4">6</span>
    <span class="s2">assert </span><span class="s1">lpgo_1</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">4</span><span class="s3">)) == </span><span class="s4">4</span>

    <span class="s5"># raise ValueError if a `groups` parameter is illegal</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">logo</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, [</span><span class="s4">0.0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s4">0.0</span><span class="s3">])</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">lpgo_2</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, [</span><span class="s4">0.0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, </span><span class="s4">0.0</span><span class="s3">])</span>

    <span class="s1">msg </span><span class="s3">= </span><span class="s6">&quot;The 'groups' parameter should not be None.&quot;</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">logo</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">lpgo_1</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_leave_group_out_changing_groups</span><span class="s3">():</span>
    <span class="s5"># Check that LeaveOneGroupOut and LeavePGroupsOut work normally if</span>
    <span class="s5"># the groups variable is changed before calling split</span>
    <span class="s1">groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">])</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">))</span>
    <span class="s1">groups_changing </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">lolo </span><span class="s3">= </span><span class="s1">LeaveOneGroupOut</span><span class="s3">().</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups</span><span class="s3">)</span>
    <span class="s1">lolo_changing </span><span class="s3">= </span><span class="s1">LeaveOneGroupOut</span><span class="s3">().</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups</span><span class="s3">)</span>
    <span class="s1">lplo </span><span class="s3">= </span><span class="s1">LeavePGroupsOut</span><span class="s3">(</span><span class="s1">n_groups</span><span class="s3">=</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups</span><span class="s3">)</span>
    <span class="s1">lplo_changing </span><span class="s3">= </span><span class="s1">LeavePGroupsOut</span><span class="s3">(</span><span class="s1">n_groups</span><span class="s3">=</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups</span><span class="s3">)</span>
    <span class="s1">groups_changing</span><span class="s3">[:] = </span><span class="s4">0</span>
    <span class="s2">for </span><span class="s1">llo</span><span class="s3">, </span><span class="s1">llo_changing </span><span class="s2">in </span><span class="s3">[(</span><span class="s1">lolo</span><span class="s3">, </span><span class="s1">lolo_changing</span><span class="s3">), (</span><span class="s1">lplo</span><span class="s3">, </span><span class="s1">lplo_changing</span><span class="s3">)]:</span>
        <span class="s2">for </span><span class="s3">(</span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span><span class="s3">), (</span><span class="s1">train_chan</span><span class="s3">, </span><span class="s1">test_chan</span><span class="s3">) </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">llo</span><span class="s3">, </span><span class="s1">llo_changing</span><span class="s3">):</span>
            <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, </span><span class="s1">train_chan</span><span class="s3">)</span>
            <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, </span><span class="s1">test_chan</span><span class="s3">)</span>

    <span class="s5"># n_splits = no of 2 (p) group combinations of the unique groups = 3C2 = 3</span>
    <span class="s2">assert </span><span class="s4">3 </span><span class="s3">== </span><span class="s1">LeavePGroupsOut</span><span class="s3">(</span><span class="s1">n_groups</span><span class="s3">=</span><span class="s4">2</span><span class="s3">).</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s1">X</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups</span><span class="s3">)</span>
    <span class="s5"># n_splits = no of unique groups (C(uniq_lbls, 1) = n_unique_groups)</span>
    <span class="s2">assert </span><span class="s4">3 </span><span class="s3">== </span><span class="s1">LeaveOneGroupOut</span><span class="s3">().</span><span class="s1">get_n_splits</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s1">X</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_leave_group_out_order_dependence</span><span class="s3">():</span>
    <span class="s5"># Check that LeaveOneGroupOut orders the splits according to the index</span>
    <span class="s5"># of the group left out.</span>
    <span class="s1">groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">])</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">))</span>

    <span class="s1">splits </span><span class="s3">= </span><span class="s1">iter</span><span class="s3">(</span><span class="s1">LeaveOneGroupOut</span><span class="s3">().</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups</span><span class="s3">))</span>

    <span class="s1">expected_indices </span><span class="s3">= [</span>
        <span class="s3">([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">], [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">]),</span>
        <span class="s3">([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">], [</span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">]),</span>
        <span class="s3">([</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">], [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">]),</span>
    <span class="s3">]</span>

    <span class="s2">for </span><span class="s1">expected_train</span><span class="s3">, </span><span class="s1">expected_test </span><span class="s2">in </span><span class="s1">expected_indices</span><span class="s3">:</span>
        <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, </span><span class="s1">expected_train</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, </span><span class="s1">expected_test</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_leave_one_p_group_out_error_on_fewer_number_of_groups</span><span class="s3">():</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">y </span><span class="s3">= </span><span class="s1">groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">msg </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">escape</span><span class="s3">(</span><span class="s6">&quot;Found array with 0 sample(s)&quot;</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">LeaveOneGroupOut</span><span class="s3">().</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">))</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">y </span><span class="s3">= </span><span class="s1">groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">msg </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">escape</span><span class="s3">(</span>
        <span class="s6">f&quot;The groups parameter contains fewer than 2 unique groups (</span><span class="s2">{</span><span class="s1">groups</span><span class="s2">}</span><span class="s6">).&quot;</span>
        <span class="s6">&quot; LeaveOneGroupOut expects at least 2.&quot;</span>
    <span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">LeaveOneGroupOut</span><span class="s3">().</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">))</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">y </span><span class="s3">= </span><span class="s1">groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">msg </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">escape</span><span class="s3">(</span>
        <span class="s6">&quot;The groups parameter contains fewer than (or equal to) n_groups &quot;</span>
        <span class="s6">f&quot;(3) numbers of unique groups (</span><span class="s2">{</span><span class="s1">groups</span><span class="s2">}</span><span class="s6">). LeavePGroupsOut expects &quot;</span>
        <span class="s6">&quot;that at least n_groups + 1 (4) unique groups &quot;</span>
        <span class="s6">&quot;be present&quot;</span>
    <span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">LeavePGroupsOut</span><span class="s3">(</span><span class="s1">n_groups</span><span class="s3">=</span><span class="s4">3</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">))</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">y </span><span class="s3">= </span><span class="s1">groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">3</span><span class="s3">)</span>
    <span class="s1">msg </span><span class="s3">= </span><span class="s1">re</span><span class="s3">.</span><span class="s1">escape</span><span class="s3">(</span>
        <span class="s6">&quot;The groups parameter contains fewer than (or equal to) n_groups &quot;</span>
        <span class="s6">f&quot;(3) numbers of unique groups (</span><span class="s2">{</span><span class="s1">groups</span><span class="s2">}</span><span class="s6">). LeavePGroupsOut expects &quot;</span>
        <span class="s6">&quot;that at least n_groups + 1 (4) unique groups &quot;</span>
        <span class="s6">&quot;be present&quot;</span>
    <span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">LeavePGroupsOut</span><span class="s3">(</span><span class="s1">n_groups</span><span class="s3">=</span><span class="s4">3</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">test_repeated_cv_value_errors</span><span class="s3">():</span>
    <span class="s5"># n_repeats is not integer or &lt;= 0</span>
    <span class="s2">for </span><span class="s1">cv </span><span class="s2">in </span><span class="s3">(</span><span class="s1">RepeatedKFold</span><span class="s3">, </span><span class="s1">RepeatedStratifiedKFold</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
            <span class="s1">cv</span><span class="s3">(</span><span class="s1">n_repeats</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
            <span class="s1">cv</span><span class="s3">(</span><span class="s1">n_repeats</span><span class="s3">=</span><span class="s4">1.5</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;RepeatedCV&quot;</span><span class="s3">, [</span><span class="s1">RepeatedKFold</span><span class="s3">, </span><span class="s1">RepeatedStratifiedKFold</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_repeated_cv_repr</span><span class="s3">(</span><span class="s1">RepeatedCV</span><span class="s3">):</span>
    <span class="s1">n_splits</span><span class="s3">, </span><span class="s1">n_repeats </span><span class="s3">= </span><span class="s4">2</span><span class="s3">, </span><span class="s4">6</span>
    <span class="s1">repeated_cv </span><span class="s3">= </span><span class="s1">RepeatedCV</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s1">n_splits</span><span class="s3">, </span><span class="s1">n_repeats</span><span class="s3">=</span><span class="s1">n_repeats</span><span class="s3">)</span>
    <span class="s1">repeated_cv_repr </span><span class="s3">= </span><span class="s6">&quot;{}(n_repeats=6, n_splits=2, random_state=None)&quot;</span><span class="s3">.</span><span class="s1">format</span><span class="s3">(</span>
        <span class="s1">repeated_cv</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span>
    <span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">repeated_cv_repr </span><span class="s3">== </span><span class="s1">repr</span><span class="s3">(</span><span class="s1">repeated_cv</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_repeated_kfold_determinstic_split</span><span class="s3">():</span>
    <span class="s1">X </span><span class="s3">= [[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">], [</span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">], [</span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">], [</span><span class="s4">7</span><span class="s3">, </span><span class="s4">8</span><span class="s3">], [</span><span class="s4">9</span><span class="s3">, </span><span class="s4">10</span><span class="s3">]]</span>
    <span class="s1">random_state </span><span class="s3">= </span><span class="s4">258173307</span>
    <span class="s1">rkf </span><span class="s3">= </span><span class="s1">RepeatedKFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">n_repeats</span><span class="s3">=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">random_state</span><span class="s3">)</span>

    <span class="s5"># split should produce same and deterministic splits on</span>
    <span class="s5"># each call</span>
    <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">3</span><span class="s3">):</span>
        <span class="s1">splits </span><span class="s3">= </span><span class="s1">rkf</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">3</span><span class="s3">])</span>

        <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">3</span><span class="s3">])</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>

        <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">])</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>

        <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">])</span>

        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">StopIteration</span><span class="s3">):</span>
            <span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_get_n_splits_for_repeated_kfold</span><span class="s3">():</span>
    <span class="s1">n_splits </span><span class="s3">= </span><span class="s4">3</span>
    <span class="s1">n_repeats </span><span class="s3">= </span><span class="s4">4</span>
    <span class="s1">rkf </span><span class="s3">= </span><span class="s1">RepeatedKFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s1">n_splits</span><span class="s3">, </span><span class="s1">n_repeats</span><span class="s3">=</span><span class="s1">n_repeats</span><span class="s3">)</span>
    <span class="s1">expected_n_splits </span><span class="s3">= </span><span class="s1">n_splits </span><span class="s3">* </span><span class="s1">n_repeats</span>
    <span class="s2">assert </span><span class="s1">expected_n_splits </span><span class="s3">== </span><span class="s1">rkf</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">test_get_n_splits_for_repeated_stratified_kfold</span><span class="s3">():</span>
    <span class="s1">n_splits </span><span class="s3">= </span><span class="s4">3</span>
    <span class="s1">n_repeats </span><span class="s3">= </span><span class="s4">4</span>
    <span class="s1">rskf </span><span class="s3">= </span><span class="s1">RepeatedStratifiedKFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s1">n_splits</span><span class="s3">, </span><span class="s1">n_repeats</span><span class="s3">=</span><span class="s1">n_repeats</span><span class="s3">)</span>
    <span class="s1">expected_n_splits </span><span class="s3">= </span><span class="s1">n_splits </span><span class="s3">* </span><span class="s1">n_repeats</span>
    <span class="s2">assert </span><span class="s1">expected_n_splits </span><span class="s3">== </span><span class="s1">rskf</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">test_repeated_stratified_kfold_determinstic_split</span><span class="s3">():</span>
    <span class="s1">X </span><span class="s3">= [[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">], [</span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">], [</span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">], [</span><span class="s4">7</span><span class="s3">, </span><span class="s4">8</span><span class="s3">], [</span><span class="s4">9</span><span class="s3">, </span><span class="s4">10</span><span class="s3">]]</span>
    <span class="s1">y </span><span class="s3">= [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">]</span>
    <span class="s1">random_state </span><span class="s3">= </span><span class="s4">1944695409</span>
    <span class="s1">rskf </span><span class="s3">= </span><span class="s1">RepeatedStratifiedKFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">n_repeats</span><span class="s3">=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">random_state</span><span class="s3">)</span>

    <span class="s5"># split should produce same and deterministic splits on</span>
    <span class="s5"># each call</span>
    <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">3</span><span class="s3">):</span>
        <span class="s1">splits </span><span class="s3">= </span><span class="s1">rskf</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">])</span>

        <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">])</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>

        <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">])</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>

        <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">])</span>

        <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">StopIteration</span><span class="s3">):</span>
            <span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_train_test_split_errors</span><span class="s3">():</span>
    <span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">train_test_split</span><span class="s3">)</span>

    <span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">train_test_split</span><span class="s3">, </span><span class="s1">range</span><span class="s3">(</span><span class="s4">3</span><span class="s3">), </span><span class="s1">train_size</span><span class="s3">=</span><span class="s4">1.1</span><span class="s3">)</span>

    <span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">train_test_split</span><span class="s3">, </span><span class="s1">range</span><span class="s3">(</span><span class="s4">3</span><span class="s3">), </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">0.6</span><span class="s3">, </span><span class="s1">train_size</span><span class="s3">=</span><span class="s4">0.6</span><span class="s3">)</span>
    <span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span>
        <span class="s1">ValueError</span><span class="s3">,</span>
        <span class="s1">train_test_split</span><span class="s3">,</span>
        <span class="s1">range</span><span class="s3">(</span><span class="s4">3</span><span class="s3">),</span>
        <span class="s1">test_size</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">(</span><span class="s4">0.6</span><span class="s3">),</span>
        <span class="s1">train_size</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">(</span><span class="s4">0.6</span><span class="s3">),</span>
    <span class="s3">)</span>
    <span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">train_test_split</span><span class="s3">, </span><span class="s1">range</span><span class="s3">(</span><span class="s4">3</span><span class="s3">), </span><span class="s1">test_size</span><span class="s3">=</span><span class="s6">&quot;wrong_type&quot;</span><span class="s3">)</span>
    <span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">train_test_split</span><span class="s3">, </span><span class="s1">range</span><span class="s3">(</span><span class="s4">3</span><span class="s3">), </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">train_size</span><span class="s3">=</span><span class="s4">4</span><span class="s3">)</span>
    <span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">train_test_split</span><span class="s3">, </span><span class="s1">range</span><span class="s3">(</span><span class="s4">3</span><span class="s3">), </span><span class="s1">some_argument</span><span class="s3">=</span><span class="s4">1.1</span><span class="s3">)</span>
    <span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">train_test_split</span><span class="s3">, </span><span class="s1">range</span><span class="s3">(</span><span class="s4">3</span><span class="s3">), </span><span class="s1">range</span><span class="s3">(</span><span class="s4">42</span><span class="s3">))</span>
    <span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">train_test_split</span><span class="s3">, </span><span class="s1">range</span><span class="s3">(</span><span class="s4">10</span><span class="s3">), </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">stratify</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span>
        <span class="s1">ValueError</span><span class="s3">,</span>
        <span class="s1">match</span><span class="s3">=</span><span class="s6">r&quot;train_size=11 should be either positive and &quot;</span>
        <span class="s6">r&quot;smaller than the number of samples 10 or a &quot;</span>
        <span class="s6">r&quot;float in the \(0, 1\) range&quot;</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s4">10</span><span class="s3">), </span><span class="s1">train_size</span><span class="s3">=</span><span class="s4">11</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">1</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s6">&quot;train_size, exp_train, exp_test&quot;</span><span class="s3">, [(</span><span class="s2">None</span><span class="s3">, </span><span class="s4">7</span><span class="s3">, </span><span class="s4">3</span><span class="s3">), (</span><span class="s4">8</span><span class="s3">, </span><span class="s4">8</span><span class="s3">, </span><span class="s4">2</span><span class="s3">), (</span><span class="s4">0.8</span><span class="s3">, </span><span class="s4">8</span><span class="s3">, </span><span class="s4">2</span><span class="s3">)]</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_train_test_split_default_test_size</span><span class="s3">(</span><span class="s1">train_size</span><span class="s3">, </span><span class="s1">exp_train</span><span class="s3">, </span><span class="s1">exp_test</span><span class="s3">):</span>
    <span class="s5"># Check that the default value has the expected behavior, i.e. complement</span>
    <span class="s5"># train_size unless both are specified.</span>
    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_test </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">train_size</span><span class="s3">=</span><span class="s1">train_size</span><span class="s3">)</span>

    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">) == </span><span class="s1">exp_train</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">) == </span><span class="s1">exp_test</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s6">&quot;array_namespace, device, dtype_name&quot;</span><span class="s3">, </span><span class="s1">yield_namespace_device_dtype_combinations</span><span class="s3">()</span>
<span class="s3">)</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s6">&quot;shuffle,stratify&quot;</span><span class="s3">,</span>
    <span class="s3">(</span>
        <span class="s3">(</span><span class="s2">True</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s2">True</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">6</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">4</span><span class="s3">)))),</span>
        <span class="s5"># stratification only works with shuffling</span>
        <span class="s3">(</span><span class="s2">False</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
    <span class="s3">),</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_array_api_train_test_split</span><span class="s3">(</span>
    <span class="s1">shuffle</span><span class="s3">, </span><span class="s1">stratify</span><span class="s3">, </span><span class="s1">array_namespace</span><span class="s3">, </span><span class="s1">device</span><span class="s3">, </span><span class="s1">dtype_name</span>
<span class="s3">):</span>
    <span class="s1">xp </span><span class="s3">= </span><span class="s1">_array_api_for_tests</span><span class="s3">(</span><span class="s1">array_namespace</span><span class="s3">, </span><span class="s1">device</span><span class="s3">)</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">100</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">((</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s3">))</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>

    <span class="s1">X_np </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype_name</span><span class="s3">)</span>
    <span class="s1">X_xp </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">X_np</span><span class="s3">, </span><span class="s1">device</span><span class="s3">=</span><span class="s1">device</span><span class="s3">)</span>

    <span class="s1">y_np </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype_name</span><span class="s3">)</span>
    <span class="s1">y_xp </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y_np</span><span class="s3">, </span><span class="s1">device</span><span class="s3">=</span><span class="s1">device</span><span class="s3">)</span>

    <span class="s1">X_train_np</span><span class="s3">, </span><span class="s1">X_test_np</span><span class="s3">, </span><span class="s1">y_train_np</span><span class="s3">, </span><span class="s1">y_test_np </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span>
        <span class="s1">X_np</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s1">shuffle</span><span class="s3">, </span><span class="s1">stratify</span><span class="s3">=</span><span class="s1">stratify</span>
    <span class="s3">)</span>
    <span class="s2">with </span><span class="s1">config_context</span><span class="s3">(</span><span class="s1">array_api_dispatch</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">stratify </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">stratify_xp </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">stratify</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">stratify_xp </span><span class="s3">= </span><span class="s1">stratify</span>
        <span class="s1">X_train_xp</span><span class="s3">, </span><span class="s1">X_test_xp</span><span class="s3">, </span><span class="s1">y_train_xp</span><span class="s3">, </span><span class="s1">y_test_xp </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span>
            <span class="s1">X_xp</span><span class="s3">, </span><span class="s1">y_xp</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s1">shuffle</span><span class="s3">, </span><span class="s1">stratify</span><span class="s3">=</span><span class="s1">stratify_xp</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span>
        <span class="s3">)</span>

        <span class="s5"># Check that namespace is preserved, has to happen with</span>
        <span class="s5"># array_api_dispatch enabled.</span>
        <span class="s2">assert </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">X_train_xp</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">] == </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">X_xp</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s2">assert </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">X_test_xp</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">] == </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">X_xp</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s2">assert </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">y_train_xp</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">] == </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">y_xp</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s2">assert </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">y_test_xp</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">] == </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">y_xp</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">]</span>

    <span class="s5"># Check device and dtype is preserved on output</span>
    <span class="s2">assert </span><span class="s1">array_api_device</span><span class="s3">(</span><span class="s1">X_train_xp</span><span class="s3">) == </span><span class="s1">array_api_device</span><span class="s3">(</span><span class="s1">X_xp</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">array_api_device</span><span class="s3">(</span><span class="s1">y_train_xp</span><span class="s3">) == </span><span class="s1">array_api_device</span><span class="s3">(</span><span class="s1">y_xp</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">array_api_device</span><span class="s3">(</span><span class="s1">X_test_xp</span><span class="s3">) == </span><span class="s1">array_api_device</span><span class="s3">(</span><span class="s1">X_xp</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">array_api_device</span><span class="s3">(</span><span class="s1">y_test_xp</span><span class="s3">) == </span><span class="s1">array_api_device</span><span class="s3">(</span><span class="s1">y_xp</span><span class="s3">)</span>

    <span class="s2">assert </span><span class="s1">X_train_xp</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">X_xp</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s2">assert </span><span class="s1">y_train_xp</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">y_xp</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s2">assert </span><span class="s1">X_test_xp</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">X_xp</span><span class="s3">.</span><span class="s1">dtype</span>
    <span class="s2">assert </span><span class="s1">y_test_xp</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">y_xp</span><span class="s3">.</span><span class="s1">dtype</span>

    <span class="s1">assert_allclose</span><span class="s3">(</span>
        <span class="s1">_convert_to_numpy</span><span class="s3">(</span><span class="s1">X_train_xp</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">),</span>
        <span class="s1">X_train_np</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span>
        <span class="s1">_convert_to_numpy</span><span class="s3">(</span><span class="s1">X_test_xp</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">),</span>
        <span class="s1">X_test_np</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;coo_container&quot;</span><span class="s3">, </span><span class="s1">COO_CONTAINERS</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_train_test_split</span><span class="s3">(</span><span class="s1">coo_container</span><span class="s3">):</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">100</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">((</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s3">))</span>
    <span class="s1">X_s </span><span class="s3">= </span><span class="s1">coo_container</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>

    <span class="s5"># simple test</span>
    <span class="s1">split </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">train_size</span><span class="s3">=</span><span class="s4">0.5</span><span class="s3">)</span>
    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">y_test </span><span class="s3">= </span><span class="s1">split</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">y_test</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">y_train</span><span class="s3">)</span>
    <span class="s5"># test correspondence of X and y</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">[:, </span><span class="s4">0</span><span class="s3">], </span><span class="s1">y_train </span><span class="s3">* </span><span class="s4">10</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">[:, </span><span class="s4">0</span><span class="s3">], </span><span class="s1">y_test </span><span class="s3">* </span><span class="s4">10</span><span class="s3">)</span>

    <span class="s5"># don't convert lists to anything else by default</span>
    <span class="s1">split </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">X_s</span><span class="s3">, </span><span class="s1">y</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">())</span>
    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">X_s_train</span><span class="s3">, </span><span class="s1">X_s_test</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">y_test </span><span class="s3">= </span><span class="s1">split</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">list</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">y_test</span><span class="s3">, </span><span class="s1">list</span><span class="s3">)</span>

    <span class="s5"># allow nd-arrays</span>
    <span class="s1">X_4d </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10 </span><span class="s3">* </span><span class="s4">5 </span><span class="s3">* </span><span class="s4">3 </span><span class="s3">* </span><span class="s4">2</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">2</span><span class="s3">)</span>
    <span class="s1">y_3d </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10 </span><span class="s3">* </span><span class="s4">7 </span><span class="s3">* </span><span class="s4">11</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, </span><span class="s4">7</span><span class="s3">, </span><span class="s4">11</span><span class="s3">)</span>
    <span class="s1">split </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">X_4d</span><span class="s3">, </span><span class="s1">y_3d</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">split</span><span class="s3">[</span><span class="s4">0</span><span class="s3">].</span><span class="s1">shape </span><span class="s3">== (</span><span class="s4">7</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">2</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">split</span><span class="s3">[</span><span class="s4">1</span><span class="s3">].</span><span class="s1">shape </span><span class="s3">== (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">2</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">split</span><span class="s3">[</span><span class="s4">2</span><span class="s3">].</span><span class="s1">shape </span><span class="s3">== (</span><span class="s4">7</span><span class="s3">, </span><span class="s4">7</span><span class="s3">, </span><span class="s4">11</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">split</span><span class="s3">[</span><span class="s4">3</span><span class="s3">].</span><span class="s1">shape </span><span class="s3">== (</span><span class="s4">3</span><span class="s3">, </span><span class="s4">7</span><span class="s3">, </span><span class="s4">11</span><span class="s3">)</span>

    <span class="s5"># test stratification option</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">])</span>
    <span class="s2">for </span><span class="s1">test_size</span><span class="s3">, </span><span class="s1">exp_test_size </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">([</span><span class="s4">2</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">0.25</span><span class="s3">, </span><span class="s4">0.5</span><span class="s3">, </span><span class="s4">0.75</span><span class="s3">], [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">6</span><span class="s3">]):</span>
        <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span>
            <span class="s1">y</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s1">test_size</span><span class="s3">, </span><span class="s1">stratify</span><span class="s3">=</span><span class="s1">y</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span>
        <span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">test</span><span class="s3">) == </span><span class="s1">exp_test_size</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">test</span><span class="s3">) + </span><span class="s1">len</span><span class="s3">(</span><span class="s1">train</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
        <span class="s5"># check the 1:1 ratio of ones and twos in the data is preserved</span>
        <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">train </span><span class="s3">== </span><span class="s4">1</span><span class="s3">) == </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">train </span><span class="s3">== </span><span class="s4">2</span><span class="s3">)</span>

    <span class="s5"># test unshuffled split</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">10</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">test_size </span><span class="s2">in </span><span class="s3">[</span><span class="s4">2</span><span class="s3">, </span><span class="s4">0.2</span><span class="s3">]:</span>
        <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s1">test_size</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">8</span><span class="s3">, </span><span class="s4">9</span><span class="s3">])</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">, </span><span class="s4">7</span><span class="s3">])</span>


<span class="s2">def </span><span class="s1">test_train_test_split_32bit_overflow</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Check for integer overflow on 32-bit platforms. 
 
    Non-regression test for: 
    https://github.com/scikit-learn/scikit-learn/issues/20774 
    &quot;&quot;&quot;</span>

    <span class="s5"># A number 'n' big enough for expression 'n * n * train_size' to cause</span>
    <span class="s5"># an overflow for signed 32-bit integer</span>
    <span class="s1">big_number </span><span class="s3">= </span><span class="s4">100000</span>

    <span class="s5"># Definition of 'y' is a part of reproduction - population for at least</span>
    <span class="s5"># one class should be in the same order of magnitude as size of X</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">big_number</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">X </span><span class="s3">&gt; (</span><span class="s4">0.99 </span><span class="s3">* </span><span class="s1">big_number</span><span class="s3">)</span>

    <span class="s1">split </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">stratify</span><span class="s3">=</span><span class="s1">y</span><span class="s3">, </span><span class="s1">train_size</span><span class="s3">=</span><span class="s4">0.25</span><span class="s3">)</span>
    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">y_test </span><span class="s3">= </span><span class="s1">split</span>

    <span class="s2">assert </span><span class="s1">X_train</span><span class="s3">.</span><span class="s1">size </span><span class="s3">+ </span><span class="s1">X_test</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s1">big_number</span>
    <span class="s2">assert </span><span class="s1">y_train</span><span class="s3">.</span><span class="s1">size </span><span class="s3">+ </span><span class="s1">y_test</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s1">big_number</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">test_train_test_split_pandas</span><span class="s3">():</span>
    <span class="s5"># check train_test_split doesn't destroy pandas dataframe</span>
    <span class="s1">types </span><span class="s3">= [</span><span class="s1">MockDataFrame</span><span class="s3">]</span>
    <span class="s2">try</span><span class="s3">:</span>
        <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">DataFrame</span>

        <span class="s1">types</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">DataFrame</span><span class="s3">)</span>
    <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
        <span class="s2">pass</span>
    <span class="s2">for </span><span class="s1">InputFeatureType </span><span class="s2">in </span><span class="s1">types</span><span class="s3">:</span>
        <span class="s5"># X dataframe</span>
        <span class="s1">X_df </span><span class="s3">= </span><span class="s1">InputFeatureType</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_test </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">X_df</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">InputFeatureType</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">InputFeatureType</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s6">&quot;sparse_container&quot;</span><span class="s3">, </span><span class="s1">COO_CONTAINERS </span><span class="s3">+ </span><span class="s1">CSC_CONTAINERS </span><span class="s3">+ </span><span class="s1">CSR_CONTAINERS</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_train_test_split_sparse</span><span class="s3">(</span><span class="s1">sparse_container</span><span class="s3">):</span>
    <span class="s5"># check that train_test_split converts scipy sparse matrices</span>
    <span class="s5"># to csr, as stated in the documentation</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">100</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">((</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s3">))</span>
    <span class="s1">X_s </span><span class="s3">= </span><span class="s1">sparse_container</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_test </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">X_s</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">) </span><span class="s2">and </span><span class="s1">X_train</span><span class="s3">.</span><span class="s1">format </span><span class="s3">== </span><span class="s6">&quot;csr&quot;</span>
    <span class="s2">assert </span><span class="s1">issparse</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">) </span><span class="s2">and </span><span class="s1">X_test</span><span class="s3">.</span><span class="s1">format </span><span class="s3">== </span><span class="s6">&quot;csr&quot;</span>


<span class="s2">def </span><span class="s1">test_train_test_split_mock_pandas</span><span class="s3">():</span>
    <span class="s5"># X mock dataframe</span>
    <span class="s1">X_df </span><span class="s3">= </span><span class="s1">MockDataFrame</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">X_test </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">X_df</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">MockDataFrame</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">MockDataFrame</span><span class="s3">)</span>
    <span class="s1">X_train_arr</span><span class="s3">, </span><span class="s1">X_test_arr </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">X_df</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_train_test_split_list_input</span><span class="s3">():</span>
    <span class="s5"># Check that when y is a list / list of string labels, it works.</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">7</span><span class="s3">)</span>
    <span class="s1">y1 </span><span class="s3">= [</span><span class="s6">&quot;1&quot;</span><span class="s3">] * </span><span class="s4">4 </span><span class="s3">+ [</span><span class="s6">&quot;0&quot;</span><span class="s3">] * </span><span class="s4">3</span>
    <span class="s1">y2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">4</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">3</span><span class="s3">)))</span>
    <span class="s1">y3 </span><span class="s3">= </span><span class="s1">y2</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">()</span>

    <span class="s2">for </span><span class="s1">stratify </span><span class="s2">in </span><span class="s3">(</span><span class="s2">True</span><span class="s3">, </span><span class="s2">False</span><span class="s3">):</span>
        <span class="s1">X_train1</span><span class="s3">, </span><span class="s1">X_test1</span><span class="s3">, </span><span class="s1">y_train1</span><span class="s3">, </span><span class="s1">y_test1 </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">y1</span><span class="s3">, </span><span class="s1">stratify</span><span class="s3">=</span><span class="s1">y1 </span><span class="s2">if </span><span class="s1">stratify </span><span class="s2">else None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span>
        <span class="s3">)</span>
        <span class="s1">X_train2</span><span class="s3">, </span><span class="s1">X_test2</span><span class="s3">, </span><span class="s1">y_train2</span><span class="s3">, </span><span class="s1">y_test2 </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">y2</span><span class="s3">, </span><span class="s1">stratify</span><span class="s3">=</span><span class="s1">y2 </span><span class="s2">if </span><span class="s1">stratify </span><span class="s2">else None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span>
        <span class="s3">)</span>
        <span class="s1">X_train3</span><span class="s3">, </span><span class="s1">X_test3</span><span class="s3">, </span><span class="s1">y_train3</span><span class="s3">, </span><span class="s1">y_test3 </span><span class="s3">= </span><span class="s1">train_test_split</span><span class="s3">(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">y3</span><span class="s3">, </span><span class="s1">stratify</span><span class="s3">=</span><span class="s1">y3 </span><span class="s2">if </span><span class="s1">stratify </span><span class="s2">else None</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span>
        <span class="s3">)</span>

        <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">X_train1</span><span class="s3">, </span><span class="s1">X_train2</span><span class="s3">)</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">y_train2</span><span class="s3">, </span><span class="s1">y_train3</span><span class="s3">)</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">X_test1</span><span class="s3">, </span><span class="s1">X_test3</span><span class="s3">)</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">y_test3</span><span class="s3">, </span><span class="s1">y_test2</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s6">&quot;test_size, train_size&quot;</span><span class="s3">,</span>
    <span class="s3">[(</span><span class="s4">2.0</span><span class="s3">, </span><span class="s2">None</span><span class="s3">), (</span><span class="s4">1.0</span><span class="s3">, </span><span class="s2">None</span><span class="s3">), (</span><span class="s4">0.1</span><span class="s3">, </span><span class="s4">0.95</span><span class="s3">), (</span><span class="s2">None</span><span class="s3">, </span><span class="s4">1j</span><span class="s3">), (</span><span class="s4">11</span><span class="s3">, </span><span class="s2">None</span><span class="s3">), (</span><span class="s4">10</span><span class="s3">, </span><span class="s2">None</span><span class="s3">), (</span><span class="s4">8</span><span class="s3">, </span><span class="s4">3</span><span class="s3">)],</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_shufflesplit_errors</span><span class="s3">(</span><span class="s1">test_size</span><span class="s3">, </span><span class="s1">train_size</span><span class="s3">):</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">ShuffleSplit</span><span class="s3">(</span><span class="s1">test_size</span><span class="s3">=</span><span class="s1">test_size</span><span class="s3">, </span><span class="s1">train_size</span><span class="s3">=</span><span class="s1">train_size</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_shufflesplit_reproducible</span><span class="s3">():</span>
    <span class="s5"># Check that iterating twice on the ShuffleSplit gives the same</span>
    <span class="s5"># sequence of train-test when the random_state is given</span>
    <span class="s1">ss </span><span class="s3">= </span><span class="s1">ShuffleSplit</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">21</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">([</span><span class="s1">a </span><span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">ss</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)], [</span><span class="s1">a </span><span class="s2">for </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b </span><span class="s2">in </span><span class="s1">ss</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)])</span>


<span class="s2">def </span><span class="s1">test_stratifiedshufflesplit_list_input</span><span class="s3">():</span>
    <span class="s5"># Check that when y is a list / list of string labels, it works.</span>
    <span class="s1">sss </span><span class="s3">= </span><span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">42</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">7</span><span class="s3">)</span>
    <span class="s1">y1 </span><span class="s3">= [</span><span class="s6">&quot;1&quot;</span><span class="s3">] * </span><span class="s4">4 </span><span class="s3">+ [</span><span class="s6">&quot;0&quot;</span><span class="s3">] * </span><span class="s4">3</span>
    <span class="s1">y2 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">4</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">3</span><span class="s3">)))</span>
    <span class="s1">y3 </span><span class="s3">= </span><span class="s1">y2</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">()</span>

    <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">list</span><span class="s3">(</span><span class="s1">sss</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y1</span><span class="s3">)), </span><span class="s1">list</span><span class="s3">(</span><span class="s1">sss</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y2</span><span class="s3">)))</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">list</span><span class="s3">(</span><span class="s1">sss</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y3</span><span class="s3">)), </span><span class="s1">list</span><span class="s3">(</span><span class="s1">sss</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y2</span><span class="s3">)))</span>


<span class="s2">def </span><span class="s1">test_train_test_split_allow_nans</span><span class="s3">():</span>
    <span class="s5"># Check that train_test_split allows input data with NaNs</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">200</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s4">10</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">X</span><span class="s3">[</span><span class="s4">2</span><span class="s3">, :] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">repeat</span><span class="s3">([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">], </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] / </span><span class="s4">2</span><span class="s3">)</span>
    <span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">0.2</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">42</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_check_cv</span><span class="s3">():</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">9</span><span class="s3">)</span>
    <span class="s1">cv </span><span class="s3">= </span><span class="s1">check_cv</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">classifier</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s5"># Use numpy.testing.assert_equal which recursively compares</span>
    <span class="s5"># lists of lists</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">list</span><span class="s3">(</span><span class="s1">KFold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)), </span><span class="s1">list</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)))</span>

    <span class="s1">y_binary </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">])</span>
    <span class="s1">cv </span><span class="s3">= </span><span class="s1">check_cv</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">y_binary</span><span class="s3">, </span><span class="s1">classifier</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span>
        <span class="s1">list</span><span class="s3">(</span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_binary</span><span class="s3">)), </span><span class="s1">list</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_binary</span><span class="s3">))</span>
    <span class="s3">)</span>

    <span class="s1">y_multiclass </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">2</span><span class="s3">])</span>
    <span class="s1">cv </span><span class="s3">= </span><span class="s1">check_cv</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">y_multiclass</span><span class="s3">, </span><span class="s1">classifier</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span>
        <span class="s1">list</span><span class="s3">(</span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_multiclass</span><span class="s3">)), </span><span class="s1">list</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_multiclass</span><span class="s3">))</span>
    <span class="s3">)</span>
    <span class="s5"># also works with 2d multiclass</span>
    <span class="s1">y_multiclass_2d </span><span class="s3">= </span><span class="s1">y_multiclass</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(-</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">cv </span><span class="s3">= </span><span class="s1">check_cv</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">y_multiclass_2d</span><span class="s3">, </span><span class="s1">classifier</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span>
        <span class="s1">list</span><span class="s3">(</span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_multiclass_2d</span><span class="s3">)),</span>
        <span class="s1">list</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_multiclass_2d</span><span class="s3">)),</span>
    <span class="s3">)</span>

    <span class="s2">assert not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_multiclass_2d</span><span class="s3">))[</span><span class="s4">0</span><span class="s3">]</span>
        <span class="s3">== </span><span class="s1">next</span><span class="s3">(</span><span class="s1">KFold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y_multiclass_2d</span><span class="s3">))[</span><span class="s4">0</span><span class="s3">]</span>
    <span class="s3">)</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s4">5</span><span class="s3">)</span>
    <span class="s1">y_multilabel </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
        <span class="s3">[[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">], [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">], [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">]]</span>
    <span class="s3">)</span>
    <span class="s1">cv </span><span class="s3">= </span><span class="s1">check_cv</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">y_multilabel</span><span class="s3">, </span><span class="s1">classifier</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">list</span><span class="s3">(</span><span class="s1">KFold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)), </span><span class="s1">list</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)))</span>

    <span class="s1">y_multioutput </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">], [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">3</span><span class="s3">], [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">], [</span><span class="s4">3</span><span class="s3">, </span><span class="s4">1</span><span class="s3">], [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">0</span><span class="s3">]])</span>
    <span class="s1">cv </span><span class="s3">= </span><span class="s1">check_cv</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">y_multioutput</span><span class="s3">, </span><span class="s1">classifier</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">list</span><span class="s3">(</span><span class="s1">KFold</span><span class="s3">(</span><span class="s4">3</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)), </span><span class="s1">list</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)))</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s1">check_cv</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">=</span><span class="s6">&quot;lolo&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_cv_iterable_wrapper</span><span class="s3">():</span>
    <span class="s1">kf_iter </span><span class="s3">= </span><span class="s1">KFold</span><span class="s3">().</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">kf_iter_wrapped </span><span class="s3">= </span><span class="s1">check_cv</span><span class="s3">(</span><span class="s1">kf_iter</span><span class="s3">)</span>
    <span class="s5"># Since the wrapped iterable is enlisted and stored,</span>
    <span class="s5"># split can be called any number of times to produce</span>
    <span class="s5"># consistent results.</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span>
        <span class="s1">list</span><span class="s3">(</span><span class="s1">kf_iter_wrapped</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)), </span><span class="s1">list</span><span class="s3">(</span><span class="s1">kf_iter_wrapped</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>
    <span class="s3">)</span>
    <span class="s5"># If the splits are randomized, successive calls to split yields different</span>
    <span class="s5"># results</span>
    <span class="s1">kf_randomized_iter </span><span class="s3">= </span><span class="s1">KFold</span><span class="s3">(</span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">kf_randomized_iter_wrapped </span><span class="s3">= </span><span class="s1">check_cv</span><span class="s3">(</span><span class="s1">kf_randomized_iter</span><span class="s3">)</span>
    <span class="s5"># numpy's assert_array_equal properly compares nested lists</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span>
        <span class="s1">list</span><span class="s3">(</span><span class="s1">kf_randomized_iter_wrapped</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)),</span>
        <span class="s1">list</span><span class="s3">(</span><span class="s1">kf_randomized_iter_wrapped</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)),</span>
    <span class="s3">)</span>

    <span class="s2">try</span><span class="s3">:</span>
        <span class="s1">splits_are_equal </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s1">np</span><span class="s3">.</span><span class="s1">testing</span><span class="s3">.</span><span class="s1">assert_equal</span><span class="s3">(</span>
            <span class="s1">list</span><span class="s3">(</span><span class="s1">kf_iter_wrapped</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)),</span>
            <span class="s1">list</span><span class="s3">(</span><span class="s1">kf_randomized_iter_wrapped</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)),</span>
        <span class="s3">)</span>
    <span class="s2">except </span><span class="s1">AssertionError</span><span class="s3">:</span>
        <span class="s1">splits_are_equal </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s2">assert not </span><span class="s1">splits_are_equal</span><span class="s3">, (</span>
        <span class="s6">&quot;If the splits are randomized, &quot;</span>
        <span class="s6">&quot;successive calls to split should yield different results&quot;</span>
    <span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;kfold&quot;</span><span class="s3">, [</span><span class="s1">GroupKFold</span><span class="s3">, </span><span class="s1">StratifiedGroupKFold</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_group_kfold</span><span class="s3">(</span><span class="s1">kfold</span><span class="s3">):</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>

    <span class="s5"># Parameters of the test</span>
    <span class="s1">n_groups </span><span class="s3">= </span><span class="s4">15</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s4">1000</span>
    <span class="s1">n_splits </span><span class="s3">= </span><span class="s4">5</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">)</span>

    <span class="s5"># Construct the test data</span>
    <span class="s1">tolerance </span><span class="s3">= </span><span class="s4">0.05 </span><span class="s3">* </span><span class="s1">n_samples  </span><span class="s5"># 5 percent error allowed</span>
    <span class="s1">groups </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">n_groups</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">)</span>

    <span class="s1">ideal_n_groups_per_fold </span><span class="s3">= </span><span class="s1">n_samples </span><span class="s3">// </span><span class="s1">n_splits</span>

    <span class="s1">len</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">))</span>
    <span class="s5"># Get the test fold indices from the test set indices of each fold</span>
    <span class="s1">folds </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s1">lkf </span><span class="s3">= </span><span class="s1">kfold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s1">n_splits</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s3">, (</span><span class="s1">_</span><span class="s3">, </span><span class="s1">test</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">lkf</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">)):</span>
        <span class="s1">folds</span><span class="s3">[</span><span class="s1">test</span><span class="s3">] = </span><span class="s1">i</span>

    <span class="s5"># Check that folds have approximately the same size</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">folds</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">folds</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">tolerance </span><span class="s3">&gt;= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">folds </span><span class="s3">== </span><span class="s1">i</span><span class="s3">) - </span><span class="s1">ideal_n_groups_per_fold</span><span class="s3">)</span>

    <span class="s5"># Check that each group appears only in 1 fold</span>
    <span class="s2">for </span><span class="s1">group </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">folds</span><span class="s3">[</span><span class="s1">groups </span><span class="s3">== </span><span class="s1">group</span><span class="s3">])) == </span><span class="s4">1</span>

    <span class="s5"># Check that no group is on both sides of the split</span>
    <span class="s1">groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">lkf</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intersect1d</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">[</span><span class="s1">train</span><span class="s3">], </span><span class="s1">groups</span><span class="s3">[</span><span class="s1">test</span><span class="s3">])) == </span><span class="s4">0</span>

    <span class="s5"># Construct the test data</span>
    <span class="s1">groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
        <span class="s3">[</span>
            <span class="s6">&quot;Albert&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Jean&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Bertrand&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Michel&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Jean&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Francis&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Robert&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Michel&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Rachel&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Lois&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Michelle&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Bernard&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Marion&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Laura&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Jean&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Rachel&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Franck&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;John&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Gael&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Anna&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Alix&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Robert&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Marion&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;David&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Tony&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Abel&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Becky&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Madmood&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Cary&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Mary&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Alexandre&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;David&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Francis&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Barack&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Abdoul&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Rasha&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Xi&quot;</span><span class="s3">,</span>
            <span class="s6">&quot;Silvia&quot;</span><span class="s3">,</span>
        <span class="s3">]</span>
    <span class="s3">)</span>

    <span class="s1">n_groups </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">))</span>
    <span class="s1">n_samples </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">)</span>
    <span class="s1">n_splits </span><span class="s3">= </span><span class="s4">5</span>
    <span class="s1">tolerance </span><span class="s3">= </span><span class="s4">0.05 </span><span class="s3">* </span><span class="s1">n_samples  </span><span class="s5"># 5 percent error allowed</span>
    <span class="s1">ideal_n_groups_per_fold </span><span class="s3">= </span><span class="s1">n_samples </span><span class="s3">// </span><span class="s1">n_splits</span>

    <span class="s1">X </span><span class="s3">= </span><span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">)</span>

    <span class="s5"># Get the test fold indices from the test set indices of each fold</span>
    <span class="s1">folds </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s3">, (</span><span class="s1">_</span><span class="s3">, </span><span class="s1">test</span><span class="s3">) </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">lkf</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">)):</span>
        <span class="s1">folds</span><span class="s3">[</span><span class="s1">test</span><span class="s3">] = </span><span class="s1">i</span>

    <span class="s5"># Check that folds have approximately the same size</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">folds</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">folds</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">tolerance </span><span class="s3">&gt;= </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">folds </span><span class="s3">== </span><span class="s1">i</span><span class="s3">) - </span><span class="s1">ideal_n_groups_per_fold</span><span class="s3">)</span>

    <span class="s5"># Check that each group appears only in 1 fold</span>
    <span class="s2">with </span><span class="s1">warnings</span><span class="s3">.</span><span class="s1">catch_warnings</span><span class="s3">():</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">simplefilter</span><span class="s3">(</span><span class="s6">&quot;ignore&quot;</span><span class="s3">, </span><span class="s1">FutureWarning</span><span class="s3">)</span>
        <span class="s2">for </span><span class="s1">group </span><span class="s2">in </span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">):</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">folds</span><span class="s3">[</span><span class="s1">groups </span><span class="s3">== </span><span class="s1">group</span><span class="s3">])) == </span><span class="s4">1</span>

    <span class="s5"># Check that no group is on both sides of the split</span>
    <span class="s1">groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">object</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s2">in </span><span class="s1">lkf</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">intersect1d</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">[</span><span class="s1">train</span><span class="s3">], </span><span class="s1">groups</span><span class="s3">[</span><span class="s1">test</span><span class="s3">])) == </span><span class="s4">0</span>

    <span class="s5"># groups can also be a list</span>
    <span class="s1">cv_iter </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">lkf</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">()))</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">train1</span><span class="s3">, </span><span class="s1">test1</span><span class="s3">), (</span><span class="s1">train2</span><span class="s3">, </span><span class="s1">test2</span><span class="s3">) </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">lkf</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">), </span><span class="s1">cv_iter</span><span class="s3">):</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train1</span><span class="s3">, </span><span class="s1">train2</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test1</span><span class="s3">, </span><span class="s1">test2</span><span class="s3">)</span>

    <span class="s5"># Should fail if there are more folds than groups</span>
    <span class="s1">groups </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">])</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">groups</span><span class="s3">))</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Cannot have number of splits.*greater&quot;</span><span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">GroupKFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">3</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_time_series_cv</span><span class="s3">():</span>
    <span class="s1">X </span><span class="s3">= [[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">], [</span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">], [</span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">], [</span><span class="s4">7</span><span class="s3">, </span><span class="s4">8</span><span class="s3">], [</span><span class="s4">9</span><span class="s3">, </span><span class="s4">10</span><span class="s3">], [</span><span class="s4">11</span><span class="s3">, </span><span class="s4">12</span><span class="s3">], [</span><span class="s4">13</span><span class="s3">, </span><span class="s4">14</span><span class="s3">]]</span>

    <span class="s5"># Should fail if there are more folds than samples</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Cannot have number of folds.*greater&quot;</span><span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">TimeSeriesSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">7</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">))</span>

    <span class="s1">tscv </span><span class="s3">= </span><span class="s1">TimeSeriesSplit</span><span class="s3">(</span><span class="s4">2</span><span class="s3">)</span>

    <span class="s5"># Manually check that Time Series CV preserves the data</span>
    <span class="s5"># ordering on toy datasets</span>
    <span class="s1">splits </span><span class="s3">= </span><span class="s1">tscv</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">[:-</span><span class="s4">1</span><span class="s3">])</span>
    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">])</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">])</span>

    <span class="s1">splits </span><span class="s3">= </span><span class="s1">TimeSeriesSplit</span><span class="s3">(</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">])</span>

    <span class="s5"># Check get_n_splits returns the correct number of splits</span>
    <span class="s1">splits </span><span class="s3">= </span><span class="s1">TimeSeriesSplit</span><span class="s3">(</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">n_splits_actual </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">list</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">))</span>
    <span class="s2">assert </span><span class="s1">n_splits_actual </span><span class="s3">== </span><span class="s1">tscv</span><span class="s3">.</span><span class="s1">get_n_splits</span><span class="s3">()</span>
    <span class="s2">assert </span><span class="s1">n_splits_actual </span><span class="s3">== </span><span class="s4">2</span>


<span class="s2">def </span><span class="s1">_check_time_series_max_train_size</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">, </span><span class="s1">check_splits</span><span class="s3">, </span><span class="s1">max_train_size</span><span class="s3">):</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span><span class="s3">), (</span><span class="s1">check_train</span><span class="s3">, </span><span class="s1">check_test</span><span class="s3">) </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">, </span><span class="s1">check_splits</span><span class="s3">):</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, </span><span class="s1">check_test</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">check_train</span><span class="s3">) &lt;= </span><span class="s1">max_train_size</span>
        <span class="s1">suffix_start </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">train</span><span class="s3">) - </span><span class="s1">max_train_size</span><span class="s3">, </span><span class="s4">0</span><span class="s3">)</span>
        <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">check_train</span><span class="s3">, </span><span class="s1">train</span><span class="s3">[</span><span class="s1">suffix_start</span><span class="s3">:])</span>


<span class="s2">def </span><span class="s1">test_time_series_max_train_size</span><span class="s3">():</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s4">6</span><span class="s3">, </span><span class="s4">1</span><span class="s3">))</span>
    <span class="s1">splits </span><span class="s3">= </span><span class="s1">TimeSeriesSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">3</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">check_splits </span><span class="s3">= </span><span class="s1">TimeSeriesSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">3</span><span class="s3">, </span><span class="s1">max_train_size</span><span class="s3">=</span><span class="s4">3</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">_check_time_series_max_train_size</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">, </span><span class="s1">check_splits</span><span class="s3">, </span><span class="s1">max_train_size</span><span class="s3">=</span><span class="s4">3</span><span class="s3">)</span>

    <span class="s5"># Test for the case where the size of a fold is greater than max_train_size</span>
    <span class="s1">check_splits </span><span class="s3">= </span><span class="s1">TimeSeriesSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">3</span><span class="s3">, </span><span class="s1">max_train_size</span><span class="s3">=</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">_check_time_series_max_train_size</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">, </span><span class="s1">check_splits</span><span class="s3">, </span><span class="s1">max_train_size</span><span class="s3">=</span><span class="s4">2</span><span class="s3">)</span>

    <span class="s5"># Test for the case where the size of each fold is less than max_train_size</span>
    <span class="s1">check_splits </span><span class="s3">= </span><span class="s1">TimeSeriesSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">3</span><span class="s3">, </span><span class="s1">max_train_size</span><span class="s3">=</span><span class="s4">5</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
    <span class="s1">_check_time_series_max_train_size</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">, </span><span class="s1">check_splits</span><span class="s3">, </span><span class="s1">max_train_size</span><span class="s3">=</span><span class="s4">2</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_time_series_test_size</span><span class="s3">():</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s4">10</span><span class="s3">, </span><span class="s4">1</span><span class="s3">))</span>

    <span class="s5"># Test alone</span>
    <span class="s1">splits </span><span class="s3">= </span><span class="s1">TimeSeriesSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">3</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">3</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">])</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">])</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">7</span><span class="s3">, </span><span class="s4">8</span><span class="s3">, </span><span class="s4">9</span><span class="s3">])</span>

    <span class="s5"># Test with max_train_size</span>
    <span class="s1">splits </span><span class="s3">= </span><span class="s1">TimeSeriesSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">max_train_size</span><span class="s3">=</span><span class="s4">4</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">6</span><span class="s3">, </span><span class="s4">7</span><span class="s3">])</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">, </span><span class="s4">7</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">8</span><span class="s3">, </span><span class="s4">9</span><span class="s3">])</span>

    <span class="s5"># Should fail with not enough data points for configuration</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Too many splits.*with test_size&quot;</span><span class="s3">):</span>
        <span class="s1">splits </span><span class="s3">= </span><span class="s1">TimeSeriesSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">5</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_time_series_gap</span><span class="s3">():</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s4">10</span><span class="s3">, </span><span class="s4">1</span><span class="s3">))</span>

    <span class="s5"># Test alone</span>
    <span class="s1">splits </span><span class="s3">= </span><span class="s1">TimeSeriesSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">gap</span><span class="s3">=</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">])</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">7</span><span class="s3">, </span><span class="s4">8</span><span class="s3">, </span><span class="s4">9</span><span class="s3">])</span>

    <span class="s5"># Test with max_train_size</span>
    <span class="s1">splits </span><span class="s3">= </span><span class="s1">TimeSeriesSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">3</span><span class="s3">, </span><span class="s1">gap</span><span class="s3">=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">max_train_size</span><span class="s3">=</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">])</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">6</span><span class="s3">, </span><span class="s4">7</span><span class="s3">])</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">8</span><span class="s3">, </span><span class="s4">9</span><span class="s3">])</span>

    <span class="s5"># Test with test_size</span>
    <span class="s1">splits </span><span class="s3">= </span><span class="s1">TimeSeriesSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">gap</span><span class="s3">=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">max_train_size</span><span class="s3">=</span><span class="s4">4</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">6</span><span class="s3">, </span><span class="s4">7</span><span class="s3">])</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">8</span><span class="s3">, </span><span class="s4">9</span><span class="s3">])</span>

    <span class="s5"># Test with additional test_size</span>
    <span class="s1">splits </span><span class="s3">= </span><span class="s1">TimeSeriesSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">gap</span><span class="s3">=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">3</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">])</span>

    <span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">train</span><span class="s3">, [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">])</span>
    <span class="s1">assert_array_equal</span><span class="s3">(</span><span class="s1">test</span><span class="s3">, [</span><span class="s4">7</span><span class="s3">, </span><span class="s4">8</span><span class="s3">, </span><span class="s4">9</span><span class="s3">])</span>

    <span class="s5"># Verify proper error is thrown</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Too many splits.*and gap&quot;</span><span class="s3">):</span>
        <span class="s1">splits </span><span class="s3">= </span><span class="s1">TimeSeriesSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">4</span><span class="s3">, </span><span class="s1">gap</span><span class="s3">=</span><span class="s4">2</span><span class="s3">).</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">splits</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">ignore_warnings</span>
<span class="s2">def </span><span class="s1">test_nested_cv</span><span class="s3">():</span>
    <span class="s5"># Test if nested cross validation works with different combinations of cv</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)</span>

    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">make_classification</span><span class="s3">(</span><span class="s1">n_samples</span><span class="s3">=</span><span class="s4">15</span><span class="s3">, </span><span class="s1">n_classes</span><span class="s3">=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">groups </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">15</span><span class="s3">)</span>

    <span class="s1">cvs </span><span class="s3">= [</span>
        <span class="s1">LeaveOneGroupOut</span><span class="s3">(),</span>
        <span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">2</span><span class="s3">),</span>
        <span class="s1">LeaveOneOut</span><span class="s3">(),</span>
        <span class="s1">GroupKFold</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">3</span><span class="s3">),</span>
        <span class="s1">StratifiedKFold</span><span class="s3">(),</span>
        <span class="s1">StratifiedGroupKFold</span><span class="s3">(),</span>
        <span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span><span class="s1">n_splits</span><span class="s3">=</span><span class="s4">3</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">),</span>
    <span class="s3">]</span>

    <span class="s2">for </span><span class="s1">inner_cv</span><span class="s3">, </span><span class="s1">outer_cv </span><span class="s2">in </span><span class="s1">combinations_with_replacement</span><span class="s3">(</span><span class="s1">cvs</span><span class="s3">, </span><span class="s4">2</span><span class="s3">):</span>
        <span class="s1">gs </span><span class="s3">= </span><span class="s1">GridSearchCV</span><span class="s3">(</span>
            <span class="s1">DummyClassifier</span><span class="s3">(),</span>
            <span class="s1">param_grid</span><span class="s3">={</span><span class="s6">&quot;strategy&quot;</span><span class="s3">: [</span><span class="s6">&quot;stratified&quot;</span><span class="s3">, </span><span class="s6">&quot;most_frequent&quot;</span><span class="s3">]},</span>
            <span class="s1">cv</span><span class="s3">=</span><span class="s1">inner_cv</span><span class="s3">,</span>
            <span class="s1">error_score</span><span class="s3">=</span><span class="s6">&quot;raise&quot;</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s1">cross_val_score</span><span class="s3">(</span>
            <span class="s1">gs</span><span class="s3">, </span><span class="s1">X</span><span class="s3">=</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">=</span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups</span><span class="s3">, </span><span class="s1">cv</span><span class="s3">=</span><span class="s1">outer_cv</span><span class="s3">, </span><span class="s1">params</span><span class="s3">={</span><span class="s6">&quot;groups&quot;</span><span class="s3">: </span><span class="s1">groups</span><span class="s3">}</span>
        <span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_build_repr</span><span class="s3">():</span>
    <span class="s2">class </span><span class="s1">MockSplitter</span><span class="s3">:</span>
        <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">c</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">a </span><span class="s3">= </span><span class="s1">a</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">b </span><span class="s3">= </span><span class="s1">b</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">c </span><span class="s3">= </span><span class="s1">c</span>

        <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">_build_repr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">assert </span><span class="s1">repr</span><span class="s3">(</span><span class="s1">MockSplitter</span><span class="s3">(</span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">)) == </span><span class="s6">&quot;MockSplitter(a=5, b=6, c=None)&quot;</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s6">&quot;CVSplitter&quot;</span><span class="s3">, (</span><span class="s1">ShuffleSplit</span><span class="s3">, </span><span class="s1">GroupShuffleSplit</span><span class="s3">, </span><span class="s1">StratifiedShuffleSplit</span><span class="s3">)</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_shuffle_split_empty_trainset</span><span class="s3">(</span><span class="s1">CVSplitter</span><span class="s3">):</span>
    <span class="s1">cv </span><span class="s3">= </span><span class="s1">CVSplitter</span><span class="s3">(</span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">0.99</span><span class="s3">)</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= [[</span><span class="s4">1</span><span class="s3">]], [</span><span class="s4">0</span><span class="s3">]  </span><span class="s5"># 1 sample</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span>
        <span class="s1">ValueError</span><span class="s3">,</span>
        <span class="s1">match</span><span class="s3">=(</span>
            <span class="s6">&quot;With n_samples=1, test_size=0.99 and train_size=None, &quot;</span>
            <span class="s6">&quot;the resulting train set will be empty&quot;</span>
        <span class="s3">),</span>
    <span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">_split</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=[</span><span class="s4">1</span><span class="s3">]))</span>


<span class="s2">def </span><span class="s1">test_train_test_split_empty_trainset</span><span class="s3">():</span>
    <span class="s3">(</span><span class="s1">X</span><span class="s3">,) = [[</span><span class="s4">1</span><span class="s3">]]  </span><span class="s5"># 1 sample</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span>
        <span class="s1">ValueError</span><span class="s3">,</span>
        <span class="s1">match</span><span class="s3">=(</span>
            <span class="s6">&quot;With n_samples=1, test_size=0.99 and train_size=None, &quot;</span>
            <span class="s6">&quot;the resulting train set will be empty&quot;</span>
        <span class="s3">),</span>
    <span class="s3">):</span>
        <span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">0.99</span><span class="s3">)</span>

    <span class="s1">X </span><span class="s3">= [[</span><span class="s4">1</span><span class="s3">], [</span><span class="s4">1</span><span class="s3">], [</span><span class="s4">1</span><span class="s3">]]  </span><span class="s5"># 3 samples, ask for more than 2 thirds</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span>
        <span class="s1">ValueError</span><span class="s3">,</span>
        <span class="s1">match</span><span class="s3">=(</span>
            <span class="s6">&quot;With n_samples=3, test_size=0.67 and train_size=None, &quot;</span>
            <span class="s6">&quot;the resulting train set will be empty&quot;</span>
        <span class="s3">),</span>
    <span class="s3">):</span>
        <span class="s1">train_test_split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">=</span><span class="s4">0.67</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_leave_one_out_empty_trainset</span><span class="s3">():</span>
    <span class="s5"># LeaveOneGroup out expect at least 2 groups so no need to check</span>
    <span class="s1">cv </span><span class="s3">= </span><span class="s1">LeaveOneOut</span><span class="s3">()</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= [[</span><span class="s4">1</span><span class="s3">]], [</span><span class="s4">0</span><span class="s3">]  </span><span class="s5"># 1 sample</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Cannot perform LeaveOneOut with n_samples=1&quot;</span><span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">test_leave_p_out_empty_trainset</span><span class="s3">():</span>
    <span class="s5"># No need to check LeavePGroupsOut</span>
    <span class="s1">cv </span><span class="s3">= </span><span class="s1">LeavePOut</span><span class="s3">(</span><span class="s1">p</span><span class="s3">=</span><span class="s4">2</span><span class="s3">)</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= [[</span><span class="s4">1</span><span class="s3">], [</span><span class="s4">2</span><span class="s3">]], [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">3</span><span class="s3">]  </span><span class="s5"># 2 samples</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span>
        <span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;p=2 must be strictly less than the number of samples=2&quot;</span>
    <span class="s3">):</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;Klass&quot;</span><span class="s3">, (</span><span class="s1">KFold</span><span class="s3">, </span><span class="s1">StratifiedKFold</span><span class="s3">, </span><span class="s1">StratifiedGroupKFold</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">test_random_state_shuffle_false</span><span class="s3">(</span><span class="s1">Klass</span><span class="s3">):</span>
    <span class="s5"># passing a non-default random_state when shuffle=False makes no sense</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;has no effect since shuffle is False&quot;</span><span class="s3">):</span>
        <span class="s1">Klass</span><span class="s3">(</span><span class="s4">3</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span>
    <span class="s6">&quot;cv, expected&quot;</span><span class="s3">,</span>
    <span class="s3">[</span>
        <span class="s3">(</span><span class="s1">KFold</span><span class="s3">(), </span><span class="s2">True</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">KFold</span><span class="s3">(</span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">123</span><span class="s3">), </span><span class="s2">True</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">StratifiedKFold</span><span class="s3">(), </span><span class="s2">True</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">123</span><span class="s3">), </span><span class="s2">True</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">StratifiedGroupKFold</span><span class="s3">(</span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">123</span><span class="s3">), </span><span class="s2">True</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">StratifiedGroupKFold</span><span class="s3">(), </span><span class="s2">True</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">RepeatedKFold</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">123</span><span class="s3">), </span><span class="s2">True</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">RepeatedStratifiedKFold</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">123</span><span class="s3">), </span><span class="s2">True</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">ShuffleSplit</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">123</span><span class="s3">), </span><span class="s2">True</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">GroupShuffleSplit</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">123</span><span class="s3">), </span><span class="s2">True</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s4">123</span><span class="s3">), </span><span class="s2">True</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">GroupKFold</span><span class="s3">(), </span><span class="s2">True</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">TimeSeriesSplit</span><span class="s3">(), </span><span class="s2">True</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">LeaveOneOut</span><span class="s3">(), </span><span class="s2">True</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">LeaveOneGroupOut</span><span class="s3">(), </span><span class="s2">True</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">LeavePGroupsOut</span><span class="s3">(</span><span class="s1">n_groups</span><span class="s3">=</span><span class="s4">2</span><span class="s3">), </span><span class="s2">True</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">LeavePOut</span><span class="s3">(</span><span class="s1">p</span><span class="s3">=</span><span class="s4">2</span><span class="s3">), </span><span class="s2">True</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">KFold</span><span class="s3">(</span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">), </span><span class="s2">False</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">KFold</span><span class="s3">(</span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">), </span><span class="s2">False</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)), </span><span class="s2">False</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">StratifiedKFold</span><span class="s3">(</span><span class="s1">shuffle</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)), </span><span class="s2">False</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">RepeatedKFold</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">), </span><span class="s2">False</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">RepeatedKFold</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)), </span><span class="s2">False</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">RepeatedStratifiedKFold</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">), </span><span class="s2">False</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">RepeatedStratifiedKFold</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)), </span><span class="s2">False</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">ShuffleSplit</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">), </span><span class="s2">False</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">ShuffleSplit</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)), </span><span class="s2">False</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">GroupShuffleSplit</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">), </span><span class="s2">False</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">GroupShuffleSplit</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)), </span><span class="s2">False</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s2">None</span><span class="s3">), </span><span class="s2">False</span><span class="s3">),</span>
        <span class="s3">(</span><span class="s1">StratifiedShuffleSplit</span><span class="s3">(</span><span class="s1">random_state</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s4">0</span><span class="s3">)), </span><span class="s2">False</span><span class="s3">),</span>
    <span class="s3">],</span>
<span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_yields_constant_splits</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">):</span>
    <span class="s2">assert </span><span class="s1">_yields_constant_splits</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">) == </span><span class="s1">expected</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;cv&quot;</span><span class="s3">, </span><span class="s1">ALL_SPLITTERS</span><span class="s3">, </span><span class="s1">ids</span><span class="s3">=[</span><span class="s1">str</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">) </span><span class="s2">for </span><span class="s1">cv </span><span class="s2">in </span><span class="s1">ALL_SPLITTERS</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_splitter_get_metadata_routing</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check get_metadata_routing returns the correct MetadataRouter.&quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">, </span><span class="s6">&quot;get_metadata_routing&quot;</span><span class="s3">)</span>
    <span class="s1">metadata </span><span class="s3">= </span><span class="s1">cv</span><span class="s3">.</span><span class="s1">get_metadata_routing</span><span class="s3">()</span>
    <span class="s2">if </span><span class="s1">cv </span><span class="s2">in </span><span class="s1">GROUP_SPLITTERS</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">metadata</span><span class="s3">.</span><span class="s1">split</span><span class="s3">.</span><span class="s1">requests</span><span class="s3">[</span><span class="s6">&quot;groups&quot;</span><span class="s3">] </span><span class="s2">is True</span>
    <span class="s2">elif </span><span class="s1">cv </span><span class="s2">in </span><span class="s1">NO_GROUP_SPLITTERS</span><span class="s3">:</span>
        <span class="s2">assert not </span><span class="s1">metadata</span><span class="s3">.</span><span class="s1">split</span><span class="s3">.</span><span class="s1">requests</span>

    <span class="s1">assert_request_is_empty</span><span class="s3">(</span><span class="s1">metadata</span><span class="s3">, </span><span class="s1">exclude</span><span class="s3">=[</span><span class="s6">&quot;split&quot;</span><span class="s3">])</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;cv&quot;</span><span class="s3">, </span><span class="s1">ALL_SPLITTERS</span><span class="s3">, </span><span class="s1">ids</span><span class="s3">=[</span><span class="s1">str</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">) </span><span class="s2">for </span><span class="s1">cv </span><span class="s2">in </span><span class="s1">ALL_SPLITTERS</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_splitter_set_split_request</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check set_split_request is defined for group splitters and not for others.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">cv </span><span class="s2">in </span><span class="s1">GROUP_SPLITTERS</span><span class="s3">:</span>
        <span class="s2">assert </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">, </span><span class="s6">&quot;set_split_request&quot;</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">cv </span><span class="s2">in </span><span class="s1">NO_GROUP_SPLITTERS</span><span class="s3">:</span>
        <span class="s2">assert not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">, </span><span class="s6">&quot;set_split_request&quot;</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;cv&quot;</span><span class="s3">, </span><span class="s1">NO_GROUP_SPLITTERS</span><span class="s3">, </span><span class="s1">ids</span><span class="s3">=</span><span class="s1">str</span><span class="s3">)</span>
<span class="s2">def </span><span class="s1">test_no_group_splitters_warns_with_groups</span><span class="s3">(</span><span class="s1">cv</span><span class="s3">):</span>
    <span class="s1">msg </span><span class="s3">= </span><span class="s6">f&quot;The groups parameter is ignored by </span><span class="s2">{</span><span class="s1">cv</span><span class="s3">.</span><span class="s1">__class__</span><span class="s3">.</span><span class="s1">__name__</span><span class="s2">}</span><span class="s6">&quot;</span>

    <span class="s1">n_samples </span><span class="s3">= </span><span class="s4">30</span>
    <span class="s1">rng </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">RandomState</span><span class="s3">(</span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">, </span><span class="s4">2</span><span class="s3">))</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">,))</span>
    <span class="s1">groups </span><span class="s3">= </span><span class="s1">rng</span><span class="s3">.</span><span class="s1">randint</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=(</span><span class="s1">n_samples</span><span class="s3">,))</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">warns</span><span class="s3">(</span><span class="s1">UserWarning</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s1">msg</span><span class="s3">):</span>
        <span class="s1">cv</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">=</span><span class="s1">groups</span><span class="s3">)</span>
</pre>
</body>
</html>