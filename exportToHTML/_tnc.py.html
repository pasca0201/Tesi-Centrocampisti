<html>
<head>
<title>_tnc.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_tnc.py</font>
</center></td></tr></table>
<pre><span class="s0"># TNC Python interface</span>
<span class="s0"># @(#) $Jeannot: tnc.py,v 1.11 2005/01/28 18:27:31 js Exp $</span>

<span class="s0"># Copyright (c) 2004-2005, Jean-Sebastien Roy (js@jeannot.org)</span>

<span class="s0"># Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s0"># copy of this software and associated documentation files (the</span>
<span class="s0"># &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="s0"># without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="s0"># distribute, sublicense, and/or sell copies of the Software, and to</span>
<span class="s0"># permit persons to whom the Software is furnished to do so, subject to</span>
<span class="s0"># the following conditions:</span>

<span class="s0"># The above copyright notice and this permission notice shall be included</span>
<span class="s0"># in all copies or substantial portions of the Software.</span>

<span class="s0"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="s0"># OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="s0"># MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.</span>
<span class="s0"># IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY</span>
<span class="s0"># CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,</span>
<span class="s0"># TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE</span>
<span class="s0"># SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="s2">&quot;&quot;&quot; 
TNC: A Python interface to the TNC non-linear optimizer 
 
TNC is a non-linear optimizer. To use it, you must provide a function to 
minimize. The function must take one argument: the list of coordinates where to 
evaluate the function; and it must return either a tuple, whose first element is the 
value of the function, and whose second argument is the gradient of the function 
(as a list of values); or None, to abort the minimization. 
&quot;&quot;&quot;</span>

<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">optimize </span><span class="s3">import </span><span class="s1">_moduleTNC </span><span class="s3">as </span><span class="s1">moduleTNC</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_optimize </span><span class="s3">import </span><span class="s4">(</span><span class="s1">MemoizeJac</span><span class="s4">, </span><span class="s1">OptimizeResult</span><span class="s4">, </span><span class="s1">_check_unknown_options</span><span class="s4">,</span>
                       <span class="s1">_prepare_scalar_function</span><span class="s4">)</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_constraints </span><span class="s3">import </span><span class="s1">old_bound_to_new</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">_lib</span><span class="s4">.</span><span class="s1">_array_api </span><span class="s3">import </span><span class="s1">atleast_nd</span><span class="s4">, </span><span class="s1">array_namespace</span>

<span class="s3">from </span><span class="s1">numpy </span><span class="s3">import </span><span class="s1">inf</span><span class="s4">, </span><span class="s1">array</span><span class="s4">, </span><span class="s1">zeros</span>

<span class="s1">__all__ </span><span class="s4">= [</span><span class="s5">'fmin_tnc'</span><span class="s4">]</span>


<span class="s1">MSG_NONE </span><span class="s4">= </span><span class="s6">0  </span><span class="s0"># No messages</span>
<span class="s1">MSG_ITER </span><span class="s4">= </span><span class="s6">1  </span><span class="s0"># One line per iteration</span>
<span class="s1">MSG_INFO </span><span class="s4">= </span><span class="s6">2  </span><span class="s0"># Informational messages</span>
<span class="s1">MSG_VERS </span><span class="s4">= </span><span class="s6">4  </span><span class="s0"># Version info</span>
<span class="s1">MSG_EXIT </span><span class="s4">= </span><span class="s6">8  </span><span class="s0"># Exit reasons</span>
<span class="s1">MSG_ALL </span><span class="s4">= </span><span class="s1">MSG_ITER </span><span class="s4">+ </span><span class="s1">MSG_INFO </span><span class="s4">+ </span><span class="s1">MSG_VERS </span><span class="s4">+ </span><span class="s1">MSG_EXIT</span>

<span class="s1">MSGS </span><span class="s4">= {</span>
        <span class="s1">MSG_NONE</span><span class="s4">: </span><span class="s5">&quot;No messages&quot;</span><span class="s4">,</span>
        <span class="s1">MSG_ITER</span><span class="s4">: </span><span class="s5">&quot;One line per iteration&quot;</span><span class="s4">,</span>
        <span class="s1">MSG_INFO</span><span class="s4">: </span><span class="s5">&quot;Informational messages&quot;</span><span class="s4">,</span>
        <span class="s1">MSG_VERS</span><span class="s4">: </span><span class="s5">&quot;Version info&quot;</span><span class="s4">,</span>
        <span class="s1">MSG_EXIT</span><span class="s4">: </span><span class="s5">&quot;Exit reasons&quot;</span><span class="s4">,</span>
        <span class="s1">MSG_ALL</span><span class="s4">: </span><span class="s5">&quot;All messages&quot;</span>
<span class="s4">}</span>

<span class="s1">INFEASIBLE </span><span class="s4">= -</span><span class="s6">1  </span><span class="s0"># Infeasible (lower bound &gt; upper bound)</span>
<span class="s1">LOCALMINIMUM </span><span class="s4">= </span><span class="s6">0  </span><span class="s0"># Local minimum reached (|pg| ~= 0)</span>
<span class="s1">FCONVERGED </span><span class="s4">= </span><span class="s6">1  </span><span class="s0"># Converged (|f_n-f_(n-1)| ~= 0)</span>
<span class="s1">XCONVERGED </span><span class="s4">= </span><span class="s6">2  </span><span class="s0"># Converged (|x_n-x_(n-1)| ~= 0)</span>
<span class="s1">MAXFUN </span><span class="s4">= </span><span class="s6">3  </span><span class="s0"># Max. number of function evaluations reached</span>
<span class="s1">LSFAIL </span><span class="s4">= </span><span class="s6">4  </span><span class="s0"># Linear search failed</span>
<span class="s1">CONSTANT </span><span class="s4">= </span><span class="s6">5  </span><span class="s0"># All lower bounds are equal to the upper bounds</span>
<span class="s1">NOPROGRESS </span><span class="s4">= </span><span class="s6">6  </span><span class="s0"># Unable to progress</span>
<span class="s1">USERABORT </span><span class="s4">= </span><span class="s6">7  </span><span class="s0"># User requested end of minimization</span>

<span class="s1">RCSTRINGS </span><span class="s4">= {</span>
        <span class="s1">INFEASIBLE</span><span class="s4">: </span><span class="s5">&quot;Infeasible (lower bound &gt; upper bound)&quot;</span><span class="s4">,</span>
        <span class="s1">LOCALMINIMUM</span><span class="s4">: </span><span class="s5">&quot;Local minimum reached (|pg| ~= 0)&quot;</span><span class="s4">,</span>
        <span class="s1">FCONVERGED</span><span class="s4">: </span><span class="s5">&quot;Converged (|f_n-f_(n-1)| ~= 0)&quot;</span><span class="s4">,</span>
        <span class="s1">XCONVERGED</span><span class="s4">: </span><span class="s5">&quot;Converged (|x_n-x_(n-1)| ~= 0)&quot;</span><span class="s4">,</span>
        <span class="s1">MAXFUN</span><span class="s4">: </span><span class="s5">&quot;Max. number of function evaluations reached&quot;</span><span class="s4">,</span>
        <span class="s1">LSFAIL</span><span class="s4">: </span><span class="s5">&quot;Linear search failed&quot;</span><span class="s4">,</span>
        <span class="s1">CONSTANT</span><span class="s4">: </span><span class="s5">&quot;All lower bounds are equal to the upper bounds&quot;</span><span class="s4">,</span>
        <span class="s1">NOPROGRESS</span><span class="s4">: </span><span class="s5">&quot;Unable to progress&quot;</span><span class="s4">,</span>
        <span class="s1">USERABORT</span><span class="s4">: </span><span class="s5">&quot;User requested end of minimization&quot;</span>
<span class="s4">}</span>

<span class="s0"># Changes to interface made by Travis Oliphant, Apr. 2004 for inclusion in</span>
<span class="s0">#  SciPy</span>


<span class="s3">def </span><span class="s1">fmin_tnc</span><span class="s4">(</span><span class="s1">func</span><span class="s4">, </span><span class="s1">x0</span><span class="s4">, </span><span class="s1">fprime</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">args</span><span class="s4">=(), </span><span class="s1">approx_grad</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
             <span class="s1">bounds</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">epsilon</span><span class="s4">=</span><span class="s6">1e-8</span><span class="s4">, </span><span class="s1">scale</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
             <span class="s1">messages</span><span class="s4">=</span><span class="s1">MSG_ALL</span><span class="s4">, </span><span class="s1">maxCGit</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">, </span><span class="s1">maxfun</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">eta</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">,</span>
             <span class="s1">stepmx</span><span class="s4">=</span><span class="s6">0</span><span class="s4">, </span><span class="s1">accuracy</span><span class="s4">=</span><span class="s6">0</span><span class="s4">, </span><span class="s1">fmin</span><span class="s4">=</span><span class="s6">0</span><span class="s4">, </span><span class="s1">ftol</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">, </span><span class="s1">xtol</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">, </span><span class="s1">pgtol</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">,</span>
             <span class="s1">rescale</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">, </span><span class="s1">disp</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">callback</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Minimize a function with variables subject to bounds, using 
    gradient information in a truncated Newton algorithm. This 
    method wraps a C implementation of the algorithm. 
 
    Parameters 
    ---------- 
    func : callable ``func(x, *args)`` 
        Function to minimize.  Must do one of: 
 
        1. Return f and g, where f is the value of the function and g its 
           gradient (a list of floats). 
 
        2. Return the function value but supply gradient function 
           separately as `fprime`. 
 
        3. Return the function value and set ``approx_grad=True``. 
 
        If the function returns None, the minimization 
        is aborted. 
    x0 : array_like 
        Initial estimate of minimum. 
    fprime : callable ``fprime(x, *args)``, optional 
        Gradient of `func`. If None, then either `func` must return the 
        function value and the gradient (``f,g = func(x, *args)``) 
        or `approx_grad` must be True. 
    args : tuple, optional 
        Arguments to pass to function. 
    approx_grad : bool, optional 
        If true, approximate the gradient numerically. 
    bounds : list, optional 
        (min, max) pairs for each element in x0, defining the 
        bounds on that parameter. Use None or +/-inf for one of 
        min or max when there is no bound in that direction. 
    epsilon : float, optional 
        Used if approx_grad is True. The stepsize in a finite 
        difference approximation for fprime. 
    scale : array_like, optional 
        Scaling factors to apply to each variable. If None, the 
        factors are up-low for interval bounded variables and 
        1+|x| for the others. Defaults to None. 
    offset : array_like, optional 
        Value to subtract from each variable. If None, the 
        offsets are (up+low)/2 for interval bounded variables 
        and x for the others. 
    messages : int, optional 
        Bit mask used to select messages display during 
        minimization values defined in the MSGS dict. Defaults to 
        MGS_ALL. 
    disp : int, optional 
        Integer interface to messages. 0 = no message, 5 = all messages 
    maxCGit : int, optional 
        Maximum number of hessian*vector evaluations per main 
        iteration. If maxCGit == 0, the direction chosen is 
        -gradient if maxCGit &lt; 0, maxCGit is set to 
        max(1,min(50,n/2)). Defaults to -1. 
    maxfun : int, optional 
        Maximum number of function evaluation. If None, maxfun is 
        set to max(100, 10*len(x0)). Defaults to None. Note that this function 
        may violate the limit because of evaluating gradients by numerical 
        differentiation. 
    eta : float, optional 
        Severity of the line search. If &lt; 0 or &gt; 1, set to 0.25. 
        Defaults to -1. 
    stepmx : float, optional 
        Maximum step for the line search. May be increased during 
        call. If too small, it will be set to 10.0. Defaults to 0. 
    accuracy : float, optional 
        Relative precision for finite difference calculations. If 
        &lt;= machine_precision, set to sqrt(machine_precision). 
        Defaults to 0. 
    fmin : float, optional 
        Minimum function value estimate. Defaults to 0. 
    ftol : float, optional 
        Precision goal for the value of f in the stopping criterion. 
        If ftol &lt; 0.0, ftol is set to 0.0 defaults to -1. 
    xtol : float, optional 
        Precision goal for the value of x in the stopping 
        criterion (after applying x scaling factors). If xtol &lt; 
        0.0, xtol is set to sqrt(machine_precision). Defaults to 
        -1. 
    pgtol : float, optional 
        Precision goal for the value of the projected gradient in 
        the stopping criterion (after applying x scaling factors). 
        If pgtol &lt; 0.0, pgtol is set to 1e-2 * sqrt(accuracy). 
        Setting it to 0.0 is not recommended. Defaults to -1. 
    rescale : float, optional 
        Scaling factor (in log10) used to trigger f value 
        rescaling. If 0, rescale at each iteration. If a large 
        value, never rescale. If &lt; 0, rescale is set to 1.3. 
    callback : callable, optional 
        Called after each iteration, as callback(xk), where xk is the 
        current parameter vector. 
 
    Returns 
    ------- 
    x : ndarray 
        The solution. 
    nfeval : int 
        The number of function evaluations. 
    rc : int 
        Return code, see below 
 
    See also 
    -------- 
    minimize: Interface to minimization algorithms for multivariate 
        functions. See the 'TNC' `method` in particular. 
 
    Notes 
    ----- 
    The underlying algorithm is truncated Newton, also called 
    Newton Conjugate-Gradient. This method differs from 
    scipy.optimize.fmin_ncg in that 
 
    1. it wraps a C implementation of the algorithm 
    2. it allows each variable to be given an upper and lower bound. 
 
    The algorithm incorporates the bound constraints by determining 
    the descent direction as in an unconstrained truncated Newton, 
    but never taking a step-size large enough to leave the space 
    of feasible x's. The algorithm keeps track of a set of 
    currently active constraints, and ignores them when computing 
    the minimum allowable step size. (The x's associated with the 
    active constraint are kept fixed.) If the maximum allowable 
    step size is zero then a new constraint is added. At the end 
    of each iteration one of the constraints may be deemed no 
    longer active and removed. A constraint is considered 
    no longer active is if it is currently active 
    but the gradient for that variable points inward from the 
    constraint. The specific constraint removed is the one 
    associated with the variable of largest index whose 
    constraint is no longer active. 
 
    Return codes are defined as follows:: 
 
        -1 : Infeasible (lower bound &gt; upper bound) 
         0 : Local minimum reached (|pg| ~= 0) 
         1 : Converged (|f_n-f_(n-1)| ~= 0) 
         2 : Converged (|x_n-x_(n-1)| ~= 0) 
         3 : Max. number of function evaluations reached 
         4 : Linear search failed 
         5 : All lower bounds are equal to the upper bounds 
         6 : Unable to progress 
         7 : User requested end of minimization 
 
    References 
    ---------- 
    Wright S., Nocedal J. (2006), 'Numerical Optimization' 
 
    Nash S.G. (1984), &quot;Newton-Type Minimization Via the Lanczos Method&quot;, 
    SIAM Journal of Numerical Analysis 21, pp. 770-778 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># handle fprime/approx_grad</span>
    <span class="s3">if </span><span class="s1">approx_grad</span><span class="s4">:</span>
        <span class="s1">fun </span><span class="s4">= </span><span class="s1">func</span>
        <span class="s1">jac </span><span class="s4">= </span><span class="s3">None</span>
    <span class="s3">elif </span><span class="s1">fprime </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">fun </span><span class="s4">= </span><span class="s1">MemoizeJac</span><span class="s4">(</span><span class="s1">func</span><span class="s4">)</span>
        <span class="s1">jac </span><span class="s4">= </span><span class="s1">fun</span><span class="s4">.</span><span class="s1">derivative</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">fun </span><span class="s4">= </span><span class="s1">func</span>
        <span class="s1">jac </span><span class="s4">= </span><span class="s1">fprime</span>

    <span class="s3">if </span><span class="s1">disp </span><span class="s3">is not None</span><span class="s4">:  </span><span class="s0"># disp takes precedence over messages</span>
        <span class="s1">mesg_num </span><span class="s4">= </span><span class="s1">disp</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">mesg_num </span><span class="s4">= {</span><span class="s6">0</span><span class="s4">:</span><span class="s1">MSG_NONE</span><span class="s4">, </span><span class="s6">1</span><span class="s4">:</span><span class="s1">MSG_ITER</span><span class="s4">, </span><span class="s6">2</span><span class="s4">:</span><span class="s1">MSG_INFO</span><span class="s4">, </span><span class="s6">3</span><span class="s4">:</span><span class="s1">MSG_VERS</span><span class="s4">,</span>
                    <span class="s6">4</span><span class="s4">:</span><span class="s1">MSG_EXIT</span><span class="s4">, </span><span class="s6">5</span><span class="s4">:</span><span class="s1">MSG_ALL</span><span class="s4">}.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">messages</span><span class="s4">, </span><span class="s1">MSG_ALL</span><span class="s4">)</span>
    <span class="s0"># build options</span>
    <span class="s1">opts </span><span class="s4">= {</span><span class="s5">'eps'</span><span class="s4">: </span><span class="s1">epsilon</span><span class="s4">,</span>
            <span class="s5">'scale'</span><span class="s4">: </span><span class="s1">scale</span><span class="s4">,</span>
            <span class="s5">'offset'</span><span class="s4">: </span><span class="s1">offset</span><span class="s4">,</span>
            <span class="s5">'mesg_num'</span><span class="s4">: </span><span class="s1">mesg_num</span><span class="s4">,</span>
            <span class="s5">'maxCGit'</span><span class="s4">: </span><span class="s1">maxCGit</span><span class="s4">,</span>
            <span class="s5">'maxfun'</span><span class="s4">: </span><span class="s1">maxfun</span><span class="s4">,</span>
            <span class="s5">'eta'</span><span class="s4">: </span><span class="s1">eta</span><span class="s4">,</span>
            <span class="s5">'stepmx'</span><span class="s4">: </span><span class="s1">stepmx</span><span class="s4">,</span>
            <span class="s5">'accuracy'</span><span class="s4">: </span><span class="s1">accuracy</span><span class="s4">,</span>
            <span class="s5">'minfev'</span><span class="s4">: </span><span class="s1">fmin</span><span class="s4">,</span>
            <span class="s5">'ftol'</span><span class="s4">: </span><span class="s1">ftol</span><span class="s4">,</span>
            <span class="s5">'xtol'</span><span class="s4">: </span><span class="s1">xtol</span><span class="s4">,</span>
            <span class="s5">'gtol'</span><span class="s4">: </span><span class="s1">pgtol</span><span class="s4">,</span>
            <span class="s5">'rescale'</span><span class="s4">: </span><span class="s1">rescale</span><span class="s4">,</span>
            <span class="s5">'disp'</span><span class="s4">: </span><span class="s3">False</span><span class="s4">}</span>

    <span class="s1">res </span><span class="s4">= </span><span class="s1">_minimize_tnc</span><span class="s4">(</span><span class="s1">fun</span><span class="s4">, </span><span class="s1">x0</span><span class="s4">, </span><span class="s1">args</span><span class="s4">, </span><span class="s1">jac</span><span class="s4">, </span><span class="s1">bounds</span><span class="s4">, </span><span class="s1">callback</span><span class="s4">=</span><span class="s1">callback</span><span class="s4">, **</span><span class="s1">opts</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">res</span><span class="s4">[</span><span class="s5">'x'</span><span class="s4">], </span><span class="s1">res</span><span class="s4">[</span><span class="s5">'nfev'</span><span class="s4">], </span><span class="s1">res</span><span class="s4">[</span><span class="s5">'status'</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">_minimize_tnc</span><span class="s4">(</span><span class="s1">fun</span><span class="s4">, </span><span class="s1">x0</span><span class="s4">, </span><span class="s1">args</span><span class="s4">=(), </span><span class="s1">jac</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">bounds</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
                  <span class="s1">eps</span><span class="s4">=</span><span class="s6">1e-8</span><span class="s4">, </span><span class="s1">scale</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">mesg_num</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
                  <span class="s1">maxCGit</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">, </span><span class="s1">eta</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">, </span><span class="s1">stepmx</span><span class="s4">=</span><span class="s6">0</span><span class="s4">, </span><span class="s1">accuracy</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
                  <span class="s1">minfev</span><span class="s4">=</span><span class="s6">0</span><span class="s4">, </span><span class="s1">ftol</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">, </span><span class="s1">xtol</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">, </span><span class="s1">gtol</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">, </span><span class="s1">rescale</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">, </span><span class="s1">disp</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
                  <span class="s1">callback</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">finite_diff_rel_step</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">maxfun</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
                  <span class="s4">**</span><span class="s1">unknown_options</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Minimize a scalar function of one or more variables using a truncated 
    Newton (TNC) algorithm. 
 
    Options 
    ------- 
    eps : float or ndarray 
        If `jac is None` the absolute step size used for numerical 
        approximation of the jacobian via forward differences. 
    scale : list of floats 
        Scaling factors to apply to each variable. If None, the 
        factors are up-low for interval bounded variables and 
        1+|x] for the others. Defaults to None. 
    offset : float 
        Value to subtract from each variable. If None, the 
        offsets are (up+low)/2 for interval bounded variables 
        and x for the others. 
    disp : bool 
       Set to True to print convergence messages. 
    maxCGit : int 
        Maximum number of hessian*vector evaluations per main 
        iteration. If maxCGit == 0, the direction chosen is 
        -gradient if maxCGit &lt; 0, maxCGit is set to 
        max(1,min(50,n/2)). Defaults to -1. 
    eta : float 
        Severity of the line search. If &lt; 0 or &gt; 1, set to 0.25. 
        Defaults to -1. 
    stepmx : float 
        Maximum step for the line search. May be increased during 
        call. If too small, it will be set to 10.0. Defaults to 0. 
    accuracy : float 
        Relative precision for finite difference calculations. If 
        &lt;= machine_precision, set to sqrt(machine_precision). 
        Defaults to 0. 
    minfev : float 
        Minimum function value estimate. Defaults to 0. 
    ftol : float 
        Precision goal for the value of f in the stopping criterion. 
        If ftol &lt; 0.0, ftol is set to 0.0 defaults to -1. 
    xtol : float 
        Precision goal for the value of x in the stopping 
        criterion (after applying x scaling factors). If xtol &lt; 
        0.0, xtol is set to sqrt(machine_precision). Defaults to 
        -1. 
    gtol : float 
        Precision goal for the value of the projected gradient in 
        the stopping criterion (after applying x scaling factors). 
        If gtol &lt; 0.0, gtol is set to 1e-2 * sqrt(accuracy). 
        Setting it to 0.0 is not recommended. Defaults to -1. 
    rescale : float 
        Scaling factor (in log10) used to trigger f value 
        rescaling.  If 0, rescale at each iteration.  If a large 
        value, never rescale.  If &lt; 0, rescale is set to 1.3. 
    finite_diff_rel_step : None or array_like, optional 
        If `jac in ['2-point', '3-point', 'cs']` the relative step size to 
        use for numerical approximation of the jacobian. The absolute step 
        size is computed as ``h = rel_step * sign(x) * max(1, abs(x))``, 
        possibly adjusted to fit into the bounds. For ``method='3-point'`` 
        the sign of `h` is ignored. If None (default) then step is selected 
        automatically. 
    maxfun : int 
        Maximum number of function evaluations. If None, `maxfun` is 
        set to max(100, 10*len(x0)). Defaults to None. 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_unknown_options</span><span class="s4">(</span><span class="s1">unknown_options</span><span class="s4">)</span>
    <span class="s1">fmin </span><span class="s4">= </span><span class="s1">minfev</span>
    <span class="s1">pgtol </span><span class="s4">= </span><span class="s1">gtol</span>

    <span class="s1">xp </span><span class="s4">= </span><span class="s1">array_namespace</span><span class="s4">(</span><span class="s1">x0</span><span class="s4">)</span>
    <span class="s1">x0 </span><span class="s4">= </span><span class="s1">atleast_nd</span><span class="s4">(</span><span class="s1">x0</span><span class="s4">, </span><span class="s1">ndim</span><span class="s4">=</span><span class="s6">1</span><span class="s4">, </span><span class="s1">xp</span><span class="s4">=</span><span class="s1">xp</span><span class="s4">)</span>
    <span class="s1">dtype </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">float64</span>
    <span class="s3">if </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">isdtype</span><span class="s4">(</span><span class="s1">x0</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s5">&quot;real floating&quot;</span><span class="s4">):</span>
        <span class="s1">dtype </span><span class="s4">= </span><span class="s1">x0</span><span class="s4">.</span><span class="s1">dtype</span>
    <span class="s1">x0 </span><span class="s4">= </span><span class="s1">xp</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">(</span><span class="s1">xp</span><span class="s4">.</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">x0</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">), -</span><span class="s6">1</span><span class="s4">)</span>

    <span class="s1">n </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">x0</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">bounds </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">bounds </span><span class="s4">= [(</span><span class="s3">None</span><span class="s4">,</span><span class="s3">None</span><span class="s4">)] * </span><span class="s1">n</span>
    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">bounds</span><span class="s4">) != </span><span class="s1">n</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'length of x0 != length of bounds'</span><span class="s4">)</span>
    <span class="s1">new_bounds </span><span class="s4">= </span><span class="s1">old_bound_to_new</span><span class="s4">(</span><span class="s1">bounds</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">mesg_num </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">messages </span><span class="s4">= {</span><span class="s6">0</span><span class="s4">:</span><span class="s1">MSG_NONE</span><span class="s4">, </span><span class="s6">1</span><span class="s4">:</span><span class="s1">MSG_ITER</span><span class="s4">, </span><span class="s6">2</span><span class="s4">:</span><span class="s1">MSG_INFO</span><span class="s4">, </span><span class="s6">3</span><span class="s4">:</span><span class="s1">MSG_VERS</span><span class="s4">,</span>
                    <span class="s6">4</span><span class="s4">:</span><span class="s1">MSG_EXIT</span><span class="s4">, </span><span class="s6">5</span><span class="s4">:</span><span class="s1">MSG_ALL</span><span class="s4">}.</span><span class="s1">get</span><span class="s4">(</span><span class="s1">mesg_num</span><span class="s4">, </span><span class="s1">MSG_ALL</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">disp</span><span class="s4">:</span>
        <span class="s1">messages </span><span class="s4">= </span><span class="s1">MSG_ALL</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">messages </span><span class="s4">= </span><span class="s1">MSG_NONE</span>

    <span class="s1">sf </span><span class="s4">= </span><span class="s1">_prepare_scalar_function</span><span class="s4">(</span><span class="s1">fun</span><span class="s4">, </span><span class="s1">x0</span><span class="s4">, </span><span class="s1">jac</span><span class="s4">=</span><span class="s1">jac</span><span class="s4">, </span><span class="s1">args</span><span class="s4">=</span><span class="s1">args</span><span class="s4">, </span><span class="s1">epsilon</span><span class="s4">=</span><span class="s1">eps</span><span class="s4">,</span>
                                  <span class="s1">finite_diff_rel_step</span><span class="s4">=</span><span class="s1">finite_diff_rel_step</span><span class="s4">,</span>
                                  <span class="s1">bounds</span><span class="s4">=</span><span class="s1">new_bounds</span><span class="s4">)</span>
    <span class="s1">func_and_grad </span><span class="s4">= </span><span class="s1">sf</span><span class="s4">.</span><span class="s1">fun_and_grad</span>

    <span class="s5">&quot;&quot;&quot; 
    low, up   : the bounds (lists of floats) 
                if low is None, the lower bounds are removed. 
                if up is None, the upper bounds are removed. 
                low and up defaults to None 
    &quot;&quot;&quot;</span>
    <span class="s1">low </span><span class="s4">= </span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)</span>
    <span class="s1">up </span><span class="s4">= </span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n</span><span class="s4">)</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">n</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">bounds</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">l</span><span class="s4">, </span><span class="s1">u </span><span class="s4">= -</span><span class="s1">inf</span><span class="s4">, </span><span class="s1">inf</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">l</span><span class="s4">,</span><span class="s1">u </span><span class="s4">= </span><span class="s1">bounds</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
            <span class="s3">if </span><span class="s1">l </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">low</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = -</span><span class="s1">inf</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">low</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s1">l</span>
            <span class="s3">if </span><span class="s1">u </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">up</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s1">inf</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">up</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s1">u</span>

    <span class="s3">if </span><span class="s1">scale </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">scale </span><span class="s4">= </span><span class="s1">array</span><span class="s4">([])</span>

    <span class="s3">if </span><span class="s1">offset </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">offset </span><span class="s4">= </span><span class="s1">array</span><span class="s4">([])</span>

    <span class="s3">if </span><span class="s1">maxfun </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">maxfun </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s6">100</span><span class="s4">, </span><span class="s6">10</span><span class="s4">*</span><span class="s1">len</span><span class="s4">(</span><span class="s1">x0</span><span class="s4">))</span>

    <span class="s1">rc</span><span class="s4">, </span><span class="s1">nf</span><span class="s4">, </span><span class="s1">nit</span><span class="s4">, </span><span class="s1">x</span><span class="s4">, </span><span class="s1">funv</span><span class="s4">, </span><span class="s1">jacv </span><span class="s4">= </span><span class="s1">moduleTNC</span><span class="s4">.</span><span class="s1">tnc_minimize</span><span class="s4">(</span>
        <span class="s1">func_and_grad</span><span class="s4">, </span><span class="s1">x0</span><span class="s4">, </span><span class="s1">low</span><span class="s4">, </span><span class="s1">up</span><span class="s4">, </span><span class="s1">scale</span><span class="s4">,</span>
        <span class="s1">offset</span><span class="s4">, </span><span class="s1">messages</span><span class="s4">, </span><span class="s1">maxCGit</span><span class="s4">, </span><span class="s1">maxfun</span><span class="s4">,</span>
        <span class="s1">eta</span><span class="s4">, </span><span class="s1">stepmx</span><span class="s4">, </span><span class="s1">accuracy</span><span class="s4">, </span><span class="s1">fmin</span><span class="s4">, </span><span class="s1">ftol</span><span class="s4">,</span>
        <span class="s1">xtol</span><span class="s4">, </span><span class="s1">pgtol</span><span class="s4">, </span><span class="s1">rescale</span><span class="s4">, </span><span class="s1">callback</span>
    <span class="s4">)</span>
    <span class="s0"># the TNC documentation states: &quot;On output, x, f and g may be very</span>
    <span class="s0"># slightly out of sync because of scaling&quot;. Therefore re-evaluate</span>
    <span class="s0"># func_and_grad so they are synced.</span>
    <span class="s1">funv</span><span class="s4">, </span><span class="s1">jacv </span><span class="s4">= </span><span class="s1">func_and_grad</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">OptimizeResult</span><span class="s4">(</span><span class="s1">x</span><span class="s4">=</span><span class="s1">x</span><span class="s4">, </span><span class="s1">fun</span><span class="s4">=</span><span class="s1">funv</span><span class="s4">, </span><span class="s1">jac</span><span class="s4">=</span><span class="s1">jacv</span><span class="s4">, </span><span class="s1">nfev</span><span class="s4">=</span><span class="s1">sf</span><span class="s4">.</span><span class="s1">nfev</span><span class="s4">,</span>
                          <span class="s1">nit</span><span class="s4">=</span><span class="s1">nit</span><span class="s4">, </span><span class="s1">status</span><span class="s4">=</span><span class="s1">rc</span><span class="s4">, </span><span class="s1">message</span><span class="s4">=</span><span class="s1">RCSTRINGS</span><span class="s4">[</span><span class="s1">rc</span><span class="s4">],</span>
                          <span class="s1">success</span><span class="s4">=(-</span><span class="s6">1 </span><span class="s4">&lt; </span><span class="s1">rc </span><span class="s4">&lt; </span><span class="s6">3</span><span class="s4">))</span>
</pre>
</body>
</html>