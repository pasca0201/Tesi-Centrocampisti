<html>
<head>
<title>_root.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #cf8e6d;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_root.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Unified interfaces to root finding algorithms. 
 
Functions 
--------- 
- root : find a root of a vector function. 
&quot;&quot;&quot;</span>
<span class="s1">__all__ </span><span class="s2">= [</span><span class="s3">'root'</span><span class="s2">]</span>

<span class="s4">import </span><span class="s1">numpy </span><span class="s4">as </span><span class="s1">np</span>

<span class="s4">from </span><span class="s1">warnings </span><span class="s4">import </span><span class="s1">warn</span>

<span class="s4">from </span><span class="s2">.</span><span class="s1">_optimize </span><span class="s4">import </span><span class="s1">MemoizeJac</span><span class="s2">, </span><span class="s1">OptimizeResult</span><span class="s2">, </span><span class="s1">_check_unknown_options</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_minpack_py </span><span class="s4">import </span><span class="s1">_root_hybr</span><span class="s2">, </span><span class="s1">leastsq</span>
<span class="s4">from </span><span class="s2">.</span><span class="s1">_spectral </span><span class="s4">import </span><span class="s1">_root_df_sane</span>
<span class="s4">from </span><span class="s2">. </span><span class="s4">import </span><span class="s1">_nonlin </span><span class="s4">as </span><span class="s1">nonlin</span>


<span class="s1">ROOT_METHODS </span><span class="s2">= [</span><span class="s3">'hybr'</span><span class="s2">, </span><span class="s3">'lm'</span><span class="s2">, </span><span class="s3">'broyden1'</span><span class="s2">, </span><span class="s3">'broyden2'</span><span class="s2">, </span><span class="s3">'anderson'</span><span class="s2">,</span>
                <span class="s3">'linearmixing'</span><span class="s2">, </span><span class="s3">'diagbroyden'</span><span class="s2">, </span><span class="s3">'excitingmixing'</span><span class="s2">, </span><span class="s3">'krylov'</span><span class="s2">,</span>
                <span class="s3">'df-sane'</span><span class="s2">]</span>


<span class="s4">def </span><span class="s1">root</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">method</span><span class="s2">=</span><span class="s3">'hybr'</span><span class="s2">, </span><span class="s1">jac</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
         <span class="s1">options</span><span class="s2">=</span><span class="s4">None</span><span class="s2">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Find a root of a vector function. 
 
    Parameters 
    ---------- 
    fun : callable 
        A vector function to find a root of. 
    x0 : ndarray 
        Initial guess. 
    args : tuple, optional 
        Extra arguments passed to the objective function and its Jacobian. 
    method : str, optional 
        Type of solver. Should be one of 
 
            - 'hybr'             :ref:`(see here) &lt;optimize.root-hybr&gt;` 
            - 'lm'               :ref:`(see here) &lt;optimize.root-lm&gt;` 
            - 'broyden1'         :ref:`(see here) &lt;optimize.root-broyden1&gt;` 
            - 'broyden2'         :ref:`(see here) &lt;optimize.root-broyden2&gt;` 
            - 'anderson'         :ref:`(see here) &lt;optimize.root-anderson&gt;` 
            - 'linearmixing'     :ref:`(see here) &lt;optimize.root-linearmixing&gt;` 
            - 'diagbroyden'      :ref:`(see here) &lt;optimize.root-diagbroyden&gt;` 
            - 'excitingmixing'   :ref:`(see here) &lt;optimize.root-excitingmixing&gt;` 
            - 'krylov'           :ref:`(see here) &lt;optimize.root-krylov&gt;` 
            - 'df-sane'          :ref:`(see here) &lt;optimize.root-dfsane&gt;` 
 
    jac : bool or callable, optional 
        If `jac` is a Boolean and is True, `fun` is assumed to return the 
        value of Jacobian along with the objective function. If False, the 
        Jacobian will be estimated numerically. 
        `jac` can also be a callable returning the Jacobian of `fun`. In 
        this case, it must accept the same arguments as `fun`. 
    tol : float, optional 
        Tolerance for termination. For detailed control, use solver-specific 
        options. 
    callback : function, optional 
        Optional callback function. It is called on every iteration as 
        ``callback(x, f)`` where `x` is the current solution and `f` 
        the corresponding residual. For all methods but 'hybr' and 'lm'. 
    options : dict, optional 
        A dictionary of solver options. E.g., `xtol` or `maxiter`, see 
        :obj:`show_options()` for details. 
 
    Returns 
    ------- 
    sol : OptimizeResult 
        The solution represented as a ``OptimizeResult`` object. 
        Important attributes are: ``x`` the solution array, ``success`` a 
        Boolean flag indicating if the algorithm exited successfully and 
        ``message`` which describes the cause of the termination. See 
        `OptimizeResult` for a description of other attributes. 
 
    See also 
    -------- 
    show_options : Additional options accepted by the solvers 
 
    Notes 
    ----- 
    This section describes the available solvers that can be selected by the 
    'method' parameter. The default method is *hybr*. 
 
    Method *hybr* uses a modification of the Powell hybrid method as 
    implemented in MINPACK [1]_. 
 
    Method *lm* solves the system of nonlinear equations in a least squares 
    sense using a modification of the Levenberg-Marquardt algorithm as 
    implemented in MINPACK [1]_. 
 
    Method *df-sane* is a derivative-free spectral method. [3]_ 
 
    Methods *broyden1*, *broyden2*, *anderson*, *linearmixing*, 
    *diagbroyden*, *excitingmixing*, *krylov* are inexact Newton methods, 
    with backtracking or full line searches [2]_. Each method corresponds 
    to a particular Jacobian approximations. 
 
    - Method *broyden1* uses Broyden's first Jacobian approximation, it is 
      known as Broyden's good method. 
    - Method *broyden2* uses Broyden's second Jacobian approximation, it 
      is known as Broyden's bad method. 
    - Method *anderson* uses (extended) Anderson mixing. 
    - Method *Krylov* uses Krylov approximation for inverse Jacobian. It 
      is suitable for large-scale problem. 
    - Method *diagbroyden* uses diagonal Broyden Jacobian approximation. 
    - Method *linearmixing* uses a scalar Jacobian approximation. 
    - Method *excitingmixing* uses a tuned diagonal Jacobian 
      approximation. 
 
    .. warning:: 
 
        The algorithms implemented for methods *diagbroyden*, 
        *linearmixing* and *excitingmixing* may be useful for specific 
        problems, but whether they will work may depend strongly on the 
        problem. 
 
    .. versionadded:: 0.11.0 
 
    References 
    ---------- 
    .. [1] More, Jorge J., Burton S. Garbow, and Kenneth E. Hillstrom. 
       1980. User Guide for MINPACK-1. 
    .. [2] C. T. Kelley. 1995. Iterative Methods for Linear and Nonlinear 
       Equations. Society for Industrial and Applied Mathematics. 
       &lt;https://archive.siam.org/books/kelley/fr16/&gt; 
    .. [3] W. La Cruz, J.M. Martinez, M. Raydan. Math. Comp. 75, 1429 (2006). 
 
    Examples 
    -------- 
    The following functions define a system of nonlinear equations and its 
    jacobian. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; def fun(x): 
    ...     return [x[0]  + 0.5 * (x[0] - x[1])**3 - 1.0, 
    ...             0.5 * (x[1] - x[0])**3 + x[1]] 
 
    &gt;&gt;&gt; def jac(x): 
    ...     return np.array([[1 + 1.5 * (x[0] - x[1])**2, 
    ...                       -1.5 * (x[0] - x[1])**2], 
    ...                      [-1.5 * (x[1] - x[0])**2, 
    ...                       1 + 1.5 * (x[1] - x[0])**2]]) 
 
    A solution can be obtained as follows. 
 
    &gt;&gt;&gt; from scipy import optimize 
    &gt;&gt;&gt; sol = optimize.root(fun, [0, 0], jac=jac, method='hybr') 
    &gt;&gt;&gt; sol.x 
    array([ 0.8411639,  0.1588361]) 
 
    **Large problem** 
 
    Suppose that we needed to solve the following integrodifferential 
    equation on the square :math:`[0,1]\times[0,1]`: 
 
    .. math:: 
 
       \nabla^2 P = 10 \left(\int_0^1\int_0^1\cosh(P)\,dx\,dy\right)^2 
 
    with :math:`P(x,1) = 1` and :math:`P=0` elsewhere on the boundary of 
    the square. 
 
    The solution can be found using the ``method='krylov'`` solver: 
 
    &gt;&gt;&gt; from scipy import optimize 
    &gt;&gt;&gt; # parameters 
    &gt;&gt;&gt; nx, ny = 75, 75 
    &gt;&gt;&gt; hx, hy = 1./(nx-1), 1./(ny-1) 
 
    &gt;&gt;&gt; P_left, P_right = 0, 0 
    &gt;&gt;&gt; P_top, P_bottom = 1, 0 
 
    &gt;&gt;&gt; def residual(P): 
    ...    d2x = np.zeros_like(P) 
    ...    d2y = np.zeros_like(P) 
    ... 
    ...    d2x[1:-1] = (P[2:]   - 2*P[1:-1] + P[:-2]) / hx/hx 
    ...    d2x[0]    = (P[1]    - 2*P[0]    + P_left)/hx/hx 
    ...    d2x[-1]   = (P_right - 2*P[-1]   + P[-2])/hx/hx 
    ... 
    ...    d2y[:,1:-1] = (P[:,2:] - 2*P[:,1:-1] + P[:,:-2])/hy/hy 
    ...    d2y[:,0]    = (P[:,1]  - 2*P[:,0]    + P_bottom)/hy/hy 
    ...    d2y[:,-1]   = (P_top   - 2*P[:,-1]   + P[:,-2])/hy/hy 
    ... 
    ...    return d2x + d2y - 10*np.cosh(P).mean()**2 
 
    &gt;&gt;&gt; guess = np.zeros((nx, ny), float) 
    &gt;&gt;&gt; sol = optimize.root(residual, guess, method='krylov') 
    &gt;&gt;&gt; print('Residual: %g' % abs(residual(sol.x)).max()) 
    Residual: 5.7972e-06  # may vary 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x, y = np.mgrid[0:1:(nx*1j), 0:1:(ny*1j)] 
    &gt;&gt;&gt; plt.pcolormesh(x, y, sol.x, shading='gouraud') 
    &gt;&gt;&gt; plt.colorbar() 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s4">def </span><span class="s1">_wrapped_fun</span><span class="s2">(*</span><span class="s1">fargs</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Wrapped `func` to track the number of times 
        the function has been called. 
        &quot;&quot;&quot;</span>
        <span class="s1">_wrapped_fun</span><span class="s2">.</span><span class="s1">nfev </span><span class="s2">+= </span><span class="s5">1</span>
        <span class="s4">return </span><span class="s1">fun</span><span class="s2">(*</span><span class="s1">fargs</span><span class="s2">)</span>

    <span class="s1">_wrapped_fun</span><span class="s2">.</span><span class="s1">nfev </span><span class="s2">= </span><span class="s5">0</span>

    <span class="s4">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">args</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
        <span class="s1">args </span><span class="s2">= (</span><span class="s1">args</span><span class="s2">,)</span>

    <span class="s1">meth </span><span class="s2">= </span><span class="s1">method</span><span class="s2">.</span><span class="s1">lower</span><span class="s2">()</span>
    <span class="s4">if </span><span class="s1">options </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">options </span><span class="s2">= {}</span>

    <span class="s4">if </span><span class="s1">callback </span><span class="s4">is not None and </span><span class="s1">meth </span><span class="s4">in </span><span class="s2">(</span><span class="s3">'hybr'</span><span class="s2">, </span><span class="s3">'lm'</span><span class="s2">):</span>
        <span class="s1">warn</span><span class="s2">(</span><span class="s3">'Method %s does not accept callback.' </span><span class="s2">% </span><span class="s1">method</span><span class="s2">,</span>
             <span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>

    <span class="s6"># fun also returns the Jacobian</span>
    <span class="s4">if not </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">jac</span><span class="s2">) </span><span class="s4">and </span><span class="s1">meth </span><span class="s4">in </span><span class="s2">(</span><span class="s3">'hybr'</span><span class="s2">, </span><span class="s3">'lm'</span><span class="s2">):</span>
        <span class="s4">if </span><span class="s1">bool</span><span class="s2">(</span><span class="s1">jac</span><span class="s2">):</span>
            <span class="s1">fun </span><span class="s2">= </span><span class="s1">MemoizeJac</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">)</span>
            <span class="s1">jac </span><span class="s2">= </span><span class="s1">fun</span><span class="s2">.</span><span class="s1">derivative</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s1">jac </span><span class="s2">= </span><span class="s4">None</span>

    <span class="s6"># set default tolerances</span>
    <span class="s4">if </span><span class="s1">tol </span><span class="s4">is not None</span><span class="s2">:</span>
        <span class="s1">options </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(</span><span class="s1">options</span><span class="s2">)</span>
        <span class="s4">if </span><span class="s1">meth </span><span class="s4">in </span><span class="s2">(</span><span class="s3">'hybr'</span><span class="s2">, </span><span class="s3">'lm'</span><span class="s2">):</span>
            <span class="s1">options</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s3">'xtol'</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s1">meth </span><span class="s4">in </span><span class="s2">(</span><span class="s3">'df-sane'</span><span class="s2">,):</span>
            <span class="s1">options</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s3">'ftol'</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">)</span>
        <span class="s4">elif </span><span class="s1">meth </span><span class="s4">in </span><span class="s2">(</span><span class="s3">'broyden1'</span><span class="s2">, </span><span class="s3">'broyden2'</span><span class="s2">, </span><span class="s3">'anderson'</span><span class="s2">, </span><span class="s3">'linearmixing'</span><span class="s2">,</span>
                      <span class="s3">'diagbroyden'</span><span class="s2">, </span><span class="s3">'excitingmixing'</span><span class="s2">, </span><span class="s3">'krylov'</span><span class="s2">):</span>
            <span class="s1">options</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s3">'xtol'</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">)</span>
            <span class="s1">options</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s3">'xatol'</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">)</span>
            <span class="s1">options</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s3">'ftol'</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">)</span>
            <span class="s1">options</span><span class="s2">.</span><span class="s1">setdefault</span><span class="s2">(</span><span class="s3">'fatol'</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">)</span>

    <span class="s4">if </span><span class="s1">meth </span><span class="s2">== </span><span class="s3">'hybr'</span><span class="s2">:</span>
        <span class="s1">sol </span><span class="s2">= </span><span class="s1">_root_hybr</span><span class="s2">(</span><span class="s1">_wrapped_fun</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">, </span><span class="s1">jac</span><span class="s2">=</span><span class="s1">jac</span><span class="s2">, **</span><span class="s1">options</span><span class="s2">)</span>
    <span class="s4">elif </span><span class="s1">meth </span><span class="s2">== </span><span class="s3">'lm'</span><span class="s2">:</span>
        <span class="s1">sol </span><span class="s2">= </span><span class="s1">_root_leastsq</span><span class="s2">(</span><span class="s1">_wrapped_fun</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">, </span><span class="s1">jac</span><span class="s2">=</span><span class="s1">jac</span><span class="s2">, **</span><span class="s1">options</span><span class="s2">)</span>
    <span class="s4">elif </span><span class="s1">meth </span><span class="s2">== </span><span class="s3">'df-sane'</span><span class="s2">:</span>
        <span class="s1">_warn_jac_unused</span><span class="s2">(</span><span class="s1">jac</span><span class="s2">, </span><span class="s1">method</span><span class="s2">)</span>
        <span class="s1">sol </span><span class="s2">= </span><span class="s1">_root_df_sane</span><span class="s2">(</span><span class="s1">_wrapped_fun</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">=</span><span class="s1">callback</span><span class="s2">,</span>
                            <span class="s2">**</span><span class="s1">options</span><span class="s2">)</span>
    <span class="s4">elif </span><span class="s1">meth </span><span class="s4">in </span><span class="s2">(</span><span class="s3">'broyden1'</span><span class="s2">, </span><span class="s3">'broyden2'</span><span class="s2">, </span><span class="s3">'anderson'</span><span class="s2">, </span><span class="s3">'linearmixing'</span><span class="s2">,</span>
                  <span class="s3">'diagbroyden'</span><span class="s2">, </span><span class="s3">'excitingmixing'</span><span class="s2">, </span><span class="s3">'krylov'</span><span class="s2">):</span>
        <span class="s1">_warn_jac_unused</span><span class="s2">(</span><span class="s1">jac</span><span class="s2">, </span><span class="s1">method</span><span class="s2">)</span>
        <span class="s1">sol </span><span class="s2">= </span><span class="s1">_root_nonlin_solve</span><span class="s2">(</span><span class="s1">_wrapped_fun</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">, </span><span class="s1">jac</span><span class="s2">=</span><span class="s1">jac</span><span class="s2">,</span>
                                 <span class="s1">_method</span><span class="s2">=</span><span class="s1">meth</span><span class="s2">, </span><span class="s1">_callback</span><span class="s2">=</span><span class="s1">callback</span><span class="s2">,</span>
                                 <span class="s2">**</span><span class="s1">options</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s4">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">'Unknown solver %s' </span><span class="s2">% </span><span class="s1">method</span><span class="s2">)</span>

    <span class="s1">sol</span><span class="s2">.</span><span class="s1">nfev </span><span class="s2">= </span><span class="s1">_wrapped_fun</span><span class="s2">.</span><span class="s1">nfev</span>
    <span class="s4">return </span><span class="s1">sol</span>


<span class="s4">def </span><span class="s1">_warn_jac_unused</span><span class="s2">(</span><span class="s1">jac</span><span class="s2">, </span><span class="s1">method</span><span class="s2">):</span>
    <span class="s4">if </span><span class="s1">jac </span><span class="s4">is not None</span><span class="s2">:</span>
        <span class="s1">warn</span><span class="s2">(</span><span class="s3">f'Method </span><span class="s4">{</span><span class="s1">method</span><span class="s4">} </span><span class="s3">does not use the jacobian (jac).'</span><span class="s2">,</span>
             <span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>


<span class="s4">def </span><span class="s1">_root_leastsq</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">jac</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                  <span class="s1">col_deriv</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s5">1.49012e-08</span><span class="s2">, </span><span class="s1">ftol</span><span class="s2">=</span><span class="s5">1.49012e-08</span><span class="s2">,</span>
                  <span class="s1">gtol</span><span class="s2">=</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">eps</span><span class="s2">=</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">=</span><span class="s5">100</span><span class="s2">, </span><span class="s1">diag</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                  <span class="s2">**</span><span class="s1">unknown_options</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Solve for least squares with Levenberg-Marquardt 
 
    Options 
    ------- 
    col_deriv : bool 
        non-zero to specify that the Jacobian function computes derivatives 
        down the columns (faster, because there is no transpose operation). 
    ftol : float 
        Relative error desired in the sum of squares. 
    xtol : float 
        Relative error desired in the approximate solution. 
    gtol : float 
        Orthogonality desired between the function vector and the columns 
        of the Jacobian. 
    maxiter : int 
        The maximum number of calls to the function. If zero, then 
        100*(N+1) is the maximum where N is the number of elements in x0. 
    eps : float 
        A suitable step length for the forward-difference approximation of 
        the Jacobian (for Dfun=None). If `eps` is less than the machine 
        precision, it is assumed that the relative errors in the functions 
        are of the order of the machine precision. 
    factor : float 
        A parameter determining the initial step bound 
        (``factor * || diag * x||``). Should be in interval ``(0.1, 100)``. 
    diag : sequence 
        N positive entries that serve as a scale factors for the variables. 
    &quot;&quot;&quot;</span>
    <span class="s1">nfev </span><span class="s2">= </span><span class="s5">0</span>
    <span class="s4">def </span><span class="s1">_wrapped_fun</span><span class="s2">(*</span><span class="s1">fargs</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Wrapped `func` to track the number of times 
        the function has been called. 
        &quot;&quot;&quot;</span>
        <span class="s4">nonlocal </span><span class="s1">nfev</span>
        <span class="s1">nfev </span><span class="s2">+= </span><span class="s5">1</span>
        <span class="s4">return </span><span class="s1">fun</span><span class="s2">(*</span><span class="s1">fargs</span><span class="s2">)</span>

    <span class="s1">_check_unknown_options</span><span class="s2">(</span><span class="s1">unknown_options</span><span class="s2">)</span>
    <span class="s1">x</span><span class="s2">, </span><span class="s1">cov_x</span><span class="s2">, </span><span class="s1">info</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">ier </span><span class="s2">= </span><span class="s1">leastsq</span><span class="s2">(</span><span class="s1">_wrapped_fun</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">,</span>
                                       <span class="s1">Dfun</span><span class="s2">=</span><span class="s1">jac</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s4">True</span><span class="s2">,</span>
                                       <span class="s1">col_deriv</span><span class="s2">=</span><span class="s1">col_deriv</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s1">xtol</span><span class="s2">,</span>
                                       <span class="s1">ftol</span><span class="s2">=</span><span class="s1">ftol</span><span class="s2">, </span><span class="s1">gtol</span><span class="s2">=</span><span class="s1">gtol</span><span class="s2">,</span>
                                       <span class="s1">maxfev</span><span class="s2">=</span><span class="s1">maxiter</span><span class="s2">, </span><span class="s1">epsfcn</span><span class="s2">=</span><span class="s1">eps</span><span class="s2">,</span>
                                       <span class="s1">factor</span><span class="s2">=</span><span class="s1">factor</span><span class="s2">, </span><span class="s1">diag</span><span class="s2">=</span><span class="s1">diag</span><span class="s2">)</span>
    <span class="s1">sol </span><span class="s2">= </span><span class="s1">OptimizeResult</span><span class="s2">(</span><span class="s1">x</span><span class="s2">=</span><span class="s1">x</span><span class="s2">, </span><span class="s1">message</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">status</span><span class="s2">=</span><span class="s1">ier</span><span class="s2">,</span>
                         <span class="s1">success</span><span class="s2">=</span><span class="s1">ier </span><span class="s4">in </span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">), </span><span class="s1">cov_x</span><span class="s2">=</span><span class="s1">cov_x</span><span class="s2">,</span>
                         <span class="s1">fun</span><span class="s2">=</span><span class="s1">info</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(</span><span class="s3">'fvec'</span><span class="s2">), </span><span class="s1">method</span><span class="s2">=</span><span class="s3">&quot;lm&quot;</span><span class="s2">)</span>
    <span class="s1">sol</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">info</span><span class="s2">)</span>
    <span class="s1">sol</span><span class="s2">.</span><span class="s1">nfev </span><span class="s2">= </span><span class="s1">nfev</span>
    <span class="s4">return </span><span class="s1">sol</span>


<span class="s4">def </span><span class="s1">_root_nonlin_solve</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(), </span><span class="s1">jac</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                       <span class="s1">_callback</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">_method</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                       <span class="s1">nit</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s4">False</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                       <span class="s1">ftol</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">fatol</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">xatol</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                       <span class="s1">tol_norm</span><span class="s2">=</span><span class="s4">None</span><span class="s2">, </span><span class="s1">line_search</span><span class="s2">=</span><span class="s3">'armijo'</span><span class="s2">, </span><span class="s1">jac_options</span><span class="s2">=</span><span class="s4">None</span><span class="s2">,</span>
                       <span class="s2">**</span><span class="s1">unknown_options</span><span class="s2">):</span>
    <span class="s1">_check_unknown_options</span><span class="s2">(</span><span class="s1">unknown_options</span><span class="s2">)</span>

    <span class="s1">f_tol </span><span class="s2">= </span><span class="s1">fatol</span>
    <span class="s1">f_rtol </span><span class="s2">= </span><span class="s1">ftol</span>
    <span class="s1">x_tol </span><span class="s2">= </span><span class="s1">xatol</span>
    <span class="s1">x_rtol </span><span class="s2">= </span><span class="s1">xtol</span>
    <span class="s1">verbose </span><span class="s2">= </span><span class="s1">disp</span>
    <span class="s4">if </span><span class="s1">jac_options </span><span class="s4">is None</span><span class="s2">:</span>
        <span class="s1">jac_options </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">()</span>

    <span class="s1">jacobian </span><span class="s2">= {</span><span class="s3">'broyden1'</span><span class="s2">: </span><span class="s1">nonlin</span><span class="s2">.</span><span class="s1">BroydenFirst</span><span class="s2">,</span>
                <span class="s3">'broyden2'</span><span class="s2">: </span><span class="s1">nonlin</span><span class="s2">.</span><span class="s1">BroydenSecond</span><span class="s2">,</span>
                <span class="s3">'anderson'</span><span class="s2">: </span><span class="s1">nonlin</span><span class="s2">.</span><span class="s1">Anderson</span><span class="s2">,</span>
                <span class="s3">'linearmixing'</span><span class="s2">: </span><span class="s1">nonlin</span><span class="s2">.</span><span class="s1">LinearMixing</span><span class="s2">,</span>
                <span class="s3">'diagbroyden'</span><span class="s2">: </span><span class="s1">nonlin</span><span class="s2">.</span><span class="s1">DiagBroyden</span><span class="s2">,</span>
                <span class="s3">'excitingmixing'</span><span class="s2">: </span><span class="s1">nonlin</span><span class="s2">.</span><span class="s1">ExcitingMixing</span><span class="s2">,</span>
                <span class="s3">'krylov'</span><span class="s2">: </span><span class="s1">nonlin</span><span class="s2">.</span><span class="s1">KrylovJacobian</span>
                <span class="s2">}[</span><span class="s1">_method</span><span class="s2">]</span>

    <span class="s4">if </span><span class="s1">args</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s1">jac </span><span class="s4">is True</span><span class="s2">:</span>
            <span class="s4">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
                <span class="s4">return </span><span class="s1">fun</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s4">else</span><span class="s2">:</span>
            <span class="s4">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
                <span class="s4">return </span><span class="s1">fun</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">args</span><span class="s2">)</span>
    <span class="s4">else</span><span class="s2">:</span>
        <span class="s1">f </span><span class="s2">= </span><span class="s1">fun</span>

    <span class="s1">x</span><span class="s2">, </span><span class="s1">info </span><span class="s2">= </span><span class="s1">nonlin</span><span class="s2">.</span><span class="s1">nonlin_solve</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">jacobian</span><span class="s2">=</span><span class="s1">jacobian</span><span class="s2">(**</span><span class="s1">jac_options</span><span class="s2">),</span>
                                  <span class="s1">iter</span><span class="s2">=</span><span class="s1">nit</span><span class="s2">, </span><span class="s1">verbose</span><span class="s2">=</span><span class="s1">verbose</span><span class="s2">,</span>
                                  <span class="s1">maxiter</span><span class="s2">=</span><span class="s1">maxiter</span><span class="s2">, </span><span class="s1">f_tol</span><span class="s2">=</span><span class="s1">f_tol</span><span class="s2">,</span>
                                  <span class="s1">f_rtol</span><span class="s2">=</span><span class="s1">f_rtol</span><span class="s2">, </span><span class="s1">x_tol</span><span class="s2">=</span><span class="s1">x_tol</span><span class="s2">,</span>
                                  <span class="s1">x_rtol</span><span class="s2">=</span><span class="s1">x_rtol</span><span class="s2">, </span><span class="s1">tol_norm</span><span class="s2">=</span><span class="s1">tol_norm</span><span class="s2">,</span>
                                  <span class="s1">line_search</span><span class="s2">=</span><span class="s1">line_search</span><span class="s2">,</span>
                                  <span class="s1">callback</span><span class="s2">=</span><span class="s1">_callback</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s4">True</span><span class="s2">,</span>
                                  <span class="s1">raise_exception</span><span class="s2">=</span><span class="s4">False</span><span class="s2">)</span>
    <span class="s1">sol </span><span class="s2">= </span><span class="s1">OptimizeResult</span><span class="s2">(</span><span class="s1">x</span><span class="s2">=</span><span class="s1">x</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s1">_method</span><span class="s2">)</span>
    <span class="s1">sol</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">info</span><span class="s2">)</span>
    <span class="s4">return </span><span class="s1">sol</span>

<span class="s4">def </span><span class="s1">_root_broyden1_doc</span><span class="s2">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Options 
    ------- 
    nit : int, optional 
        Number of iterations to make. If omitted (default), make as many 
        as required to meet tolerances. 
    disp : bool, optional 
        Print status to stdout on every iteration. 
    maxiter : int, optional 
        Maximum number of iterations to make. 
    ftol : float, optional 
        Relative tolerance for the residual. If omitted, not used. 
    fatol : float, optional 
        Absolute tolerance (in max-norm) for the residual. 
        If omitted, default is 6e-6. 
    xtol : float, optional 
        Relative minimum step size. If omitted, not used. 
    xatol : float, optional 
        Absolute minimum step size, as determined from the Jacobian 
        approximation. If the step size is smaller than this, optimization 
        is terminated as successful. If omitted, not used. 
    tol_norm : function(vector) -&gt; scalar, optional 
        Norm to use in convergence check. Default is the maximum norm. 
    line_search : {None, 'armijo' (default), 'wolfe'}, optional 
        Which type of a line search to use to determine the step size in 
        the direction given by the Jacobian approximation. Defaults to 
        'armijo'. 
    jac_options : dict, optional 
        Options for the respective Jacobian approximation. 
            alpha : float, optional 
                Initial guess for the Jacobian is (-1/alpha). 
            reduction_method : str or tuple, optional 
                Method used in ensuring that the rank of the Broyden 
                matrix stays low. Can either be a string giving the 
                name of the method, or a tuple of the form ``(method, 
                param1, param2, ...)`` that gives the name of the 
                method and values for additional parameters. 
 
                Methods available: 
 
                    - ``restart`` 
                        Drop all matrix columns. Has no 
                        extra parameters. 
                    - ``simple`` 
                        Drop oldest matrix column. Has no 
                        extra parameters. 
                    - ``svd`` 
                        Keep only the most significant SVD 
                        components. 
 
                        Extra parameters: 
 
                            - ``to_retain`` 
                                Number of SVD components to 
                                retain when rank reduction is done. 
                                Default is ``max_rank - 2``. 
            max_rank : int, optional 
                Maximum rank for the Broyden matrix. 
                Default is infinity (i.e., no rank reduction). 
 
    Examples 
    -------- 
    &gt;&gt;&gt; def func(x): 
    ...     return np.cos(x) + x[::-1] - [1, 2, 3, 4] 
    ... 
    &gt;&gt;&gt; from scipy import optimize 
    &gt;&gt;&gt; res = optimize.root(func, [1, 1, 1, 1], method='broyden1', tol=1e-14) 
    &gt;&gt;&gt; x = res.x 
    &gt;&gt;&gt; x 
    array([4.04674914, 3.91158389, 2.71791677, 1.61756251]) 
    &gt;&gt;&gt; np.cos(x) + x[::-1] 
    array([1., 2., 3., 4.]) 
 
    &quot;&quot;&quot;</span>
    <span class="s4">pass</span>

<span class="s4">def </span><span class="s1">_root_broyden2_doc</span><span class="s2">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Options 
    ------- 
    nit : int, optional 
        Number of iterations to make. If omitted (default), make as many 
        as required to meet tolerances. 
    disp : bool, optional 
        Print status to stdout on every iteration. 
    maxiter : int, optional 
        Maximum number of iterations to make. 
    ftol : float, optional 
        Relative tolerance for the residual. If omitted, not used. 
    fatol : float, optional 
        Absolute tolerance (in max-norm) for the residual. 
        If omitted, default is 6e-6. 
    xtol : float, optional 
        Relative minimum step size. If omitted, not used. 
    xatol : float, optional 
        Absolute minimum step size, as determined from the Jacobian 
        approximation. If the step size is smaller than this, optimization 
        is terminated as successful. If omitted, not used. 
    tol_norm : function(vector) -&gt; scalar, optional 
        Norm to use in convergence check. Default is the maximum norm. 
    line_search : {None, 'armijo' (default), 'wolfe'}, optional 
        Which type of a line search to use to determine the step size in 
        the direction given by the Jacobian approximation. Defaults to 
        'armijo'. 
    jac_options : dict, optional 
        Options for the respective Jacobian approximation. 
 
        alpha : float, optional 
            Initial guess for the Jacobian is (-1/alpha). 
        reduction_method : str or tuple, optional 
            Method used in ensuring that the rank of the Broyden 
            matrix stays low. Can either be a string giving the 
            name of the method, or a tuple of the form ``(method, 
            param1, param2, ...)`` that gives the name of the 
            method and values for additional parameters. 
 
            Methods available: 
 
                - ``restart`` 
                    Drop all matrix columns. Has no 
                    extra parameters. 
                - ``simple`` 
                    Drop oldest matrix column. Has no 
                    extra parameters. 
                - ``svd`` 
                    Keep only the most significant SVD 
                    components. 
 
                    Extra parameters: 
 
                        - ``to_retain`` 
                            Number of SVD components to 
                            retain when rank reduction is done. 
                            Default is ``max_rank - 2``. 
        max_rank : int, optional 
            Maximum rank for the Broyden matrix. 
            Default is infinity (i.e., no rank reduction). 
    &quot;&quot;&quot;</span>
    <span class="s4">pass</span>

<span class="s4">def </span><span class="s1">_root_anderson_doc</span><span class="s2">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Options 
    ------- 
    nit : int, optional 
        Number of iterations to make. If omitted (default), make as many 
        as required to meet tolerances. 
    disp : bool, optional 
        Print status to stdout on every iteration. 
    maxiter : int, optional 
        Maximum number of iterations to make. 
    ftol : float, optional 
        Relative tolerance for the residual. If omitted, not used. 
    fatol : float, optional 
        Absolute tolerance (in max-norm) for the residual. 
        If omitted, default is 6e-6. 
    xtol : float, optional 
        Relative minimum step size. If omitted, not used. 
    xatol : float, optional 
        Absolute minimum step size, as determined from the Jacobian 
        approximation. If the step size is smaller than this, optimization 
        is terminated as successful. If omitted, not used. 
    tol_norm : function(vector) -&gt; scalar, optional 
        Norm to use in convergence check. Default is the maximum norm. 
    line_search : {None, 'armijo' (default), 'wolfe'}, optional 
        Which type of a line search to use to determine the step size in 
        the direction given by the Jacobian approximation. Defaults to 
        'armijo'. 
    jac_options : dict, optional 
        Options for the respective Jacobian approximation. 
 
        alpha : float, optional 
            Initial guess for the Jacobian is (-1/alpha). 
        M : float, optional 
            Number of previous vectors to retain. Defaults to 5. 
        w0 : float, optional 
            Regularization parameter for numerical stability. 
            Compared to unity, good values of the order of 0.01. 
    &quot;&quot;&quot;</span>
    <span class="s4">pass</span>

<span class="s4">def </span><span class="s1">_root_linearmixing_doc</span><span class="s2">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Options 
    ------- 
    nit : int, optional 
        Number of iterations to make. If omitted (default), make as many 
        as required to meet tolerances. 
    disp : bool, optional 
        Print status to stdout on every iteration. 
    maxiter : int, optional 
        Maximum number of iterations to make. 
    ftol : float, optional 
        Relative tolerance for the residual. If omitted, not used. 
    fatol : float, optional 
        Absolute tolerance (in max-norm) for the residual. 
        If omitted, default is 6e-6. 
    xtol : float, optional 
        Relative minimum step size. If omitted, not used. 
    xatol : float, optional 
        Absolute minimum step size, as determined from the Jacobian 
        approximation. If the step size is smaller than this, optimization 
        is terminated as successful. If omitted, not used. 
    tol_norm : function(vector) -&gt; scalar, optional 
        Norm to use in convergence check. Default is the maximum norm. 
    line_search : {None, 'armijo' (default), 'wolfe'}, optional 
        Which type of a line search to use to determine the step size in 
        the direction given by the Jacobian approximation. Defaults to 
        'armijo'. 
    jac_options : dict, optional 
        Options for the respective Jacobian approximation. 
 
        alpha : float, optional 
            initial guess for the jacobian is (-1/alpha). 
    &quot;&quot;&quot;</span>
    <span class="s4">pass</span>

<span class="s4">def </span><span class="s1">_root_diagbroyden_doc</span><span class="s2">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Options 
    ------- 
    nit : int, optional 
        Number of iterations to make. If omitted (default), make as many 
        as required to meet tolerances. 
    disp : bool, optional 
        Print status to stdout on every iteration. 
    maxiter : int, optional 
        Maximum number of iterations to make. 
    ftol : float, optional 
        Relative tolerance for the residual. If omitted, not used. 
    fatol : float, optional 
        Absolute tolerance (in max-norm) for the residual. 
        If omitted, default is 6e-6. 
    xtol : float, optional 
        Relative minimum step size. If omitted, not used. 
    xatol : float, optional 
        Absolute minimum step size, as determined from the Jacobian 
        approximation. If the step size is smaller than this, optimization 
        is terminated as successful. If omitted, not used. 
    tol_norm : function(vector) -&gt; scalar, optional 
        Norm to use in convergence check. Default is the maximum norm. 
    line_search : {None, 'armijo' (default), 'wolfe'}, optional 
        Which type of a line search to use to determine the step size in 
        the direction given by the Jacobian approximation. Defaults to 
        'armijo'. 
    jac_options : dict, optional 
        Options for the respective Jacobian approximation. 
 
        alpha : float, optional 
            initial guess for the jacobian is (-1/alpha). 
    &quot;&quot;&quot;</span>
    <span class="s4">pass</span>

<span class="s4">def </span><span class="s1">_root_excitingmixing_doc</span><span class="s2">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Options 
    ------- 
    nit : int, optional 
        Number of iterations to make. If omitted (default), make as many 
        as required to meet tolerances. 
    disp : bool, optional 
        Print status to stdout on every iteration. 
    maxiter : int, optional 
        Maximum number of iterations to make. 
    ftol : float, optional 
        Relative tolerance for the residual. If omitted, not used. 
    fatol : float, optional 
        Absolute tolerance (in max-norm) for the residual. 
        If omitted, default is 6e-6. 
    xtol : float, optional 
        Relative minimum step size. If omitted, not used. 
    xatol : float, optional 
        Absolute minimum step size, as determined from the Jacobian 
        approximation. If the step size is smaller than this, optimization 
        is terminated as successful. If omitted, not used. 
    tol_norm : function(vector) -&gt; scalar, optional 
        Norm to use in convergence check. Default is the maximum norm. 
    line_search : {None, 'armijo' (default), 'wolfe'}, optional 
        Which type of a line search to use to determine the step size in 
        the direction given by the Jacobian approximation. Defaults to 
        'armijo'. 
    jac_options : dict, optional 
        Options for the respective Jacobian approximation. 
 
        alpha : float, optional 
            Initial Jacobian approximation is (-1/alpha). 
        alphamax : float, optional 
            The entries of the diagonal Jacobian are kept in the range 
            ``[alpha, alphamax]``. 
    &quot;&quot;&quot;</span>
    <span class="s4">pass</span>

<span class="s4">def </span><span class="s1">_root_krylov_doc</span><span class="s2">():</span>
    <span class="s0">&quot;&quot;&quot; 
    Options 
    ------- 
    nit : int, optional 
        Number of iterations to make. If omitted (default), make as many 
        as required to meet tolerances. 
    disp : bool, optional 
        Print status to stdout on every iteration. 
    maxiter : int, optional 
        Maximum number of iterations to make. 
    ftol : float, optional 
        Relative tolerance for the residual. If omitted, not used. 
    fatol : float, optional 
        Absolute tolerance (in max-norm) for the residual. 
        If omitted, default is 6e-6. 
    xtol : float, optional 
        Relative minimum step size. If omitted, not used. 
    xatol : float, optional 
        Absolute minimum step size, as determined from the Jacobian 
        approximation. If the step size is smaller than this, optimization 
        is terminated as successful. If omitted, not used. 
    tol_norm : function(vector) -&gt; scalar, optional 
        Norm to use in convergence check. Default is the maximum norm. 
    line_search : {None, 'armijo' (default), 'wolfe'}, optional 
        Which type of a line search to use to determine the step size in 
        the direction given by the Jacobian approximation. Defaults to 
        'armijo'. 
    jac_options : dict, optional 
        Options for the respective Jacobian approximation. 
 
        rdiff : float, optional 
            Relative step size to use in numerical differentiation. 
        method : str or callable, optional 
            Krylov method to use to approximate the Jacobian.  Can be a string, 
            or a function implementing the same interface as the iterative 
            solvers in `scipy.sparse.linalg`. If a string, needs to be one of: 
            ``'lgmres'``, ``'gmres'``, ``'bicgstab'``, ``'cgs'``, ``'minres'``, 
            ``'tfqmr'``. 
 
            The default is `scipy.sparse.linalg.lgmres`. 
        inner_M : LinearOperator or InverseJacobian 
            Preconditioner for the inner Krylov iteration. 
            Note that you can use also inverse Jacobians as (adaptive) 
            preconditioners. For example, 
 
            &gt;&gt;&gt; jac = BroydenFirst() 
            &gt;&gt;&gt; kjac = KrylovJacobian(inner_M=jac.inverse). 
 
            If the preconditioner has a method named 'update', it will 
            be called as ``update(x, f)`` after each nonlinear step, 
            with ``x`` giving the current point, and ``f`` the current 
            function value. 
        inner_tol, inner_maxiter, ... 
            Parameters to pass on to the &quot;inner&quot; Krylov solver. 
            See `scipy.sparse.linalg.gmres` for details. 
        outer_k : int, optional 
            Size of the subspace kept across LGMRES nonlinear 
            iterations. 
 
            See `scipy.sparse.linalg.lgmres` for details. 
    &quot;&quot;&quot;</span>
    <span class="s4">pass</span>
</pre>
</body>
</html>