<html>
<head>
<title>test_dask.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #7a7e85;}
.s5 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_dask.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">print_function</span><span class="s2">, </span><span class="s1">division</span><span class="s2">, </span><span class="s1">absolute_import</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">random </span><span class="s0">import </span><span class="s1">random</span>
<span class="s0">from </span><span class="s1">uuid </span><span class="s0">import </span><span class="s1">uuid4</span>
<span class="s0">from </span><span class="s1">time </span><span class="s0">import </span><span class="s1">sleep</span>

<span class="s0">from </span><span class="s2">.. </span><span class="s0">import </span><span class="s1">Parallel</span><span class="s2">, </span><span class="s1">delayed</span><span class="s2">, </span><span class="s1">parallel_config</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">parallel </span><span class="s0">import </span><span class="s1">ThreadingBackend</span><span class="s2">, </span><span class="s1">AutoBatchingMixin</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">_dask </span><span class="s0">import </span><span class="s1">DaskDistributedBackend</span>

<span class="s1">distributed </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">importorskip</span><span class="s2">(</span><span class="s3">'distributed'</span><span class="s2">)</span>
<span class="s1">dask </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">importorskip</span><span class="s2">(</span><span class="s3">'dask'</span><span class="s2">)</span>

<span class="s4"># These imports need to be after the pytest.importorskip hence the noqa: E402</span>
<span class="s0">from </span><span class="s1">distributed </span><span class="s0">import </span><span class="s1">Client</span><span class="s2">, </span><span class="s1">LocalCluster</span><span class="s2">, </span><span class="s1">get_client  </span><span class="s4"># noqa: E402</span>
<span class="s0">from </span><span class="s1">distributed</span><span class="s2">.</span><span class="s1">metrics </span><span class="s0">import </span><span class="s1">time  </span><span class="s4"># noqa: E402</span>
<span class="s4"># Note: pytest requires to manually import all fixtures used in the test</span>
<span class="s4"># and their dependencies.</span>
<span class="s0">from </span><span class="s1">distributed</span><span class="s2">.</span><span class="s1">utils_test </span><span class="s0">import </span><span class="s1">cluster</span><span class="s2">, </span><span class="s1">inc</span><span class="s2">, </span><span class="s1">cleanup  </span><span class="s4"># noqa: E402, F401</span>


<span class="s0">def </span><span class="s1">noop</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
    <span class="s0">pass</span>


<span class="s0">def </span><span class="s1">slow_raise_value_error</span><span class="s2">(</span><span class="s1">condition</span><span class="s2">, </span><span class="s1">duration</span><span class="s2">=</span><span class="s5">0.05</span><span class="s2">):</span>
    <span class="s1">sleep</span><span class="s2">(</span><span class="s1">duration</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">condition</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s3">&quot;condition evaluated to True&quot;</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">count_events</span><span class="s2">(</span><span class="s1">event_name</span><span class="s2">, </span><span class="s1">client</span><span class="s2">):</span>
    <span class="s1">worker_events </span><span class="s2">= </span><span class="s1">client</span><span class="s2">.</span><span class="s1">run</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">dask_worker</span><span class="s2">: </span><span class="s1">dask_worker</span><span class="s2">.</span><span class="s1">log</span><span class="s2">)</span>
    <span class="s1">event_counts </span><span class="s2">= {}</span>
    <span class="s0">for </span><span class="s1">w</span><span class="s2">, </span><span class="s1">events </span><span class="s0">in </span><span class="s1">worker_events</span><span class="s2">.</span><span class="s1">items</span><span class="s2">():</span>
        <span class="s1">event_counts</span><span class="s2">[</span><span class="s1">w</span><span class="s2">] = </span><span class="s1">len</span><span class="s2">([</span><span class="s1">event </span><span class="s0">for </span><span class="s1">event </span><span class="s0">in </span><span class="s1">list</span><span class="s2">(</span><span class="s1">events</span><span class="s2">)</span>
                               <span class="s0">if </span><span class="s1">event</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] == </span><span class="s1">event_name</span><span class="s2">])</span>
    <span class="s0">return </span><span class="s1">event_counts</span>


<span class="s0">def </span><span class="s1">test_simple</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">):</span>
    <span class="s0">with </span><span class="s1">cluster</span><span class="s2">() </span><span class="s0">as </span><span class="s2">(</span><span class="s1">s</span><span class="s2">, [</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">]):</span>
        <span class="s0">with </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">s</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">], </span><span class="s1">loop</span><span class="s2">=</span><span class="s1">loop</span><span class="s2">) </span><span class="s0">as </span><span class="s1">client</span><span class="s2">:  </span><span class="s4"># noqa: F841</span>
            <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">):</span>
                <span class="s1">seq </span><span class="s2">= </span><span class="s1">Parallel</span><span class="s2">()(</span><span class="s1">delayed</span><span class="s2">(</span><span class="s1">inc</span><span class="s2">)(</span><span class="s1">i</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">10</span><span class="s2">))</span>
                <span class="s0">assert </span><span class="s1">seq </span><span class="s2">== [</span><span class="s1">inc</span><span class="s2">(</span><span class="s1">i</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">10</span><span class="s2">)]</span>

                <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">):</span>
                    <span class="s1">Parallel</span><span class="s2">()(</span><span class="s1">delayed</span><span class="s2">(</span><span class="s1">slow_raise_value_error</span><span class="s2">)(</span><span class="s1">i </span><span class="s2">== </span><span class="s5">3</span><span class="s2">)</span>
                               <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">10</span><span class="s2">))</span>

                <span class="s1">seq </span><span class="s2">= </span><span class="s1">Parallel</span><span class="s2">()(</span><span class="s1">delayed</span><span class="s2">(</span><span class="s1">inc</span><span class="s2">)(</span><span class="s1">i</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">10</span><span class="s2">))</span>
                <span class="s0">assert </span><span class="s1">seq </span><span class="s2">== [</span><span class="s1">inc</span><span class="s2">(</span><span class="s1">i</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">10</span><span class="s2">)]</span>


<span class="s0">def </span><span class="s1">test_dask_backend_uses_autobatching</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">):</span>
    <span class="s0">assert </span><span class="s2">(</span><span class="s1">DaskDistributedBackend</span><span class="s2">.</span><span class="s1">compute_batch_size</span>
            <span class="s0">is </span><span class="s1">AutoBatchingMixin</span><span class="s2">.</span><span class="s1">compute_batch_size</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">cluster</span><span class="s2">() </span><span class="s0">as </span><span class="s2">(</span><span class="s1">s</span><span class="s2">, [</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">]):</span>
        <span class="s0">with </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">s</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">], </span><span class="s1">loop</span><span class="s2">=</span><span class="s1">loop</span><span class="s2">) </span><span class="s0">as </span><span class="s1">client</span><span class="s2">:  </span><span class="s4"># noqa: F841</span>
            <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">):</span>
                <span class="s0">with </span><span class="s1">Parallel</span><span class="s2">() </span><span class="s0">as </span><span class="s1">parallel</span><span class="s2">:</span>
                    <span class="s4"># The backend should be initialized with a default</span>
                    <span class="s4"># batch size of 1:</span>
                    <span class="s1">backend </span><span class="s2">= </span><span class="s1">parallel</span><span class="s2">.</span><span class="s1">_backend</span>
                    <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">, </span><span class="s1">DaskDistributedBackend</span><span class="s2">)</span>
                    <span class="s0">assert </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">parallel </span><span class="s0">is </span><span class="s1">parallel</span>
                    <span class="s0">assert </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">_effective_batch_size </span><span class="s2">== </span><span class="s5">1</span>

                    <span class="s4"># Launch many short tasks that should trigger</span>
                    <span class="s4"># auto-batching:</span>
                    <span class="s1">parallel</span><span class="s2">(</span>
                        <span class="s1">delayed</span><span class="s2">(</span><span class="s0">lambda</span><span class="s2">: </span><span class="s0">None</span><span class="s2">)()</span>
                        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">int</span><span class="s2">(</span><span class="s5">1e4</span><span class="s2">))</span>
                    <span class="s2">)</span>
                    <span class="s0">assert </span><span class="s1">backend</span><span class="s2">.</span><span class="s1">_effective_batch_size </span><span class="s2">&gt; </span><span class="s5">10</span>


<span class="s0">def </span><span class="s1">random2</span><span class="s2">():</span>
    <span class="s0">return </span><span class="s1">random</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">test_dont_assume_function_purity</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">):</span>
    <span class="s0">with </span><span class="s1">cluster</span><span class="s2">() </span><span class="s0">as </span><span class="s2">(</span><span class="s1">s</span><span class="s2">, [</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">]):</span>
        <span class="s0">with </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">s</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">], </span><span class="s1">loop</span><span class="s2">=</span><span class="s1">loop</span><span class="s2">) </span><span class="s0">as </span><span class="s1">client</span><span class="s2">:  </span><span class="s4"># noqa: F841</span>
            <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">):</span>
                <span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">= </span><span class="s1">Parallel</span><span class="s2">()(</span><span class="s1">delayed</span><span class="s2">(</span><span class="s1">random2</span><span class="s2">)() </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">2</span><span class="s2">))</span>
                <span class="s0">assert </span><span class="s1">x </span><span class="s2">!= </span><span class="s1">y</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s3">&quot;mixed&quot;</span><span class="s2">, [</span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">])</span>
<span class="s0">def </span><span class="s1">test_dask_funcname</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">, </span><span class="s1">mixed</span><span class="s2">):</span>
    <span class="s0">from </span><span class="s1">joblib</span><span class="s2">.</span><span class="s1">_dask </span><span class="s0">import </span><span class="s1">Batch</span>
    <span class="s0">if not </span><span class="s1">mixed</span><span class="s2">:</span>
        <span class="s1">tasks </span><span class="s2">= [</span><span class="s1">delayed</span><span class="s2">(</span><span class="s1">inc</span><span class="s2">)(</span><span class="s1">i</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">4</span><span class="s2">)]</span>
        <span class="s1">batch_repr </span><span class="s2">= </span><span class="s3">'batch_of_inc_4_calls'</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">tasks </span><span class="s2">= [</span>
            <span class="s1">delayed</span><span class="s2">(</span><span class="s1">abs</span><span class="s2">)(</span><span class="s1">i</span><span class="s2">) </span><span class="s0">if </span><span class="s1">i </span><span class="s2">% </span><span class="s5">2 </span><span class="s0">else </span><span class="s1">delayed</span><span class="s2">(</span><span class="s1">inc</span><span class="s2">)(</span><span class="s1">i</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">4</span><span class="s2">)</span>
        <span class="s2">]</span>
        <span class="s1">batch_repr </span><span class="s2">= </span><span class="s3">'mixed_batch_of_inc_4_calls'</span>

    <span class="s0">assert </span><span class="s1">repr</span><span class="s2">(</span><span class="s1">Batch</span><span class="s2">(</span><span class="s1">tasks</span><span class="s2">)) == </span><span class="s1">batch_repr</span>

    <span class="s0">with </span><span class="s1">cluster</span><span class="s2">() </span><span class="s0">as </span><span class="s2">(</span><span class="s1">s</span><span class="s2">, [</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">]):</span>
        <span class="s0">with </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">s</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">], </span><span class="s1">loop</span><span class="s2">=</span><span class="s1">loop</span><span class="s2">) </span><span class="s0">as </span><span class="s1">client</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">):</span>
                <span class="s1">_ </span><span class="s2">= </span><span class="s1">Parallel</span><span class="s2">(</span><span class="s1">batch_size</span><span class="s2">=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">pre_dispatch</span><span class="s2">=</span><span class="s3">'all'</span><span class="s2">)(</span><span class="s1">tasks</span><span class="s2">)</span>

            <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">dask_scheduler</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s1">list</span><span class="s2">(</span><span class="s1">dask_scheduler</span><span class="s2">.</span><span class="s1">transition_log</span><span class="s2">)</span>
            <span class="s1">batch_repr </span><span class="s2">= </span><span class="s1">batch_repr</span><span class="s2">.</span><span class="s1">replace</span><span class="s2">(</span><span class="s3">'4'</span><span class="s2">, </span><span class="s3">'2'</span><span class="s2">)</span>
            <span class="s1">log </span><span class="s2">= </span><span class="s1">client</span><span class="s2">.</span><span class="s1">run_on_scheduler</span><span class="s2">(</span><span class="s1">f</span><span class="s2">)</span>
            <span class="s0">assert </span><span class="s1">all</span><span class="s2">(</span><span class="s3">'batch_of_inc' </span><span class="s0">in </span><span class="s1">tup</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] </span><span class="s0">for </span><span class="s1">tup </span><span class="s0">in </span><span class="s1">log</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_no_undesired_distributed_cache_hit</span><span class="s2">():</span>
    <span class="s4"># Dask has a pickle cache for callables that are called many times. Because</span>
    <span class="s4"># the dask backends used to wrap both the functions and the arguments</span>
    <span class="s4"># under instances of the Batch callable class this caching mechanism could</span>
    <span class="s4"># lead to bugs as described in: https://github.com/joblib/joblib/pull/1055</span>
    <span class="s4"># The joblib-dask backend has been refactored to avoid bundling the</span>
    <span class="s4"># arguments as an attribute of the Batch instance to avoid this problem.</span>
    <span class="s4"># This test serves as non-regression problem.</span>

    <span class="s4"># Use a large number of input arguments to give the AutoBatchingMixin</span>
    <span class="s4"># enough tasks to kick-in.</span>
    <span class="s1">lists </span><span class="s2">= [[] </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">100</span><span class="s2">)]</span>
    <span class="s1">np </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">importorskip</span><span class="s2">(</span><span class="s3">'numpy'</span><span class="s2">)</span>
    <span class="s1">X </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">int</span><span class="s2">(</span><span class="s5">1e6</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">isolated_operation</span><span class="s2">(</span><span class="s1">list_</span><span class="s2">, </span><span class="s1">data</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">data </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">testing</span><span class="s2">.</span><span class="s1">assert_array_equal</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">X</span><span class="s2">)</span>
        <span class="s1">list_</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">uuid4</span><span class="s2">().</span><span class="s1">hex</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">list_</span>

    <span class="s1">cluster </span><span class="s2">= </span><span class="s1">LocalCluster</span><span class="s2">(</span><span class="s1">n_workers</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">threads_per_worker</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>
    <span class="s1">client </span><span class="s2">= </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">cluster</span><span class="s2">)</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">):</span>
            <span class="s4"># dispatches joblib.parallel.BatchedCalls</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">Parallel</span><span class="s2">()(</span>
                <span class="s1">delayed</span><span class="s2">(</span><span class="s1">isolated_operation</span><span class="s2">)(</span><span class="s1">list_</span><span class="s2">) </span><span class="s0">for </span><span class="s1">list_ </span><span class="s0">in </span><span class="s1">lists</span>
            <span class="s2">)</span>

        <span class="s4"># The original arguments should not have been mutated as the mutation</span>
        <span class="s4"># happens in the dask worker process.</span>
        <span class="s0">assert </span><span class="s1">lists </span><span class="s2">== [[] </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">100</span><span class="s2">)]</span>

        <span class="s4"># Here we did not pass any large numpy array as argument to</span>
        <span class="s4"># isolated_operation so no scattering event should happen under the</span>
        <span class="s4"># hood.</span>
        <span class="s1">counts </span><span class="s2">= </span><span class="s1">count_events</span><span class="s2">(</span><span class="s3">'receive-from-scatter'</span><span class="s2">, </span><span class="s1">client</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">counts</span><span class="s2">.</span><span class="s1">values</span><span class="s2">()) == </span><span class="s5">0</span>
        <span class="s0">assert </span><span class="s1">all</span><span class="s2">([</span><span class="s1">len</span><span class="s2">(</span><span class="s1">r</span><span class="s2">) == </span><span class="s5">1 </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">res</span><span class="s2">])</span>

        <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">):</span>
            <span class="s4"># Append a large array which will be scattered by dask, and</span>
            <span class="s4"># dispatch joblib._dask.Batch</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">Parallel</span><span class="s2">()(</span>
                <span class="s1">delayed</span><span class="s2">(</span><span class="s1">isolated_operation</span><span class="s2">)(</span><span class="s1">list_</span><span class="s2">, </span><span class="s1">data</span><span class="s2">=</span><span class="s1">X</span><span class="s2">) </span><span class="s0">for </span><span class="s1">list_ </span><span class="s0">in </span><span class="s1">lists</span>
            <span class="s2">)</span>

        <span class="s4"># This time, auto-scattering should have kicked it.</span>
        <span class="s1">counts </span><span class="s2">= </span><span class="s1">count_events</span><span class="s2">(</span><span class="s3">'receive-from-scatter'</span><span class="s2">, </span><span class="s1">client</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">counts</span><span class="s2">.</span><span class="s1">values</span><span class="s2">()) &gt; </span><span class="s5">0</span>
        <span class="s0">assert </span><span class="s1">all</span><span class="s2">([</span><span class="s1">len</span><span class="s2">(</span><span class="s1">r</span><span class="s2">) == </span><span class="s5">1 </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">res</span><span class="s2">])</span>
    <span class="s0">finally</span><span class="s2">:</span>
        <span class="s1">client</span><span class="s2">.</span><span class="s1">close</span><span class="s2">(</span><span class="s1">timeout</span><span class="s2">=</span><span class="s5">30</span><span class="s2">)</span>
        <span class="s1">cluster</span><span class="s2">.</span><span class="s1">close</span><span class="s2">(</span><span class="s1">timeout</span><span class="s2">=</span><span class="s5">30</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">CountSerialized</span><span class="s2">(</span><span class="s1">object</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">x </span><span class="s2">= </span><span class="s1">x</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">count </span><span class="s2">= </span><span class="s5">0</span>

    <span class="s0">def </span><span class="s1">__add__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">x </span><span class="s2">+ </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s3">'x'</span><span class="s2">, </span><span class="s1">other</span><span class="s2">)</span>

    <span class="s1">__radd__ </span><span class="s2">= </span><span class="s1">__add__</span>

    <span class="s0">def </span><span class="s1">__reduce__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">count </span><span class="s2">+= </span><span class="s5">1</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s1">CountSerialized</span><span class="s2">, (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">x</span><span class="s2">,))</span>


<span class="s0">def </span><span class="s1">add5</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">e</span><span class="s2">=</span><span class="s5">0</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">a </span><span class="s2">+ </span><span class="s1">b </span><span class="s2">+ </span><span class="s1">c </span><span class="s2">+ </span><span class="s1">d </span><span class="s2">+ </span><span class="s1">e</span>


<span class="s0">def </span><span class="s1">test_manual_scatter</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">):</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">CountSerialized</span><span class="s2">(</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">CountSerialized</span><span class="s2">(</span><span class="s5">2</span><span class="s2">)</span>
    <span class="s1">z </span><span class="s2">= </span><span class="s1">CountSerialized</span><span class="s2">(</span><span class="s5">3</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">cluster</span><span class="s2">() </span><span class="s0">as </span><span class="s2">(</span><span class="s1">s</span><span class="s2">, [</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">]):</span>
        <span class="s0">with </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">s</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">], </span><span class="s1">loop</span><span class="s2">=</span><span class="s1">loop</span><span class="s2">) </span><span class="s0">as </span><span class="s1">client</span><span class="s2">:  </span><span class="s4"># noqa: F841</span>
            <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">, </span><span class="s1">scatter</span><span class="s2">=[</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">]):</span>
                <span class="s1">f </span><span class="s2">= </span><span class="s1">delayed</span><span class="s2">(</span><span class="s1">add5</span><span class="s2">)</span>
                <span class="s1">tasks </span><span class="s2">= [</span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">d</span><span class="s2">=</span><span class="s5">4</span><span class="s2">, </span><span class="s1">e</span><span class="s2">=</span><span class="s5">5</span><span class="s2">),</span>
                         <span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">d</span><span class="s2">=</span><span class="s5">5</span><span class="s2">, </span><span class="s1">e</span><span class="s2">=</span><span class="s5">4</span><span class="s2">),</span>
                         <span class="s1">f</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">d</span><span class="s2">=</span><span class="s1">x</span><span class="s2">, </span><span class="s1">e</span><span class="s2">=</span><span class="s5">5</span><span class="s2">),</span>
                         <span class="s1">f</span><span class="s2">(</span><span class="s1">z</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">d</span><span class="s2">=</span><span class="s1">z</span><span class="s2">, </span><span class="s1">e</span><span class="s2">=</span><span class="s1">y</span><span class="s2">)]</span>
                <span class="s1">expected </span><span class="s2">= [</span><span class="s1">func</span><span class="s2">(*</span><span class="s1">args</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
                            <span class="s0">for </span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs </span><span class="s0">in </span><span class="s1">tasks</span><span class="s2">]</span>
                <span class="s1">results </span><span class="s2">= </span><span class="s1">Parallel</span><span class="s2">()(</span><span class="s1">tasks</span><span class="s2">)</span>

            <span class="s4"># Scatter must take a list/tuple</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">):</span>
                <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">, </span><span class="s1">loop</span><span class="s2">=</span><span class="s1">loop</span><span class="s2">, </span><span class="s1">scatter</span><span class="s2">=</span><span class="s5">1</span><span class="s2">):</span>
                    <span class="s0">pass</span>

    <span class="s0">assert </span><span class="s1">results </span><span class="s2">== </span><span class="s1">expected</span>

    <span class="s4"># Scattered variables only serialized once</span>
    <span class="s0">assert </span><span class="s1">x</span><span class="s2">.</span><span class="s1">count </span><span class="s2">== </span><span class="s5">1</span>
    <span class="s0">assert </span><span class="s1">y</span><span class="s2">.</span><span class="s1">count </span><span class="s2">== </span><span class="s5">1</span>
    <span class="s4"># Depending on the version of distributed, the unscattered z variable</span>
    <span class="s4"># is either pickled 4 or 6 times, possibly because of the memoization</span>
    <span class="s4"># of objects that appear several times in the arguments of a delayed</span>
    <span class="s4"># task.</span>
    <span class="s0">assert </span><span class="s1">z</span><span class="s2">.</span><span class="s1">count </span><span class="s0">in </span><span class="s2">(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">6</span><span class="s2">)</span>


<span class="s4"># When the same IOLoop is used for multiple clients in a row, use</span>
<span class="s4"># loop_in_thread instead of loop to prevent the Client from closing it.  See</span>
<span class="s4"># dask/distributed #4112</span>
<span class="s0">def </span><span class="s1">test_auto_scatter</span><span class="s2">(</span><span class="s1">loop_in_thread</span><span class="s2">):</span>
    <span class="s1">np </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">importorskip</span><span class="s2">(</span><span class="s3">'numpy'</span><span class="s2">)</span>
    <span class="s1">data1 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">int</span><span class="s2">(</span><span class="s5">1e4</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
    <span class="s1">data2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">int</span><span class="s2">(</span><span class="s5">1e4</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint8</span><span class="s2">)</span>
    <span class="s1">data_to_process </span><span class="s2">= ([</span><span class="s1">data1</span><span class="s2">] * </span><span class="s5">3</span><span class="s2">) + ([</span><span class="s1">data2</span><span class="s2">] * </span><span class="s5">3</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">cluster</span><span class="s2">() </span><span class="s0">as </span><span class="s2">(</span><span class="s1">s</span><span class="s2">, [</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">]):</span>
        <span class="s0">with </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">s</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">], </span><span class="s1">loop</span><span class="s2">=</span><span class="s1">loop_in_thread</span><span class="s2">) </span><span class="s0">as </span><span class="s1">client</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">):</span>
                <span class="s4"># Passing the same data as arg and kwarg triggers a single</span>
                <span class="s4"># scatter operation whose result is reused.</span>
                <span class="s1">Parallel</span><span class="s2">()(</span><span class="s1">delayed</span><span class="s2">(</span><span class="s1">noop</span><span class="s2">)(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">opt</span><span class="s2">=</span><span class="s1">data</span><span class="s2">)</span>
                           <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">data </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">data_to_process</span><span class="s2">))</span>
            <span class="s4"># By default large array are automatically scattered with</span>
            <span class="s4"># broadcast=1 which means that one worker must directly receive</span>
            <span class="s4"># the data from the scatter operation once.</span>
            <span class="s1">counts </span><span class="s2">= </span><span class="s1">count_events</span><span class="s2">(</span><span class="s3">'receive-from-scatter'</span><span class="s2">, </span><span class="s1">client</span><span class="s2">)</span>
            <span class="s0">assert </span><span class="s1">counts</span><span class="s2">[</span><span class="s1">a</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">]] + </span><span class="s1">counts</span><span class="s2">[</span><span class="s1">b</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">]] == </span><span class="s5">2</span>

    <span class="s0">with </span><span class="s1">cluster</span><span class="s2">() </span><span class="s0">as </span><span class="s2">(</span><span class="s1">s</span><span class="s2">, [</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">]):</span>
        <span class="s0">with </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">s</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">], </span><span class="s1">loop</span><span class="s2">=</span><span class="s1">loop_in_thread</span><span class="s2">) </span><span class="s0">as </span><span class="s1">client</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">):</span>
                <span class="s1">Parallel</span><span class="s2">()(</span><span class="s1">delayed</span><span class="s2">(</span><span class="s1">noop</span><span class="s2">)(</span><span class="s1">data1</span><span class="s2">[:</span><span class="s5">3</span><span class="s2">], </span><span class="s1">i</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">5</span><span class="s2">))</span>
            <span class="s4"># Small arrays are passed within the task definition without going</span>
            <span class="s4"># through a scatter operation.</span>
            <span class="s1">counts </span><span class="s2">= </span><span class="s1">count_events</span><span class="s2">(</span><span class="s3">'receive-from-scatter'</span><span class="s2">, </span><span class="s1">client</span><span class="s2">)</span>
            <span class="s0">assert </span><span class="s1">counts</span><span class="s2">[</span><span class="s1">a</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">]] == </span><span class="s5">0</span>
            <span class="s0">assert </span><span class="s1">counts</span><span class="s2">[</span><span class="s1">b</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">]] == </span><span class="s5">0</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s3">&quot;retry_no&quot;</span><span class="s2">, </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s5">2</span><span class="s2">)))</span>
<span class="s0">def </span><span class="s1">test_nested_scatter</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">, </span><span class="s1">retry_no</span><span class="s2">):</span>

    <span class="s1">np </span><span class="s2">= </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">importorskip</span><span class="s2">(</span><span class="s3">'numpy'</span><span class="s2">)</span>

    <span class="s1">NUM_INNER_TASKS </span><span class="s2">= </span><span class="s5">10</span>
    <span class="s1">NUM_OUTER_TASKS </span><span class="s2">= </span><span class="s5">10</span>

    <span class="s0">def </span><span class="s1">my_sum</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">outer_function_joblib</span><span class="s2">(</span><span class="s1">array</span><span class="s2">, </span><span class="s1">i</span><span class="s2">):</span>
        <span class="s1">client </span><span class="s2">= </span><span class="s1">get_client</span><span class="s2">()  </span><span class="s4"># noqa</span>
        <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">&quot;dask&quot;</span><span class="s2">):</span>
            <span class="s1">results </span><span class="s2">= </span><span class="s1">Parallel</span><span class="s2">()(</span>
                <span class="s1">delayed</span><span class="s2">(</span><span class="s1">my_sum</span><span class="s2">)(</span><span class="s1">array</span><span class="s2">[</span><span class="s1">j</span><span class="s2">:], </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">) </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span>
                    <span class="s1">NUM_INNER_TASKS</span><span class="s2">)</span>
            <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">results</span><span class="s2">)</span>

    <span class="s0">with </span><span class="s1">cluster</span><span class="s2">() </span><span class="s0">as </span><span class="s2">(</span><span class="s1">s</span><span class="s2">, [</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">]):</span>
        <span class="s0">with </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">s</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">], </span><span class="s1">loop</span><span class="s2">=</span><span class="s1">loop</span><span class="s2">) </span><span class="s0">as </span><span class="s1">_</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">&quot;dask&quot;</span><span class="s2">):</span>
                <span class="s1">my_array </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s5">10000</span><span class="s2">)</span>
                <span class="s1">_ </span><span class="s2">= </span><span class="s1">Parallel</span><span class="s2">()(</span>
                    <span class="s1">delayed</span><span class="s2">(</span><span class="s1">outer_function_joblib</span><span class="s2">)(</span>
                        <span class="s1">my_array</span><span class="s2">[</span><span class="s1">i</span><span class="s2">:], </span><span class="s1">i</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">NUM_OUTER_TASKS</span><span class="s2">)</span>
                <span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_nested_backend_context_manager</span><span class="s2">(</span><span class="s1">loop_in_thread</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">get_nested_pids</span><span class="s2">():</span>
        <span class="s1">pids </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">Parallel</span><span class="s2">(</span><span class="s1">n_jobs</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)(</span><span class="s1">delayed</span><span class="s2">(</span><span class="s1">os</span><span class="s2">.</span><span class="s1">getpid</span><span class="s2">)() </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">2</span><span class="s2">)))</span>
        <span class="s1">pids </span><span class="s2">|= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">Parallel</span><span class="s2">(</span><span class="s1">n_jobs</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)(</span><span class="s1">delayed</span><span class="s2">(</span><span class="s1">os</span><span class="s2">.</span><span class="s1">getpid</span><span class="s2">)() </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">2</span><span class="s2">)))</span>
        <span class="s0">return </span><span class="s1">pids</span>

    <span class="s0">with </span><span class="s1">cluster</span><span class="s2">() </span><span class="s0">as </span><span class="s2">(</span><span class="s1">s</span><span class="s2">, [</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">]):</span>
        <span class="s0">with </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">s</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">], </span><span class="s1">loop</span><span class="s2">=</span><span class="s1">loop_in_thread</span><span class="s2">) </span><span class="s0">as </span><span class="s1">client</span><span class="s2">:</span>
            <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">):</span>
                <span class="s1">pid_groups </span><span class="s2">= </span><span class="s1">Parallel</span><span class="s2">(</span><span class="s1">n_jobs</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)(</span>
                    <span class="s1">delayed</span><span class="s2">(</span><span class="s1">get_nested_pids</span><span class="s2">)()</span>
                    <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">10</span><span class="s2">)</span>
                <span class="s2">)</span>
                <span class="s0">for </span><span class="s1">pid_group </span><span class="s0">in </span><span class="s1">pid_groups</span><span class="s2">:</span>
                    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">pid_group</span><span class="s2">)) &lt;= </span><span class="s5">2</span>

        <span class="s4"># No deadlocks</span>
        <span class="s0">with </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">s</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">], </span><span class="s1">loop</span><span class="s2">=</span><span class="s1">loop_in_thread</span><span class="s2">) </span><span class="s0">as </span><span class="s1">client</span><span class="s2">:  </span><span class="s4"># noqa: F841</span>
            <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">):</span>
                <span class="s1">pid_groups </span><span class="s2">= </span><span class="s1">Parallel</span><span class="s2">(</span><span class="s1">n_jobs</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)(</span>
                    <span class="s1">delayed</span><span class="s2">(</span><span class="s1">get_nested_pids</span><span class="s2">)()</span>
                    <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">10</span><span class="s2">)</span>
                <span class="s2">)</span>
                <span class="s0">for </span><span class="s1">pid_group </span><span class="s0">in </span><span class="s1">pid_groups</span><span class="s2">:</span>
                    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">pid_group</span><span class="s2">)) &lt;= </span><span class="s5">2</span>


<span class="s0">def </span><span class="s1">test_nested_backend_context_manager_implicit_n_jobs</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">):</span>
    <span class="s4"># Check that Parallel with no explicit n_jobs value automatically selects</span>
    <span class="s4"># all the dask workers, including in nested calls.</span>

    <span class="s0">def </span><span class="s1">_backend_type</span><span class="s2">(</span><span class="s1">p</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">p</span><span class="s2">.</span><span class="s1">_backend</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span>

    <span class="s0">def </span><span class="s1">get_nested_implicit_n_jobs</span><span class="s2">():</span>
        <span class="s0">with </span><span class="s1">Parallel</span><span class="s2">() </span><span class="s0">as </span><span class="s1">p</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">_backend_type</span><span class="s2">(</span><span class="s1">p</span><span class="s2">), </span><span class="s1">p</span><span class="s2">.</span><span class="s1">n_jobs</span>

    <span class="s0">with </span><span class="s1">cluster</span><span class="s2">() </span><span class="s0">as </span><span class="s2">(</span><span class="s1">s</span><span class="s2">, [</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">]):</span>
        <span class="s0">with </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">s</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">], </span><span class="s1">loop</span><span class="s2">=</span><span class="s1">loop</span><span class="s2">) </span><span class="s0">as </span><span class="s1">client</span><span class="s2">:  </span><span class="s4"># noqa: F841</span>
            <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">):</span>
                <span class="s0">with </span><span class="s1">Parallel</span><span class="s2">() </span><span class="s0">as </span><span class="s1">p</span><span class="s2">:</span>
                    <span class="s0">assert </span><span class="s1">_backend_type</span><span class="s2">(</span><span class="s1">p</span><span class="s2">) == </span><span class="s3">&quot;DaskDistributedBackend&quot;</span>
                    <span class="s0">assert </span><span class="s1">p</span><span class="s2">.</span><span class="s1">n_jobs </span><span class="s2">== -</span><span class="s5">1</span>
                    <span class="s1">all_nested_n_jobs </span><span class="s2">= </span><span class="s1">p</span><span class="s2">(</span>
                        <span class="s1">delayed</span><span class="s2">(</span><span class="s1">get_nested_implicit_n_jobs</span><span class="s2">)()</span>
                        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">2</span><span class="s2">)</span>
                    <span class="s2">)</span>
                <span class="s0">for </span><span class="s1">backend_type</span><span class="s2">, </span><span class="s1">nested_n_jobs </span><span class="s0">in </span><span class="s1">all_nested_n_jobs</span><span class="s2">:</span>
                    <span class="s0">assert </span><span class="s1">backend_type </span><span class="s2">== </span><span class="s3">&quot;DaskDistributedBackend&quot;</span>
                    <span class="s0">assert </span><span class="s1">nested_n_jobs </span><span class="s2">== -</span><span class="s5">1</span>


<span class="s0">def </span><span class="s1">test_errors</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">):</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">) </span><span class="s0">as </span><span class="s1">info</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">):</span>
            <span class="s0">pass</span>

    <span class="s0">assert </span><span class="s3">&quot;create a dask client&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">info</span><span class="s2">.</span><span class="s1">value</span><span class="s2">).</span><span class="s1">lower</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">test_correct_nested_backend</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">):</span>
    <span class="s0">with </span><span class="s1">cluster</span><span class="s2">() </span><span class="s0">as </span><span class="s2">(</span><span class="s1">s</span><span class="s2">, [</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">]):</span>
        <span class="s0">with </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">s</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">], </span><span class="s1">loop</span><span class="s2">=</span><span class="s1">loop</span><span class="s2">) </span><span class="s0">as </span><span class="s1">client</span><span class="s2">:  </span><span class="s4"># noqa: F841</span>
            <span class="s4"># No requirement, should be us</span>
            <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">):</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">Parallel</span><span class="s2">(</span><span class="s1">n_jobs</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)(</span>
                    <span class="s1">delayed</span><span class="s2">(</span><span class="s1">outer</span><span class="s2">)(</span><span class="s1">nested_require</span><span class="s2">=</span><span class="s0">None</span><span class="s2">) </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">1</span><span class="s2">))</span>
                <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">[</span><span class="s5">0</span><span class="s2">][</span><span class="s5">0</span><span class="s2">][</span><span class="s5">0</span><span class="s2">], </span><span class="s1">DaskDistributedBackend</span><span class="s2">)</span>

            <span class="s4"># Require threads, should be threading</span>
            <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">):</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">Parallel</span><span class="s2">(</span><span class="s1">n_jobs</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)(</span>
                    <span class="s1">delayed</span><span class="s2">(</span><span class="s1">outer</span><span class="s2">)(</span><span class="s1">nested_require</span><span class="s2">=</span><span class="s3">'sharedmem'</span><span class="s2">)</span>
                    <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">1</span><span class="s2">))</span>
                <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">result</span><span class="s2">[</span><span class="s5">0</span><span class="s2">][</span><span class="s5">0</span><span class="s2">][</span><span class="s5">0</span><span class="s2">], </span><span class="s1">ThreadingBackend</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">outer</span><span class="s2">(</span><span class="s1">nested_require</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">Parallel</span><span class="s2">(</span><span class="s1">n_jobs</span><span class="s2">=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">prefer</span><span class="s2">=</span><span class="s3">'threads'</span><span class="s2">)(</span>
        <span class="s1">delayed</span><span class="s2">(</span><span class="s1">middle</span><span class="s2">)(</span><span class="s1">nested_require</span><span class="s2">) </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">middle</span><span class="s2">(</span><span class="s1">require</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">Parallel</span><span class="s2">(</span><span class="s1">n_jobs</span><span class="s2">=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">require</span><span class="s2">=</span><span class="s1">require</span><span class="s2">)(</span>
        <span class="s1">delayed</span><span class="s2">(</span><span class="s1">inner</span><span class="s2">)() </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">1</span><span class="s2">)</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">inner</span><span class="s2">():</span>
    <span class="s0">return </span><span class="s1">Parallel</span><span class="s2">().</span><span class="s1">_backend</span>


<span class="s0">def </span><span class="s1">test_secede_with_no_processes</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">):</span>
    <span class="s4"># https://github.com/dask/distributed/issues/1775</span>
    <span class="s0">with </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">=</span><span class="s1">loop</span><span class="s2">, </span><span class="s1">processes</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">set_as_default</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
        <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">):</span>
            <span class="s1">Parallel</span><span class="s2">(</span><span class="s1">n_jobs</span><span class="s2">=</span><span class="s5">4</span><span class="s2">)(</span><span class="s1">delayed</span><span class="s2">(</span><span class="s1">id</span><span class="s2">)(</span><span class="s1">i</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">2</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">_worker_address</span><span class="s2">(</span><span class="s1">_</span><span class="s2">):</span>
    <span class="s0">from </span><span class="s1">distributed </span><span class="s0">import </span><span class="s1">get_worker</span>
    <span class="s0">return </span><span class="s1">get_worker</span><span class="s2">().</span><span class="s1">address</span>


<span class="s0">def </span><span class="s1">test_dask_backend_keywords</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">):</span>
    <span class="s0">with </span><span class="s1">cluster</span><span class="s2">() </span><span class="s0">as </span><span class="s2">(</span><span class="s1">s</span><span class="s2">, [</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">]):</span>
        <span class="s0">with </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">s</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">], </span><span class="s1">loop</span><span class="s2">=</span><span class="s1">loop</span><span class="s2">) </span><span class="s0">as </span><span class="s1">client</span><span class="s2">:  </span><span class="s4"># noqa: F841</span>
            <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">, </span><span class="s1">workers</span><span class="s2">=</span><span class="s1">a</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">]):</span>
                <span class="s1">seq </span><span class="s2">= </span><span class="s1">Parallel</span><span class="s2">()(</span>
                    <span class="s1">delayed</span><span class="s2">(</span><span class="s1">_worker_address</span><span class="s2">)(</span><span class="s1">i</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">10</span><span class="s2">))</span>
                <span class="s0">assert </span><span class="s1">seq </span><span class="s2">== [</span><span class="s1">a</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">]] * </span><span class="s5">10</span>

            <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">, </span><span class="s1">workers</span><span class="s2">=</span><span class="s1">b</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">]):</span>
                <span class="s1">seq </span><span class="s2">= </span><span class="s1">Parallel</span><span class="s2">()(</span>
                    <span class="s1">delayed</span><span class="s2">(</span><span class="s1">_worker_address</span><span class="s2">)(</span><span class="s1">i</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">10</span><span class="s2">))</span>
                <span class="s0">assert </span><span class="s1">seq </span><span class="s2">== [</span><span class="s1">b</span><span class="s2">[</span><span class="s3">'address'</span><span class="s2">]] * </span><span class="s5">10</span>


<span class="s0">def </span><span class="s1">test_scheduler_tasks_cleanup</span><span class="s2">(</span><span class="s1">loop</span><span class="s2">):</span>
    <span class="s0">with </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">processes</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">loop</span><span class="s2">=</span><span class="s1">loop</span><span class="s2">) </span><span class="s0">as </span><span class="s1">client</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">):</span>
            <span class="s1">Parallel</span><span class="s2">()(</span><span class="s1">delayed</span><span class="s2">(</span><span class="s1">inc</span><span class="s2">)(</span><span class="s1">i</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">10</span><span class="s2">))</span>

        <span class="s1">start </span><span class="s2">= </span><span class="s1">time</span><span class="s2">()</span>
        <span class="s0">while </span><span class="s1">client</span><span class="s2">.</span><span class="s1">cluster</span><span class="s2">.</span><span class="s1">scheduler</span><span class="s2">.</span><span class="s1">tasks</span><span class="s2">:</span>
            <span class="s1">sleep</span><span class="s2">(</span><span class="s5">0.01</span><span class="s2">)</span>
            <span class="s0">assert </span><span class="s1">time</span><span class="s2">() &lt; </span><span class="s1">start </span><span class="s2">+ </span><span class="s5">5</span>

        <span class="s0">assert not </span><span class="s1">client</span><span class="s2">.</span><span class="s1">futures</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s3">&quot;cluster_strategy&quot;</span><span class="s2">, [</span><span class="s3">&quot;adaptive&quot;</span><span class="s2">, </span><span class="s3">&quot;late_scaling&quot;</span><span class="s2">])</span>
<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">skipif</span><span class="s2">(</span>
    <span class="s1">distributed</span><span class="s2">.</span><span class="s1">__version__ </span><span class="s2">&lt;= </span><span class="s3">'2.1.1' </span><span class="s0">and </span><span class="s1">distributed</span><span class="s2">.</span><span class="s1">__version__ </span><span class="s2">&gt;= </span><span class="s3">'1.28.0'</span><span class="s2">,</span>
    <span class="s1">reason</span><span class="s2">=</span><span class="s3">&quot;distributed bug - https://github.com/dask/distributed/pull/2841&quot;</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">test_wait_for_workers</span><span class="s2">(</span><span class="s1">cluster_strategy</span><span class="s2">):</span>
    <span class="s1">cluster </span><span class="s2">= </span><span class="s1">LocalCluster</span><span class="s2">(</span><span class="s1">n_workers</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">processes</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">threads_per_worker</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>
    <span class="s1">client </span><span class="s2">= </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">cluster</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">cluster_strategy </span><span class="s2">== </span><span class="s3">&quot;adaptive&quot;</span><span class="s2">:</span>
        <span class="s1">cluster</span><span class="s2">.</span><span class="s1">adapt</span><span class="s2">(</span><span class="s1">minimum</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">maximum</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">cluster_strategy </span><span class="s2">== </span><span class="s3">&quot;late_scaling&quot;</span><span class="s2">:</span>
        <span class="s4"># Tell the cluster to start workers but this is a non-blocking call</span>
        <span class="s4"># and new workers might take time to connect. In this case the Parallel</span>
        <span class="s4"># call should wait for at least one worker to come up before starting</span>
        <span class="s4"># to schedule work.</span>
        <span class="s1">cluster</span><span class="s2">.</span><span class="s1">scale</span><span class="s2">(</span><span class="s5">2</span><span class="s2">)</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">):</span>
            <span class="s4"># The following should wait a bit for at least one worker to</span>
            <span class="s4"># become available.</span>
            <span class="s1">Parallel</span><span class="s2">()(</span><span class="s1">delayed</span><span class="s2">(</span><span class="s1">inc</span><span class="s2">)(</span><span class="s1">i</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">10</span><span class="s2">))</span>
    <span class="s0">finally</span><span class="s2">:</span>
        <span class="s1">client</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>
        <span class="s1">cluster</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">test_wait_for_workers_timeout</span><span class="s2">():</span>
    <span class="s4"># Start a cluster with 0 worker:</span>
    <span class="s1">cluster </span><span class="s2">= </span><span class="s1">LocalCluster</span><span class="s2">(</span><span class="s1">n_workers</span><span class="s2">=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">processes</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">threads_per_worker</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>
    <span class="s1">client </span><span class="s2">= </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">cluster</span><span class="s2">)</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">, </span><span class="s1">wait_for_workers_timeout</span><span class="s2">=</span><span class="s5">0.1</span><span class="s2">):</span>
            <span class="s4"># Short timeout: DaskDistributedBackend</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s3">&quot;DaskDistributedBackend has no worker after 0.1 seconds.&quot;</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TimeoutError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">):</span>
                <span class="s1">Parallel</span><span class="s2">()(</span><span class="s1">delayed</span><span class="s2">(</span><span class="s1">inc</span><span class="s2">)(</span><span class="s1">i</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">10</span><span class="s2">))</span>

        <span class="s0">with </span><span class="s1">parallel_config</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">=</span><span class="s3">'dask'</span><span class="s2">, </span><span class="s1">wait_for_workers_timeout</span><span class="s2">=</span><span class="s5">0</span><span class="s2">):</span>
            <span class="s4"># No timeout: fallback to generic joblib failure:</span>
            <span class="s1">msg </span><span class="s2">= </span><span class="s3">&quot;DaskDistributedBackend has no active worker&quot;</span>
            <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">):</span>
                <span class="s1">Parallel</span><span class="s2">()(</span><span class="s1">delayed</span><span class="s2">(</span><span class="s1">inc</span><span class="s2">)(</span><span class="s1">i</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">10</span><span class="s2">))</span>
    <span class="s0">finally</span><span class="s2">:</span>
        <span class="s1">client</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>
        <span class="s1">cluster</span><span class="s2">.</span><span class="s1">close</span><span class="s2">()</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s3">&quot;backend&quot;</span><span class="s2">, [</span><span class="s3">&quot;loky&quot;</span><span class="s2">, </span><span class="s3">&quot;multiprocessing&quot;</span><span class="s2">])</span>
<span class="s0">def </span><span class="s1">test_joblib_warning_inside_dask_daemonic_worker</span><span class="s2">(</span><span class="s1">backend</span><span class="s2">):</span>
    <span class="s1">cluster </span><span class="s2">= </span><span class="s1">LocalCluster</span><span class="s2">(</span><span class="s1">n_workers</span><span class="s2">=</span><span class="s5">2</span><span class="s2">)</span>
    <span class="s1">client </span><span class="s2">= </span><span class="s1">Client</span><span class="s2">(</span><span class="s1">cluster</span><span class="s2">)</span>
    <span class="s0">try</span><span class="s2">:</span>

        <span class="s0">def </span><span class="s1">func_using_joblib_parallel</span><span class="s2">():</span>
            <span class="s4"># Somehow trying to check the warning type here (e.g. with</span>
            <span class="s4"># pytest.warns(UserWarning)) make the test hang. Work-around:</span>
            <span class="s4"># return the warning record to the client and the warning check is</span>
            <span class="s4"># done client-side.</span>
            <span class="s0">with </span><span class="s1">warnings</span><span class="s2">.</span><span class="s1">catch_warnings</span><span class="s2">(</span><span class="s1">record</span><span class="s2">=</span><span class="s0">True</span><span class="s2">) </span><span class="s0">as </span><span class="s1">record</span><span class="s2">:</span>
                <span class="s1">Parallel</span><span class="s2">(</span><span class="s1">n_jobs</span><span class="s2">=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">=</span><span class="s1">backend</span><span class="s2">)(</span>
                    <span class="s1">delayed</span><span class="s2">(</span><span class="s1">inc</span><span class="s2">)(</span><span class="s1">i</span><span class="s2">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s5">10</span><span class="s2">))</span>

            <span class="s0">return </span><span class="s1">record</span>

        <span class="s1">fut </span><span class="s2">= </span><span class="s1">client</span><span class="s2">.</span><span class="s1">submit</span><span class="s2">(</span><span class="s1">func_using_joblib_parallel</span><span class="s2">)</span>
        <span class="s1">record </span><span class="s2">= </span><span class="s1">fut</span><span class="s2">.</span><span class="s1">result</span><span class="s2">()</span>

        <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">record</span><span class="s2">) == </span><span class="s5">1</span>
        <span class="s1">warning </span><span class="s2">= </span><span class="s1">record</span><span class="s2">[</span><span class="s5">0</span><span class="s2">].</span><span class="s1">message</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">warning</span><span class="s2">, </span><span class="s1">UserWarning</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s3">&quot;distributed.worker.daemon&quot; </span><span class="s0">in </span><span class="s1">str</span><span class="s2">(</span><span class="s1">warning</span><span class="s2">)</span>
    <span class="s0">finally</span><span class="s2">:</span>
        <span class="s1">client</span><span class="s2">.</span><span class="s1">close</span><span class="s2">(</span><span class="s1">timeout</span><span class="s2">=</span><span class="s5">30</span><span class="s2">)</span>
        <span class="s1">cluster</span><span class="s2">.</span><span class="s1">close</span><span class="s2">(</span><span class="s1">timeout</span><span class="s2">=</span><span class="s5">30</span><span class="s2">)</span>
</pre>
</body>
</html>