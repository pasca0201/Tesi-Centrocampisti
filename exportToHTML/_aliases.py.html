<html>
<head>
<title>_aliases.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_aliases.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
These are functions that are just aliases of existing functions in NumPy. 
&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s2">if </span><span class="s1">TYPE_CHECKING</span><span class="s3">:</span>
    <span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
    <span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">, </span><span class="s1">Union</span>
    <span class="s2">from </span><span class="s3">.</span><span class="s1">_typing </span><span class="s2">import </span><span class="s1">ndarray</span><span class="s3">, </span><span class="s1">Device</span><span class="s3">, </span><span class="s1">Dtype</span><span class="s3">, </span><span class="s1">NestedSequence</span><span class="s3">, </span><span class="s1">SupportsBufferProtocol</span>

<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">NamedTuple</span>
<span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">ModuleType</span>
<span class="s2">import </span><span class="s1">inspect</span>

<span class="s2">from </span><span class="s3">.</span><span class="s1">_helpers </span><span class="s2">import </span><span class="s1">_check_device</span><span class="s3">, </span><span class="s1">is_numpy_array</span><span class="s3">, </span><span class="s1">array_namespace</span>

<span class="s4"># These functions are modified from the NumPy versions.</span>

<span class="s2">def </span><span class="s1">arange</span><span class="s3">(</span>
    <span class="s1">start</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">float</span><span class="s3">],</span>
    <span class="s3">/,</span>
    <span class="s1">stop</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">float</span><span class="s3">]] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">step</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">float</span><span class="s3">] = </span><span class="s5">1</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">xp</span><span class="s3">,</span>
    <span class="s1">dtype</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Dtype</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">device</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Device</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s1">_check_device</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s1">device</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">=</span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step</span><span class="s3">=</span><span class="s1">step</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">empty</span><span class="s3">(</span>
    <span class="s1">shape</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, ...]],</span>
    <span class="s1">xp</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">dtype</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Dtype</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">device</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Device</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s1">_check_device</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s1">device</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">empty_like</span><span class="s3">(</span>
    <span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, /, </span><span class="s1">xp</span><span class="s3">, *, </span><span class="s1">dtype</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Dtype</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">, </span><span class="s1">device</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Device</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s1">_check_device</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s1">device</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">empty_like</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">eye</span><span class="s3">(</span>
    <span class="s1">n_rows</span><span class="s3">: </span><span class="s1">int</span><span class="s3">,</span>
    <span class="s1">n_cols</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">int</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">/,</span>
    <span class="s3">*,</span>
    <span class="s1">xp</span><span class="s3">,</span>
    <span class="s1">k</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= </span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">dtype</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Dtype</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">device</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Device</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s1">_check_device</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s1">device</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">eye</span><span class="s3">(</span><span class="s1">n_rows</span><span class="s3">, </span><span class="s1">M</span><span class="s3">=</span><span class="s1">n_cols</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s1">k</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">full</span><span class="s3">(</span>
    <span class="s1">shape</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, ...]],</span>
    <span class="s1">fill_value</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">float</span><span class="s3">],</span>
    <span class="s1">xp</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">dtype</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Dtype</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">device</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Device</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s1">_check_device</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s1">device</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">full</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">full_like</span><span class="s3">(</span>
    <span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">,</span>
    <span class="s3">/,</span>
    <span class="s1">fill_value</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">float</span><span class="s3">],</span>
    <span class="s3">*,</span>
    <span class="s1">xp</span><span class="s3">,</span>
    <span class="s1">dtype</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Dtype</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">device</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Device</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s1">_check_device</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s1">device</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">full_like</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">fill_value</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">linspace</span><span class="s3">(</span>
    <span class="s1">start</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">float</span><span class="s3">],</span>
    <span class="s1">stop</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">float</span><span class="s3">],</span>
    <span class="s3">/,</span>
    <span class="s1">num</span><span class="s3">: </span><span class="s1">int</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">xp</span><span class="s3">,</span>
    <span class="s1">dtype</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Dtype</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">device</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Device</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">endpoint</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s1">_check_device</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s1">device</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">num</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">endpoint</span><span class="s3">=</span><span class="s1">endpoint</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">ones</span><span class="s3">(</span>
    <span class="s1">shape</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, ...]],</span>
    <span class="s1">xp</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">dtype</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Dtype</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">device</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Device</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s1">_check_device</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s1">device</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">ones_like</span><span class="s3">(</span>
    <span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, /, </span><span class="s1">xp</span><span class="s3">, *, </span><span class="s1">dtype</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Dtype</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">, </span><span class="s1">device</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Device</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s1">_check_device</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s1">device</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">ones_like</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">zeros</span><span class="s3">(</span>
    <span class="s1">shape</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, ...]],</span>
    <span class="s1">xp</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">dtype</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Dtype</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">device</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Device</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s1">_check_device</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s1">device</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">zeros_like</span><span class="s3">(</span>
    <span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, /, </span><span class="s1">xp</span><span class="s3">, *, </span><span class="s1">dtype</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Dtype</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">, </span><span class="s1">device</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Device</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s1">_check_device</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s1">device</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">zeros_like</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s4"># np.unique() is split into four functions in the array API:</span>
<span class="s4"># unique_all, unique_counts, unique_inverse, and unique_values (this is done</span>
<span class="s4"># to remove polymorphic return types).</span>

<span class="s4"># The functions here return namedtuples (np.unique() returns a normal</span>
<span class="s4"># tuple).</span>

<span class="s4"># Note that these named tuples aren't actually part of the standard namespace,</span>
<span class="s4"># but I don't see any issue with exporting the names here regardless.</span>
<span class="s2">class </span><span class="s1">UniqueAllResult</span><span class="s3">(</span><span class="s1">NamedTuple</span><span class="s3">):</span>
    <span class="s1">values</span><span class="s3">: </span><span class="s1">ndarray</span>
    <span class="s1">indices</span><span class="s3">: </span><span class="s1">ndarray</span>
    <span class="s1">inverse_indices</span><span class="s3">: </span><span class="s1">ndarray</span>
    <span class="s1">counts</span><span class="s3">: </span><span class="s1">ndarray</span>


<span class="s2">class </span><span class="s1">UniqueCountsResult</span><span class="s3">(</span><span class="s1">NamedTuple</span><span class="s3">):</span>
    <span class="s1">values</span><span class="s3">: </span><span class="s1">ndarray</span>
    <span class="s1">counts</span><span class="s3">: </span><span class="s1">ndarray</span>


<span class="s2">class </span><span class="s1">UniqueInverseResult</span><span class="s3">(</span><span class="s1">NamedTuple</span><span class="s3">):</span>
    <span class="s1">values</span><span class="s3">: </span><span class="s1">ndarray</span>
    <span class="s1">inverse_indices</span><span class="s3">: </span><span class="s1">ndarray</span>


<span class="s2">def </span><span class="s1">_unique_kwargs</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">):</span>
    <span class="s4"># Older versions of NumPy and CuPy do not have equal_nan. Rather than</span>
    <span class="s4"># trying to parse version numbers, just check if equal_nan is in the</span>
    <span class="s4"># signature.</span>
    <span class="s1">s </span><span class="s3">= </span><span class="s1">inspect</span><span class="s3">.</span><span class="s1">signature</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s6">'equal_nan' </span><span class="s2">in </span><span class="s1">s</span><span class="s3">.</span><span class="s1">parameters</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s3">{</span><span class="s6">'equal_nan'</span><span class="s3">: </span><span class="s2">False</span><span class="s3">}</span>
    <span class="s2">return </span><span class="s3">{}</span>

<span class="s2">def </span><span class="s1">unique_all</span><span class="s3">(</span><span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, /, </span><span class="s1">xp</span><span class="s3">) </span><span class="s1">-&gt; UniqueAllResult</span><span class="s3">:</span>
    <span class="s1">kwargs </span><span class="s3">= </span><span class="s1">_unique_kwargs</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">)</span>
    <span class="s1">values</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">inverse_indices</span><span class="s3">, </span><span class="s1">counts </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">return_counts</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">return_index</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">return_inverse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s4"># np.unique() flattens inverse indices, but they need to share x's shape</span>
    <span class="s4"># See https://github.com/numpy/numpy/issues/20638</span>
    <span class="s1">inverse_indices </span><span class="s3">= </span><span class="s1">inverse_indices</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">UniqueAllResult</span><span class="s3">(</span>
        <span class="s1">values</span><span class="s3">,</span>
        <span class="s1">indices</span><span class="s3">,</span>
        <span class="s1">inverse_indices</span><span class="s3">,</span>
        <span class="s1">counts</span><span class="s3">,</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">unique_counts</span><span class="s3">(</span><span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, /, </span><span class="s1">xp</span><span class="s3">) </span><span class="s1">-&gt; UniqueCountsResult</span><span class="s3">:</span>
    <span class="s1">kwargs </span><span class="s3">= </span><span class="s1">_unique_kwargs</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">)</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">return_counts</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s1">return_index</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">return_inverse</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span>
    <span class="s3">)</span>

    <span class="s2">return </span><span class="s1">UniqueCountsResult</span><span class="s3">(*</span><span class="s1">res</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">unique_inverse</span><span class="s3">(</span><span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, /, </span><span class="s1">xp</span><span class="s3">) </span><span class="s1">-&gt; UniqueInverseResult</span><span class="s3">:</span>
    <span class="s1">kwargs </span><span class="s3">= </span><span class="s1">_unique_kwargs</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">)</span>
    <span class="s1">values</span><span class="s3">, </span><span class="s1">inverse_indices </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">return_counts</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">return_index</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">return_inverse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">)</span>
    <span class="s4"># xp.unique() flattens inverse indices, but they need to share x's shape</span>
    <span class="s4"># See https://github.com/numpy/numpy/issues/20638</span>
    <span class="s1">inverse_indices </span><span class="s3">= </span><span class="s1">inverse_indices</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">UniqueInverseResult</span><span class="s3">(</span><span class="s1">values</span><span class="s3">, </span><span class="s1">inverse_indices</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">unique_values</span><span class="s3">(</span><span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, /, </span><span class="s1">xp</span><span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s1">kwargs </span><span class="s3">= </span><span class="s1">_unique_kwargs</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">return_counts</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">return_index</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s1">return_inverse</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
        <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
    <span class="s3">)</span>

<span class="s2">def </span><span class="s1">astype</span><span class="s3">(</span><span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">: </span><span class="s1">Dtype</span><span class="s3">, /, *, </span><span class="s1">copy</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s2">if not </span><span class="s1">copy </span><span class="s2">and </span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">x</span>
    <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">)</span>

<span class="s4"># These functions have different keyword argument names</span>

<span class="s2">def </span><span class="s1">std</span><span class="s3">(</span>
    <span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">,</span>
    <span class="s3">/,</span>
    <span class="s1">xp</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">axis</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, ...]]] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">correction</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">float</span><span class="s3">] = </span><span class="s5">0.0</span><span class="s3">, </span><span class="s4"># correction instead of ddof</span>
    <span class="s1">keepdims</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">std</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s1">correction</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s1">keepdims</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">var</span><span class="s3">(</span>
    <span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">,</span>
    <span class="s3">/,</span>
    <span class="s1">xp</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">axis</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, ...]]] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">correction</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">float</span><span class="s3">] = </span><span class="s5">0.0</span><span class="s3">, </span><span class="s4"># correction instead of ddof</span>
    <span class="s1">keepdims</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">var</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s1">correction</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s1">keepdims</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s4"># Unlike transpose(), the axes argument to permute_dims() is required.</span>
<span class="s2">def </span><span class="s1">permute_dims</span><span class="s3">(</span><span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, /, </span><span class="s1">axes</span><span class="s3">: </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, ...], </span><span class="s1">xp</span><span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">transpose</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">)</span>

<span class="s4"># Creation functions add the device keyword (which does nothing for NumPy)</span>

<span class="s4"># asarray also adds the copy keyword</span>
<span class="s2">def </span><span class="s1">_asarray</span><span class="s3">(</span>
    <span class="s1">obj</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span>
        <span class="s1">ndarray</span><span class="s3">,</span>
        <span class="s1">bool</span><span class="s3">,</span>
        <span class="s1">int</span><span class="s3">,</span>
        <span class="s1">float</span><span class="s3">,</span>
        <span class="s1">NestedSequence</span><span class="s3">[</span><span class="s1">bool </span><span class="s3">| </span><span class="s1">int </span><span class="s3">| </span><span class="s1">float</span><span class="s3">],</span>
        <span class="s1">SupportsBufferProtocol</span><span class="s3">,</span>
    <span class="s3">],</span>
    <span class="s3">/,</span>
    <span class="s3">*,</span>
    <span class="s1">dtype</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Dtype</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">device</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Device</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">copy</span><span class="s3">: </span><span class="s6">&quot;Optional[Union[bool, np._CopyMode]]&quot; </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">namespace </span><span class="s3">= </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Array API compatibility wrapper for asarray(). 
 
    See the corresponding documentation in NumPy/CuPy and/or the array API 
    specification for more details. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">namespace </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">xp </span><span class="s3">= </span><span class="s1">array_namespace</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">_use_compat</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">ValueError</span><span class="s3">:</span>
            <span class="s4"># TODO: What about lists of arrays?</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;A namespace must be specified for asarray() with non-array input&quot;</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">namespace</span><span class="s3">, </span><span class="s1">ModuleType</span><span class="s3">):</span>
        <span class="s1">xp </span><span class="s3">= </span><span class="s1">namespace</span>
    <span class="s2">elif </span><span class="s1">namespace </span><span class="s3">== </span><span class="s6">'numpy'</span><span class="s3">:</span>
        <span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">xp</span>
    <span class="s2">elif </span><span class="s1">namespace </span><span class="s3">== </span><span class="s6">'cupy'</span><span class="s3">:</span>
        <span class="s2">import </span><span class="s1">cupy </span><span class="s2">as </span><span class="s1">xp</span>
    <span class="s2">elif </span><span class="s1">namespace </span><span class="s3">== </span><span class="s6">'dask.array'</span><span class="s3">:</span>
        <span class="s2">import </span><span class="s1">dask</span><span class="s3">.</span><span class="s1">array </span><span class="s2">as </span><span class="s1">xp</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;Unrecognized namespace argument to asarray()&quot;</span><span class="s3">)</span>

    <span class="s1">_check_device</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s1">device</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">is_numpy_array</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">):</span>
        <span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">np</span><span class="s3">, </span><span class="s6">'_CopyMode'</span><span class="s3">):</span>
            <span class="s4"># Not present in older NumPys</span>
            <span class="s1">COPY_FALSE </span><span class="s3">= (</span><span class="s2">False</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">_CopyMode</span><span class="s3">.</span><span class="s1">IF_NEEDED</span><span class="s3">)</span>
            <span class="s1">COPY_TRUE </span><span class="s3">= (</span><span class="s2">True</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">_CopyMode</span><span class="s3">.</span><span class="s1">ALWAYS</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">COPY_FALSE </span><span class="s3">= (</span><span class="s2">False</span><span class="s3">,)</span>
            <span class="s1">COPY_TRUE </span><span class="s3">= (</span><span class="s2">True</span><span class="s3">,)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">COPY_FALSE </span><span class="s3">= (</span><span class="s2">False</span><span class="s3">,)</span>
        <span class="s1">COPY_TRUE </span><span class="s3">= (</span><span class="s2">True</span><span class="s3">,)</span>
    <span class="s2">if </span><span class="s1">copy </span><span class="s2">in </span><span class="s1">COPY_FALSE </span><span class="s2">and </span><span class="s1">namespace </span><span class="s3">!= </span><span class="s6">&quot;dask.array&quot;</span><span class="s3">:</span>
        <span class="s4"># copy=False is not yet implemented in xp.asarray</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s6">&quot;copy=False is not yet implemented&quot;</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s6">&quot;ndarray&quot;</span><span class="s3">) </span><span class="s2">and </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">)):</span>
        <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is not None and </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">!= </span><span class="s1">dtype</span><span class="s3">:</span>
            <span class="s1">copy </span><span class="s3">= </span><span class="s2">True</span>
        <span class="s2">if </span><span class="s1">copy </span><span class="s2">in </span><span class="s1">COPY_TRUE</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">obj</span>
    <span class="s2">elif </span><span class="s1">namespace </span><span class="s3">== </span><span class="s6">&quot;dask.array&quot;</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">copy </span><span class="s2">in </span><span class="s1">COPY_TRUE</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s4"># Go through numpy, since dask copy is no-op by default</span>
            <span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
            <span class="s1">obj </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">import </span><span class="s1">dask</span><span class="s3">.</span><span class="s1">array </span><span class="s2">as </span><span class="s1">da</span>
            <span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">da</span><span class="s3">.</span><span class="s1">Array</span><span class="s3">):</span>
                <span class="s1">obj </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
                <span class="s2">return </span><span class="s1">da</span><span class="s3">.</span><span class="s1">from_array</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">obj</span>

    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s4"># np.reshape calls the keyword argument 'newshape' instead of 'shape'</span>
<span class="s2">def </span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">,</span>
            <span class="s3">/,</span>
            <span class="s1">shape</span><span class="s3">: </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, ...],</span>
            <span class="s1">xp</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">bool</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
            <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s2">if </span><span class="s1">copy </span><span class="s2">is True</span><span class="s3">:</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s2">elif </span><span class="s1">copy </span><span class="s2">is False</span><span class="s3">:</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">view</span><span class="s3">()</span>
        <span class="s1">y</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">= </span><span class="s1">shape</span>
        <span class="s2">return </span><span class="s1">y</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s4"># The descending keyword is new in sort and argsort, and 'kind' replaced with</span>
<span class="s4"># 'stable'</span>
<span class="s2">def </span><span class="s1">argsort</span><span class="s3">(</span>
    <span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, /, </span><span class="s1">xp</span><span class="s3">, *, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= -</span><span class="s5">1</span><span class="s3">, </span><span class="s1">descending</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">, </span><span class="s1">stable</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s4"># Note: this keyword argument is different, and the default is different.</span>
    <span class="s4"># We set it in kwargs like this because numpy.sort uses kind='quicksort'</span>
    <span class="s4"># as the default whereas cupy.sort uses kind=None.</span>
    <span class="s2">if </span><span class="s1">stable</span><span class="s3">:</span>
        <span class="s1">kwargs</span><span class="s3">[</span><span class="s6">'kind'</span><span class="s3">] = </span><span class="s6">&quot;stable&quot;</span>
    <span class="s2">if not </span><span class="s1">descending</span><span class="s3">:</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s4"># As NumPy has no native descending sort, we imitate it here. Note that</span>
        <span class="s4"># simply flipping the results of xp.argsort(x, ...) would not</span>
        <span class="s4"># respect the relative order like it would in native descending sorts.</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">flip</span><span class="s3">(</span>
            <span class="s1">xp</span><span class="s3">.</span><span class="s1">argsort</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">flip</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">),</span>
            <span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s4"># Rely on flip()/argsort() to validate axis</span>
        <span class="s1">normalised_axis </span><span class="s3">= </span><span class="s1">axis </span><span class="s2">if </span><span class="s1">axis </span><span class="s3">&gt;= </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">+ </span><span class="s1">axis</span>
        <span class="s1">max_i </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">normalised_axis</span><span class="s3">] - </span><span class="s5">1</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">max_i </span><span class="s3">- </span><span class="s1">res</span>
    <span class="s2">return </span><span class="s1">res</span>

<span class="s2">def </span><span class="s1">sort</span><span class="s3">(</span>
    <span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, /, </span><span class="s1">xp</span><span class="s3">, *, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= -</span><span class="s5">1</span><span class="s3">, </span><span class="s1">descending</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">, </span><span class="s1">stable</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">True</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s4"># Note: this keyword argument is different, and the default is different.</span>
    <span class="s4"># We set it in kwargs like this because numpy.sort uses kind='quicksort'</span>
    <span class="s4"># as the default whereas cupy.sort uses kind=None.</span>
    <span class="s2">if </span><span class="s1">stable</span><span class="s3">:</span>
        <span class="s1">kwargs</span><span class="s3">[</span><span class="s6">'kind'</span><span class="s3">] = </span><span class="s6">&quot;stable&quot;</span>
    <span class="s1">res </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">descending</span><span class="s3">:</span>
        <span class="s1">res </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">flip</span><span class="s3">(</span><span class="s1">res</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">res</span>

<span class="s4"># nonzero should error for zero-dimensional arrays</span>
<span class="s2">def </span><span class="s1">nonzero</span><span class="s3">(</span><span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, /, </span><span class="s1">xp</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">) </span><span class="s1">-&gt; Tuple</span><span class="s3">[</span><span class="s1">ndarray</span><span class="s3">, ...]:</span>
    <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s5">0</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;nonzero() does not support zero-dimensional arrays&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">nonzero</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s4"># sum() and prod() should always upcast when dtype=None</span>
<span class="s2">def </span><span class="s1">sum</span><span class="s3">(</span>
    <span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">,</span>
    <span class="s3">/,</span>
    <span class="s1">xp</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">axis</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, ...]]] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">dtype</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Dtype</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">keepdims</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s4"># `xp.sum` already upcasts integers, but not floats or complexes</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">float64</span>
        <span class="s2">elif </span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">complex64</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">complex128</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s1">keepdims</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">prod</span><span class="s3">(</span>
    <span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">,</span>
    <span class="s3">/,</span>
    <span class="s1">xp</span><span class="s3">,</span>
    <span class="s3">*,</span>
    <span class="s1">axis</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, ...]]] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">dtype</span><span class="s3">: </span><span class="s1">Optional</span><span class="s3">[</span><span class="s1">Dtype</span><span class="s3">] = </span><span class="s2">None</span><span class="s3">,</span>
    <span class="s1">keepdims</span><span class="s3">: </span><span class="s1">bool </span><span class="s3">= </span><span class="s2">False</span><span class="s3">,</span>
    <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">float64</span>
        <span class="s2">elif </span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">complex64</span><span class="s3">:</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">complex128</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s1">keepdims</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s4"># ceil, floor, and trunc return integers for integer inputs</span>

<span class="s2">def </span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, /, </span><span class="s1">xp</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s2">if </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">x</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, /, </span><span class="s1">xp</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s2">if </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">x</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">trunc</span><span class="s3">(</span><span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, /, </span><span class="s1">xp</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s2">if </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">x</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">trunc</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s4"># linear algebra functions</span>

<span class="s2">def </span><span class="s1">matmul</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, /, </span><span class="s1">xp</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">matmul</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s4"># Unlike transpose, matrix_transpose only transposes the last two axes.</span>
<span class="s2">def </span><span class="s1">matrix_transpose</span><span class="s3">(</span><span class="s1">x</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, /, </span><span class="s1">xp</span><span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">&lt; </span><span class="s5">2</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;x must be at least 2-dimensional for matrix_transpose&quot;</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">swapaxes</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, -</span><span class="s5">2</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">tensordot</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">,</span>
              <span class="s1">x2</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">,</span>
              <span class="s3">/,</span>
              <span class="s1">xp</span><span class="s3">,</span>
              <span class="s3">*,</span>
              <span class="s1">axes</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">int</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">int</span><span class="s3">], </span><span class="s1">Sequence</span><span class="s3">[</span><span class="s1">int</span><span class="s3">]]] = </span><span class="s5">2</span><span class="s3">,</span>
              <span class="s3">**</span><span class="s1">kwargs</span><span class="s3">,</span>
<span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">tensordot</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s1">axes</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">vecdot</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, </span><span class="s1">x2</span><span class="s3">: </span><span class="s1">ndarray</span><span class="s3">, /, </span><span class="s1">xp</span><span class="s3">, *, </span><span class="s1">axis</span><span class="s3">: </span><span class="s1">int </span><span class="s3">= -</span><span class="s5">1</span><span class="s3">) </span><span class="s1">-&gt; ndarray</span><span class="s3">:</span>
    <span class="s2">if </span><span class="s1">x1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] != </span><span class="s1">x2</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">&quot;x1 and x2 must have the same size along the given axis&quot;</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s6">'broadcast_tensors'</span><span class="s3">):</span>
        <span class="s1">_broadcast </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">broadcast_tensors</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">_broadcast </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">broadcast_arrays</span>

    <span class="s1">x1_ </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">x2_ </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">x2</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">x1_</span><span class="s3">, </span><span class="s1">x2_ </span><span class="s3">= </span><span class="s1">_broadcast</span><span class="s3">(</span><span class="s1">x1_</span><span class="s3">, </span><span class="s1">x2_</span><span class="s3">)</span>

    <span class="s1">res </span><span class="s3">= </span><span class="s1">x1_</span><span class="s3">[..., </span><span class="s2">None</span><span class="s3">, :] @ </span><span class="s1">x2_</span><span class="s3">[..., </span><span class="s2">None</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">res</span><span class="s3">[..., </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]</span>

<span class="s4"># isdtype is a new function in the 2022.12 array API specification.</span>

<span class="s2">def </span><span class="s1">isdtype</span><span class="s3">(</span>
    <span class="s1">dtype</span><span class="s3">: </span><span class="s1">Dtype</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">: </span><span class="s1">Union</span><span class="s3">[</span><span class="s1">Dtype</span><span class="s3">, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">[</span><span class="s1">Union</span><span class="s3">[</span><span class="s1">Dtype</span><span class="s3">, </span><span class="s1">str</span><span class="s3">], ...]], </span><span class="s1">xp</span><span class="s3">,</span>
    <span class="s3">*, </span><span class="s1">_tuple</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s4"># Disallow nested tuples</span>
<span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a boolean indicating whether a provided dtype is of a specified data type ``kind``. 
 
    Note that outside of this function, this compat library does not yet fully 
    support complex numbers. 
 
    See 
    https://data-apis.org/array-api/latest/API_specification/generated/array_api.isdtype.html 
    for more details 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">) </span><span class="s2">and </span><span class="s1">_tuple</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">any</span><span class="s3">(</span><span class="s1">isdtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">, </span><span class="s1">_tuple</span><span class="s3">=</span><span class="s2">False</span><span class="s3">) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">kind</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">kind </span><span class="s3">== </span><span class="s6">'bool'</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">bool_</span>
        <span class="s2">elif </span><span class="s1">kind </span><span class="s3">== </span><span class="s6">'signed integer'</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">signedinteger</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">kind </span><span class="s3">== </span><span class="s6">'unsigned integer'</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">unsignedinteger</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">kind </span><span class="s3">== </span><span class="s6">'integral'</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">kind </span><span class="s3">== </span><span class="s6">'real floating'</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">floating</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">kind </span><span class="s3">== </span><span class="s6">'complex floating'</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">complexfloating</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">kind </span><span class="s3">== </span><span class="s6">'numeric'</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">issubdtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">number</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">f&quot;Unrecognized data type kind: </span><span class="s2">{</span><span class="s1">kind</span><span class="s2">!r}</span><span class="s6">&quot;</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s4"># This will allow things that aren't required by the spec, like</span>
        <span class="s4"># isdtype(np.float64, float) or isdtype(np.int64, 'l'). Should we be</span>
        <span class="s4"># more strict here to match the type annotation? Note that the</span>
        <span class="s4"># array_api_strict implementation will be very strict.</span>
        <span class="s2">return </span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">kind</span>

<span class="s1">__all__ </span><span class="s3">= [</span><span class="s6">'arange'</span><span class="s3">, </span><span class="s6">'empty'</span><span class="s3">, </span><span class="s6">'empty_like'</span><span class="s3">, </span><span class="s6">'eye'</span><span class="s3">, </span><span class="s6">'full'</span><span class="s3">, </span><span class="s6">'full_like'</span><span class="s3">,</span>
           <span class="s6">'linspace'</span><span class="s3">, </span><span class="s6">'ones'</span><span class="s3">, </span><span class="s6">'ones_like'</span><span class="s3">, </span><span class="s6">'zeros'</span><span class="s3">, </span><span class="s6">'zeros_like'</span><span class="s3">,</span>
           <span class="s6">'UniqueAllResult'</span><span class="s3">, </span><span class="s6">'UniqueCountsResult'</span><span class="s3">, </span><span class="s6">'UniqueInverseResult'</span><span class="s3">,</span>
           <span class="s6">'unique_all'</span><span class="s3">, </span><span class="s6">'unique_counts'</span><span class="s3">, </span><span class="s6">'unique_inverse'</span><span class="s3">, </span><span class="s6">'unique_values'</span><span class="s3">,</span>
           <span class="s6">'astype'</span><span class="s3">, </span><span class="s6">'std'</span><span class="s3">, </span><span class="s6">'var'</span><span class="s3">, </span><span class="s6">'permute_dims'</span><span class="s3">, </span><span class="s6">'reshape'</span><span class="s3">, </span><span class="s6">'argsort'</span><span class="s3">,</span>
           <span class="s6">'sort'</span><span class="s3">, </span><span class="s6">'nonzero'</span><span class="s3">, </span><span class="s6">'sum'</span><span class="s3">, </span><span class="s6">'prod'</span><span class="s3">, </span><span class="s6">'ceil'</span><span class="s3">, </span><span class="s6">'floor'</span><span class="s3">, </span><span class="s6">'trunc'</span><span class="s3">,</span>
           <span class="s6">'matmul'</span><span class="s3">, </span><span class="s6">'matrix_transpose'</span><span class="s3">, </span><span class="s6">'tensordot'</span><span class="s3">, </span><span class="s6">'vecdot'</span><span class="s3">, </span><span class="s6">'isdtype'</span><span class="s3">]</span>
</pre>
</body>
</html>