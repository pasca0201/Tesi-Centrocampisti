<html>
<head>
<title>_ksstats.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_ksstats.py</font>
</center></td></tr></table>
<pre><span class="s0"># Compute the two-sided one-sample Kolmogorov-Smirnov Prob(Dn &lt;= d) where:</span>
<span class="s0">#    D_n = sup_x{|F_n(x) - F(x)|},</span>
<span class="s0">#    F_n(x) is the empirical CDF for a sample of size n {x_i: i=1,...,n},</span>
<span class="s0">#    F(x) is the CDF of a probability distribution.</span>
<span class="s0">#</span>
<span class="s0"># Exact methods:</span>
<span class="s0"># Prob(D_n &gt;= d) can be computed via a matrix algorithm of Durbin[1]</span>
<span class="s0">#   or a recursion algorithm due to Pomeranz[2].</span>
<span class="s0"># Marsaglia, Tsang &amp; Wang[3] gave a computation-efficient way to perform</span>
<span class="s0">#   the Durbin algorithm.</span>
<span class="s0">#   D_n &gt;= d &lt;==&gt;  D_n+ &gt;= d or D_n- &gt;= d (the one-sided K-S statistics), hence</span>
<span class="s0">#   Prob(D_n &gt;= d) = 2*Prob(D_n+ &gt;= d) - Prob(D_n+ &gt;= d and D_n- &gt;= d).</span>
<span class="s0">#   For d &gt; 0.5, the latter intersection probability is 0.</span>
<span class="s0">#</span>
<span class="s0"># Approximate methods:</span>
<span class="s0"># For d close to 0.5, ignoring that intersection term may still give a</span>
<span class="s0">#   reasonable approximation.</span>
<span class="s0"># Li-Chien[4] and Korolyuk[5] gave an asymptotic formula extending</span>
<span class="s0"># Kolmogorov's initial asymptotic, suitable for large d. (See</span>
<span class="s0">#   scipy.special.kolmogorov for that asymptotic)</span>
<span class="s0"># Pelz-Good[6] used the functional equation for Jacobi theta functions to</span>
<span class="s0">#   transform the Li-Chien/Korolyuk formula produce a computational formula</span>
<span class="s0">#   suitable for small d.</span>
<span class="s0">#</span>
<span class="s0"># Simard and L'Ecuyer[7] provided an algorithm to decide when to use each of</span>
<span class="s0">#   the above approaches and it is that which is used here.</span>
<span class="s0">#</span>
<span class="s0"># Other approaches:</span>
<span class="s0"># Carvalho[8] optimizes Durbin's matrix algorithm for large values of d.</span>
<span class="s0"># Moscovich and Nadler[9] use FFTs to compute the convolutions.</span>

<span class="s0"># References:</span>
<span class="s0"># [1] Durbin J (1968).</span>
<span class="s0">#     &quot;The Probability that the Sample Distribution Function Lies Between Two</span>
<span class="s0">#     Parallel Straight Lines.&quot;</span>
<span class="s0">#     Annals of Mathematical Statistics, 39, 398-411.</span>
<span class="s0"># [2] Pomeranz J (1974).</span>
<span class="s0">#     &quot;Exact Cumulative Distribution of the Kolmogorov-Smirnov Statistic for</span>
<span class="s0">#     Small Samples (Algorithm 487).&quot;</span>
<span class="s0">#     Communications of the ACM, 17(12), 703-704.</span>
<span class="s0"># [3] Marsaglia G, Tsang WW, Wang J (2003).</span>
<span class="s0">#     &quot;Evaluating Kolmogorov's Distribution.&quot;</span>
<span class="s0">#     Journal of Statistical Software, 8(18), 1-4.</span>
<span class="s0"># [4] LI-CHIEN, C. (1956).</span>
<span class="s0">#     &quot;On the exact distribution of the statistics of A. N. Kolmogorov and</span>
<span class="s0">#     their asymptotic expansion.&quot;</span>
<span class="s0">#     Acta Matematica Sinica, 6, 55-81.</span>
<span class="s0"># [5] KOROLYUK, V. S. (1960).</span>
<span class="s0">#     &quot;Asymptotic analysis of the distribution of the maximum deviation in</span>
<span class="s0">#     the Bernoulli scheme.&quot;</span>
<span class="s0">#     Theor. Probability Appl., 4, 339-366.</span>
<span class="s0"># [6] Pelz W, Good IJ (1976).</span>
<span class="s0">#     &quot;Approximating the Lower Tail-areas of the Kolmogorov-Smirnov One-sample</span>
<span class="s0">#     Statistic.&quot;</span>
<span class="s0">#     Journal of the Royal Statistical Society, Series B, 38(2), 152-156.</span>
<span class="s0">#  [7] Simard, R., L'Ecuyer, P. (2011)</span>
<span class="s0">#     &quot;Computing the Two-Sided Kolmogorov-Smirnov Distribution&quot;,</span>
<span class="s0">#     Journal of Statistical Software, Vol 39, 11, 1-18.</span>
<span class="s0">#  [8] Carvalho, Luis (2015)</span>
<span class="s0">#     &quot;An Improved Evaluation of Kolmogorov's Distribution&quot;</span>
<span class="s0">#     Journal of Statistical Software, Code Snippets; Vol 65(3), 1-8.</span>
<span class="s0">#  [9] Amit Moscovich, Boaz Nadler (2017)</span>
<span class="s0">#     &quot;Fast calculation of boundary crossing probabilities for Poisson</span>
<span class="s0">#     processes&quot;,</span>
<span class="s0">#     Statistics &amp; Probability Letters, Vol 123, 177-182.</span>


<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special</span>
<span class="s2">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special</span><span class="s3">.</span><span class="s1">_ufuncs </span><span class="s2">as </span><span class="s1">scu</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">_lib</span><span class="s3">.</span><span class="s1">_finite_differences </span><span class="s2">import </span><span class="s1">_derivative</span>

<span class="s1">_E128 </span><span class="s3">= </span><span class="s4">128</span>
<span class="s1">_EP128 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ldexp</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">longdouble</span><span class="s3">(</span><span class="s4">1</span><span class="s3">), </span><span class="s1">_E128</span><span class="s3">)</span>
<span class="s1">_EM128 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ldexp</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">longdouble</span><span class="s3">(</span><span class="s4">1</span><span class="s3">), -</span><span class="s1">_E128</span><span class="s3">)</span>

<span class="s1">_SQRT2PI </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s4">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">)</span>
<span class="s1">_LOG_2PI </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s4">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">)</span>
<span class="s1">_MIN_LOG </span><span class="s3">= -</span><span class="s4">708</span>
<span class="s1">_SQRT3 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s4">3</span><span class="s3">)</span>
<span class="s1">_PI_SQUARED </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">** </span><span class="s4">2</span>
<span class="s1">_PI_FOUR </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">** </span><span class="s4">4</span>
<span class="s1">_PI_SIX </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">** </span><span class="s4">6</span>

<span class="s0"># [Lifted from _loggamma.pxd.] If B_m are the Bernoulli numbers,</span>
<span class="s0"># then Stirling coeffs are B_{2j}/(2j)/(2j-1) for j=8,...1.</span>
<span class="s1">_STIRLING_COEFFS </span><span class="s3">= [-</span><span class="s4">2.955065359477124183e-2</span><span class="s3">, </span><span class="s4">6.4102564102564102564e-3</span><span class="s3">,</span>
                    <span class="s3">-</span><span class="s4">1.9175269175269175269e-3</span><span class="s3">, </span><span class="s4">8.4175084175084175084e-4</span><span class="s3">,</span>
                    <span class="s3">-</span><span class="s4">5.952380952380952381e-4</span><span class="s3">, </span><span class="s4">7.9365079365079365079e-4</span><span class="s3">,</span>
                    <span class="s3">-</span><span class="s4">2.7777777777777777778e-3</span><span class="s3">, </span><span class="s4">8.3333333333333333333e-2</span><span class="s3">]</span>


<span class="s2">def </span><span class="s1">_log_nfactorial_div_n_pow_n</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
    <span class="s0"># Computes n! / n**n</span>
    <span class="s0">#    = (n-1)! / n**(n-1)</span>
    <span class="s0"># Uses Stirling's approximation, but removes n*log(n) up-front to</span>
    <span class="s0"># avoid subtractive cancellation.</span>
    <span class="s0">#    = log(n)/2 - n + log(sqrt(2pi)) + sum B_{2j}/(2j)/(2j-1)/n**(2j-1)</span>
    <span class="s1">rn </span><span class="s3">= </span><span class="s4">1.0</span><span class="s3">/</span><span class="s1">n</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)/</span><span class="s4">2 </span><span class="s3">- </span><span class="s1">n </span><span class="s3">+ </span><span class="s1">_LOG_2PI</span><span class="s3">/</span><span class="s4">2 </span><span class="s3">+ </span><span class="s1">rn </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">polyval</span><span class="s3">(</span><span class="s1">_STIRLING_COEFFS</span><span class="s3">, </span><span class="s1">rn</span><span class="s3">/</span><span class="s1">n</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_clip_prob</span><span class="s3">(</span><span class="s1">p</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;clips a probability to range 0&lt;=p&lt;=1.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">clip</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s1">cdfprob</span><span class="s3">, </span><span class="s1">sfprob</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Selects either the CDF or SF, and then clips to range 0&lt;=p&lt;=1.&quot;&quot;&quot;</span>
    <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">cdf</span><span class="s3">, </span><span class="s1">cdfprob</span><span class="s3">, </span><span class="s1">sfprob</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_clip_prob</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_kolmogn_DMTW</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">d</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s5">r&quot;&quot;&quot;Computes the Kolmogorov CDF:  Pr(D_n &lt;= d) using the MTW approach to 
    the Durbin matrix algorithm. 
 
    Durbin (1968); Marsaglia, Tsang, Wang (2003). [1], [3]. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Write d = (k-h)/n, where k is positive integer and 0 &lt;= h &lt; 1</span>
    <span class="s0"># Generate initial matrix H of size m*m where m=(2k-1)</span>
    <span class="s0"># Compute k-th row of (n!/n^n) * H^n, scaling intermediate results.</span>
    <span class="s0"># Requires memory O(m^2) and computation O(m^2 log(n)).</span>
    <span class="s0"># Most suitable for small m.</span>

    <span class="s2">if </span><span class="s1">d </span><span class="s3">&gt;= </span><span class="s4">1.0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">0.0</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">)</span>
    <span class="s1">nd </span><span class="s3">= </span><span class="s1">n </span><span class="s3">* </span><span class="s1">d</span>
    <span class="s2">if </span><span class="s1">nd </span><span class="s3">&lt;= </span><span class="s4">0.5</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">)</span>
    <span class="s1">k </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">nd</span><span class="s3">))</span>
    <span class="s1">h </span><span class="s3">= </span><span class="s1">k </span><span class="s3">- </span><span class="s1">nd</span>
    <span class="s1">m </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">k </span><span class="s3">- </span><span class="s4">1</span>

    <span class="s1">H </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">([</span><span class="s1">m</span><span class="s3">, </span><span class="s1">m</span><span class="s3">])</span>

    <span class="s0"># Initialize: v is first column (and last row) of H</span>
    <span class="s0">#  v[j] = (1-h^(j+1)/(j+1)!  (except for v[-1])</span>
    <span class="s0">#  w[j] = 1/(j)!</span>
    <span class="s0"># q = k-th row of H (actually i!/n^i*H^i)</span>
    <span class="s1">intm </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">m </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">v </span><span class="s3">= </span><span class="s4">1.0 </span><span class="s3">- </span><span class="s1">h </span><span class="s3">** </span><span class="s1">intm</span>
    <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">m</span><span class="s3">)</span>
    <span class="s1">fac </span><span class="s3">= </span><span class="s4">1.0</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">intm</span><span class="s3">:</span>
        <span class="s1">w</span><span class="s3">[</span><span class="s1">j </span><span class="s3">- </span><span class="s4">1</span><span class="s3">] = </span><span class="s1">fac</span>
        <span class="s1">fac </span><span class="s3">/= </span><span class="s1">j  </span><span class="s0"># This might underflow.  Isn't a problem.</span>
        <span class="s1">v</span><span class="s3">[</span><span class="s1">j </span><span class="s3">- </span><span class="s4">1</span><span class="s3">] *= </span><span class="s1">fac</span>
    <span class="s1">tt </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s4">2 </span><span class="s3">* </span><span class="s1">h </span><span class="s3">- </span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">0</span><span class="s3">)**</span><span class="s1">m </span><span class="s3">- </span><span class="s4">2</span><span class="s3">*</span><span class="s1">h</span><span class="s3">**</span><span class="s1">m</span>
    <span class="s1">v</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">] = (</span><span class="s4">1.0 </span><span class="s3">+ </span><span class="s1">tt</span><span class="s3">) * </span><span class="s1">fac</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">m</span><span class="s3">):</span>
        <span class="s1">H</span><span class="s3">[</span><span class="s1">i </span><span class="s3">- </span><span class="s4">1</span><span class="s3">:, </span><span class="s1">i</span><span class="s3">] = </span><span class="s1">w</span><span class="s3">[:</span><span class="s1">m </span><span class="s3">- </span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">]</span>
    <span class="s1">H</span><span class="s3">[:, </span><span class="s4">0</span><span class="s3">] = </span><span class="s1">v</span>
    <span class="s1">H</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">, :] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">flip</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>

    <span class="s1">Hpwr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">eye</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">(</span><span class="s1">H</span><span class="s3">)[</span><span class="s4">0</span><span class="s3">])  </span><span class="s0"># Holds intermediate powers of H</span>
    <span class="s1">nn </span><span class="s3">= </span><span class="s1">n</span>
    <span class="s1">expnt </span><span class="s3">= </span><span class="s4">0  </span><span class="s0"># Scaling of Hpwr</span>
    <span class="s1">Hexpnt </span><span class="s3">= </span><span class="s4">0  </span><span class="s0"># Scaling of H</span>
    <span class="s2">while </span><span class="s1">nn </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">nn </span><span class="s3">% </span><span class="s4">2</span><span class="s3">:</span>
            <span class="s1">Hpwr </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">matmul</span><span class="s3">(</span><span class="s1">Hpwr</span><span class="s3">, </span><span class="s1">H</span><span class="s3">)</span>
            <span class="s1">expnt </span><span class="s3">+= </span><span class="s1">Hexpnt</span>
        <span class="s1">H </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">matmul</span><span class="s3">(</span><span class="s1">H</span><span class="s3">, </span><span class="s1">H</span><span class="s3">)</span>
        <span class="s1">Hexpnt </span><span class="s3">*= </span><span class="s4">2</span>
        <span class="s0"># Scale as needed.</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">H</span><span class="s3">[</span><span class="s1">k </span><span class="s3">- </span><span class="s4">1</span><span class="s3">, </span><span class="s1">k </span><span class="s3">- </span><span class="s4">1</span><span class="s3">]) &gt; </span><span class="s1">_EP128</span><span class="s3">:</span>
            <span class="s1">H </span><span class="s3">/= </span><span class="s1">_EP128</span>
            <span class="s1">Hexpnt </span><span class="s3">+= </span><span class="s1">_E128</span>
        <span class="s1">nn </span><span class="s3">= </span><span class="s1">nn </span><span class="s3">// </span><span class="s4">2</span>

    <span class="s1">p </span><span class="s3">= </span><span class="s1">Hpwr</span><span class="s3">[</span><span class="s1">k </span><span class="s3">- </span><span class="s4">1</span><span class="s3">, </span><span class="s1">k </span><span class="s3">- </span><span class="s4">1</span><span class="s3">]</span>

    <span class="s0"># Multiply by n!/n^n</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">n </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">):</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">i </span><span class="s3">* </span><span class="s1">p </span><span class="s3">/ </span><span class="s1">n</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) &lt; </span><span class="s1">_EM128</span><span class="s3">:</span>
            <span class="s1">p </span><span class="s3">*= </span><span class="s1">_EP128</span>
            <span class="s1">expnt </span><span class="s3">-= </span><span class="s1">_E128</span>

    <span class="s0"># unscale</span>
    <span class="s2">if </span><span class="s1">expnt </span><span class="s3">!= </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s1">p </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ldexp</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s1">expnt</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s1">p</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">-</span><span class="s1">p</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_pomeranz_compute_j1j2</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">ll</span><span class="s3">, </span><span class="s1">ceilf</span><span class="s3">, </span><span class="s1">roundf</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Compute the endpoints of the interval for row i.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">i </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s1">j1</span><span class="s3">, </span><span class="s1">j2 </span><span class="s3">= -</span><span class="s1">ll </span><span class="s3">- </span><span class="s1">ceilf </span><span class="s3">- </span><span class="s4">1</span><span class="s3">, </span><span class="s1">ll </span><span class="s3">+ </span><span class="s1">ceilf </span><span class="s3">- </span><span class="s4">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s0"># i + 1 = 2*ip1div2 + ip1mod2</span>
        <span class="s1">ip1div2</span><span class="s3">, </span><span class="s1">ip1mod2 </span><span class="s3">= </span><span class="s1">divmod</span><span class="s3">(</span><span class="s1">i </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">ip1mod2 </span><span class="s3">== </span><span class="s4">0</span><span class="s3">:  </span><span class="s0"># i is odd</span>
            <span class="s2">if </span><span class="s1">ip1div2 </span><span class="s3">== </span><span class="s1">n </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">:</span>
                <span class="s1">j1</span><span class="s3">, </span><span class="s1">j2 </span><span class="s3">= </span><span class="s1">n </span><span class="s3">- </span><span class="s1">ll </span><span class="s3">- </span><span class="s1">ceilf </span><span class="s3">- </span><span class="s4">1</span><span class="s3">, </span><span class="s1">n </span><span class="s3">+ </span><span class="s1">ll </span><span class="s3">+ </span><span class="s1">ceilf </span><span class="s3">- </span><span class="s4">1</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">j1</span><span class="s3">, </span><span class="s1">j2 </span><span class="s3">= </span><span class="s1">ip1div2 </span><span class="s3">- </span><span class="s4">1 </span><span class="s3">- </span><span class="s1">ll </span><span class="s3">- </span><span class="s1">roundf </span><span class="s3">- </span><span class="s4">1</span><span class="s3">, </span><span class="s1">ip1div2 </span><span class="s3">+ </span><span class="s1">ll </span><span class="s3">- </span><span class="s4">1 </span><span class="s3">+ </span><span class="s1">ceilf </span><span class="s3">- </span><span class="s4">1</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">j1</span><span class="s3">, </span><span class="s1">j2 </span><span class="s3">= </span><span class="s1">ip1div2 </span><span class="s3">- </span><span class="s4">1 </span><span class="s3">- </span><span class="s1">ll </span><span class="s3">- </span><span class="s4">1</span><span class="s3">, </span><span class="s1">ip1div2 </span><span class="s3">+ </span><span class="s1">ll </span><span class="s3">+ </span><span class="s1">roundf </span><span class="s3">- </span><span class="s4">1</span>

    <span class="s2">return </span><span class="s1">max</span><span class="s3">(</span><span class="s1">j1 </span><span class="s3">+ </span><span class="s4">2</span><span class="s3">, </span><span class="s4">0</span><span class="s3">), </span><span class="s1">min</span><span class="s3">(</span><span class="s1">j2</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_kolmogn_Pomeranz</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s5">r&quot;&quot;&quot;Computes Pr(D_n &lt;= d) using the Pomeranz recursion algorithm. 
 
    Pomeranz (1974) [2] 
    &quot;&quot;&quot;</span>

    <span class="s0"># V is n*(2n+2) matrix.</span>
    <span class="s0"># Each row is convolution of the previous row and probabilities from a</span>
    <span class="s0">#  Poisson distribution.</span>
    <span class="s0"># Desired CDF probability is n! V[n-1, 2n+1]  (final entry in final row).</span>
    <span class="s0"># Only two rows are needed at any given stage:</span>
    <span class="s0">#  - Call them V0 and V1.</span>
    <span class="s0">#  - Swap each iteration</span>
    <span class="s0"># Only a few (contiguous) entries in each row can be non-zero.</span>
    <span class="s0">#  - Keep track of start and end (j1 and j2 below)</span>
    <span class="s0">#  - V0s and V1s track the start in the two rows</span>
    <span class="s0"># Scale intermediate results as needed.</span>
    <span class="s0"># Only a few different Poisson distributions can occur</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">n </span><span class="s3">* </span><span class="s1">x</span>
    <span class="s1">ll </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">t</span><span class="s3">))</span>
    <span class="s1">f </span><span class="s3">= </span><span class="s4">1.0 </span><span class="s3">* (</span><span class="s1">t </span><span class="s3">- </span><span class="s1">ll</span><span class="s3">)  </span><span class="s0"># fractional part of t</span>
    <span class="s1">g </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s4">1.0 </span><span class="s3">- </span><span class="s1">f</span><span class="s3">)</span>
    <span class="s1">ceilf </span><span class="s3">= (</span><span class="s4">1 </span><span class="s2">if </span><span class="s1">f </span><span class="s3">&gt; </span><span class="s4">0 </span><span class="s2">else </span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">roundf </span><span class="s3">= (</span><span class="s4">1 </span><span class="s2">if </span><span class="s1">f </span><span class="s3">&gt; </span><span class="s4">0.5 </span><span class="s2">else </span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">npwrs </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">* (</span><span class="s1">ll </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">)    </span><span class="s0"># Maximum number of powers needed in convolutions</span>
    <span class="s1">gpower </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">npwrs</span><span class="s3">)  </span><span class="s0"># gpower = (g/n)^m/m!</span>
    <span class="s1">twogpower </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">npwrs</span><span class="s3">)  </span><span class="s0"># twogpower = (2g/n)^m/m!</span>
    <span class="s1">onem2gpower </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">empty</span><span class="s3">(</span><span class="s1">npwrs</span><span class="s3">)  </span><span class="s0"># onem2gpower = ((1-2g)/n)^m/m!</span>
    <span class="s0"># gpower etc are *almost* Poisson probs, just missing normalizing factor.</span>

    <span class="s1">gpower</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s4">1.0</span>
    <span class="s1">twogpower</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s4">1.0</span>
    <span class="s1">onem2gpower</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s4">1.0</span>
    <span class="s1">expnt </span><span class="s3">= </span><span class="s4">0</span>
    <span class="s1">g_over_n</span><span class="s3">, </span><span class="s1">two_g_over_n</span><span class="s3">, </span><span class="s1">one_minus_two_g_over_n </span><span class="s3">= </span><span class="s1">g</span><span class="s3">/</span><span class="s1">n</span><span class="s3">, </span><span class="s4">2</span><span class="s3">*</span><span class="s1">g</span><span class="s3">/</span><span class="s1">n</span><span class="s3">, (</span><span class="s4">1 </span><span class="s3">- </span><span class="s4">2</span><span class="s3">*</span><span class="s1">g</span><span class="s3">)/</span><span class="s1">n</span>
    <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">npwrs</span><span class="s3">):</span>
        <span class="s1">gpower</span><span class="s3">[</span><span class="s1">m</span><span class="s3">] = </span><span class="s1">gpower</span><span class="s3">[</span><span class="s1">m </span><span class="s3">- </span><span class="s4">1</span><span class="s3">] * </span><span class="s1">g_over_n </span><span class="s3">/ </span><span class="s1">m</span>
        <span class="s1">twogpower</span><span class="s3">[</span><span class="s1">m</span><span class="s3">] = </span><span class="s1">twogpower</span><span class="s3">[</span><span class="s1">m </span><span class="s3">- </span><span class="s4">1</span><span class="s3">] * </span><span class="s1">two_g_over_n </span><span class="s3">/ </span><span class="s1">m</span>
        <span class="s1">onem2gpower</span><span class="s3">[</span><span class="s1">m</span><span class="s3">] = </span><span class="s1">onem2gpower</span><span class="s3">[</span><span class="s1">m </span><span class="s3">- </span><span class="s4">1</span><span class="s3">] * </span><span class="s1">one_minus_two_g_over_n </span><span class="s3">/ </span><span class="s1">m</span>

    <span class="s1">V0 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">([</span><span class="s1">npwrs</span><span class="s3">])</span>
    <span class="s1">V1 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">([</span><span class="s1">npwrs</span><span class="s3">])</span>
    <span class="s1">V1</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] = </span><span class="s4">1  </span><span class="s0"># first row</span>
    <span class="s1">V0s</span><span class="s3">, </span><span class="s1">V1s </span><span class="s3">= </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0  </span><span class="s0"># start indices of the two rows</span>

    <span class="s1">j1</span><span class="s3">, </span><span class="s1">j2 </span><span class="s3">= </span><span class="s1">_pomeranz_compute_j1j2</span><span class="s3">(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">ll</span><span class="s3">, </span><span class="s1">ceilf</span><span class="s3">, </span><span class="s1">roundf</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">n </span><span class="s3">+ </span><span class="s4">2</span><span class="s3">):</span>
        <span class="s0"># Preserve j1, V1, V1s, V0s from last iteration</span>
        <span class="s1">k1 </span><span class="s3">= </span><span class="s1">j1</span>
        <span class="s1">V0</span><span class="s3">, </span><span class="s1">V1 </span><span class="s3">= </span><span class="s1">V1</span><span class="s3">, </span><span class="s1">V0</span>
        <span class="s1">V0s</span><span class="s3">, </span><span class="s1">V1s </span><span class="s3">= </span><span class="s1">V1s</span><span class="s3">, </span><span class="s1">V0s</span>
        <span class="s1">V1</span><span class="s3">.</span><span class="s1">fill</span><span class="s3">(</span><span class="s4">0.0</span><span class="s3">)</span>
        <span class="s1">j1</span><span class="s3">, </span><span class="s1">j2 </span><span class="s3">= </span><span class="s1">_pomeranz_compute_j1j2</span><span class="s3">(</span><span class="s1">i</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">ll</span><span class="s3">, </span><span class="s1">ceilf</span><span class="s3">, </span><span class="s1">roundf</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">i </span><span class="s3">== </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">i </span><span class="s3">== </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">n </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">:</span>
            <span class="s1">pwrs </span><span class="s3">= </span><span class="s1">gpower</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">pwrs </span><span class="s3">= (</span><span class="s1">twogpower </span><span class="s2">if </span><span class="s1">i </span><span class="s3">% </span><span class="s4">2 </span><span class="s2">else </span><span class="s1">onem2gpower</span><span class="s3">)</span>
        <span class="s1">ln2 </span><span class="s3">= </span><span class="s1">j2 </span><span class="s3">- </span><span class="s1">k1 </span><span class="s3">+ </span><span class="s4">1</span>
        <span class="s2">if </span><span class="s1">ln2 </span><span class="s3">&gt; </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s1">conv </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">convolve</span><span class="s3">(</span><span class="s1">V0</span><span class="s3">[</span><span class="s1">k1 </span><span class="s3">- </span><span class="s1">V0s</span><span class="s3">:</span><span class="s1">k1 </span><span class="s3">- </span><span class="s1">V0s </span><span class="s3">+ </span><span class="s1">ln2</span><span class="s3">], </span><span class="s1">pwrs</span><span class="s3">[:</span><span class="s1">ln2</span><span class="s3">])</span>
            <span class="s1">conv_start </span><span class="s3">= </span><span class="s1">j1 </span><span class="s3">- </span><span class="s1">k1  </span><span class="s0"># First index to use from conv</span>
            <span class="s1">conv_len </span><span class="s3">= </span><span class="s1">j2 </span><span class="s3">- </span><span class="s1">j1 </span><span class="s3">+ </span><span class="s4">1  </span><span class="s0"># Number of entries to use from conv</span>
            <span class="s1">V1</span><span class="s3">[:</span><span class="s1">conv_len</span><span class="s3">] = </span><span class="s1">conv</span><span class="s3">[</span><span class="s1">conv_start</span><span class="s3">:</span><span class="s1">conv_start </span><span class="s3">+ </span><span class="s1">conv_len</span><span class="s3">]</span>
            <span class="s0"># Scale to avoid underflow.</span>
            <span class="s2">if </span><span class="s4">0 </span><span class="s3">&lt; </span><span class="s1">np</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">V1</span><span class="s3">) &lt; </span><span class="s1">_EM128</span><span class="s3">:</span>
                <span class="s1">V1 </span><span class="s3">*= </span><span class="s1">_EP128</span>
                <span class="s1">expnt </span><span class="s3">-= </span><span class="s1">_E128</span>
            <span class="s1">V1s </span><span class="s3">= </span><span class="s1">V0s </span><span class="s3">+ </span><span class="s1">j1 </span><span class="s3">- </span><span class="s1">k1</span>

    <span class="s0"># multiply by n!</span>
    <span class="s1">ans </span><span class="s3">= </span><span class="s1">V1</span><span class="s3">[</span><span class="s1">n </span><span class="s3">- </span><span class="s1">V1s</span><span class="s3">]</span>
    <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">n </span><span class="s3">+ </span><span class="s4">1</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">ans</span><span class="s3">) &gt; </span><span class="s1">_EP128</span><span class="s3">:</span>
            <span class="s1">ans </span><span class="s3">*= </span><span class="s1">_EM128</span>
            <span class="s1">expnt </span><span class="s3">+= </span><span class="s1">_E128</span>
        <span class="s1">ans </span><span class="s3">*= </span><span class="s1">m</span>

    <span class="s0"># Undo any intermediate scaling</span>
    <span class="s2">if </span><span class="s1">expnt </span><span class="s3">!= </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s1">ans </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ldexp</span><span class="s3">(</span><span class="s1">ans</span><span class="s3">, </span><span class="s1">expnt</span><span class="s3">)</span>
    <span class="s1">ans </span><span class="s3">= </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s1">ans</span><span class="s3">, </span><span class="s4">1.0 </span><span class="s3">- </span><span class="s1">ans</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">ans</span>


<span class="s2">def </span><span class="s1">_kolmogn_PelzGood</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Computes the Pelz-Good approximation to Prob(Dn &lt;= x) with 0&lt;=x&lt;=1. 
 
    Start with Li-Chien, Korolyuk approximation: 
        Prob(Dn &lt;= x) ~ K0(z) + K1(z)/sqrt(n) + K2(z)/n + K3(z)/n**1.5 
    where z = x*sqrt(n). 
    Transform each K_(z) using Jacobi theta functions into a form suitable 
    for small z. 
    Pelz-Good (1976). [6] 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s3">&lt;= </span><span class="s4">0.0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s1">cdf</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s3">&gt;= </span><span class="s4">1.0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">0.0</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s1">cdf</span><span class="s3">)</span>

    <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) * </span><span class="s1">x</span>
    <span class="s1">zsquared</span><span class="s3">, </span><span class="s1">zthree</span><span class="s3">, </span><span class="s1">zfour</span><span class="s3">, </span><span class="s1">zsix </span><span class="s3">= </span><span class="s1">z</span><span class="s3">**</span><span class="s4">2</span><span class="s3">, </span><span class="s1">z</span><span class="s3">**</span><span class="s4">3</span><span class="s3">, </span><span class="s1">z</span><span class="s3">**</span><span class="s4">4</span><span class="s3">, </span><span class="s1">z</span><span class="s3">**</span><span class="s4">6</span>

    <span class="s1">qlog </span><span class="s3">= -</span><span class="s1">_PI_SQUARED </span><span class="s3">/ </span><span class="s4">8 </span><span class="s3">/ </span><span class="s1">zsquared</span>
    <span class="s2">if </span><span class="s1">qlog </span><span class="s3">&lt; </span><span class="s1">_MIN_LOG</span><span class="s3">:  </span><span class="s0"># z ~ 0.041743441416853426</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s1">cdf</span><span class="s3">)</span>

    <span class="s1">q </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">qlog</span><span class="s3">)</span>

    <span class="s0"># Coefficients of terms in the sums for K1, K2 and K3</span>
    <span class="s1">k1a </span><span class="s3">= -</span><span class="s1">zsquared</span>
    <span class="s1">k1b </span><span class="s3">= </span><span class="s1">_PI_SQUARED </span><span class="s3">/ </span><span class="s4">4</span>

    <span class="s1">k2a </span><span class="s3">= </span><span class="s4">6 </span><span class="s3">* </span><span class="s1">zsix </span><span class="s3">+ </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">zfour</span>
    <span class="s1">k2b </span><span class="s3">= (</span><span class="s4">2 </span><span class="s3">* </span><span class="s1">zfour </span><span class="s3">- </span><span class="s4">5 </span><span class="s3">* </span><span class="s1">zsquared</span><span class="s3">) * </span><span class="s1">_PI_SQUARED </span><span class="s3">/ </span><span class="s4">4</span>
    <span class="s1">k2c </span><span class="s3">= </span><span class="s1">_PI_FOUR </span><span class="s3">* (</span><span class="s4">1 </span><span class="s3">- </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">zsquared</span><span class="s3">) / </span><span class="s4">16</span>

    <span class="s1">k3d </span><span class="s3">= </span><span class="s1">_PI_SIX </span><span class="s3">* (</span><span class="s4">5 </span><span class="s3">- </span><span class="s4">30 </span><span class="s3">* </span><span class="s1">zsquared</span><span class="s3">) / </span><span class="s4">64</span>
    <span class="s1">k3c </span><span class="s3">= </span><span class="s1">_PI_FOUR </span><span class="s3">* (-</span><span class="s4">60 </span><span class="s3">* </span><span class="s1">zsquared </span><span class="s3">+ </span><span class="s4">212 </span><span class="s3">* </span><span class="s1">zfour</span><span class="s3">) / </span><span class="s4">16</span>
    <span class="s1">k3b </span><span class="s3">= </span><span class="s1">_PI_SQUARED </span><span class="s3">* (</span><span class="s4">135 </span><span class="s3">* </span><span class="s1">zfour </span><span class="s3">- </span><span class="s4">96 </span><span class="s3">* </span><span class="s1">zsix</span><span class="s3">) / </span><span class="s4">4</span>
    <span class="s1">k3a </span><span class="s3">= -</span><span class="s4">30 </span><span class="s3">* </span><span class="s1">zsix </span><span class="s3">- </span><span class="s4">90 </span><span class="s3">* </span><span class="s1">z</span><span class="s3">**</span><span class="s4">8</span>

    <span class="s1">K0to3 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s4">4</span><span class="s3">)</span>
    <span class="s0"># Use a Horner scheme to evaluate sum c_i q^(i^2)</span>
    <span class="s0"># Reduces to a sum over odd integers.</span>
    <span class="s1">maxk </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s4">16 </span><span class="s3">* </span><span class="s1">z </span><span class="s3">/ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">))</span>
    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">maxk</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">):</span>
        <span class="s1">m </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">k </span><span class="s3">- </span><span class="s4">1</span>
        <span class="s1">msquared</span><span class="s3">, </span><span class="s1">mfour</span><span class="s3">, </span><span class="s1">msix </span><span class="s3">= </span><span class="s1">m</span><span class="s3">**</span><span class="s4">2</span><span class="s3">, </span><span class="s1">m</span><span class="s3">**</span><span class="s4">4</span><span class="s3">, </span><span class="s1">m</span><span class="s3">**</span><span class="s4">6</span>
        <span class="s1">qpower </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s1">q</span><span class="s3">, </span><span class="s4">8 </span><span class="s3">* </span><span class="s1">k</span><span class="s3">)</span>
        <span class="s1">coeffs </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s4">1.0</span><span class="s3">,</span>
                           <span class="s1">k1a </span><span class="s3">+ </span><span class="s1">k1b</span><span class="s3">*</span><span class="s1">msquared</span><span class="s3">,</span>
                           <span class="s1">k2a </span><span class="s3">+ </span><span class="s1">k2b</span><span class="s3">*</span><span class="s1">msquared </span><span class="s3">+ </span><span class="s1">k2c</span><span class="s3">*</span><span class="s1">mfour</span><span class="s3">,</span>
                           <span class="s1">k3a </span><span class="s3">+ </span><span class="s1">k3b</span><span class="s3">*</span><span class="s1">msquared </span><span class="s3">+ </span><span class="s1">k3c</span><span class="s3">*</span><span class="s1">mfour </span><span class="s3">+ </span><span class="s1">k3d</span><span class="s3">*</span><span class="s1">msix</span><span class="s3">])</span>
        <span class="s1">K0to3 </span><span class="s3">*= </span><span class="s1">qpower</span>
        <span class="s1">K0to3 </span><span class="s3">+= </span><span class="s1">coeffs</span>
    <span class="s1">K0to3 </span><span class="s3">*= </span><span class="s1">q</span>
    <span class="s1">K0to3 </span><span class="s3">*= </span><span class="s1">_SQRT2PI</span>
    <span class="s0"># z**10 &gt; 0 as z &gt; 0.04</span>
    <span class="s1">K0to3 </span><span class="s3">/= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">z</span><span class="s3">, </span><span class="s4">6 </span><span class="s3">* </span><span class="s1">zfour</span><span class="s3">, </span><span class="s4">72 </span><span class="s3">* </span><span class="s1">z</span><span class="s3">**</span><span class="s4">7</span><span class="s3">, </span><span class="s4">6480 </span><span class="s3">* </span><span class="s1">z</span><span class="s3">**</span><span class="s4">10</span><span class="s3">])</span>

    <span class="s0"># Now do the other sum over the other terms, all integers k</span>
    <span class="s0"># K_2:  (pi^2 k^2) q^(k^2),</span>
    <span class="s0"># K_3:  (3pi^2 k^2 z^2 - pi^4 k^4)*q^(k^2)</span>
    <span class="s0"># Don't expect much subtractive cancellation so use direct calculation</span>
    <span class="s1">q </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">_PI_SQUARED </span><span class="s3">/ </span><span class="s4">2 </span><span class="s3">/ </span><span class="s1">zsquared</span><span class="s3">)</span>
    <span class="s1">ks </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">maxk</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, -</span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">ksquared </span><span class="s3">= </span><span class="s1">ks </span><span class="s3">** </span><span class="s4">2</span>
    <span class="s1">sqrt3z </span><span class="s3">= </span><span class="s1">_SQRT3 </span><span class="s3">* </span><span class="s1">z</span>
    <span class="s1">kspi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">ks</span>
    <span class="s1">qpwers </span><span class="s3">= </span><span class="s1">q </span><span class="s3">** </span><span class="s1">ksquared</span>
    <span class="s1">k2extra </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">ksquared </span><span class="s3">* </span><span class="s1">qpwers</span><span class="s3">)</span>
    <span class="s1">k2extra </span><span class="s3">*= </span><span class="s1">_PI_SQUARED </span><span class="s3">* </span><span class="s1">_SQRT2PI</span><span class="s3">/(-</span><span class="s4">36 </span><span class="s3">* </span><span class="s1">zthree</span><span class="s3">)</span>
    <span class="s1">K0to3</span><span class="s3">[</span><span class="s4">2</span><span class="s3">] += </span><span class="s1">k2extra</span>
    <span class="s1">k3extra </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">((</span><span class="s1">sqrt3z </span><span class="s3">+ </span><span class="s1">kspi</span><span class="s3">) * (</span><span class="s1">sqrt3z </span><span class="s3">- </span><span class="s1">kspi</span><span class="s3">) * </span><span class="s1">ksquared </span><span class="s3">* </span><span class="s1">qpwers</span><span class="s3">)</span>
    <span class="s1">k3extra </span><span class="s3">*= </span><span class="s1">_PI_SQUARED </span><span class="s3">* </span><span class="s1">_SQRT2PI</span><span class="s3">/(</span><span class="s4">216 </span><span class="s3">* </span><span class="s1">zsix</span><span class="s3">)</span>
    <span class="s1">K0to3</span><span class="s3">[</span><span class="s4">3</span><span class="s3">] += </span><span class="s1">k3extra</span>
    <span class="s1">powers_of_n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">power</span><span class="s3">(</span><span class="s1">n </span><span class="s3">* </span><span class="s4">1.0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">K0to3</span><span class="s3">)) / </span><span class="s4">2.0</span><span class="s3">)</span>
    <span class="s1">K0to3 </span><span class="s3">/= </span><span class="s1">powers_of_n</span>

    <span class="s2">if not </span><span class="s1">cdf</span><span class="s3">:</span>
        <span class="s1">K0to3 </span><span class="s3">*= -</span><span class="s4">1</span>
        <span class="s1">K0to3</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] += </span><span class="s4">1</span>

    <span class="s1">Ksum </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">K0to3</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">Ksum</span>


<span class="s2">def </span><span class="s1">_kolmogn</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Computes the CDF(or SF) for the two-sided Kolmogorov-Smirnov statistic. 
 
    x must be of type float, n of type integer. 
 
    Simard &amp; L'Ecuyer (2011) [7]. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">n  </span><span class="s0"># Keep the same type of nan</span>
    <span class="s2">if </span><span class="s1">int</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) != </span><span class="s1">n </span><span class="s2">or </span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s3">&gt;= </span><span class="s4">1.0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">0.0</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s1">cdf</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s3">&lt;= </span><span class="s4">0.0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s1">cdf</span><span class="s3">)</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">n </span><span class="s3">* </span><span class="s1">x</span>
    <span class="s2">if </span><span class="s1">t </span><span class="s3">&lt;= </span><span class="s4">1.0</span><span class="s3">:  </span><span class="s0"># Ruben-Gambino: 1/2n &lt;= x &lt;= 1/n</span>
        <span class="s2">if </span><span class="s1">t </span><span class="s3">&lt;= </span><span class="s4">0.5</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s1">cdf</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s4">140</span><span class="s3">:</span>
            <span class="s1">prob </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">+</span><span class="s4">1</span><span class="s3">) * (</span><span class="s4">1.0</span><span class="s3">/</span><span class="s1">n</span><span class="s3">) * (</span><span class="s4">2</span><span class="s3">*</span><span class="s1">t </span><span class="s3">- </span><span class="s4">1</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">prob </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">_log_nfactorial_div_n_pow_n</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) + </span><span class="s1">n </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s4">2</span><span class="s3">*</span><span class="s1">t</span><span class="s3">-</span><span class="s4">1</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s1">prob</span><span class="s3">, </span><span class="s4">1.0 </span><span class="s3">- </span><span class="s1">prob</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s1">cdf</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">t </span><span class="s3">&gt;= </span><span class="s1">n </span><span class="s3">- </span><span class="s4">1</span><span class="s3">:  </span><span class="s0"># Ruben-Gambino</span>
        <span class="s1">prob </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">* (</span><span class="s4">1.0 </span><span class="s3">- </span><span class="s1">x</span><span class="s3">)**</span><span class="s1">n</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s4">1 </span><span class="s3">- </span><span class="s1">prob</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s1">cdf</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s3">&gt;= </span><span class="s4">0.5</span><span class="s3">:  </span><span class="s0"># Exact: 2 * smirnov</span>
        <span class="s1">prob </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special</span><span class="s3">.</span><span class="s1">smirnov</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s4">1.0 </span><span class="s3">- </span><span class="s1">prob</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s1">cdf</span><span class="s3">)</span>

    <span class="s1">nxsquared </span><span class="s3">= </span><span class="s1">t </span><span class="s3">* </span><span class="s1">x</span>
    <span class="s2">if </span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s4">140</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">nxsquared </span><span class="s3">&lt;= </span><span class="s4">0.754693</span><span class="s3">:</span>
            <span class="s1">prob </span><span class="s3">= </span><span class="s1">_kolmogn_DMTW</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s1">prob</span><span class="s3">, </span><span class="s4">1.0 </span><span class="s3">- </span><span class="s1">prob</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s1">cdf</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">nxsquared </span><span class="s3">&lt;= </span><span class="s4">4</span><span class="s3">:</span>
            <span class="s1">prob </span><span class="s3">= </span><span class="s1">_kolmogn_Pomeranz</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s1">prob</span><span class="s3">, </span><span class="s4">1.0 </span><span class="s3">- </span><span class="s1">prob</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s1">cdf</span><span class="s3">)</span>
        <span class="s0"># Now use Miller approximation of 2*smirnov</span>
        <span class="s1">prob </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special</span><span class="s3">.</span><span class="s1">smirnov</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s4">1.0 </span><span class="s3">- </span><span class="s1">prob</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s1">cdf</span><span class="s3">)</span>

    <span class="s0"># Split CDF and SF as they have different cutoffs on nxsquared.</span>
    <span class="s2">if not </span><span class="s1">cdf</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">nxsquared </span><span class="s3">&gt;= </span><span class="s4">370.0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s4">0.0</span>
        <span class="s2">if </span><span class="s1">nxsquared </span><span class="s3">&gt;= </span><span class="s4">2.2</span><span class="s3">:</span>
            <span class="s1">prob </span><span class="s3">= </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special</span><span class="s3">.</span><span class="s1">smirnov</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">_clip_prob</span><span class="s3">(</span><span class="s1">prob</span><span class="s3">)</span>
        <span class="s0"># Fall through and compute the SF as 1.0-CDF</span>
    <span class="s2">if </span><span class="s1">nxsquared </span><span class="s3">&gt;= </span><span class="s4">18.0</span><span class="s3">:</span>
        <span class="s1">cdfprob </span><span class="s3">= </span><span class="s4">1.0</span>
    <span class="s2">elif </span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s4">100000 </span><span class="s2">and </span><span class="s1">n </span><span class="s3">* </span><span class="s1">x</span><span class="s3">**</span><span class="s4">1.5 </span><span class="s3">&lt;= </span><span class="s4">1.4</span><span class="s3">:</span>
        <span class="s1">cdfprob </span><span class="s3">= </span><span class="s1">_kolmogn_DMTW</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">cdfprob </span><span class="s3">= </span><span class="s1">_kolmogn_PelzGood</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">_select_and_clip_prob</span><span class="s3">(</span><span class="s1">cdfprob</span><span class="s3">, </span><span class="s4">1.0 </span><span class="s3">- </span><span class="s1">cdfprob</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s1">cdf</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_kolmogn_p</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Computes the PDF for the two-sided Kolmogorov-Smirnov statistic. 
 
    x must be of type float, n of type integer. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">n  </span><span class="s0"># Keep the same type of nan</span>
    <span class="s2">if </span><span class="s1">int</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) != </span><span class="s1">n </span><span class="s2">or </span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s3">&gt;= </span><span class="s4">1.0 </span><span class="s2">or </span><span class="s1">x </span><span class="s3">&lt;= </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">0</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">n </span><span class="s3">* </span><span class="s1">x</span>
    <span class="s2">if </span><span class="s1">t </span><span class="s3">&lt;= </span><span class="s4">1.0</span><span class="s3">:</span>
        <span class="s0"># Ruben-Gambino: n!/n^n * (2t-1)^n -&gt; 2 n!/n^n * n^2 * (2t-1)^(n-1)</span>
        <span class="s2">if </span><span class="s1">t </span><span class="s3">&lt;= </span><span class="s4">0.5</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s4">0.0</span>
        <span class="s2">if </span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s4">140</span><span class="s3">:</span>
            <span class="s1">prd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">) * (</span><span class="s4">1.0 </span><span class="s3">/ </span><span class="s1">n</span><span class="s3">) * (</span><span class="s4">2 </span><span class="s3">* </span><span class="s1">t </span><span class="s3">- </span><span class="s4">1</span><span class="s3">))</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">prd </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s1">_log_nfactorial_div_n_pow_n</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) + (</span><span class="s1">n</span><span class="s3">-</span><span class="s4">1</span><span class="s3">) * </span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s4">2 </span><span class="s3">* </span><span class="s1">t </span><span class="s3">- </span><span class="s4">1</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">prd </span><span class="s3">* </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">n</span><span class="s3">**</span><span class="s4">2</span>
    <span class="s2">if </span><span class="s1">t </span><span class="s3">&gt;= </span><span class="s1">n </span><span class="s3">- </span><span class="s4">1</span><span class="s3">:</span>
        <span class="s0"># Ruben-Gambino : 1-2(1-x)**n -&gt; 2n*(1-x)**(n-1)</span>
        <span class="s2">return </span><span class="s4">2 </span><span class="s3">* (</span><span class="s4">1.0 </span><span class="s3">- </span><span class="s1">x</span><span class="s3">) ** (</span><span class="s1">n</span><span class="s3">-</span><span class="s4">1</span><span class="s3">) * </span><span class="s1">n</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s3">&gt;= </span><span class="s4">0.5</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">2 </span><span class="s3">* </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats</span><span class="s3">.</span><span class="s1">ksone</span><span class="s3">.</span><span class="s1">pdf</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>

    <span class="s0"># Just take a small delta.</span>
    <span class="s0"># Ideally x +/- delta would stay within [i/n, (i+1)/n] for some integer a.</span>
    <span class="s0"># as the CDF is a piecewise degree n polynomial.</span>
    <span class="s0"># It has knots at 1/n, 2/n, ... (n-1)/n</span>
    <span class="s0"># and is not a C-infinity function at the knots</span>
    <span class="s1">delta </span><span class="s3">= </span><span class="s1">x </span><span class="s3">/ </span><span class="s4">2.0</span><span class="s3">**</span><span class="s4">16</span>
    <span class="s1">delta </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">delta</span><span class="s3">, </span><span class="s1">x </span><span class="s3">- </span><span class="s4">1.0</span><span class="s3">/</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">delta </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">delta</span><span class="s3">, </span><span class="s4">0.5 </span><span class="s3">- </span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_kk</span><span class="s3">(</span><span class="s1">_x</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">kolmogn</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">_x</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">_derivative</span><span class="s3">(</span><span class="s1">_kk</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">=</span><span class="s1">delta</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s4">5</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_kolmogni</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">q</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Computes the PPF/ISF of kolmogn. 
 
    n of type integer, n&gt;= 1 
    p is the CDF, q the SF, p+q=1 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">n</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">n  </span><span class="s0"># Keep the same type of nan</span>
    <span class="s2">if </span><span class="s1">int</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) != </span><span class="s1">n </span><span class="s2">or </span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span>
    <span class="s2">if </span><span class="s1">p </span><span class="s3">&lt;= </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">1.0</span><span class="s3">/</span><span class="s1">n</span>
    <span class="s2">if </span><span class="s1">q </span><span class="s3">&lt;= </span><span class="s4">0</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s4">1.0</span>
    <span class="s1">delta </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">((</span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">p</span><span class="s3">) - </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special</span><span class="s3">.</span><span class="s1">loggamma</span><span class="s3">(</span><span class="s1">n</span><span class="s3">+</span><span class="s4">1</span><span class="s3">))/</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">delta </span><span class="s3">&lt;= </span><span class="s4">1.0</span><span class="s3">/</span><span class="s1">n</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">delta </span><span class="s3">+ </span><span class="s4">1.0 </span><span class="s3">/ </span><span class="s1">n</span><span class="s3">) / </span><span class="s4">2</span>
    <span class="s1">x </span><span class="s3">= -</span><span class="s1">np</span><span class="s3">.</span><span class="s1">expm1</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">log</span><span class="s3">(</span><span class="s1">q</span><span class="s3">/</span><span class="s4">2.0</span><span class="s3">)/</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s3">&gt;= </span><span class="s4">1 </span><span class="s3">- </span><span class="s4">1.0</span><span class="s3">/</span><span class="s1">n</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">x</span>
    <span class="s1">x1 </span><span class="s3">= </span><span class="s1">scu</span><span class="s3">.</span><span class="s1">_kolmogci</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)/</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">x1 </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s4">1.0 </span><span class="s3">- </span><span class="s4">1.0</span><span class="s3">/</span><span class="s1">n</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_f</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">_kolmogn</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">) - </span><span class="s1">p</span>

    <span class="s2">return </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">optimize</span><span class="s3">.</span><span class="s1">brentq</span><span class="s3">(</span><span class="s1">_f</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">/</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">xtol</span><span class="s3">=</span><span class="s4">1e-14</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">kolmogn</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Computes the CDF for the two-sided Kolmogorov-Smirnov distribution. 
 
    The two-sided Kolmogorov-Smirnov distribution has as its CDF Pr(D_n &lt;= x), 
    for a sample of size n drawn from a distribution with CDF F(t), where 
    :math:`D_n &amp;= sup_t |F_n(t) - F(t)|`, and 
    :math:`F_n(t)` is the Empirical Cumulative Distribution Function of the sample. 
 
    Parameters 
    ---------- 
    n : integer, array_like 
        the number of samples 
    x : float, array_like 
        The K-S statistic, float between 0 and 1 
    cdf : bool, optional 
        whether to compute the CDF(default=true) or the SF. 
 
    Returns 
    ------- 
    cdf : ndarray 
        CDF (or SF it cdf is False) at the specified locations. 
 
    The return value has shape the result of numpy broadcasting n and x. 
    &quot;&quot;&quot;</span>
    <span class="s1">it </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">([</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">, </span><span class="s2">None</span><span class="s3">],</span>
                   <span class="s1">op_dtypes</span><span class="s3">=[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">bool_</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">])</span>
    <span class="s2">for </span><span class="s1">_n</span><span class="s3">, </span><span class="s1">_x</span><span class="s3">, </span><span class="s1">_cdf</span><span class="s3">, </span><span class="s1">z </span><span class="s2">in </span><span class="s1">it</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">_n</span><span class="s3">):</span>
            <span class="s1">z</span><span class="s3">[...] = </span><span class="s1">_n</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">int</span><span class="s3">(</span><span class="s1">_n</span><span class="s3">) != </span><span class="s1">_n</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">f'n is not integral: </span><span class="s2">{</span><span class="s1">_n</span><span class="s2">}</span><span class="s6">'</span><span class="s3">)</span>
        <span class="s1">z</span><span class="s3">[...] = </span><span class="s1">_kolmogn</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">_n</span><span class="s3">), </span><span class="s1">_x</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s1">_cdf</span><span class="s3">)</span>
    <span class="s1">result </span><span class="s3">= </span><span class="s1">it</span><span class="s3">.</span><span class="s1">operands</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">kolmognp</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Computes the PDF for the two-sided Kolmogorov-Smirnov distribution. 
 
    Parameters 
    ---------- 
    n : integer, array_like 
        the number of samples 
    x : float, array_like 
        The K-S statistic, float between 0 and 1 
 
    Returns 
    ------- 
    pdf : ndarray 
        The PDF at the specified locations 
 
    The return value has shape the result of numpy broadcasting n and x. 
    &quot;&quot;&quot;</span>
    <span class="s1">it </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">([</span><span class="s1">n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s2">None</span><span class="s3">])</span>
    <span class="s2">for </span><span class="s1">_n</span><span class="s3">, </span><span class="s1">_x</span><span class="s3">, </span><span class="s1">z </span><span class="s2">in </span><span class="s1">it</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">_n</span><span class="s3">):</span>
            <span class="s1">z</span><span class="s3">[...] = </span><span class="s1">_n</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">int</span><span class="s3">(</span><span class="s1">_n</span><span class="s3">) != </span><span class="s1">_n</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">f'n is not integral: </span><span class="s2">{</span><span class="s1">_n</span><span class="s2">}</span><span class="s6">'</span><span class="s3">)</span>
        <span class="s1">z</span><span class="s3">[...] = </span><span class="s1">_kolmogn_p</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">_n</span><span class="s3">), </span><span class="s1">_x</span><span class="s3">)</span>
    <span class="s1">result </span><span class="s3">= </span><span class="s1">it</span><span class="s3">.</span><span class="s1">operands</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">kolmogni</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s5">&quot;&quot;&quot;Computes the PPF(or ISF) for the two-sided Kolmogorov-Smirnov distribution. 
 
    Parameters 
    ---------- 
    n : integer, array_like 
        the number of samples 
    q : float, array_like 
        Probabilities, float between 0 and 1 
    cdf : bool, optional 
        whether to compute the PPF(default=true) or the ISF. 
 
    Returns 
    ------- 
    ppf : ndarray 
        PPF (or ISF if cdf is False) at the specified locations 
 
    The return value has shape the result of numpy broadcasting n and x. 
    &quot;&quot;&quot;</span>
    <span class="s1">it </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">nditer</span><span class="s3">([</span><span class="s1">n</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">cdf</span><span class="s3">, </span><span class="s2">None</span><span class="s3">])</span>
    <span class="s2">for </span><span class="s1">_n</span><span class="s3">, </span><span class="s1">_q</span><span class="s3">, </span><span class="s1">_cdf</span><span class="s3">, </span><span class="s1">z </span><span class="s2">in </span><span class="s1">it</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">_n</span><span class="s3">):</span>
            <span class="s1">z</span><span class="s3">[...] = </span><span class="s1">_n</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">int</span><span class="s3">(</span><span class="s1">_n</span><span class="s3">) != </span><span class="s1">_n</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s6">f'n is not integral: </span><span class="s2">{</span><span class="s1">_n</span><span class="s2">}</span><span class="s6">'</span><span class="s3">)</span>
        <span class="s1">_pcdf</span><span class="s3">, </span><span class="s1">_psf </span><span class="s3">= (</span><span class="s1">_q</span><span class="s3">, </span><span class="s4">1</span><span class="s3">-</span><span class="s1">_q</span><span class="s3">) </span><span class="s2">if </span><span class="s1">_cdf </span><span class="s2">else </span><span class="s3">(</span><span class="s4">1</span><span class="s3">-</span><span class="s1">_q</span><span class="s3">, </span><span class="s1">_q</span><span class="s3">)</span>
        <span class="s1">z</span><span class="s3">[...] = </span><span class="s1">_kolmogni</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">_n</span><span class="s3">), </span><span class="s1">_pcdf</span><span class="s3">, </span><span class="s1">_psf</span><span class="s3">)</span>
    <span class="s1">result </span><span class="s3">= </span><span class="s1">it</span><span class="s3">.</span><span class="s1">operands</span><span class="s3">[-</span><span class="s4">1</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">result</span>
</pre>
</body>
</html>