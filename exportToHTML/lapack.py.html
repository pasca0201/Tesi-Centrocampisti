<html>
<head>
<title>lapack.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
lapack.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Low-level LAPACK functions (:mod:`scipy.linalg.lapack`) 
======================================================= 
 
This module contains low-level functions from the LAPACK library. 
 
.. versionadded:: 0.12.0 
 
.. note:: 
 
    The common ``overwrite_&lt;&gt;`` option in many routines, allows the 
    input arrays to be overwritten to avoid extra memory allocation. 
    However this requires the array to satisfy two conditions 
    which are memory order and the data type to match exactly the 
    order and the type expected by the routine. 
 
    As an example, if you pass a double precision float array to any 
    ``S....`` routine which expects single precision arguments, f2py 
    will create an intermediate array to match the argument types and 
    overwriting will be performed on that intermediate array. 
 
    Similarly, if a C-contiguous array is passed, f2py will pass a 
    FORTRAN-contiguous array internally. Please make sure that these 
    details are satisfied. More information can be found in the f2py 
    documentation. 
 
.. warning:: 
 
   These functions do little to no error checking. 
   It is possible to cause crashes by mis-using them, 
   so prefer using the higher-level routines in `scipy.linalg`. 
 
Finding functions 
----------------- 
 
.. autosummary:: 
   :toctree: generated/ 
 
   get_lapack_funcs 
 
All functions 
------------- 
 
.. autosummary:: 
   :toctree: generated/ 
 
   sgbsv 
   dgbsv 
   cgbsv 
   zgbsv 
 
   sgbtrf 
   dgbtrf 
   cgbtrf 
   zgbtrf 
 
   sgbtrs 
   dgbtrs 
   cgbtrs 
   zgbtrs 
 
   sgebal 
   dgebal 
   cgebal 
   zgebal 
 
   sgecon 
   dgecon 
   cgecon 
   zgecon 
 
   sgeequ 
   dgeequ 
   cgeequ 
   zgeequ 
 
   sgeequb 
   dgeequb 
   cgeequb 
   zgeequb 
 
   sgees 
   dgees 
   cgees 
   zgees 
 
   sgeev 
   dgeev 
   cgeev 
   zgeev 
 
   sgeev_lwork 
   dgeev_lwork 
   cgeev_lwork 
   zgeev_lwork 
 
   sgehrd 
   dgehrd 
   cgehrd 
   zgehrd 
 
   sgehrd_lwork 
   dgehrd_lwork 
   cgehrd_lwork 
   zgehrd_lwork 
 
   sgejsv 
   dgejsv 
 
   sgels 
   dgels 
   cgels 
   zgels 
 
   sgels_lwork 
   dgels_lwork 
   cgels_lwork 
   zgels_lwork 
 
   sgelsd 
   dgelsd 
   cgelsd 
   zgelsd 
 
   sgelsd_lwork 
   dgelsd_lwork 
   cgelsd_lwork 
   zgelsd_lwork 
 
   sgelss 
   dgelss 
   cgelss 
   zgelss 
 
   sgelss_lwork 
   dgelss_lwork 
   cgelss_lwork 
   zgelss_lwork 
 
   sgelsy 
   dgelsy 
   cgelsy 
   zgelsy 
 
   sgelsy_lwork 
   dgelsy_lwork 
   cgelsy_lwork 
   zgelsy_lwork 
 
   sgeqp3 
   dgeqp3 
   cgeqp3 
   zgeqp3 
 
   sgeqrf 
   dgeqrf 
   cgeqrf 
   zgeqrf 
 
   sgeqrf_lwork 
   dgeqrf_lwork 
   cgeqrf_lwork 
   zgeqrf_lwork 
 
   sgeqrfp 
   dgeqrfp 
   cgeqrfp 
   zgeqrfp 
 
   sgeqrfp_lwork 
   dgeqrfp_lwork 
   cgeqrfp_lwork 
   zgeqrfp_lwork 
 
   sgerqf 
   dgerqf 
   cgerqf 
   zgerqf 
 
   sgesdd 
   dgesdd 
   cgesdd 
   zgesdd 
 
   sgesdd_lwork 
   dgesdd_lwork 
   cgesdd_lwork 
   zgesdd_lwork 
 
   sgesv 
   dgesv 
   cgesv 
   zgesv 
 
   sgesvd 
   dgesvd 
   cgesvd 
   zgesvd 
 
   sgesvd_lwork 
   dgesvd_lwork 
   cgesvd_lwork 
   zgesvd_lwork 
 
   sgesvx 
   dgesvx 
   cgesvx 
   zgesvx 
 
   sgetrf 
   dgetrf 
   cgetrf 
   zgetrf 
 
   sgetc2 
   dgetc2 
   cgetc2 
   zgetc2 
 
   sgetri 
   dgetri 
   cgetri 
   zgetri 
 
   sgetri_lwork 
   dgetri_lwork 
   cgetri_lwork 
   zgetri_lwork 
 
   sgetrs 
   dgetrs 
   cgetrs 
   zgetrs 
 
   sgesc2 
   dgesc2 
   cgesc2 
   zgesc2 
 
   sgges 
   dgges 
   cgges 
   zgges 
 
   sggev 
   dggev 
   cggev 
   zggev 
 
   sgglse 
   dgglse 
   cgglse 
   zgglse 
 
   sgglse_lwork 
   dgglse_lwork 
   cgglse_lwork 
   zgglse_lwork 
 
   sgtsv 
   dgtsv 
   cgtsv 
   zgtsv 
 
   sgtsvx 
   dgtsvx 
   cgtsvx 
   zgtsvx 
 
   chbevd 
   zhbevd 
 
   chbevx 
   zhbevx 
 
   checon 
   zhecon 
 
   cheequb 
   zheequb 
 
   cheev 
   zheev 
 
   cheev_lwork 
   zheev_lwork 
 
   cheevd 
   zheevd 
 
   cheevd_lwork 
   zheevd_lwork 
 
   cheevr 
   zheevr 
 
   cheevr_lwork 
   zheevr_lwork 
 
   cheevx 
   zheevx 
 
   cheevx_lwork 
   zheevx_lwork 
 
   chegst 
   zhegst 
 
   chegv 
   zhegv 
 
   chegv_lwork 
   zhegv_lwork 
 
   chegvd 
   zhegvd 
 
   chegvx 
   zhegvx 
 
   chegvx_lwork 
   zhegvx_lwork 
 
   chesv 
   zhesv 
 
   chesv_lwork 
   zhesv_lwork 
 
   chesvx 
   zhesvx 
 
   chesvx_lwork 
   zhesvx_lwork 
 
   chetrd 
   zhetrd 
 
   chetrd_lwork 
   zhetrd_lwork 
 
   chetrf 
   zhetrf 
 
   chetrf_lwork 
   zhetrf_lwork 
 
   chfrk 
   zhfrk 
 
   slamch 
   dlamch 
 
   slange 
   dlange 
   clange 
   zlange 
 
   slarf 
   dlarf 
   clarf 
   zlarf 
 
   slarfg 
   dlarfg 
   clarfg 
   zlarfg 
 
   slartg 
   dlartg 
   clartg 
   zlartg 
 
   slasd4 
   dlasd4 
 
   slaswp 
   dlaswp 
   claswp 
   zlaswp 
 
   slauum 
   dlauum 
   clauum 
   zlauum 
 
   sorcsd 
   dorcsd 
   sorcsd_lwork 
   dorcsd_lwork 
 
   sorghr 
   dorghr 
   sorghr_lwork 
   dorghr_lwork 
 
   sorgqr 
   dorgqr 
 
   sorgrq 
   dorgrq 
 
   sormqr 
   dormqr 
 
   sormrz 
   dormrz 
 
   sormrz_lwork 
   dormrz_lwork 
 
   spbsv 
   dpbsv 
   cpbsv 
   zpbsv 
 
   spbtrf 
   dpbtrf 
   cpbtrf 
   zpbtrf 
 
   spbtrs 
   dpbtrs 
   cpbtrs 
   zpbtrs 
 
   spftrf 
   dpftrf 
   cpftrf 
   zpftrf 
 
   spftri 
   dpftri 
   cpftri 
   zpftri 
 
   spftrs 
   dpftrs 
   cpftrs 
   zpftrs 
 
   spocon 
   dpocon 
   cpocon 
   zpocon 
 
   spstrf 
   dpstrf 
   cpstrf 
   zpstrf 
 
   spstf2 
   dpstf2 
   cpstf2 
   zpstf2 
 
   sposv 
   dposv 
   cposv 
   zposv 
 
   sposvx 
   dposvx 
   cposvx 
   zposvx 
 
   spotrf 
   dpotrf 
   cpotrf 
   zpotrf 
 
   spotri 
   dpotri 
   cpotri 
   zpotri 
 
   spotrs 
   dpotrs 
   cpotrs 
   zpotrs 
 
   sppcon 
   dppcon 
   cppcon 
   zppcon 
 
   sppsv 
   dppsv 
   cppsv 
   zppsv 
 
   spptrf 
   dpptrf 
   cpptrf 
   zpptrf 
 
   spptri 
   dpptri 
   cpptri 
   zpptri 
 
   spptrs 
   dpptrs 
   cpptrs 
   zpptrs 
 
   sptsv 
   dptsv 
   cptsv 
   zptsv 
 
   sptsvx 
   dptsvx 
   cptsvx 
   zptsvx 
 
   spttrf 
   dpttrf 
   cpttrf 
   zpttrf 
 
   spttrs 
   dpttrs 
   cpttrs 
   zpttrs 
 
   spteqr 
   dpteqr 
   cpteqr 
   zpteqr 
 
   crot 
   zrot 
 
   ssbev 
   dsbev 
 
   ssbevd 
   dsbevd 
 
   ssbevx 
   dsbevx 
 
   ssfrk 
   dsfrk 
 
   sstebz 
   dstebz 
 
   sstein 
   dstein 
 
   sstemr 
   dstemr 
 
   sstemr_lwork 
   dstemr_lwork 
 
   ssterf 
   dsterf 
 
   sstev 
   dstev 
 
   ssycon 
   dsycon 
   csycon 
   zsycon 
 
   ssyconv 
   dsyconv 
   csyconv 
   zsyconv 
 
   ssyequb 
   dsyequb 
   csyequb 
   zsyequb 
 
   ssyev 
   dsyev 
 
   ssyev_lwork 
   dsyev_lwork 
 
   ssyevd 
   dsyevd 
 
   ssyevd_lwork 
   dsyevd_lwork 
 
   ssyevr 
   dsyevr 
 
   ssyevr_lwork 
   dsyevr_lwork 
 
   ssyevx 
   dsyevx 
 
   ssyevx_lwork 
   dsyevx_lwork 
 
   ssygst 
   dsygst 
 
   ssygv 
   dsygv 
 
   ssygv_lwork 
   dsygv_lwork 
 
   ssygvd 
   dsygvd 
 
   ssygvx 
   dsygvx 
 
   ssygvx_lwork 
   dsygvx_lwork 
 
   ssysv 
   dsysv 
   csysv 
   zsysv 
 
   ssysv_lwork 
   dsysv_lwork 
   csysv_lwork 
   zsysv_lwork 
 
   ssysvx 
   dsysvx 
   csysvx 
   zsysvx 
 
   ssysvx_lwork 
   dsysvx_lwork 
   csysvx_lwork 
   zsysvx_lwork 
 
   ssytf2 
   dsytf2 
   csytf2 
   zsytf2 
 
   ssytrd 
   dsytrd 
 
   ssytrd_lwork 
   dsytrd_lwork 
 
   ssytrf 
   dsytrf 
   csytrf 
   zsytrf 
 
   ssytrf_lwork 
   dsytrf_lwork 
   csytrf_lwork 
   zsytrf_lwork 
 
   stbtrs 
   dtbtrs 
   ctbtrs 
   ztbtrs 
 
   stfsm 
   dtfsm 
   ctfsm 
   ztfsm 
 
   stfttp 
   dtfttp 
   ctfttp 
   ztfttp 
 
   stfttr 
   dtfttr 
   ctfttr 
   ztfttr 
 
   stgexc 
   dtgexc 
   ctgexc 
   ztgexc 
 
   stgsen 
   dtgsen 
   ctgsen 
   ztgsen 
 
   stgsen_lwork 
   dtgsen_lwork 
   ctgsen_lwork 
   ztgsen_lwork 
 
   stgsyl 
   dtgsyl 
 
   stpttf 
   dtpttf 
   ctpttf 
   ztpttf 
 
   stpttr 
   dtpttr 
   ctpttr 
   ztpttr 
 
   strexc 
   dtrexc 
   ctrexc 
   ztrexc 
 
   strsen 
   dtrsen 
   ctrsen 
   ztrsen 
 
   strsen_lwork 
   dtrsen_lwork 
   ctrsen_lwork 
   ztrsen_lwork 
 
   strsyl 
   dtrsyl 
   ctrsyl 
   ztrsyl 
 
   strtri 
   dtrtri 
   ctrtri 
   ztrtri 
 
   strtrs 
   dtrtrs 
   ctrtrs 
   ztrtrs 
 
   strttf 
   dtrttf 
   ctrttf 
   ztrttf 
 
   strttp 
   dtrttp 
   ctrttp 
   ztrttp 
 
   stzrzf 
   dtzrzf 
   ctzrzf 
   ztzrzf 
 
   stzrzf_lwork 
   dtzrzf_lwork 
   ctzrzf_lwork 
   ztzrzf_lwork 
 
   cunghr 
   zunghr 
 
   cunghr_lwork 
   zunghr_lwork 
 
   cungqr 
   zungqr 
 
   cungrq 
   zungrq 
 
   cunmqr 
   zunmqr 
 
   sgeqrt 
   dgeqrt 
   cgeqrt 
   zgeqrt 
 
   sgemqrt 
   dgemqrt 
   cgemqrt 
   zgemqrt 
 
   sgttrf 
   dgttrf 
   cgttrf 
   zgttrf 
 
   sgttrs 
   dgttrs 
   cgttrs 
   zgttrs 
 
   stpqrt 
   dtpqrt 
   ctpqrt 
   ztpqrt 
 
   stpmqrt 
   dtpmqrt 
   ctpmqrt 
   ztpmqrt 
 
   cuncsd 
   zuncsd 
 
   cuncsd_lwork 
   zuncsd_lwork 
 
   cunmrz 
   zunmrz 
 
   cunmrz_lwork 
   zunmrz_lwork 
 
   ilaver 
 
&quot;&quot;&quot;</span>
<span class="s2">#</span>
<span class="s2"># Author: Pearu Peterson, March 2002</span>
<span class="s2">#</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">blas </span><span class="s3">import </span><span class="s1">_get_funcs</span><span class="s4">, </span><span class="s1">_memoize_get_funcs</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">linalg </span><span class="s3">import </span><span class="s1">_flapack</span>
<span class="s3">from </span><span class="s1">re </span><span class="s3">import </span><span class="s1">compile </span><span class="s3">as </span><span class="s1">regex_compile</span>
<span class="s3">try</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">linalg </span><span class="s3">import </span><span class="s1">_clapack</span>
<span class="s3">except </span><span class="s1">ImportError</span><span class="s4">:</span>
    <span class="s1">_clapack </span><span class="s4">= </span><span class="s3">None</span>

<span class="s3">try</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">linalg </span><span class="s3">import </span><span class="s1">_flapack_64</span>
    <span class="s1">HAS_ILP64 </span><span class="s4">= </span><span class="s3">True</span>
<span class="s3">except </span><span class="s1">ImportError</span><span class="s4">:</span>
    <span class="s1">HAS_ILP64 </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_flapack_64 </span><span class="s4">= </span><span class="s3">None</span>


<span class="s2"># Expose all functions (only flapack --- clapack is an implementation detail)</span>
<span class="s1">empty_module </span><span class="s4">= </span><span class="s3">None</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">_flapack </span><span class="s3">import </span><span class="s4">*  </span><span class="s2"># noqa: E402, F403</span>
<span class="s3">del </span><span class="s1">empty_module</span>

<span class="s1">__all__ </span><span class="s4">= [</span><span class="s5">'get_lapack_funcs'</span><span class="s4">]</span>

<span class="s2"># some convenience alias for complex functions</span>
<span class="s1">_lapack_alias </span><span class="s4">= {</span>
    <span class="s5">'corghr'</span><span class="s4">: </span><span class="s5">'cunghr'</span><span class="s4">, </span><span class="s5">'zorghr'</span><span class="s4">: </span><span class="s5">'zunghr'</span><span class="s4">,</span>
    <span class="s5">'corghr_lwork'</span><span class="s4">: </span><span class="s5">'cunghr_lwork'</span><span class="s4">, </span><span class="s5">'zorghr_lwork'</span><span class="s4">: </span><span class="s5">'zunghr_lwork'</span><span class="s4">,</span>
    <span class="s5">'corgqr'</span><span class="s4">: </span><span class="s5">'cungqr'</span><span class="s4">, </span><span class="s5">'zorgqr'</span><span class="s4">: </span><span class="s5">'zungqr'</span><span class="s4">,</span>
    <span class="s5">'cormqr'</span><span class="s4">: </span><span class="s5">'cunmqr'</span><span class="s4">, </span><span class="s5">'zormqr'</span><span class="s4">: </span><span class="s5">'zunmqr'</span><span class="s4">,</span>
    <span class="s5">'corgrq'</span><span class="s4">: </span><span class="s5">'cungrq'</span><span class="s4">, </span><span class="s5">'zorgrq'</span><span class="s4">: </span><span class="s5">'zungrq'</span><span class="s4">,</span>
<span class="s4">}</span>


<span class="s2"># Place guards against docstring rendering issues with special characters</span>
<span class="s1">p1 </span><span class="s4">= </span><span class="s1">regex_compile</span><span class="s4">(</span><span class="s5">r'with bounds (?P&lt;b&gt;.*?)( and (?P&lt;s&gt;.*?) storage){0,1}\n'</span><span class="s4">)</span>
<span class="s1">p2 </span><span class="s4">= </span><span class="s1">regex_compile</span><span class="s4">(</span><span class="s5">r'Default: (?P&lt;d&gt;.*?)\n'</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">backtickrepl</span><span class="s4">(</span><span class="s1">m</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">'s'</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">(</span><span class="s5">'with bounds ``{}`` with ``{}`` storage</span><span class="s3">\n</span><span class="s5">'</span>
                <span class="s5">''</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">'b'</span><span class="s4">), </span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">'s'</span><span class="s4">)))</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s5">'with bounds ``{}``</span><span class="s3">\n</span><span class="s5">'</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">m</span><span class="s4">.</span><span class="s1">group</span><span class="s4">(</span><span class="s5">'b'</span><span class="s4">))</span>


<span class="s3">for </span><span class="s1">routine </span><span class="s3">in </span><span class="s4">[</span><span class="s1">ssyevr</span><span class="s4">, </span><span class="s1">dsyevr</span><span class="s4">, </span><span class="s1">cheevr</span><span class="s4">, </span><span class="s1">zheevr</span><span class="s4">,</span>
                <span class="s1">ssyevx</span><span class="s4">, </span><span class="s1">dsyevx</span><span class="s4">, </span><span class="s1">cheevx</span><span class="s4">, </span><span class="s1">zheevx</span><span class="s4">,</span>
                <span class="s1">ssygvd</span><span class="s4">, </span><span class="s1">dsygvd</span><span class="s4">, </span><span class="s1">chegvd</span><span class="s4">, </span><span class="s1">zhegvd</span><span class="s4">]:</span>
    <span class="s3">if </span><span class="s1">routine</span><span class="s4">.</span><span class="s1">__doc__</span><span class="s4">:</span>
        <span class="s1">routine</span><span class="s4">.</span><span class="s1">__doc__ </span><span class="s4">= </span><span class="s1">p1</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">(</span><span class="s1">backtickrepl</span><span class="s4">, </span><span class="s1">routine</span><span class="s4">.</span><span class="s1">__doc__</span><span class="s4">)</span>
        <span class="s1">routine</span><span class="s4">.</span><span class="s1">__doc__ </span><span class="s4">= </span><span class="s1">p2</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">(</span><span class="s5">'Default ``</span><span class="s3">\\</span><span class="s5">1``</span><span class="s3">\n</span><span class="s5">'</span><span class="s4">, </span><span class="s1">routine</span><span class="s4">.</span><span class="s1">__doc__</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">continue</span>

<span class="s3">del </span><span class="s1">regex_compile</span><span class="s4">, </span><span class="s1">p1</span><span class="s4">, </span><span class="s1">p2</span><span class="s4">, </span><span class="s1">backtickrepl</span>


<span class="s4">@</span><span class="s1">_memoize_get_funcs</span>
<span class="s3">def </span><span class="s1">get_lapack_funcs</span><span class="s4">(</span><span class="s1">names</span><span class="s4">, </span><span class="s1">arrays</span><span class="s4">=(), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">ilp64</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Return available LAPACK function objects from names. 
 
    Arrays are used to determine the optimal prefix of LAPACK routines. 
 
    Parameters 
    ---------- 
    names : str or sequence of str 
        Name(s) of LAPACK functions without type prefix. 
 
    arrays : sequence of ndarrays, optional 
        Arrays can be given to determine optimal prefix of LAPACK 
        routines. If not given, double-precision routines will be 
        used, otherwise the most generic type in arrays will be used. 
 
    dtype : str or dtype, optional 
        Data-type specifier. Not used if `arrays` is non-empty. 
 
    ilp64 : {True, False, 'preferred'}, optional 
        Whether to return ILP64 routine variant. 
        Choosing 'preferred' returns ILP64 routine if available, and 
        otherwise the 32-bit routine. Default: False 
 
    Returns 
    ------- 
    funcs : list 
        List containing the found function(s). 
 
    Notes 
    ----- 
    This routine automatically chooses between Fortran/C 
    interfaces. Fortran code is used whenever possible for arrays with 
    column major order. In all other cases, C code is preferred. 
 
    In LAPACK, the naming convention is that all functions start with a 
    type prefix, which depends on the type of the principal 
    matrix. These can be one of {'s', 'd', 'c', 'z'} for the NumPy 
    types {float32, float64, complex64, complex128} respectively, and 
    are stored in attribute ``typecode`` of the returned functions. 
 
    Examples 
    -------- 
    Suppose we would like to use '?lange' routine which computes the selected 
    norm of an array. We pass our array in order to get the correct 'lange' 
    flavor. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import scipy.linalg as LA 
    &gt;&gt;&gt; rng = np.random.default_rng() 
 
    &gt;&gt;&gt; a = rng.random((3,2)) 
    &gt;&gt;&gt; x_lange = LA.get_lapack_funcs('lange', (a,)) 
    &gt;&gt;&gt; x_lange.typecode 
    'd' 
    &gt;&gt;&gt; x_lange = LA.get_lapack_funcs('lange',(a*1j,)) 
    &gt;&gt;&gt; x_lange.typecode 
    'z' 
 
    Several LAPACK routines work best when its internal WORK array has 
    the optimal size (big enough for fast computation and small enough to 
    avoid waste of memory). This size is determined also by a dedicated query 
    to the function which is often wrapped as a standalone function and 
    commonly denoted as ``###_lwork``. Below is an example for ``?sysv`` 
 
    &gt;&gt;&gt; a = rng.random((1000, 1000)) 
    &gt;&gt;&gt; b = rng.random((1000, 1)) * 1j 
    &gt;&gt;&gt; # We pick up zsysv and zsysv_lwork due to b array 
    ... xsysv, xlwork = LA.get_lapack_funcs(('sysv', 'sysv_lwork'), (a, b)) 
    &gt;&gt;&gt; opt_lwork, _ = xlwork(a.shape[0])  # returns a complex for 'z' prefix 
    &gt;&gt;&gt; udut, ipiv, x, info = xsysv(a, b, lwork=int(opt_lwork.real)) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">ilp64</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">ilp64 </span><span class="s4">== </span><span class="s5">'preferred'</span><span class="s4">:</span>
            <span class="s1">ilp64 </span><span class="s4">= </span><span class="s1">HAS_ILP64</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Invalid value for 'ilp64'&quot;</span><span class="s4">)</span>

    <span class="s3">if not </span><span class="s1">ilp64</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">_get_funcs</span><span class="s4">(</span><span class="s1">names</span><span class="s4">, </span><span class="s1">arrays</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">,</span>
                          <span class="s5">&quot;LAPACK&quot;</span><span class="s4">, </span><span class="s1">_flapack</span><span class="s4">, </span><span class="s1">_clapack</span><span class="s4">,</span>
                          <span class="s5">&quot;flapack&quot;</span><span class="s4">, </span><span class="s5">&quot;clapack&quot;</span><span class="s4">, </span><span class="s1">_lapack_alias</span><span class="s4">,</span>
                          <span class="s1">ilp64</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">if not </span><span class="s1">HAS_ILP64</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">RuntimeError</span><span class="s4">(</span><span class="s5">&quot;LAPACK ILP64 routine requested, but Scipy &quot;</span>
                               <span class="s5">&quot;compiled only with 32-bit BLAS&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">_get_funcs</span><span class="s4">(</span><span class="s1">names</span><span class="s4">, </span><span class="s1">arrays</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">,</span>
                          <span class="s5">&quot;LAPACK&quot;</span><span class="s4">, </span><span class="s1">_flapack_64</span><span class="s4">, </span><span class="s3">None</span><span class="s4">,</span>
                          <span class="s5">&quot;flapack_64&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">_lapack_alias</span><span class="s4">,</span>
                          <span class="s1">ilp64</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>


<span class="s1">_int32_max </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">iinfo</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">int32</span><span class="s4">).</span><span class="s1">max</span>
<span class="s1">_int64_max </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">iinfo</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">int64</span><span class="s4">).</span><span class="s1">max</span>


<span class="s3">def </span><span class="s1">_compute_lwork</span><span class="s4">(</span><span class="s1">routine</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Round floating-point lwork returned by lapack to integer. 
 
    Several LAPACK routines compute optimal values for LWORK, which 
    they return in a floating-point variable. However, for large 
    values of LWORK, single-precision floating point is not sufficient 
    to hold the exact value --- some LAPACK versions (&lt;= 3.5.0 at 
    least) truncate the returned integer to single precision and in 
    some cases this can be smaller than the required value. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.linalg import lapack 
    &gt;&gt;&gt; n = 5000 
    &gt;&gt;&gt; s_r, s_lw = lapack.get_lapack_funcs(('sysvx', 'sysvx_lwork')) 
    &gt;&gt;&gt; lwork = lapack._compute_lwork(s_lw, n) 
    &gt;&gt;&gt; lwork 
    32000 
 
    &quot;&quot;&quot;</span>
    <span class="s1">dtype </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">routine</span><span class="s4">, </span><span class="s5">'dtype'</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
    <span class="s1">int_dtype </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">routine</span><span class="s4">, </span><span class="s5">'int_dtype'</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
    <span class="s1">ret </span><span class="s4">= </span><span class="s1">routine</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ret</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">] != </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Internal work array size computation failed: &quot;</span>
                         <span class="s5">&quot;%d&quot; </span><span class="s4">% (</span><span class="s1">ret</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">],))</span>

    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">ret</span><span class="s4">) == </span><span class="s6">2</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">_check_work_float</span><span class="s4">(</span><span class="s1">ret</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">real</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">int_dtype</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">_check_work_float</span><span class="s4">(</span><span class="s1">x</span><span class="s4">.</span><span class="s1">real</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">int_dtype</span><span class="s4">)</span>
                     <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">ret</span><span class="s4">[:-</span><span class="s6">1</span><span class="s4">])</span>


<span class="s3">def </span><span class="s1">_check_work_float</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">int_dtype</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert LAPACK-returned work array size float to integer, 
    carefully for single-precision types. 
    &quot;&quot;&quot;</span>

    <span class="s3">if </span><span class="s1">dtype </span><span class="s4">== </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32 </span><span class="s3">or </span><span class="s1">dtype </span><span class="s4">== </span><span class="s1">np</span><span class="s4">.</span><span class="s1">complex64</span><span class="s4">:</span>
        <span class="s2"># Single-precision routine -- take next fp value to work</span>
        <span class="s2"># around possible truncation in LAPACK code</span>
        <span class="s1">value </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">nextafter</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">)</span>

    <span class="s1">value </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">int_dtype</span><span class="s4">.</span><span class="s1">itemsize </span><span class="s4">== </span><span class="s6">4</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">value </span><span class="s4">&lt; </span><span class="s6">0 </span><span class="s3">or </span><span class="s1">value </span><span class="s4">&gt; </span><span class="s1">_int32_max</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Too large work array required -- computation &quot;</span>
                             <span class="s5">&quot;cannot be performed with standard 32-bit&quot;</span>
                             <span class="s5">&quot; LAPACK.&quot;</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">int_dtype</span><span class="s4">.</span><span class="s1">itemsize </span><span class="s4">== </span><span class="s6">8</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">value </span><span class="s4">&lt; </span><span class="s6">0 </span><span class="s3">or </span><span class="s1">value </span><span class="s4">&gt; </span><span class="s1">_int64_max</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Too large work array required -- computation&quot;</span>
                             <span class="s5">&quot; cannot be performed with standard 64-bit&quot;</span>
                             <span class="s5">&quot; LAPACK.&quot;</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">value</span>
</pre>
</body>
</html>