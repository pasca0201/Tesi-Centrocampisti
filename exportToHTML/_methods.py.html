<html>
<head>
<title>_methods.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_methods.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Array methods which are called by both the C-code for the method 
and the Python code for the NumPy-namespace function 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">pickle</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">nullcontext</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">_core </span><span class="s2">import </span><span class="s1">multiarray </span><span class="s2">as </span><span class="s1">mu</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">_core </span><span class="s2">import </span><span class="s1">umath </span><span class="s2">as </span><span class="s1">um</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">_core</span><span class="s3">.</span><span class="s1">multiarray </span><span class="s2">import </span><span class="s1">asanyarray</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">_core </span><span class="s2">import </span><span class="s1">numerictypes </span><span class="s2">as </span><span class="s1">nt</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">_core </span><span class="s2">import </span><span class="s1">_exceptions</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">_core</span><span class="s3">.</span><span class="s1">_ufunc_config </span><span class="s2">import </span><span class="s1">_no_nep50_warning</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">_globals </span><span class="s2">import </span><span class="s1">_NoValue</span>

<span class="s4"># save those O(100) nanoseconds!</span>
<span class="s1">bool_dt </span><span class="s3">= </span><span class="s1">mu</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s5">&quot;bool&quot;</span><span class="s3">)</span>
<span class="s1">umr_maximum </span><span class="s3">= </span><span class="s1">um</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">.</span><span class="s1">reduce</span>
<span class="s1">umr_minimum </span><span class="s3">= </span><span class="s1">um</span><span class="s3">.</span><span class="s1">minimum</span><span class="s3">.</span><span class="s1">reduce</span>
<span class="s1">umr_sum </span><span class="s3">= </span><span class="s1">um</span><span class="s3">.</span><span class="s1">add</span><span class="s3">.</span><span class="s1">reduce</span>
<span class="s1">umr_prod </span><span class="s3">= </span><span class="s1">um</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">.</span><span class="s1">reduce</span>
<span class="s1">umr_bitwise_count </span><span class="s3">= </span><span class="s1">um</span><span class="s3">.</span><span class="s1">bitwise_count</span>
<span class="s1">umr_any </span><span class="s3">= </span><span class="s1">um</span><span class="s3">.</span><span class="s1">logical_or</span><span class="s3">.</span><span class="s1">reduce</span>
<span class="s1">umr_all </span><span class="s3">= </span><span class="s1">um</span><span class="s3">.</span><span class="s1">logical_and</span><span class="s3">.</span><span class="s1">reduce</span>

<span class="s4"># Complex types to -&gt; (2,)float view for fast-path computation in _var()</span>
<span class="s1">_complex_to_float </span><span class="s3">= {</span>
    <span class="s1">nt</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">.</span><span class="s1">csingle</span><span class="s3">) : </span><span class="s1">nt</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">.</span><span class="s1">single</span><span class="s3">),</span>
    <span class="s1">nt</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">.</span><span class="s1">cdouble</span><span class="s3">) : </span><span class="s1">nt</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">.</span><span class="s1">double</span><span class="s3">),</span>
<span class="s3">}</span>
<span class="s4"># Special case for windows: ensure double takes precedence</span>
<span class="s2">if </span><span class="s1">nt</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">.</span><span class="s1">longdouble</span><span class="s3">) != </span><span class="s1">nt</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">.</span><span class="s1">double</span><span class="s3">):</span>
    <span class="s1">_complex_to_float</span><span class="s3">.</span><span class="s1">update</span><span class="s3">({</span>
        <span class="s1">nt</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">.</span><span class="s1">clongdouble</span><span class="s3">) : </span><span class="s1">nt</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">nt</span><span class="s3">.</span><span class="s1">longdouble</span><span class="s3">),</span>
    <span class="s3">})</span>

<span class="s4"># avoid keyword arguments to speed up parsing, saves about 15%-20% for very</span>
<span class="s4"># small reductions</span>
<span class="s2">def </span><span class="s1">_amax</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
          <span class="s1">initial</span><span class="s3">=</span><span class="s1">_NoValue</span><span class="s3">, </span><span class="s1">where</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">umr_maximum</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">, </span><span class="s1">initial</span><span class="s3">, </span><span class="s1">where</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">_amin</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
          <span class="s1">initial</span><span class="s3">=</span><span class="s1">_NoValue</span><span class="s3">, </span><span class="s1">where</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">umr_minimum</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">, </span><span class="s1">initial</span><span class="s3">, </span><span class="s1">where</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">_sum</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
         <span class="s1">initial</span><span class="s3">=</span><span class="s1">_NoValue</span><span class="s3">, </span><span class="s1">where</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">umr_sum</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">, </span><span class="s1">initial</span><span class="s3">, </span><span class="s1">where</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">_prod</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
          <span class="s1">initial</span><span class="s3">=</span><span class="s1">_NoValue</span><span class="s3">, </span><span class="s1">where</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">umr_prod</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">, </span><span class="s1">initial</span><span class="s3">, </span><span class="s1">where</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">_any</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, *, </span><span class="s1">where</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s4"># By default, return a boolean for any and all</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">bool_dt</span>
    <span class="s4"># Parsing keyword arguments is currently fairly slow, so avoid it for now</span>
    <span class="s2">if </span><span class="s1">where </span><span class="s2">is True</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">umr_any</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">umr_any</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">, </span><span class="s1">where</span><span class="s3">=</span><span class="s1">where</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">_all</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, *, </span><span class="s1">where</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s4"># By default, return a boolean for any and all</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">bool_dt</span>
    <span class="s4"># Parsing keyword arguments is currently fairly slow, so avoid it for now</span>
    <span class="s2">if </span><span class="s1">where </span><span class="s2">is True</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">umr_all</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">umr_all</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">, </span><span class="s1">where</span><span class="s3">=</span><span class="s1">where</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">_count_reduce_items</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">where</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s4"># fast-path for the default case</span>
    <span class="s2">if </span><span class="s1">where </span><span class="s2">is True</span><span class="s3">:</span>
        <span class="s4"># no boolean mask given, calculate items according to axis</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">axis </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">))</span>
        <span class="s2">elif not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s1">axis </span><span class="s3">= (</span><span class="s1">axis</span><span class="s3">,)</span>
        <span class="s1">items </span><span class="s3">= </span><span class="s6">1</span>
        <span class="s2">for </span><span class="s1">ax </span><span class="s2">in </span><span class="s1">axis</span><span class="s3">:</span>
            <span class="s1">items </span><span class="s3">*= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">mu</span><span class="s3">.</span><span class="s1">normalize_axis_index</span><span class="s3">(</span><span class="s1">ax</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">)]</span>
        <span class="s1">items </span><span class="s3">= </span><span class="s1">nt</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">(</span><span class="s1">items</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s4"># TODO: Optimize case when `where` is broadcast along a non-reduction</span>
        <span class="s4"># axis and full sum is more excessive than needed.</span>

        <span class="s4"># guarded to protect circular imports</span>
        <span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">lib</span><span class="s3">.</span><span class="s1">_stride_tricks_impl </span><span class="s2">import </span><span class="s1">broadcast_to</span>
        <span class="s4"># count True values in (potentially broadcasted) boolean mask</span>
        <span class="s1">items </span><span class="s3">= </span><span class="s1">umr_sum</span><span class="s3">(</span><span class="s1">broadcast_to</span><span class="s3">(</span><span class="s1">where</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">.</span><span class="s1">intp</span><span class="s3">, </span><span class="s2">None</span><span class="s3">,</span>
                        <span class="s1">keepdims</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">items</span>

<span class="s2">def </span><span class="s1">_clip</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">min</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">max</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">kind </span><span class="s2">in </span><span class="s5">&quot;iu&quot;</span><span class="s3">:</span>
        <span class="s4"># If min/max is a Python integer, deal with out-of-bound values here.</span>
        <span class="s4"># (This enforces NEP 50 rules as no value based promotion is done.)</span>
        <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">min</span><span class="s3">) </span><span class="s2">is </span><span class="s1">int </span><span class="s2">and </span><span class="s1">min </span><span class="s3">&lt;= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iinfo</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">min</span><span class="s3">:</span>
            <span class="s1">min </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">max</span><span class="s3">) </span><span class="s2">is </span><span class="s1">int </span><span class="s2">and </span><span class="s1">max </span><span class="s3">&gt;= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">iinfo</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">max</span><span class="s3">:</span>
            <span class="s1">max </span><span class="s3">= </span><span class="s2">None</span>

    <span class="s2">if </span><span class="s1">min </span><span class="s2">is None and </span><span class="s1">max </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s4"># return identity</span>
        <span class="s2">return </span><span class="s1">um</span><span class="s3">.</span><span class="s1">positive</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">out</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">min </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">um</span><span class="s3">.</span><span class="s1">minimum</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">max</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">out</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">max </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">um</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">min</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">out</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">um</span><span class="s3">.</span><span class="s1">clip</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">min</span><span class="s3">, </span><span class="s1">max</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">out</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">_mean</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, *, </span><span class="s1">where</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

    <span class="s1">is_float16_result </span><span class="s3">= </span><span class="s2">False</span>

    <span class="s1">rcount </span><span class="s3">= </span><span class="s1">_count_reduce_items</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s1">keepdims</span><span class="s3">, </span><span class="s1">where</span><span class="s3">=</span><span class="s1">where</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">rcount </span><span class="s3">== </span><span class="s6">0 </span><span class="s2">if </span><span class="s1">where </span><span class="s2">is True else </span><span class="s1">umr_any</span><span class="s3">(</span><span class="s1">rcount </span><span class="s3">== </span><span class="s6">0</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s5">&quot;Mean of empty slice.&quot;</span><span class="s3">, </span><span class="s1">RuntimeWarning</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s6">2</span><span class="s3">)</span>

    <span class="s4"># Cast bool, unsigned int, and int to float64 by default</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, (</span><span class="s1">nt</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">.</span><span class="s1">bool</span><span class="s3">)):</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">mu</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s5">'f8'</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">.</span><span class="s1">float16</span><span class="s3">):</span>
            <span class="s1">dtype </span><span class="s3">= </span><span class="s1">mu</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s5">'f4'</span><span class="s3">)</span>
            <span class="s1">is_float16_result </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s1">ret </span><span class="s3">= </span><span class="s1">umr_sum</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">, </span><span class="s1">where</span><span class="s3">=</span><span class="s1">where</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">_no_nep50_warning</span><span class="s3">():</span>
            <span class="s1">ret </span><span class="s3">= </span><span class="s1">um</span><span class="s3">.</span><span class="s1">true_divide</span><span class="s3">(</span>
                    <span class="s1">ret</span><span class="s3">, </span><span class="s1">rcount</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">ret</span><span class="s3">, </span><span class="s1">casting</span><span class="s3">=</span><span class="s5">'unsafe'</span><span class="s3">, </span><span class="s1">subok</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">is_float16_result </span><span class="s2">and </span><span class="s1">out </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">ret </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s5">'dtype'</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">is_float16_result</span><span class="s3">:</span>
            <span class="s1">ret </span><span class="s3">= </span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s1">ret </span><span class="s3">/ </span><span class="s1">rcount</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">ret </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s1">ret </span><span class="s3">/ </span><span class="s1">rcount</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s1">ret </span><span class="s3">/ </span><span class="s1">rcount</span>

    <span class="s2">return </span><span class="s1">ret</span>

<span class="s2">def </span><span class="s1">_var</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, *,</span>
         <span class="s1">where</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">mean</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">arr </span><span class="s3">= </span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)</span>

    <span class="s1">rcount </span><span class="s3">= </span><span class="s1">_count_reduce_items</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s1">keepdims</span><span class="s3">, </span><span class="s1">where</span><span class="s3">=</span><span class="s1">where</span><span class="s3">)</span>
    <span class="s4"># Make this warning show up on top.</span>
    <span class="s2">if </span><span class="s1">ddof </span><span class="s3">&gt;= </span><span class="s1">rcount </span><span class="s2">if </span><span class="s1">where </span><span class="s2">is True else </span><span class="s1">umr_any</span><span class="s3">(</span><span class="s1">ddof </span><span class="s3">&gt;= </span><span class="s1">rcount</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s5">&quot;Degrees of freedom &lt;= 0 for slice&quot;</span><span class="s3">, </span><span class="s1">RuntimeWarning</span><span class="s3">,</span>
                      <span class="s1">stacklevel</span><span class="s3">=</span><span class="s6">2</span><span class="s3">)</span>

    <span class="s4"># Cast bool, unsigned int, and int to float64 by default</span>
    <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None and </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, (</span><span class="s1">nt</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">.</span><span class="s1">bool</span><span class="s3">)):</span>
        <span class="s1">dtype </span><span class="s3">= </span><span class="s1">mu</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s5">'f8'</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">mean </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">arrmean </span><span class="s3">= </span><span class="s1">mean</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s4"># Compute the mean.</span>
        <span class="s4"># Note that if dtype is not of inexact type then arraymean will</span>
        <span class="s4"># not be either.</span>
        <span class="s1">arrmean </span><span class="s3">= </span><span class="s1">umr_sum</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">where</span><span class="s3">=</span><span class="s1">where</span><span class="s3">)</span>
        <span class="s4"># The shape of rcount has to match arrmean to not change the shape of</span>
        <span class="s4"># out in broadcasting. Otherwise, it cannot be stored back to arrmean.</span>
        <span class="s2">if </span><span class="s1">rcount</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s4"># fast-path for default case when where is True</span>
            <span class="s1">div </span><span class="s3">= </span><span class="s1">rcount</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s4"># matching rcount to arrmean when where is specified as array</span>
            <span class="s1">div </span><span class="s3">= </span><span class="s1">rcount</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">arrmean</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">arrmean</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
            <span class="s2">with </span><span class="s1">_no_nep50_warning</span><span class="s3">():</span>
                <span class="s1">arrmean </span><span class="s3">= </span><span class="s1">um</span><span class="s3">.</span><span class="s1">true_divide</span><span class="s3">(</span><span class="s1">arrmean</span><span class="s3">, </span><span class="s1">div</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">arrmean</span><span class="s3">,</span>
                                         <span class="s1">casting</span><span class="s3">=</span><span class="s5">'unsafe'</span><span class="s3">, </span><span class="s1">subok</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">arrmean</span><span class="s3">, </span><span class="s5">&quot;dtype&quot;</span><span class="s3">):</span>
            <span class="s1">arrmean </span><span class="s3">= </span><span class="s1">arrmean</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s1">arrmean </span><span class="s3">/ </span><span class="s1">rcount</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">arrmean </span><span class="s3">= </span><span class="s1">arrmean </span><span class="s3">/ </span><span class="s1">rcount</span>

    <span class="s4"># Compute sum of squared deviations from mean</span>
    <span class="s4"># Note that x may not be inexact and that we need it to be an array,</span>
    <span class="s4"># not a scalar.</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">asanyarray</span><span class="s3">(</span><span class="s1">arr </span><span class="s3">- </span><span class="s1">arrmean</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">issubclass</span><span class="s3">(</span><span class="s1">arr</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">, (</span><span class="s1">nt</span><span class="s3">.</span><span class="s1">floating</span><span class="s3">, </span><span class="s1">nt</span><span class="s3">.</span><span class="s1">integer</span><span class="s3">)):</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">um</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s4"># Fast-paths for built-in complex types</span>
    <span class="s2">elif </span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">_complex_to_float</span><span class="s3">:</span>
        <span class="s1">xv </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">view</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">=(</span><span class="s1">_complex_to_float</span><span class="s3">[</span><span class="s1">x</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">], (</span><span class="s6">2</span><span class="s3">,)))</span>
        <span class="s1">um</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">xv</span><span class="s3">, </span><span class="s1">xv</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">xv</span><span class="s3">)</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">um</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">xv</span><span class="s3">[..., </span><span class="s6">0</span><span class="s3">], </span><span class="s1">xv</span><span class="s3">[..., </span><span class="s6">1</span><span class="s3">], </span><span class="s1">out</span><span class="s3">=</span><span class="s1">x</span><span class="s3">.</span><span class="s1">real</span><span class="s3">).</span><span class="s1">real</span>
    <span class="s4"># Most general case; includes handling object arrays containing imaginary</span>
    <span class="s4"># numbers and complex types with non-native byteorder</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">um</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">um</span><span class="s3">.</span><span class="s1">conjugate</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">out</span><span class="s3">=</span><span class="s1">x</span><span class="s3">).</span><span class="s1">real</span>

    <span class="s1">ret </span><span class="s3">= </span><span class="s1">umr_sum</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s1">keepdims</span><span class="s3">, </span><span class="s1">where</span><span class="s3">=</span><span class="s1">where</span><span class="s3">)</span>

    <span class="s4"># Compute degrees of freedom and make sure it is not negative.</span>
    <span class="s1">rcount </span><span class="s3">= </span><span class="s1">um</span><span class="s3">.</span><span class="s1">maximum</span><span class="s3">(</span><span class="s1">rcount </span><span class="s3">- </span><span class="s1">ddof</span><span class="s3">, </span><span class="s6">0</span><span class="s3">)</span>

    <span class="s4"># divide by degrees of freedom</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s2">with </span><span class="s1">_no_nep50_warning</span><span class="s3">():</span>
            <span class="s1">ret </span><span class="s3">= </span><span class="s1">um</span><span class="s3">.</span><span class="s1">true_divide</span><span class="s3">(</span>
                    <span class="s1">ret</span><span class="s3">, </span><span class="s1">rcount</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">ret</span><span class="s3">, </span><span class="s1">casting</span><span class="s3">=</span><span class="s5">'unsafe'</span><span class="s3">, </span><span class="s1">subok</span><span class="s3">=</span><span class="s2">False</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s5">'dtype'</span><span class="s3">):</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s1">ret </span><span class="s3">/ </span><span class="s1">rcount</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s1">ret </span><span class="s3">/ </span><span class="s1">rcount</span>

    <span class="s2">return </span><span class="s1">ret</span>

<span class="s2">def </span><span class="s1">_std</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, *,</span>
         <span class="s1">where</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">mean</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">ret </span><span class="s3">= </span><span class="s1">_var</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">out</span><span class="s3">, </span><span class="s1">ddof</span><span class="s3">=</span><span class="s1">ddof</span><span class="s3">,</span>
               <span class="s1">keepdims</span><span class="s3">=</span><span class="s1">keepdims</span><span class="s3">, </span><span class="s1">where</span><span class="s3">=</span><span class="s1">where</span><span class="s3">, </span><span class="s1">mean</span><span class="s3">=</span><span class="s1">mean</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s1">um</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s1">ret</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">, </span><span class="s5">'dtype'</span><span class="s3">):</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s1">ret</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">.</span><span class="s1">type</span><span class="s3">(</span><span class="s1">um</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">))</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">ret </span><span class="s3">= </span><span class="s1">um</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">ret</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">ret</span>

<span class="s2">def </span><span class="s1">_ptp</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">um</span><span class="s3">.</span><span class="s1">subtract</span><span class="s3">(</span>
        <span class="s1">umr_maximum</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">),</span>
        <span class="s1">umr_minimum</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s1">keepdims</span><span class="s3">),</span>
        <span class="s1">out</span>
    <span class="s3">)</span>

<span class="s2">def </span><span class="s1">_dump</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">file</span><span class="s3">, </span><span class="s1">protocol</span><span class="s3">=</span><span class="s6">2</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">file</span><span class="s3">, </span><span class="s5">'write'</span><span class="s3">):</span>
        <span class="s1">ctx </span><span class="s3">= </span><span class="s1">nullcontext</span><span class="s3">(</span><span class="s1">file</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">ctx </span><span class="s3">= </span><span class="s1">open</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">fspath</span><span class="s3">(</span><span class="s1">file</span><span class="s3">), </span><span class="s5">&quot;wb&quot;</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">ctx </span><span class="s2">as </span><span class="s1">f</span><span class="s3">:</span>
        <span class="s1">pickle</span><span class="s3">.</span><span class="s1">dump</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">f</span><span class="s3">, </span><span class="s1">protocol</span><span class="s3">=</span><span class="s1">protocol</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">_dumps</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">protocol</span><span class="s3">=</span><span class="s6">2</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">pickle</span><span class="s3">.</span><span class="s1">dumps</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">protocol</span><span class="s3">=</span><span class="s1">protocol</span><span class="s3">)</span>

<span class="s2">def </span><span class="s1">_bitwise_count</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">out</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, *, </span><span class="s1">where</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">casting</span><span class="s3">=</span><span class="s5">'same_kind'</span><span class="s3">,</span>
          <span class="s1">order</span><span class="s3">=</span><span class="s5">'K'</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">subok</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s1">umr_bitwise_count</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">out</span><span class="s3">, </span><span class="s1">where</span><span class="s3">=</span><span class="s1">where</span><span class="s3">, </span><span class="s1">casting</span><span class="s3">=</span><span class="s1">casting</span><span class="s3">,</span>
            <span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">subok</span><span class="s3">=</span><span class="s1">subok</span><span class="s3">)</span>
</pre>
</body>
</html>