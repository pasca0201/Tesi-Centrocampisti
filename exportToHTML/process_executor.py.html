<html>
<head>
<title>process_executor.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #cf8e6d;}
.s6 { color: #2aacb8;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
process_executor.py</font>
</center></td></tr></table>
<pre><span class="s0">###############################################################################</span>
<span class="s0"># Re-implementation of the ProcessPoolExecutor more robust to faults</span>
<span class="s0">#</span>
<span class="s0"># author: Thomas Moreau and Olivier Grisel</span>
<span class="s0">#</span>
<span class="s0"># adapted from concurrent/futures/process_pool_executor.py (17/02/2017)</span>
<span class="s0">#  * Add an extra management thread to detect executor_manager_thread failures,</span>
<span class="s0">#  * Improve the shutdown process to avoid deadlocks,</span>
<span class="s0">#  * Add timeout for workers,</span>
<span class="s0">#  * More robust pickling process.</span>
<span class="s0">#</span>
<span class="s0"># Copyright 2009 Brian Quinlan. All Rights Reserved.</span>
<span class="s0"># Licensed to PSF under a Contributor Agreement.</span>

<span class="s2">&quot;&quot;&quot;Implements ProcessPoolExecutor. 
 
The follow diagram and text describe the data-flow through the system: 
 
|======================= In-process =====================|== Out-of-process ==| 
 
+----------+     +----------+       +--------+     +-----------+    +---------+ 
|          |  =&gt; | Work Ids |       |        |     | Call Q    |    | Process | 
|          |     +----------+       |        |     +-----------+    |  Pool   | 
|          |     | ...      |       |        |     | ...       |    +---------+ 
|          |     | 6        |    =&gt; |        |  =&gt; | 5, call() | =&gt; |         | 
|          |     | 7        |       |        |     | ...       |    |         | 
| Process  |     | ...      |       | Local  |     +-----------+    | Process | 
|  Pool    |     +----------+       | Worker |                      |  #1..n  | 
| Executor |                        | Thread |                      |         | 
|          |     +----------- +     |        |     +-----------+    |         | 
|          | &lt;=&gt; | Work Items | &lt;=&gt; |        | &lt;=  | Result Q  | &lt;= |         | 
|          |     +------------+     |        |     +-----------+    |         | 
|          |     | 6: call()  |     |        |     | ...       |    |         | 
|          |     |    future  |     +--------+     | 4, result |    |         | 
|          |     | ...        |                    | 3, except |    |         | 
+----------+     +------------+                    +-----------+    +---------+ 
 
Executor.submit() called: 
- creates a uniquely numbered _WorkItem and adds it to the &quot;Work Items&quot; dict 
- adds the id of the _WorkItem to the &quot;Work Ids&quot; queue 
 
Local worker thread: 
- reads work ids from the &quot;Work Ids&quot; queue and looks up the corresponding 
  WorkItem from the &quot;Work Items&quot; dict: if the work item has been cancelled then 
  it is simply removed from the dict, otherwise it is repackaged as a 
  _CallItem and put in the &quot;Call Q&quot;. New _CallItems are put in the &quot;Call Q&quot; 
  until &quot;Call Q&quot; is full. NOTE: the size of the &quot;Call Q&quot; is kept small because 
  calls placed in the &quot;Call Q&quot; can no longer be cancelled with Future.cancel(). 
- reads _ResultItems from &quot;Result Q&quot;, updates the future stored in the 
  &quot;Work Items&quot; dict and deletes the dict entry 
 
Process #1..n: 
- reads _CallItems from &quot;Call Q&quot;, executes the calls, and puts the resulting 
  _ResultItems in &quot;Result Q&quot; 
&quot;&quot;&quot;</span>


<span class="s1">__author__ </span><span class="s3">= </span><span class="s4">&quot;Thomas Moreau (thomas.moreau.2010@gmail.com)&quot;</span>


<span class="s5">import </span><span class="s1">os</span>
<span class="s5">import </span><span class="s1">gc</span>
<span class="s5">import </span><span class="s1">sys</span>
<span class="s5">import </span><span class="s1">queue</span>
<span class="s5">import </span><span class="s1">struct</span>
<span class="s5">import </span><span class="s1">weakref</span>
<span class="s5">import </span><span class="s1">warnings</span>
<span class="s5">import </span><span class="s1">itertools</span>
<span class="s5">import </span><span class="s1">traceback</span>
<span class="s5">import </span><span class="s1">threading</span>
<span class="s5">from </span><span class="s1">time </span><span class="s5">import </span><span class="s1">time</span><span class="s3">, </span><span class="s1">sleep</span>
<span class="s5">import </span><span class="s1">multiprocessing </span><span class="s5">as </span><span class="s1">mp</span>
<span class="s5">from </span><span class="s1">functools </span><span class="s5">import </span><span class="s1">partial</span>
<span class="s5">from </span><span class="s1">pickle </span><span class="s5">import </span><span class="s1">PicklingError</span>
<span class="s5">from </span><span class="s1">concurrent</span><span class="s3">.</span><span class="s1">futures </span><span class="s5">import </span><span class="s1">Executor</span>
<span class="s5">from </span><span class="s1">concurrent</span><span class="s3">.</span><span class="s1">futures</span><span class="s3">.</span><span class="s1">_base </span><span class="s5">import </span><span class="s1">LOGGER</span>
<span class="s5">from </span><span class="s1">concurrent</span><span class="s3">.</span><span class="s1">futures</span><span class="s3">.</span><span class="s1">process </span><span class="s5">import </span><span class="s1">BrokenProcessPool </span><span class="s5">as </span><span class="s1">_BPPException</span>
<span class="s5">from </span><span class="s1">multiprocessing</span><span class="s3">.</span><span class="s1">connection </span><span class="s5">import </span><span class="s1">wait</span>

<span class="s5">from </span><span class="s3">.</span><span class="s1">_base </span><span class="s5">import </span><span class="s1">Future</span>
<span class="s5">from </span><span class="s3">.</span><span class="s1">backend </span><span class="s5">import </span><span class="s1">get_context</span>
<span class="s5">from </span><span class="s3">.</span><span class="s1">backend</span><span class="s3">.</span><span class="s1">context </span><span class="s5">import </span><span class="s1">cpu_count</span><span class="s3">, </span><span class="s1">_MAX_WINDOWS_WORKERS</span>
<span class="s5">from </span><span class="s3">.</span><span class="s1">backend</span><span class="s3">.</span><span class="s1">queues </span><span class="s5">import </span><span class="s1">Queue</span><span class="s3">, </span><span class="s1">SimpleQueue</span>
<span class="s5">from </span><span class="s3">.</span><span class="s1">backend</span><span class="s3">.</span><span class="s1">reduction </span><span class="s5">import </span><span class="s1">set_loky_pickler</span><span class="s3">, </span><span class="s1">get_loky_pickler_name</span>
<span class="s5">from </span><span class="s3">.</span><span class="s1">backend</span><span class="s3">.</span><span class="s1">utils </span><span class="s5">import </span><span class="s1">kill_process_tree</span><span class="s3">, </span><span class="s1">get_exitcodes_terminated_worker</span>
<span class="s5">from </span><span class="s3">.</span><span class="s1">initializers </span><span class="s5">import </span><span class="s1">_prepare_initializer</span>


<span class="s0"># Mechanism to prevent infinite process spawning. When a worker of a</span>
<span class="s0"># ProcessPoolExecutor nested in MAX_DEPTH Executor tries to create a new</span>
<span class="s0"># Executor, a LokyRecursionError is raised</span>
<span class="s1">MAX_DEPTH </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">os</span><span class="s3">.</span><span class="s1">environ</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;LOKY_MAX_DEPTH&quot;</span><span class="s3">, </span><span class="s6">10</span><span class="s3">))</span>
<span class="s1">_CURRENT_DEPTH </span><span class="s3">= </span><span class="s6">0</span>

<span class="s0"># Minimum time interval between two consecutive memory leak protection checks.</span>
<span class="s1">_MEMORY_LEAK_CHECK_DELAY </span><span class="s3">= </span><span class="s6">1.0</span>

<span class="s0"># Number of bytes of memory usage allowed over the reference process size.</span>
<span class="s1">_MAX_MEMORY_LEAK_SIZE </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s6">3e8</span><span class="s3">)</span>


<span class="s5">try</span><span class="s3">:</span>
    <span class="s5">from </span><span class="s1">psutil </span><span class="s5">import </span><span class="s1">Process</span>

    <span class="s1">_USE_PSUTIL </span><span class="s3">= </span><span class="s5">True</span>

    <span class="s5">def </span><span class="s1">_get_memory_usage</span><span class="s3">(</span><span class="s1">pid</span><span class="s3">, </span><span class="s1">force_gc</span><span class="s3">=</span><span class="s5">False</span><span class="s3">):</span>
        <span class="s5">if </span><span class="s1">force_gc</span><span class="s3">:</span>
            <span class="s1">gc</span><span class="s3">.</span><span class="s1">collect</span><span class="s3">()</span>

        <span class="s1">mem_size </span><span class="s3">= </span><span class="s1">Process</span><span class="s3">(</span><span class="s1">pid</span><span class="s3">).</span><span class="s1">memory_info</span><span class="s3">().</span><span class="s1">rss</span>
        <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">f&quot;psutil return memory size: </span><span class="s5">{</span><span class="s1">mem_size</span><span class="s5">}</span><span class="s4">&quot;</span><span class="s3">)</span>
        <span class="s5">return </span><span class="s1">mem_size</span>

<span class="s5">except </span><span class="s1">ImportError</span><span class="s3">:</span>
    <span class="s1">_USE_PSUTIL </span><span class="s3">= </span><span class="s5">False</span>


<span class="s5">class </span><span class="s1">_ThreadWakeup</span><span class="s3">:</span>
    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_closed </span><span class="s3">= </span><span class="s5">False</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_reader</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_writer </span><span class="s3">= </span><span class="s1">mp</span><span class="s3">.</span><span class="s1">Pipe</span><span class="s3">(</span><span class="s1">duplex</span><span class="s3">=</span><span class="s5">False</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">close</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_closed</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_closed </span><span class="s3">= </span><span class="s5">True</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_writer</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_reader</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>

    <span class="s5">def </span><span class="s1">wakeup</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_closed</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_writer</span><span class="s3">.</span><span class="s1">send_bytes</span><span class="s3">(</span><span class="s7">b&quot;&quot;</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">clear</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_closed</span><span class="s3">:</span>
            <span class="s5">while </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_reader</span><span class="s3">.</span><span class="s1">poll</span><span class="s3">():</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_reader</span><span class="s3">.</span><span class="s1">recv_bytes</span><span class="s3">()</span>


<span class="s5">class </span><span class="s1">_ExecutorFlags</span><span class="s3">:</span>
    <span class="s2">&quot;&quot;&quot;necessary references to maintain executor states without preventing gc 
 
    It permits to keep the information needed by executor_manager_thread 
    and crash_detection_thread to maintain the pool without preventing the 
    garbage collection of unreferenced executors. 
    &quot;&quot;&quot;</span>

    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">shutdown_lock</span><span class="s3">):</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">shutdown </span><span class="s3">= </span><span class="s5">False</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">broken </span><span class="s3">= </span><span class="s5">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">kill_workers </span><span class="s3">= </span><span class="s5">False</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">shutdown_lock </span><span class="s3">= </span><span class="s1">shutdown_lock</span>

    <span class="s5">def </span><span class="s1">flag_as_shutting_down</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">kill_workers</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
        <span class="s5">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">shutdown_lock</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">shutdown </span><span class="s3">= </span><span class="s5">True</span>
            <span class="s5">if </span><span class="s1">kill_workers </span><span class="s5">is not None</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">kill_workers </span><span class="s3">= </span><span class="s1">kill_workers</span>

    <span class="s5">def </span><span class="s1">flag_as_broken</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">broken</span><span class="s3">):</span>
        <span class="s5">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">shutdown_lock</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">shutdown </span><span class="s3">= </span><span class="s5">True</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">broken </span><span class="s3">= </span><span class="s1">broken</span>


<span class="s0"># Prior to 3.9, executor_manager_thread is created as daemon thread. This means</span>
<span class="s0"># that it is not joined automatically when the interpreter is shutting down.</span>
<span class="s0"># To work around this problem, an exit handler is installed to tell the</span>
<span class="s0"># thread to exit when the interpreter is shutting down and then waits until</span>
<span class="s0"># it finishes. The thread needs to be daemonized because the atexit hooks are</span>
<span class="s0"># called after all non daemonized threads are joined.</span>
<span class="s0">#</span>
<span class="s0"># Starting 3.9, there exists a specific atexit hook to be called before joining</span>
<span class="s0"># the threads so the executor_manager_thread does not need to be daemonized</span>
<span class="s0"># anymore.</span>
<span class="s0">#</span>
<span class="s0"># The atexit hooks are registered when starting the first ProcessPoolExecutor</span>
<span class="s0"># to avoid import having an effect on the interpreter.</span>

<span class="s1">_global_shutdown </span><span class="s3">= </span><span class="s5">False</span>
<span class="s1">_global_shutdown_lock </span><span class="s3">= </span><span class="s1">threading</span><span class="s3">.</span><span class="s1">Lock</span><span class="s3">()</span>
<span class="s1">_threads_wakeups </span><span class="s3">= </span><span class="s1">weakref</span><span class="s3">.</span><span class="s1">WeakKeyDictionary</span><span class="s3">()</span>


<span class="s5">def </span><span class="s1">_python_exit</span><span class="s3">():</span>
    <span class="s5">global </span><span class="s1">_global_shutdown</span>
    <span class="s1">_global_shutdown </span><span class="s3">= </span><span class="s5">True</span>

    <span class="s0"># Materialize the list of items to avoid error due to iterating over</span>
    <span class="s0"># changing size dictionary.</span>
    <span class="s1">items </span><span class="s3">= </span><span class="s1">list</span><span class="s3">(</span><span class="s1">_threads_wakeups</span><span class="s3">.</span><span class="s1">items</span><span class="s3">())</span>
    <span class="s5">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">items</span><span class="s3">) &gt; </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span>
            <span class="s4">&quot;Interpreter shutting down. Waking up {len(items)}&quot;</span>
            <span class="s4">f&quot;executor_manager_thread:</span><span class="s5">\n{</span><span class="s1">items</span><span class="s5">}</span><span class="s4">&quot;</span>
        <span class="s3">)</span>

    <span class="s0"># Wake up the executor_manager_thread's so they can detect the interpreter</span>
    <span class="s0"># is shutting down and exit.</span>
    <span class="s5">for </span><span class="s1">_</span><span class="s3">, (</span><span class="s1">shutdown_lock</span><span class="s3">, </span><span class="s1">thread_wakeup</span><span class="s3">) </span><span class="s5">in </span><span class="s1">items</span><span class="s3">:</span>
        <span class="s5">with </span><span class="s1">shutdown_lock</span><span class="s3">:</span>
            <span class="s1">thread_wakeup</span><span class="s3">.</span><span class="s1">wakeup</span><span class="s3">()</span>

    <span class="s0"># Collect the executor_manager_thread's to make sure we exit cleanly.</span>
    <span class="s5">for </span><span class="s1">thread</span><span class="s3">, </span><span class="s1">_ </span><span class="s5">in </span><span class="s1">items</span><span class="s3">:</span>
        <span class="s0"># This locks is to prevent situations where an executor is gc'ed in one</span>
        <span class="s0"># thread while the atexit finalizer is running in another thread. This</span>
        <span class="s0"># can happen when joblib is used in pypy for instance.</span>
        <span class="s5">with </span><span class="s1">_global_shutdown_lock</span><span class="s3">:</span>
            <span class="s1">thread</span><span class="s3">.</span><span class="s1">join</span><span class="s3">()</span>


<span class="s0"># With the fork context, _thread_wakeups is propagated to children.</span>
<span class="s0"># Clear it after fork to avoid some situation that can cause some</span>
<span class="s0"># freeze when joining the workers.</span>
<span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">register_after_fork</span><span class="s3">(</span><span class="s1">_threads_wakeups</span><span class="s3">, </span><span class="s5">lambda </span><span class="s1">obj</span><span class="s3">: </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">())</span>


<span class="s0"># Module variable to register the at_exit call</span>
<span class="s1">process_pool_executor_at_exit </span><span class="s3">= </span><span class="s5">None</span>

<span class="s0"># Controls how many more calls than processes will be queued in the call queue.</span>
<span class="s0"># A smaller number will mean that processes spend more time idle waiting for</span>
<span class="s0"># work while a larger number will make Future.cancel() succeed less frequently</span>
<span class="s0"># (Futures in the call queue cannot be cancelled).</span>
<span class="s1">EXTRA_QUEUED_CALLS </span><span class="s3">= </span><span class="s6">1</span>


<span class="s5">class </span><span class="s1">_RemoteTraceback</span><span class="s3">(</span><span class="s1">Exception</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Embed stringification of remote traceback in local traceback&quot;&quot;&quot;</span>

    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">tb</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">tb </span><span class="s3">= </span><span class="s4">f'</span><span class="s5">\n</span><span class="s4">&quot;&quot;&quot;</span><span class="s5">\n{</span><span class="s1">tb</span><span class="s5">}</span><span class="s4">&quot;&quot;&quot;'</span>

    <span class="s5">def </span><span class="s1">__str__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tb</span>


<span class="s0"># Do not inherit from BaseException to mirror</span>
<span class="s0"># concurrent.futures.process._ExceptionWithTraceback</span>
<span class="s5">class </span><span class="s1">_ExceptionWithTraceback</span><span class="s3">:</span>
    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">exc</span><span class="s3">):</span>
        <span class="s1">tb </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">, </span><span class="s4">&quot;__traceback__&quot;</span><span class="s3">, </span><span class="s5">None</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">tb </span><span class="s5">is None</span><span class="s3">:</span>
            <span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">tb </span><span class="s3">= </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">exc_info</span><span class="s3">()</span>
        <span class="s1">tb </span><span class="s3">= </span><span class="s1">traceback</span><span class="s3">.</span><span class="s1">format_exception</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">), </span><span class="s1">exc</span><span class="s3">, </span><span class="s1">tb</span><span class="s3">)</span>
        <span class="s1">tb </span><span class="s3">= </span><span class="s4">&quot;&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">tb</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">exc </span><span class="s3">= </span><span class="s1">exc</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">tb </span><span class="s3">= </span><span class="s1">tb</span>

    <span class="s5">def </span><span class="s1">__reduce__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">return </span><span class="s1">_rebuild_exc</span><span class="s3">, (</span><span class="s1">self</span><span class="s3">.</span><span class="s1">exc</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tb</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">_rebuild_exc</span><span class="s3">(</span><span class="s1">exc</span><span class="s3">, </span><span class="s1">tb</span><span class="s3">):</span>
    <span class="s1">exc</span><span class="s3">.</span><span class="s1">__cause__ </span><span class="s3">= </span><span class="s1">_RemoteTraceback</span><span class="s3">(</span><span class="s1">tb</span><span class="s3">)</span>
    <span class="s5">return </span><span class="s1">exc</span>


<span class="s5">class </span><span class="s1">_WorkItem</span><span class="s3">:</span>

    <span class="s1">__slots__ </span><span class="s3">= [</span><span class="s4">&quot;future&quot;</span><span class="s3">, </span><span class="s4">&quot;fn&quot;</span><span class="s3">, </span><span class="s4">&quot;args&quot;</span><span class="s3">, </span><span class="s4">&quot;kwargs&quot;</span><span class="s3">]</span>

    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">future</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">future </span><span class="s3">= </span><span class="s1">future</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fn </span><span class="s3">= </span><span class="s1">fn</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">args </span><span class="s3">= </span><span class="s1">args</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">kwargs </span><span class="s3">= </span><span class="s1">kwargs</span>


<span class="s5">class </span><span class="s1">_ResultItem</span><span class="s3">:</span>
    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">work_id</span><span class="s3">, </span><span class="s1">exception</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">result</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">work_id </span><span class="s3">= </span><span class="s1">work_id</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">exception </span><span class="s3">= </span><span class="s1">exception</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">result </span><span class="s3">= </span><span class="s1">result</span>


<span class="s5">class </span><span class="s1">_CallItem</span><span class="s3">:</span>
    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">work_id</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">work_id </span><span class="s3">= </span><span class="s1">work_id</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fn </span><span class="s3">= </span><span class="s1">fn</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">args </span><span class="s3">= </span><span class="s1">args</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">kwargs </span><span class="s3">= </span><span class="s1">kwargs</span>

        <span class="s0"># Store the current loky_pickler so it is correctly set in the worker</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">loky_pickler </span><span class="s3">= </span><span class="s1">get_loky_pickler_name</span><span class="s3">()</span>

    <span class="s5">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">set_loky_pickler</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">loky_pickler</span><span class="s3">)</span>
        <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fn</span><span class="s3">(*</span><span class="s1">self</span><span class="s3">.</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">self</span><span class="s3">.</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">return </span><span class="s3">(</span>
            <span class="s4">f&quot;CallItem(</span><span class="s5">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">work_id</span><span class="s5">}</span><span class="s4">, </span><span class="s5">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">fn</span><span class="s5">}</span><span class="s4">, </span><span class="s5">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">args</span><span class="s5">}</span><span class="s4">, </span><span class="s5">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">kwargs</span><span class="s5">}</span><span class="s4">)&quot;</span>
        <span class="s3">)</span>


<span class="s5">class </span><span class="s1">_SafeQueue</span><span class="s3">(</span><span class="s1">Queue</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Safe Queue set exception to the future object linked to a job&quot;&quot;&quot;</span>

    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">max_size</span><span class="s3">=</span><span class="s6">0</span><span class="s3">,</span>
        <span class="s1">ctx</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
        <span class="s1">pending_work_items</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
        <span class="s1">running_work_items</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
        <span class="s1">thread_wakeup</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
        <span class="s1">reducers</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">thread_wakeup </span><span class="s3">= </span><span class="s1">thread_wakeup</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pending_work_items </span><span class="s3">= </span><span class="s1">pending_work_items</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">running_work_items </span><span class="s3">= </span><span class="s1">running_work_items</span>
        <span class="s1">super</span><span class="s3">().</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">max_size</span><span class="s3">, </span><span class="s1">reducers</span><span class="s3">=</span><span class="s1">reducers</span><span class="s3">, </span><span class="s1">ctx</span><span class="s3">=</span><span class="s1">ctx</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">_on_queue_feeder_error</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">e</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">):</span>
        <span class="s5">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">_CallItem</span><span class="s3">):</span>
            <span class="s0"># format traceback only works on python3</span>
            <span class="s5">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">e</span><span class="s3">, </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">error</span><span class="s3">):</span>
                <span class="s1">raised_error </span><span class="s3">= </span><span class="s1">RuntimeError</span><span class="s3">(</span>
                    <span class="s4">&quot;The task could not be sent to the workers as it is too &quot;</span>
                    <span class="s4">&quot;large for `send_bytes`.&quot;</span>
                <span class="s3">)</span>
            <span class="s5">else</span><span class="s3">:</span>
                <span class="s1">raised_error </span><span class="s3">= </span><span class="s1">PicklingError</span><span class="s3">(</span>
                    <span class="s4">&quot;Could not pickle the task to send it to the workers.&quot;</span>
                <span class="s3">)</span>
            <span class="s1">tb </span><span class="s3">= </span><span class="s1">traceback</span><span class="s3">.</span><span class="s1">format_exception</span><span class="s3">(</span>
                <span class="s1">type</span><span class="s3">(</span><span class="s1">e</span><span class="s3">), </span><span class="s1">e</span><span class="s3">, </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">e</span><span class="s3">, </span><span class="s4">&quot;__traceback__&quot;</span><span class="s3">, </span><span class="s5">None</span><span class="s3">)</span>
            <span class="s3">)</span>
            <span class="s1">raised_error</span><span class="s3">.</span><span class="s1">__cause__ </span><span class="s3">= </span><span class="s1">_RemoteTraceback</span><span class="s3">(</span><span class="s4">&quot;&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">tb</span><span class="s3">))</span>
            <span class="s1">work_item </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pending_work_items</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">work_id</span><span class="s3">, </span><span class="s5">None</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">running_work_items</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">work_id</span><span class="s3">)</span>
            <span class="s0"># work_item can be None if another process terminated. In this</span>
            <span class="s0"># case, the executor_manager_thread fails all work_items with</span>
            <span class="s0"># BrokenProcessPool</span>
            <span class="s5">if </span><span class="s1">work_item </span><span class="s5">is not None</span><span class="s3">:</span>
                <span class="s1">work_item</span><span class="s3">.</span><span class="s1">future</span><span class="s3">.</span><span class="s1">set_exception</span><span class="s3">(</span><span class="s1">raised_error</span><span class="s3">)</span>
                <span class="s5">del </span><span class="s1">work_item</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">thread_wakeup</span><span class="s3">.</span><span class="s1">wakeup</span><span class="s3">()</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">super</span><span class="s3">().</span><span class="s1">_on_queue_feeder_error</span><span class="s3">(</span><span class="s1">e</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">_get_chunks</span><span class="s3">(</span><span class="s1">chunksize</span><span class="s3">, *</span><span class="s1">iterables</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Iterates over zip()ed iterables in chunks.&quot;&quot;&quot;</span>
    <span class="s1">it </span><span class="s3">= </span><span class="s1">zip</span><span class="s3">(*</span><span class="s1">iterables</span><span class="s3">)</span>
    <span class="s5">while True</span><span class="s3">:</span>
        <span class="s1">chunk </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">itertools</span><span class="s3">.</span><span class="s1">islice</span><span class="s3">(</span><span class="s1">it</span><span class="s3">, </span><span class="s1">chunksize</span><span class="s3">))</span>
        <span class="s5">if not </span><span class="s1">chunk</span><span class="s3">:</span>
            <span class="s5">return</span>
        <span class="s5">yield </span><span class="s1">chunk</span>


<span class="s5">def </span><span class="s1">_process_chunk</span><span class="s3">(</span><span class="s1">fn</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Processes a chunk of an iterable passed to map. 
 
    Runs the function passed to map() on a chunk of the 
    iterable passed to map. 
 
    This function is run in a separate process. 
 
    &quot;&quot;&quot;</span>
    <span class="s5">return </span><span class="s3">[</span><span class="s1">fn</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">) </span><span class="s5">for </span><span class="s1">args </span><span class="s5">in </span><span class="s1">chunk</span><span class="s3">]</span>


<span class="s5">def </span><span class="s1">_sendback_result</span><span class="s3">(</span><span class="s1">result_queue</span><span class="s3">, </span><span class="s1">work_id</span><span class="s3">, </span><span class="s1">result</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">exception</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Safely send back the given result or exception&quot;&quot;&quot;</span>
    <span class="s5">try</span><span class="s3">:</span>
        <span class="s1">result_queue</span><span class="s3">.</span><span class="s1">put</span><span class="s3">(</span>
            <span class="s1">_ResultItem</span><span class="s3">(</span><span class="s1">work_id</span><span class="s3">, </span><span class="s1">result</span><span class="s3">=</span><span class="s1">result</span><span class="s3">, </span><span class="s1">exception</span><span class="s3">=</span><span class="s1">exception</span><span class="s3">)</span>
        <span class="s3">)</span>
    <span class="s5">except </span><span class="s1">BaseException </span><span class="s5">as </span><span class="s1">e</span><span class="s3">:</span>
        <span class="s1">exc </span><span class="s3">= </span><span class="s1">_ExceptionWithTraceback</span><span class="s3">(</span><span class="s1">e</span><span class="s3">)</span>
        <span class="s1">result_queue</span><span class="s3">.</span><span class="s1">put</span><span class="s3">(</span><span class="s1">_ResultItem</span><span class="s3">(</span><span class="s1">work_id</span><span class="s3">, </span><span class="s1">exception</span><span class="s3">=</span><span class="s1">exc</span><span class="s3">))</span>


<span class="s5">def </span><span class="s1">_process_worker</span><span class="s3">(</span>
    <span class="s1">call_queue</span><span class="s3">,</span>
    <span class="s1">result_queue</span><span class="s3">,</span>
    <span class="s1">initializer</span><span class="s3">,</span>
    <span class="s1">initargs</span><span class="s3">,</span>
    <span class="s1">processes_management_lock</span><span class="s3">,</span>
    <span class="s1">timeout</span><span class="s3">,</span>
    <span class="s1">worker_exit_lock</span><span class="s3">,</span>
    <span class="s1">current_depth</span><span class="s3">,</span>
<span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Evaluates calls from call_queue and places the results in result_queue. 
 
    This worker is run in a separate process. 
 
    Args: 
        call_queue: A ctx.Queue of _CallItems that will be read and 
            evaluated by the worker. 
        result_queue: A ctx.Queue of _ResultItems that will written 
            to by the worker. 
        initializer: A callable initializer, or None 
        initargs: A tuple of args for the initializer 
        processes_management_lock: A ctx.Lock avoiding worker timeout while 
            some workers are being spawned. 
        timeout: maximum time to wait for a new item in the call_queue. If that 
            time is expired, the worker will shutdown. 
        worker_exit_lock: Lock to avoid flagging the executor as broken on 
            workers timeout. 
        current_depth: Nested parallelism level, to avoid infinite spawning. 
    &quot;&quot;&quot;</span>
    <span class="s5">if </span><span class="s1">initializer </span><span class="s5">is not None</span><span class="s3">:</span>
        <span class="s5">try</span><span class="s3">:</span>
            <span class="s1">initializer</span><span class="s3">(*</span><span class="s1">initargs</span><span class="s3">)</span>
        <span class="s5">except </span><span class="s1">BaseException</span><span class="s3">:</span>
            <span class="s1">LOGGER</span><span class="s3">.</span><span class="s1">critical</span><span class="s3">(</span><span class="s4">&quot;Exception in initializer:&quot;</span><span class="s3">, </span><span class="s1">exc_info</span><span class="s3">=</span><span class="s5">True</span><span class="s3">)</span>
            <span class="s0"># The parent will notice that the process stopped and</span>
            <span class="s0"># mark the pool broken</span>
            <span class="s5">return</span>

    <span class="s0"># set the global _CURRENT_DEPTH mechanism to limit recursive call</span>
    <span class="s5">global </span><span class="s1">_CURRENT_DEPTH</span>
    <span class="s1">_CURRENT_DEPTH </span><span class="s3">= </span><span class="s1">current_depth</span>
    <span class="s1">_process_reference_size </span><span class="s3">= </span><span class="s5">None</span>
    <span class="s1">_last_memory_leak_check </span><span class="s3">= </span><span class="s5">None</span>
    <span class="s1">pid </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">getpid</span><span class="s3">()</span>

    <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">f&quot;Worker started with timeout=</span><span class="s5">{</span><span class="s1">timeout</span><span class="s5">}</span><span class="s4">&quot;</span><span class="s3">)</span>
    <span class="s5">while True</span><span class="s3">:</span>
        <span class="s5">try</span><span class="s3">:</span>
            <span class="s1">call_item </span><span class="s3">= </span><span class="s1">call_queue</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">block</span><span class="s3">=</span><span class="s5">True</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">=</span><span class="s1">timeout</span><span class="s3">)</span>
            <span class="s5">if </span><span class="s1">call_item </span><span class="s5">is None</span><span class="s3">:</span>
                <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;Shutting down worker on sentinel&quot;</span><span class="s3">)</span>
        <span class="s5">except </span><span class="s1">queue</span><span class="s3">.</span><span class="s1">Empty</span><span class="s3">:</span>
            <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">f&quot;Shutting down worker after timeout </span><span class="s5">{</span><span class="s1">timeout</span><span class="s5">:</span><span class="s4">0.3f</span><span class="s5">}</span><span class="s4">s&quot;</span><span class="s3">)</span>
            <span class="s5">if </span><span class="s1">processes_management_lock</span><span class="s3">.</span><span class="s1">acquire</span><span class="s3">(</span><span class="s1">block</span><span class="s3">=</span><span class="s5">False</span><span class="s3">):</span>
                <span class="s1">processes_management_lock</span><span class="s3">.</span><span class="s1">release</span><span class="s3">()</span>
                <span class="s1">call_item </span><span class="s3">= </span><span class="s5">None</span>
            <span class="s5">else</span><span class="s3">:</span>
                <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;Could not acquire processes_management_lock&quot;</span><span class="s3">)</span>
                <span class="s5">continue</span>
        <span class="s5">except </span><span class="s1">BaseException</span><span class="s3">:</span>
            <span class="s1">previous_tb </span><span class="s3">= </span><span class="s1">traceback</span><span class="s3">.</span><span class="s1">format_exc</span><span class="s3">()</span>
            <span class="s5">try</span><span class="s3">:</span>
                <span class="s1">result_queue</span><span class="s3">.</span><span class="s1">put</span><span class="s3">(</span><span class="s1">_RemoteTraceback</span><span class="s3">(</span><span class="s1">previous_tb</span><span class="s3">))</span>
            <span class="s5">except </span><span class="s1">BaseException</span><span class="s3">:</span>
                <span class="s0"># If we cannot format correctly the exception, at least print</span>
                <span class="s0"># the traceback.</span>
                <span class="s1">print</span><span class="s3">(</span><span class="s1">previous_tb</span><span class="s3">)</span>
            <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">&quot;Exiting with code 1&quot;</span><span class="s3">)</span>
            <span class="s1">sys</span><span class="s3">.</span><span class="s1">exit</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">call_item </span><span class="s5">is None</span><span class="s3">:</span>
            <span class="s0"># Notify queue management thread about worker shutdown</span>
            <span class="s1">result_queue</span><span class="s3">.</span><span class="s1">put</span><span class="s3">(</span><span class="s1">pid</span><span class="s3">)</span>
            <span class="s1">is_clean </span><span class="s3">= </span><span class="s1">worker_exit_lock</span><span class="s3">.</span><span class="s1">acquire</span><span class="s3">(</span><span class="s5">True</span><span class="s3">, </span><span class="s1">timeout</span><span class="s3">=</span><span class="s6">30</span><span class="s3">)</span>

            <span class="s0"># Early notify any loky executor running in this worker process</span>
            <span class="s0"># (nested parallelism) that this process is about to shutdown to</span>
            <span class="s0"># avoid a deadlock waiting undifinitely for the worker to finish.</span>
            <span class="s1">_python_exit</span><span class="s3">()</span>

            <span class="s5">if </span><span class="s1">is_clean</span><span class="s3">:</span>
                <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">&quot;Exited cleanly&quot;</span><span class="s3">)</span>
            <span class="s5">else</span><span class="s3">:</span>
                <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;Main process did not release worker_exit&quot;</span><span class="s3">)</span>
            <span class="s5">return</span>
        <span class="s5">try</span><span class="s3">:</span>
            <span class="s1">r </span><span class="s3">= </span><span class="s1">call_item</span><span class="s3">()</span>
        <span class="s5">except </span><span class="s1">BaseException </span><span class="s5">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s1">exc </span><span class="s3">= </span><span class="s1">_ExceptionWithTraceback</span><span class="s3">(</span><span class="s1">e</span><span class="s3">)</span>
            <span class="s1">result_queue</span><span class="s3">.</span><span class="s1">put</span><span class="s3">(</span><span class="s1">_ResultItem</span><span class="s3">(</span><span class="s1">call_item</span><span class="s3">.</span><span class="s1">work_id</span><span class="s3">, </span><span class="s1">exception</span><span class="s3">=</span><span class="s1">exc</span><span class="s3">))</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">_sendback_result</span><span class="s3">(</span><span class="s1">result_queue</span><span class="s3">, </span><span class="s1">call_item</span><span class="s3">.</span><span class="s1">work_id</span><span class="s3">, </span><span class="s1">result</span><span class="s3">=</span><span class="s1">r</span><span class="s3">)</span>
            <span class="s5">del </span><span class="s1">r</span>

        <span class="s0"># Free the resource as soon as possible, to avoid holding onto</span>
        <span class="s0"># open files or shared memory that is not needed anymore</span>
        <span class="s5">del </span><span class="s1">call_item</span>

        <span class="s5">if </span><span class="s1">_USE_PSUTIL</span><span class="s3">:</span>
            <span class="s5">if </span><span class="s1">_process_reference_size </span><span class="s5">is None</span><span class="s3">:</span>
                <span class="s0"># Make reference measurement after the first call</span>
                <span class="s1">_process_reference_size </span><span class="s3">= </span><span class="s1">_get_memory_usage</span><span class="s3">(</span><span class="s1">pid</span><span class="s3">, </span><span class="s1">force_gc</span><span class="s3">=</span><span class="s5">True</span><span class="s3">)</span>
                <span class="s1">_last_memory_leak_check </span><span class="s3">= </span><span class="s1">time</span><span class="s3">()</span>
                <span class="s5">continue</span>
            <span class="s5">if </span><span class="s1">time</span><span class="s3">() - </span><span class="s1">_last_memory_leak_check </span><span class="s3">&gt; </span><span class="s1">_MEMORY_LEAK_CHECK_DELAY</span><span class="s3">:</span>
                <span class="s1">mem_usage </span><span class="s3">= </span><span class="s1">_get_memory_usage</span><span class="s3">(</span><span class="s1">pid</span><span class="s3">)</span>
                <span class="s1">_last_memory_leak_check </span><span class="s3">= </span><span class="s1">time</span><span class="s3">()</span>
                <span class="s5">if </span><span class="s1">mem_usage </span><span class="s3">- </span><span class="s1">_process_reference_size </span><span class="s3">&lt; </span><span class="s1">_MAX_MEMORY_LEAK_SIZE</span><span class="s3">:</span>
                    <span class="s0"># Memory usage stays within bounds: everything is fine.</span>
                    <span class="s5">continue</span>

                <span class="s0"># Check again memory usage; this time take the measurement</span>
                <span class="s0"># after a forced garbage collection to break any reference</span>
                <span class="s0"># cycles.</span>
                <span class="s1">mem_usage </span><span class="s3">= </span><span class="s1">_get_memory_usage</span><span class="s3">(</span><span class="s1">pid</span><span class="s3">, </span><span class="s1">force_gc</span><span class="s3">=</span><span class="s5">True</span><span class="s3">)</span>
                <span class="s1">_last_memory_leak_check </span><span class="s3">= </span><span class="s1">time</span><span class="s3">()</span>
                <span class="s5">if </span><span class="s1">mem_usage </span><span class="s3">- </span><span class="s1">_process_reference_size </span><span class="s3">&lt; </span><span class="s1">_MAX_MEMORY_LEAK_SIZE</span><span class="s3">:</span>
                    <span class="s0"># The GC managed to free the memory: everything is fine.</span>
                    <span class="s5">continue</span>

                <span class="s0"># The process is leaking memory: let the main process</span>
                <span class="s0"># know that we need to start a new worker.</span>
                <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span><span class="s4">&quot;Memory leak detected: shutting down worker&quot;</span><span class="s3">)</span>
                <span class="s1">result_queue</span><span class="s3">.</span><span class="s1">put</span><span class="s3">(</span><span class="s1">pid</span><span class="s3">)</span>
                <span class="s5">with </span><span class="s1">worker_exit_lock</span><span class="s3">:</span>
                    <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">&quot;Exit due to memory leak&quot;</span><span class="s3">)</span>
                    <span class="s5">return</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s0"># if psutil is not installed, trigger gc.collect events</span>
            <span class="s0"># regularly to limit potential memory leaks due to reference cycles</span>
            <span class="s5">if </span><span class="s1">_last_memory_leak_check </span><span class="s5">is None or </span><span class="s3">(</span>
                <span class="s1">time</span><span class="s3">() - </span><span class="s1">_last_memory_leak_check </span><span class="s3">&gt; </span><span class="s1">_MEMORY_LEAK_CHECK_DELAY</span>
            <span class="s3">):</span>
                <span class="s1">gc</span><span class="s3">.</span><span class="s1">collect</span><span class="s3">()</span>
                <span class="s1">_last_memory_leak_check </span><span class="s3">= </span><span class="s1">time</span><span class="s3">()</span>


<span class="s5">class </span><span class="s1">_ExecutorManagerThread</span><span class="s3">(</span><span class="s1">threading</span><span class="s3">.</span><span class="s1">Thread</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;Manages the communication between this process and the worker processes. 
 
    The manager is run in a local thread. 
 
    Args: 
        executor: A reference to the ProcessPoolExecutor that owns 
            this thread. A weakref will be own by the manager as well as 
            references to internal objects used to introspect the state of 
            the executor. 
    &quot;&quot;&quot;</span>

    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">executor</span><span class="s3">):</span>
        <span class="s0"># Store references to necessary internals of the executor.</span>

        <span class="s0"># A _ThreadWakeup to allow waking up the executor_manager_thread from</span>
        <span class="s0"># the main Thread and avoid deadlocks caused by permanently</span>
        <span class="s0"># locked queues.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">thread_wakeup </span><span class="s3">= </span><span class="s1">executor</span><span class="s3">.</span><span class="s1">_executor_manager_thread_wakeup</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">shutdown_lock </span><span class="s3">= </span><span class="s1">executor</span><span class="s3">.</span><span class="s1">_shutdown_lock</span>

        <span class="s0"># A weakref.ref to the ProcessPoolExecutor that owns this thread. Used</span>
        <span class="s0"># to determine if the ProcessPoolExecutor has been garbage collected</span>
        <span class="s0"># and that the manager can exit.</span>
        <span class="s0"># When the executor gets garbage collected, the weakref callback</span>
        <span class="s0"># will wake up the queue management thread so that it can terminate</span>
        <span class="s0"># if there is no pending work item.</span>
        <span class="s5">def </span><span class="s1">weakref_cb</span><span class="s3">(</span>
            <span class="s1">_</span><span class="s3">,</span>
            <span class="s1">thread_wakeup</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">thread_wakeup</span><span class="s3">,</span>
            <span class="s1">shutdown_lock</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">shutdown_lock</span><span class="s3">,</span>
        <span class="s3">):</span>
            <span class="s5">if </span><span class="s1">mp </span><span class="s5">is not None</span><span class="s3">:</span>
                <span class="s0"># At this point, the multiprocessing module can already be</span>
                <span class="s0"># garbage collected. We only log debug info when still</span>
                <span class="s0"># possible.</span>
                <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span>
                    <span class="s4">&quot;Executor collected: triggering callback for&quot;</span>
                    <span class="s4">&quot; QueueManager wakeup&quot;</span>
                <span class="s3">)</span>
            <span class="s5">with </span><span class="s1">shutdown_lock</span><span class="s3">:</span>
                <span class="s1">thread_wakeup</span><span class="s3">.</span><span class="s1">wakeup</span><span class="s3">()</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">executor_reference </span><span class="s3">= </span><span class="s1">weakref</span><span class="s3">.</span><span class="s1">ref</span><span class="s3">(</span><span class="s1">executor</span><span class="s3">, </span><span class="s1">weakref_cb</span><span class="s3">)</span>

        <span class="s0"># The flags of the executor</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">executor_flags </span><span class="s3">= </span><span class="s1">executor</span><span class="s3">.</span><span class="s1">_flags</span>

        <span class="s0"># A list of the ctx.Process instances used as workers.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">processes </span><span class="s3">= </span><span class="s1">executor</span><span class="s3">.</span><span class="s1">_processes</span>

        <span class="s0"># A ctx.Queue that will be filled with _CallItems derived from</span>
        <span class="s0"># _WorkItems for processing by the process workers.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">call_queue </span><span class="s3">= </span><span class="s1">executor</span><span class="s3">.</span><span class="s1">_call_queue</span>

        <span class="s0"># A ctx.SimpleQueue of _ResultItems generated by the process workers.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">result_queue </span><span class="s3">= </span><span class="s1">executor</span><span class="s3">.</span><span class="s1">_result_queue</span>

        <span class="s0"># A queue.Queue of work ids e.g. Queue([5, 6, ...]).</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">work_ids_queue </span><span class="s3">= </span><span class="s1">executor</span><span class="s3">.</span><span class="s1">_work_ids</span>

        <span class="s0"># A dict mapping work ids to _WorkItems e.g.</span>
        <span class="s0">#     {5: &lt;_WorkItem...&gt;, 6: &lt;_WorkItem...&gt;, ...}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pending_work_items </span><span class="s3">= </span><span class="s1">executor</span><span class="s3">.</span><span class="s1">_pending_work_items</span>

        <span class="s0"># A list of the work_ids that are currently running</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">running_work_items </span><span class="s3">= </span><span class="s1">executor</span><span class="s3">.</span><span class="s1">_running_work_items</span>

        <span class="s0"># A lock to avoid concurrent shutdown of workers on timeout and spawn</span>
        <span class="s0"># of new processes or shut down</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">processes_management_lock </span><span class="s3">= </span><span class="s1">executor</span><span class="s3">.</span><span class="s1">_processes_management_lock</span>

        <span class="s1">super</span><span class="s3">().</span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">name</span><span class="s3">=</span><span class="s4">&quot;ExecutorManagerThread&quot;</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&lt; (</span><span class="s6">3</span><span class="s3">, </span><span class="s6">9</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">daemon </span><span class="s3">= </span><span class="s5">True</span>

    <span class="s5">def </span><span class="s1">run</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Main loop for the executor manager thread.</span>

        <span class="s5">while True</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">add_call_item_to_queue</span><span class="s3">()</span>

            <span class="s1">result_item</span><span class="s3">, </span><span class="s1">is_broken</span><span class="s3">, </span><span class="s1">bpe </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">wait_result_broken_or_wakeup</span><span class="s3">()</span>

            <span class="s5">if </span><span class="s1">is_broken</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">terminate_broken</span><span class="s3">(</span><span class="s1">bpe</span><span class="s3">)</span>
                <span class="s5">return</span>
            <span class="s5">if </span><span class="s1">result_item </span><span class="s5">is not None</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">process_result_item</span><span class="s3">(</span><span class="s1">result_item</span><span class="s3">)</span>
                <span class="s0"># Delete reference to result_item to avoid keeping references</span>
                <span class="s0"># while waiting on new results.</span>
                <span class="s5">del </span><span class="s1">result_item</span>

            <span class="s5">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">is_shutting_down</span><span class="s3">():</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">flag_executor_shutting_down</span><span class="s3">()</span>

                <span class="s0"># Since no new work items can be added, it is safe to shutdown</span>
                <span class="s0"># this thread if there are no pending work items.</span>
                <span class="s5">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pending_work_items</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">join_executor_internals</span><span class="s3">()</span>
                    <span class="s5">return</span>

    <span class="s5">def </span><span class="s1">add_call_item_to_queue</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Fills call_queue with _WorkItems from pending_work_items.</span>
        <span class="s0"># This function never blocks.</span>
        <span class="s5">while True</span><span class="s3">:</span>
            <span class="s5">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">call_queue</span><span class="s3">.</span><span class="s1">full</span><span class="s3">():</span>
                <span class="s5">return</span>
            <span class="s5">try</span><span class="s3">:</span>
                <span class="s1">work_id </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">work_ids_queue</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">block</span><span class="s3">=</span><span class="s5">False</span><span class="s3">)</span>
            <span class="s5">except </span><span class="s1">queue</span><span class="s3">.</span><span class="s1">Empty</span><span class="s3">:</span>
                <span class="s5">return</span>
            <span class="s5">else</span><span class="s3">:</span>
                <span class="s1">work_item </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pending_work_items</span><span class="s3">[</span><span class="s1">work_id</span><span class="s3">]</span>

                <span class="s5">if </span><span class="s1">work_item</span><span class="s3">.</span><span class="s1">future</span><span class="s3">.</span><span class="s1">set_running_or_notify_cancel</span><span class="s3">():</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">running_work_items </span><span class="s3">+= [</span><span class="s1">work_id</span><span class="s3">]</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">call_queue</span><span class="s3">.</span><span class="s1">put</span><span class="s3">(</span>
                        <span class="s1">_CallItem</span><span class="s3">(</span>
                            <span class="s1">work_id</span><span class="s3">,</span>
                            <span class="s1">work_item</span><span class="s3">.</span><span class="s1">fn</span><span class="s3">,</span>
                            <span class="s1">work_item</span><span class="s3">.</span><span class="s1">args</span><span class="s3">,</span>
                            <span class="s1">work_item</span><span class="s3">.</span><span class="s1">kwargs</span><span class="s3">,</span>
                        <span class="s3">),</span>
                        <span class="s1">block</span><span class="s3">=</span><span class="s5">True</span><span class="s3">,</span>
                    <span class="s3">)</span>
                <span class="s5">else</span><span class="s3">:</span>
                    <span class="s5">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pending_work_items</span><span class="s3">[</span><span class="s1">work_id</span><span class="s3">]</span>
                    <span class="s5">continue</span>

    <span class="s5">def </span><span class="s1">wait_result_broken_or_wakeup</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Wait for a result to be ready in the result_queue while checking</span>
        <span class="s0"># that all worker processes are still running, or for a wake up</span>
        <span class="s0"># signal send. The wake up signals come either from new tasks being</span>
        <span class="s0"># submitted, from the executor being shutdown/gc-ed, or from the</span>
        <span class="s0"># shutdown of the python interpreter.</span>
        <span class="s1">result_reader </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">result_queue</span><span class="s3">.</span><span class="s1">_reader</span>
        <span class="s1">wakeup_reader </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">thread_wakeup</span><span class="s3">.</span><span class="s1">_reader</span>
        <span class="s1">readers </span><span class="s3">= [</span><span class="s1">result_reader</span><span class="s3">, </span><span class="s1">wakeup_reader</span><span class="s3">]</span>
        <span class="s1">worker_sentinels </span><span class="s3">= [</span><span class="s1">p</span><span class="s3">.</span><span class="s1">sentinel </span><span class="s5">for </span><span class="s1">p </span><span class="s5">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">processes</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())]</span>
        <span class="s1">ready </span><span class="s3">= </span><span class="s1">wait</span><span class="s3">(</span><span class="s1">readers </span><span class="s3">+ </span><span class="s1">worker_sentinels</span><span class="s3">)</span>

        <span class="s1">bpe </span><span class="s3">= </span><span class="s5">None</span>
        <span class="s1">is_broken </span><span class="s3">= </span><span class="s5">True</span>
        <span class="s1">result_item </span><span class="s3">= </span><span class="s5">None</span>
        <span class="s5">if </span><span class="s1">result_reader </span><span class="s5">in </span><span class="s1">ready</span><span class="s3">:</span>
            <span class="s5">try</span><span class="s3">:</span>
                <span class="s1">result_item </span><span class="s3">= </span><span class="s1">result_reader</span><span class="s3">.</span><span class="s1">recv</span><span class="s3">()</span>
                <span class="s5">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">result_item</span><span class="s3">, </span><span class="s1">_RemoteTraceback</span><span class="s3">):</span>
                    <span class="s1">bpe </span><span class="s3">= </span><span class="s1">BrokenProcessPool</span><span class="s3">(</span>
                        <span class="s4">&quot;A task has failed to un-serialize. Please ensure that&quot;</span>
                        <span class="s4">&quot; the arguments of the function are all picklable.&quot;</span>
                    <span class="s3">)</span>
                    <span class="s1">bpe</span><span class="s3">.</span><span class="s1">__cause__ </span><span class="s3">= </span><span class="s1">result_item</span>
                <span class="s5">else</span><span class="s3">:</span>
                    <span class="s1">is_broken </span><span class="s3">= </span><span class="s5">False</span>
            <span class="s5">except </span><span class="s1">BaseException </span><span class="s5">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s1">bpe </span><span class="s3">= </span><span class="s1">BrokenProcessPool</span><span class="s3">(</span>
                    <span class="s4">&quot;A result has failed to un-serialize. Please ensure that &quot;</span>
                    <span class="s4">&quot;the objects returned by the function are always &quot;</span>
                    <span class="s4">&quot;picklable.&quot;</span>
                <span class="s3">)</span>
                <span class="s1">tb </span><span class="s3">= </span><span class="s1">traceback</span><span class="s3">.</span><span class="s1">format_exception</span><span class="s3">(</span>
                    <span class="s1">type</span><span class="s3">(</span><span class="s1">e</span><span class="s3">), </span><span class="s1">e</span><span class="s3">, </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">e</span><span class="s3">, </span><span class="s4">&quot;__traceback__&quot;</span><span class="s3">, </span><span class="s5">None</span><span class="s3">)</span>
                <span class="s3">)</span>
                <span class="s1">bpe</span><span class="s3">.</span><span class="s1">__cause__ </span><span class="s3">= </span><span class="s1">_RemoteTraceback</span><span class="s3">(</span><span class="s4">&quot;&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">tb</span><span class="s3">))</span>

        <span class="s5">elif </span><span class="s1">wakeup_reader </span><span class="s5">in </span><span class="s1">ready</span><span class="s3">:</span>
            <span class="s0"># This is simply a wake-up event that might either trigger putting</span>
            <span class="s0"># more tasks in the queue or trigger the clean up of resources.</span>
            <span class="s1">is_broken </span><span class="s3">= </span><span class="s5">False</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s0"># A worker has terminated and we don't know why, set the state of</span>
            <span class="s0"># the executor as broken</span>
            <span class="s1">exit_codes </span><span class="s3">= </span><span class="s4">&quot;&quot;</span>
            <span class="s5">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">!= </span><span class="s4">&quot;win32&quot;</span><span class="s3">:</span>
                <span class="s0"># In Windows, introspecting terminated workers exitcodes seems</span>
                <span class="s0"># unstable, therefore they are not appended in the exception</span>
                <span class="s0"># message.</span>
                <span class="s1">exit_codes </span><span class="s3">= (</span>
                    <span class="s4">&quot;</span><span class="s5">\n</span><span class="s4">The exit codes of the workers are &quot;</span>
                    <span class="s4">f&quot;</span><span class="s5">{</span><span class="s1">get_exitcodes_terminated_worker</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">processes</span><span class="s3">)</span><span class="s5">}</span><span class="s4">&quot;</span>
                <span class="s3">)</span>
            <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span>
                <span class="s4">&quot;A worker unexpectedly terminated. Workers that &quot;</span>
                <span class="s4">&quot;might have caused the breakage: &quot;</span>
                <span class="s3">+ </span><span class="s1">str</span><span class="s3">(</span>
                    <span class="s3">{</span>
                        <span class="s1">p</span><span class="s3">.</span><span class="s1">name</span><span class="s3">: </span><span class="s1">p</span><span class="s3">.</span><span class="s1">exitcode</span>
                        <span class="s5">for </span><span class="s1">p </span><span class="s5">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">processes</span><span class="s3">.</span><span class="s1">values</span><span class="s3">())</span>
                        <span class="s5">if </span><span class="s1">p </span><span class="s5">is not None and </span><span class="s1">p</span><span class="s3">.</span><span class="s1">sentinel </span><span class="s5">in </span><span class="s1">ready</span>
                    <span class="s3">}</span>
                <span class="s3">)</span>
            <span class="s3">)</span>
            <span class="s1">bpe </span><span class="s3">= </span><span class="s1">TerminatedWorkerError</span><span class="s3">(</span>
                <span class="s4">&quot;A worker process managed by the executor was unexpectedly &quot;</span>
                <span class="s4">&quot;terminated. This could be caused by a segmentation fault &quot;</span>
                <span class="s4">&quot;while calling the function or by an excessive memory usage &quot;</span>
                <span class="s4">&quot;causing the Operating System to kill the worker.</span><span class="s5">\n</span><span class="s4">&quot;</span>
                <span class="s4">f&quot;</span><span class="s5">{</span><span class="s1">exit_codes</span><span class="s5">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">thread_wakeup</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">()</span>

        <span class="s5">return </span><span class="s1">result_item</span><span class="s3">, </span><span class="s1">is_broken</span><span class="s3">, </span><span class="s1">bpe</span>

    <span class="s5">def </span><span class="s1">process_result_item</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">result_item</span><span class="s3">):</span>
        <span class="s0"># Process the received a result_item. This can be either the PID of a</span>
        <span class="s0"># worker that exited gracefully or a _ResultItem</span>

        <span class="s5">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">result_item</span><span class="s3">, </span><span class="s1">int</span><span class="s3">):</span>
            <span class="s0"># Clean shutdown of a worker using its PID, either on request</span>
            <span class="s0"># by the executor.shutdown method or by the timeout of the worker</span>
            <span class="s0"># itself: we should not mark the executor as broken.</span>
            <span class="s5">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">processes_management_lock</span><span class="s3">:</span>
                <span class="s1">p </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">processes</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">result_item</span><span class="s3">, </span><span class="s5">None</span><span class="s3">)</span>

            <span class="s0"># p can be None if the executor is concurrently shutting down.</span>
            <span class="s5">if </span><span class="s1">p </span><span class="s5">is not None</span><span class="s3">:</span>
                <span class="s1">p</span><span class="s3">.</span><span class="s1">_worker_exit_lock</span><span class="s3">.</span><span class="s1">release</span><span class="s3">()</span>
                <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span>
                    <span class="s4">f&quot;joining </span><span class="s5">{</span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span><span class="s5">} </span><span class="s4">when processing </span><span class="s5">{</span><span class="s1">p</span><span class="s3">.</span><span class="s1">pid</span><span class="s5">} </span><span class="s4">as result_item&quot;</span>
                <span class="s3">)</span>
                <span class="s1">p</span><span class="s3">.</span><span class="s1">join</span><span class="s3">()</span>
                <span class="s5">del </span><span class="s1">p</span>

            <span class="s0"># Make sure the executor have the right number of worker, even if a</span>
            <span class="s0"># worker timeout while some jobs were submitted. If some work is</span>
            <span class="s0"># pending or there is less processes than running items, we need to</span>
            <span class="s0"># start a new Process and raise a warning.</span>
            <span class="s1">n_pending </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">pending_work_items</span><span class="s3">)</span>
            <span class="s1">n_running </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">running_work_items</span><span class="s3">)</span>
            <span class="s5">if </span><span class="s1">n_pending </span><span class="s3">- </span><span class="s1">n_running </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s5">or </span><span class="s1">n_running </span><span class="s3">&gt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">processes</span><span class="s3">):</span>
                <span class="s1">executor </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">executor_reference</span><span class="s3">()</span>
                <span class="s5">if </span><span class="s3">(</span>
                    <span class="s1">executor </span><span class="s5">is not None</span>
                    <span class="s5">and </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">processes</span><span class="s3">) &lt; </span><span class="s1">executor</span><span class="s3">.</span><span class="s1">_max_workers</span>
                <span class="s3">):</span>
                    <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                        <span class="s4">&quot;A worker stopped while some jobs were given to the &quot;</span>
                        <span class="s4">&quot;executor. This can be caused by a too short worker &quot;</span>
                        <span class="s4">&quot;timeout or by a memory leak.&quot;</span><span class="s3">,</span>
                        <span class="s1">UserWarning</span><span class="s3">,</span>
                    <span class="s3">)</span>
                    <span class="s5">with </span><span class="s1">executor</span><span class="s3">.</span><span class="s1">_processes_management_lock</span><span class="s3">:</span>
                        <span class="s1">executor</span><span class="s3">.</span><span class="s1">_adjust_process_count</span><span class="s3">()</span>
                    <span class="s1">executor </span><span class="s3">= </span><span class="s5">None</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s0"># Received a _ResultItem so mark the future as completed.</span>
            <span class="s1">work_item </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pending_work_items</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">result_item</span><span class="s3">.</span><span class="s1">work_id</span><span class="s3">, </span><span class="s5">None</span><span class="s3">)</span>
            <span class="s0"># work_item can be None if another process terminated (see above)</span>
            <span class="s5">if </span><span class="s1">work_item </span><span class="s5">is not None</span><span class="s3">:</span>
                <span class="s5">if </span><span class="s1">result_item</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">:</span>
                    <span class="s1">work_item</span><span class="s3">.</span><span class="s1">future</span><span class="s3">.</span><span class="s1">set_exception</span><span class="s3">(</span><span class="s1">result_item</span><span class="s3">.</span><span class="s1">exception</span><span class="s3">)</span>
                <span class="s5">else</span><span class="s3">:</span>
                    <span class="s1">work_item</span><span class="s3">.</span><span class="s1">future</span><span class="s3">.</span><span class="s1">set_result</span><span class="s3">(</span><span class="s1">result_item</span><span class="s3">.</span><span class="s1">result</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">running_work_items</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">result_item</span><span class="s3">.</span><span class="s1">work_id</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">is_shutting_down</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Check whether we should start shutting down the executor.</span>
        <span class="s1">executor </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">executor_reference</span><span class="s3">()</span>
        <span class="s0"># No more work items can be added if:</span>
        <span class="s0">#   - The interpreter is shutting down OR</span>
        <span class="s0">#   - The executor that owns this thread is not broken AND</span>
        <span class="s0">#        * The executor that owns this worker has been collected OR</span>
        <span class="s0">#        * The executor that owns this worker has been shutdown.</span>
        <span class="s0"># If the executor is broken, it should be detected in the next loop.</span>
        <span class="s5">return </span><span class="s1">_global_shutdown </span><span class="s5">or </span><span class="s3">(</span>
            <span class="s3">(</span><span class="s1">executor </span><span class="s5">is None or </span><span class="s1">self</span><span class="s3">.</span><span class="s1">executor_flags</span><span class="s3">.</span><span class="s1">shutdown</span><span class="s3">)</span>
            <span class="s5">and not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">executor_flags</span><span class="s3">.</span><span class="s1">broken</span>
        <span class="s3">)</span>

    <span class="s5">def </span><span class="s1">terminate_broken</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">bpe</span><span class="s3">):</span>
        <span class="s0"># Terminate the executor because it is in a broken state. The bpe</span>
        <span class="s0"># argument can be used to display more information on the error that</span>
        <span class="s0"># lead the executor into becoming broken.</span>

        <span class="s0"># Mark the process pool broken so that submits fail right now.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">executor_flags</span><span class="s3">.</span><span class="s1">flag_as_broken</span><span class="s3">(</span><span class="s1">bpe</span><span class="s3">)</span>

        <span class="s0"># Mark pending tasks as failed.</span>
        <span class="s5">for </span><span class="s1">work_item </span><span class="s5">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pending_work_items</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
            <span class="s1">work_item</span><span class="s3">.</span><span class="s1">future</span><span class="s3">.</span><span class="s1">set_exception</span><span class="s3">(</span><span class="s1">bpe</span><span class="s3">)</span>
            <span class="s0"># Delete references to object. See issue16284</span>
            <span class="s5">del </span><span class="s1">work_item</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">pending_work_items</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">()</span>

        <span class="s0"># Terminate remaining workers forcibly: the queues or their</span>
        <span class="s0"># locks may be in a dirty state and block forever.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">kill_workers</span><span class="s3">(</span><span class="s1">reason</span><span class="s3">=</span><span class="s4">&quot;broken executor&quot;</span><span class="s3">)</span>

        <span class="s0"># clean up resources</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">join_executor_internals</span><span class="s3">()</span>

    <span class="s5">def </span><span class="s1">flag_executor_shutting_down</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># Flag the executor as shutting down and cancel remaining tasks if</span>
        <span class="s0"># requested as early as possible if it is not gc-ed yet.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">executor_flags</span><span class="s3">.</span><span class="s1">flag_as_shutting_down</span><span class="s3">()</span>

        <span class="s0"># Cancel pending work items if requested.</span>
        <span class="s5">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">executor_flags</span><span class="s3">.</span><span class="s1">kill_workers</span><span class="s3">:</span>
            <span class="s5">while </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pending_work_items</span><span class="s3">:</span>
                <span class="s1">_</span><span class="s3">, </span><span class="s1">work_item </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">pending_work_items</span><span class="s3">.</span><span class="s1">popitem</span><span class="s3">()</span>
                <span class="s1">work_item</span><span class="s3">.</span><span class="s1">future</span><span class="s3">.</span><span class="s1">set_exception</span><span class="s3">(</span>
                    <span class="s1">ShutdownExecutorError</span><span class="s3">(</span>
                        <span class="s4">&quot;The Executor was shutdown with `kill_workers=True` &quot;</span>
                        <span class="s4">&quot;before this job could complete.&quot;</span>
                    <span class="s3">)</span>
                <span class="s3">)</span>
                <span class="s5">del </span><span class="s1">work_item</span>

            <span class="s0"># Kill the remaining worker forcibly to no waste time joining them</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">kill_workers</span><span class="s3">(</span><span class="s1">reason</span><span class="s3">=</span><span class="s4">&quot;executor shutting down&quot;</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">kill_workers</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">reason</span><span class="s3">=</span><span class="s4">&quot;&quot;</span><span class="s3">):</span>
        <span class="s0"># Terminate the remaining workers using SIGKILL. This function also</span>
        <span class="s0"># terminates descendant workers of the children in case there is some</span>
        <span class="s0"># nested parallelism.</span>
        <span class="s5">while </span><span class="s1">self</span><span class="s3">.</span><span class="s1">processes</span><span class="s3">:</span>
            <span class="s1">_</span><span class="s3">, </span><span class="s1">p </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">processes</span><span class="s3">.</span><span class="s1">popitem</span><span class="s3">()</span>
            <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">f&quot;terminate process </span><span class="s5">{</span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span><span class="s5">}</span><span class="s4">, reason: </span><span class="s5">{</span><span class="s1">reason</span><span class="s5">}</span><span class="s4">&quot;</span><span class="s3">)</span>
            <span class="s5">try</span><span class="s3">:</span>
                <span class="s1">kill_process_tree</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>
            <span class="s5">except </span><span class="s1">ProcessLookupError</span><span class="s3">:  </span><span class="s0"># pragma: no cover</span>
                <span class="s5">pass</span>

    <span class="s5">def </span><span class="s1">shutdown_workers</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># shutdown all workers in self.processes</span>

        <span class="s0"># Create a list to avoid RuntimeError due to concurrent modification of</span>
        <span class="s0"># processes. nb_children_alive is thus an upper bound. Also release the</span>
        <span class="s0"># processes' _worker_exit_lock to accelerate the shutdown procedure, as</span>
        <span class="s0"># there is no need for hand-shake here.</span>
        <span class="s5">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">processes_management_lock</span><span class="s3">:</span>
            <span class="s1">n_children_to_stop </span><span class="s3">= </span><span class="s6">0</span>
            <span class="s5">for </span><span class="s1">p </span><span class="s5">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">processes</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()):</span>
                <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">f&quot;releasing worker exit lock on </span><span class="s5">{</span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span><span class="s5">}</span><span class="s4">&quot;</span><span class="s3">)</span>
                <span class="s1">p</span><span class="s3">.</span><span class="s1">_worker_exit_lock</span><span class="s3">.</span><span class="s1">release</span><span class="s3">()</span>
                <span class="s1">n_children_to_stop </span><span class="s3">+= </span><span class="s6">1</span>

        <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">f&quot;found </span><span class="s5">{</span><span class="s1">n_children_to_stop</span><span class="s5">} </span><span class="s4">processes to stop&quot;</span><span class="s3">)</span>

        <span class="s0"># Send the right number of sentinels, to make sure all children are</span>
        <span class="s0"># properly terminated. Do it with a mechanism that avoid hanging on</span>
        <span class="s0"># Full queue when all workers have already been shutdown.</span>
        <span class="s1">n_sentinels_sent </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">cooldown_time </span><span class="s3">= </span><span class="s6">0.001</span>
        <span class="s5">while </span><span class="s3">(</span>
            <span class="s1">n_sentinels_sent </span><span class="s3">&lt; </span><span class="s1">n_children_to_stop</span>
            <span class="s5">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get_n_children_alive</span><span class="s3">() &gt; </span><span class="s6">0</span>
        <span class="s3">):</span>
            <span class="s5">for </span><span class="s1">_ </span><span class="s5">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">n_children_to_stop </span><span class="s3">- </span><span class="s1">n_sentinels_sent</span><span class="s3">):</span>
                <span class="s5">try</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">call_queue</span><span class="s3">.</span><span class="s1">put_nowait</span><span class="s3">(</span><span class="s5">None</span><span class="s3">)</span>
                    <span class="s1">n_sentinels_sent </span><span class="s3">+= </span><span class="s6">1</span>
                <span class="s5">except </span><span class="s1">queue</span><span class="s3">.</span><span class="s1">Full </span><span class="s5">as </span><span class="s1">e</span><span class="s3">:</span>
                    <span class="s5">if </span><span class="s1">cooldown_time </span><span class="s3">&gt; </span><span class="s6">5.0</span><span class="s3">:</span>
                        <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span>
                            <span class="s4">&quot;failed to send all sentinels and exit with error.&quot;</span>
                            <span class="s4">f&quot;</span><span class="s5">\n</span><span class="s4">call_queue size=</span><span class="s5">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">call_queue</span><span class="s3">.</span><span class="s1">_maxsize</span><span class="s5">}</span><span class="s4">; &quot;</span>
                            <span class="s4">f&quot; full is </span><span class="s5">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">call_queue</span><span class="s3">.</span><span class="s1">full</span><span class="s3">()</span><span class="s5">}</span><span class="s4">; &quot;</span>
                        <span class="s3">)</span>
                        <span class="s5">raise </span><span class="s1">e</span>
                    <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">info</span><span class="s3">(</span>
                        <span class="s4">&quot;full call_queue prevented to send all sentinels at &quot;</span>
                        <span class="s4">&quot;once, waiting...&quot;</span>
                    <span class="s3">)</span>
                    <span class="s1">sleep</span><span class="s3">(</span><span class="s1">cooldown_time</span><span class="s3">)</span>
                    <span class="s1">cooldown_time </span><span class="s3">*= </span><span class="s6">1.2</span>
                    <span class="s5">break</span>

        <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">f&quot;sent </span><span class="s5">{</span><span class="s1">n_sentinels_sent</span><span class="s5">} </span><span class="s4">sentinels to the call queue&quot;</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">join_executor_internals</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">shutdown_workers</span><span class="s3">()</span>

        <span class="s0"># Release the queue's resources as soon as possible. Flag the feeder</span>
        <span class="s0"># thread for clean exit to avoid having the crash detection thread flag</span>
        <span class="s0"># the Executor as broken during the shutdown. This is safe as either:</span>
        <span class="s0">#  * We don't need to communicate with the workers anymore</span>
        <span class="s0">#  * There is nothing left in the Queue buffer except None sentinels</span>
        <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">&quot;closing call_queue&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">call_queue</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">call_queue</span><span class="s3">.</span><span class="s1">join_thread</span><span class="s3">()</span>

        <span class="s0"># Closing result_queue</span>
        <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">&quot;closing result_queue&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">result_queue</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>

        <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">&quot;closing thread_wakeup&quot;</span><span class="s3">)</span>
        <span class="s5">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">shutdown_lock</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">thread_wakeup</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>

        <span class="s0"># If .join() is not called on the created processes then</span>
        <span class="s0"># some ctx.Queue methods may deadlock on macOS.</span>
        <span class="s5">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">processes_management_lock</span><span class="s3">:</span>
            <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">f&quot;joining </span><span class="s5">{</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">processes</span><span class="s3">)</span><span class="s5">} </span><span class="s4">processes&quot;</span><span class="s3">)</span>
            <span class="s1">n_joined_processes </span><span class="s3">= </span><span class="s6">0</span>
            <span class="s5">while True</span><span class="s3">:</span>
                <span class="s5">try</span><span class="s3">:</span>
                    <span class="s1">pid</span><span class="s3">, </span><span class="s1">p </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">processes</span><span class="s3">.</span><span class="s1">popitem</span><span class="s3">()</span>
                    <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">f&quot;joining process </span><span class="s5">{</span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span><span class="s5">} </span><span class="s4">with pid </span><span class="s5">{</span><span class="s1">pid</span><span class="s5">}</span><span class="s4">&quot;</span><span class="s3">)</span>
                    <span class="s1">p</span><span class="s3">.</span><span class="s1">join</span><span class="s3">()</span>
                    <span class="s1">n_joined_processes </span><span class="s3">+= </span><span class="s6">1</span>
                <span class="s5">except </span><span class="s1">KeyError</span><span class="s3">:</span>
                    <span class="s5">break</span>

            <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span>
                <span class="s4">&quot;executor management thread clean shutdown of &quot;</span>
                <span class="s4">f&quot;</span><span class="s5">{</span><span class="s1">n_joined_processes</span><span class="s5">} </span><span class="s4">workers&quot;</span>
            <span class="s3">)</span>

    <span class="s5">def </span><span class="s1">get_n_children_alive</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0"># This is an upper bound on the number of children alive.</span>
        <span class="s5">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">processes_management_lock</span><span class="s3">:</span>
            <span class="s5">return </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">is_alive</span><span class="s3">() </span><span class="s5">for </span><span class="s1">p </span><span class="s5">in </span><span class="s1">list</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">processes</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()))</span>


<span class="s1">_system_limits_checked </span><span class="s3">= </span><span class="s5">False</span>
<span class="s1">_system_limited </span><span class="s3">= </span><span class="s5">None</span>


<span class="s5">def </span><span class="s1">_check_system_limits</span><span class="s3">():</span>
    <span class="s5">global </span><span class="s1">_system_limits_checked</span><span class="s3">, </span><span class="s1">_system_limited</span>
    <span class="s5">if </span><span class="s1">_system_limits_checked </span><span class="s5">and </span><span class="s1">_system_limited</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s1">_system_limited</span><span class="s3">)</span>
    <span class="s1">_system_limits_checked </span><span class="s3">= </span><span class="s5">True</span>
    <span class="s5">try</span><span class="s3">:</span>
        <span class="s1">nsems_max </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">sysconf</span><span class="s3">(</span><span class="s4">&quot;SC_SEM_NSEMS_MAX&quot;</span><span class="s3">)</span>
    <span class="s5">except </span><span class="s3">(</span><span class="s1">AttributeError</span><span class="s3">, </span><span class="s1">ValueError</span><span class="s3">):</span>
        <span class="s0"># sysconf not available or setting not available</span>
        <span class="s5">return</span>
    <span class="s5">if </span><span class="s1">nsems_max </span><span class="s3">== -</span><span class="s6">1</span><span class="s3">:</span>
        <span class="s0"># undetermined limit, assume that limit is determined</span>
        <span class="s0"># by available memory only</span>
        <span class="s5">return</span>
    <span class="s5">if </span><span class="s1">nsems_max </span><span class="s3">&gt;= </span><span class="s6">256</span><span class="s3">:</span>
        <span class="s0"># minimum number of semaphores available</span>
        <span class="s0"># according to POSIX</span>
        <span class="s5">return</span>
    <span class="s1">_system_limited </span><span class="s3">= (</span>
        <span class="s4">f&quot;system provides too few semaphores (</span><span class="s5">{</span><span class="s1">nsems_max</span><span class="s5">} </span><span class="s4">available, &quot;</span>
        <span class="s4">&quot;256 necessary)&quot;</span>
    <span class="s3">)</span>
    <span class="s5">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s1">_system_limited</span><span class="s3">)</span>


<span class="s5">def </span><span class="s1">_chain_from_iterable_of_lists</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Specialized implementation of itertools.chain.from_iterable. 
    Each item in *iterable* should be a list.  This function is 
    careful not to keep references to yielded objects. 
    &quot;&quot;&quot;</span>
    <span class="s5">for </span><span class="s1">element </span><span class="s5">in </span><span class="s1">iterable</span><span class="s3">:</span>
        <span class="s1">element</span><span class="s3">.</span><span class="s1">reverse</span><span class="s3">()</span>
        <span class="s5">while </span><span class="s1">element</span><span class="s3">:</span>
            <span class="s5">yield </span><span class="s1">element</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">()</span>


<span class="s5">def </span><span class="s1">_check_max_depth</span><span class="s3">(</span><span class="s1">context</span><span class="s3">):</span>
    <span class="s0"># Limit the maxmal recursion level</span>
    <span class="s5">global </span><span class="s1">_CURRENT_DEPTH</span>
    <span class="s5">if </span><span class="s1">context</span><span class="s3">.</span><span class="s1">get_start_method</span><span class="s3">() == </span><span class="s4">&quot;fork&quot; </span><span class="s5">and </span><span class="s1">_CURRENT_DEPTH </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">LokyRecursionError</span><span class="s3">(</span>
            <span class="s4">&quot;Could not spawn extra nested processes at depth superior to &quot;</span>
            <span class="s4">&quot;MAX_DEPTH=1. It is not possible to increase this limit when &quot;</span>
            <span class="s4">&quot;using the 'fork' start method.&quot;</span>
        <span class="s3">)</span>

    <span class="s5">if </span><span class="s6">0 </span><span class="s3">&lt; </span><span class="s1">MAX_DEPTH </span><span class="s5">and </span><span class="s1">_CURRENT_DEPTH </span><span class="s3">+ </span><span class="s6">1 </span><span class="s3">&gt; </span><span class="s1">MAX_DEPTH</span><span class="s3">:</span>
        <span class="s5">raise </span><span class="s1">LokyRecursionError</span><span class="s3">(</span>
            <span class="s4">&quot;Could not spawn extra nested processes at depth superior to &quot;</span>
            <span class="s4">f&quot;MAX_DEPTH=</span><span class="s5">{</span><span class="s1">MAX_DEPTH</span><span class="s5">}</span><span class="s4">. If this is intendend, you can change &quot;</span>
            <span class="s4">&quot;this limit with the LOKY_MAX_DEPTH environment variable.&quot;</span>
        <span class="s3">)</span>


<span class="s5">class </span><span class="s1">LokyRecursionError</span><span class="s3">(</span><span class="s1">RuntimeError</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot;A process tries to spawn too many levels of nested processes.&quot;&quot;&quot;</span>


<span class="s5">class </span><span class="s1">BrokenProcessPool</span><span class="s3">(</span><span class="s1">_BPPException</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Raised when the executor is broken while a future was in the running state. 
    The cause can an error raised when unpickling the task in the worker 
    process or when unpickling the result value in the parent process. It can 
    also be caused by a worker process being terminated unexpectedly. 
    &quot;&quot;&quot;</span>


<span class="s5">class </span><span class="s1">TerminatedWorkerError</span><span class="s3">(</span><span class="s1">BrokenProcessPool</span><span class="s3">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Raised when a process in a ProcessPoolExecutor terminated abruptly 
    while a future was in the running state. 
    &quot;&quot;&quot;</span>


<span class="s0"># Alias for backward compat (for code written for loky 1.1.4 and earlier). Do</span>
<span class="s0"># not use in new code.</span>
<span class="s1">BrokenExecutor </span><span class="s3">= </span><span class="s1">BrokenProcessPool</span>


<span class="s5">class </span><span class="s1">ShutdownExecutorError</span><span class="s3">(</span><span class="s1">RuntimeError</span><span class="s3">):</span>

    <span class="s2">&quot;&quot;&quot; 
    Raised when a ProcessPoolExecutor is shutdown while a future was in the 
    running or pending state. 
    &quot;&quot;&quot;</span>


<span class="s5">class </span><span class="s1">ProcessPoolExecutor</span><span class="s3">(</span><span class="s1">Executor</span><span class="s3">):</span>

    <span class="s1">_at_exit </span><span class="s3">= </span><span class="s5">None</span>

    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">max_workers</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
        <span class="s1">job_reducers</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
        <span class="s1">result_reducers</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
        <span class="s1">timeout</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
        <span class="s1">context</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
        <span class="s1">initializer</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
        <span class="s1">initargs</span><span class="s3">=(),</span>
        <span class="s1">env</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
    <span class="s3">):</span>
        <span class="s2">&quot;&quot;&quot;Initializes a new ProcessPoolExecutor instance. 
 
        Args: 
            max_workers: int, optional (default: cpu_count()) 
                The maximum number of processes that can be used to execute the 
                given calls. If None or not given then as many worker processes 
                will be created as the number of CPUs the current process 
                can use. 
            job_reducers, result_reducers: dict(type: reducer_func) 
                Custom reducer for pickling the jobs and the results from the 
                Executor. If only `job_reducers` is provided, `result_reducer` 
                will use the same reducers 
            timeout: int, optional (default: None) 
                Idle workers exit after timeout seconds. If a new job is 
                submitted after the timeout, the executor will start enough 
                new Python processes to make sure the pool of workers is full. 
            context: A multiprocessing context to launch the workers. This 
                object should provide SimpleQueue, Queue and Process. 
            initializer: An callable used to initialize worker processes. 
            initargs: A tuple of arguments to pass to the initializer. 
            env: A dict of environment variable to overwrite in the child 
                process. The environment variables are set before any module is 
                loaded. Note that this only works with the loky context. 
        &quot;&quot;&quot;</span>
        <span class="s1">_check_system_limits</span><span class="s3">()</span>

        <span class="s5">if </span><span class="s1">max_workers </span><span class="s5">is None</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_max_workers </span><span class="s3">= </span><span class="s1">cpu_count</span><span class="s3">()</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s5">if </span><span class="s1">max_workers </span><span class="s3">&lt;= </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;max_workers must be greater than 0&quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_max_workers </span><span class="s3">= </span><span class="s1">max_workers</span>

        <span class="s5">if </span><span class="s3">(</span>
            <span class="s1">sys</span><span class="s3">.</span><span class="s1">platform </span><span class="s3">== </span><span class="s4">&quot;win32&quot;</span>
            <span class="s5">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_max_workers </span><span class="s3">&gt; </span><span class="s1">_MAX_WINDOWS_WORKERS</span>
        <span class="s3">):</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span>
                <span class="s4">f&quot;On Windows, max_workers cannot exceed </span><span class="s5">{</span><span class="s1">_MAX_WINDOWS_WORKERS</span><span class="s5">} </span><span class="s4">&quot;</span>
                <span class="s4">&quot;due to limitations of the operating system.&quot;</span>
            <span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_max_workers </span><span class="s3">= </span><span class="s1">_MAX_WINDOWS_WORKERS</span>

        <span class="s5">if </span><span class="s1">context </span><span class="s5">is None</span><span class="s3">:</span>
            <span class="s1">context </span><span class="s3">= </span><span class="s1">get_context</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_context </span><span class="s3">= </span><span class="s1">context</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_env </span><span class="s3">= </span><span class="s1">env</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_initializer</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_initargs </span><span class="s3">= </span><span class="s1">_prepare_initializer</span><span class="s3">(</span>
            <span class="s1">initializer</span><span class="s3">, </span><span class="s1">initargs</span>
        <span class="s3">)</span>
        <span class="s1">_check_max_depth</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_context</span><span class="s3">)</span>

        <span class="s5">if </span><span class="s1">result_reducers </span><span class="s5">is None</span><span class="s3">:</span>
            <span class="s1">result_reducers </span><span class="s3">= </span><span class="s1">job_reducers</span>

        <span class="s0"># Timeout</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_timeout </span><span class="s3">= </span><span class="s1">timeout</span>

        <span class="s0"># Management thread</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_executor_manager_thread </span><span class="s3">= </span><span class="s5">None</span>

        <span class="s0"># Map of pids to processes</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_processes </span><span class="s3">= {}</span>

        <span class="s0"># Internal variables of the ProcessPoolExecutor</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_processes </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_queue_count </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_pending_work_items </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_running_work_items </span><span class="s3">= []</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_work_ids </span><span class="s3">= </span><span class="s1">queue</span><span class="s3">.</span><span class="s1">Queue</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_processes_management_lock </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_context</span><span class="s3">.</span><span class="s1">Lock</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_executor_manager_thread </span><span class="s3">= </span><span class="s5">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_shutdown_lock </span><span class="s3">= </span><span class="s1">threading</span><span class="s3">.</span><span class="s1">Lock</span><span class="s3">()</span>

        <span class="s0"># _ThreadWakeup is a communication channel used to interrupt the wait</span>
        <span class="s0"># of the main loop of executor_manager_thread from another thread (e.g.</span>
        <span class="s0"># when calling executor.submit or executor.shutdown). We do not use the</span>
        <span class="s0"># _result_queue to send wakeup signals to the executor_manager_thread</span>
        <span class="s0"># as it could result in a deadlock if a worker process dies with the</span>
        <span class="s0"># _result_queue write lock still acquired.</span>
        <span class="s0">#</span>
        <span class="s0"># _shutdown_lock must be locked to access _ThreadWakeup.wakeup.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_executor_manager_thread_wakeup </span><span class="s3">= </span><span class="s1">_ThreadWakeup</span><span class="s3">()</span>

        <span class="s0"># Flag to hold the state of the Executor. This permits to introspect</span>
        <span class="s0"># the Executor state even once it has been garbage collected.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_flags </span><span class="s3">= </span><span class="s1">_ExecutorFlags</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_shutdown_lock</span><span class="s3">)</span>

        <span class="s0"># Finally setup the queues for interprocess communication</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_setup_queues</span><span class="s3">(</span><span class="s1">job_reducers</span><span class="s3">, </span><span class="s1">result_reducers</span><span class="s3">)</span>

        <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">&quot;ProcessPoolExecutor is setup&quot;</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">_setup_queues</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">job_reducers</span><span class="s3">, </span><span class="s1">result_reducers</span><span class="s3">, </span><span class="s1">queue_size</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
        <span class="s0"># Make the call queue slightly larger than the number of processes to</span>
        <span class="s0"># prevent the worker processes from idling. But don't make it too big</span>
        <span class="s0"># because futures in the call queue cannot be cancelled.</span>
        <span class="s5">if </span><span class="s1">queue_size </span><span class="s5">is None</span><span class="s3">:</span>
            <span class="s1">queue_size </span><span class="s3">= </span><span class="s6">2 </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_max_workers </span><span class="s3">+ </span><span class="s1">EXTRA_QUEUED_CALLS</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_call_queue </span><span class="s3">= </span><span class="s1">_SafeQueue</span><span class="s3">(</span>
            <span class="s1">max_size</span><span class="s3">=</span><span class="s1">queue_size</span><span class="s3">,</span>
            <span class="s1">pending_work_items</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_pending_work_items</span><span class="s3">,</span>
            <span class="s1">running_work_items</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_running_work_items</span><span class="s3">,</span>
            <span class="s1">thread_wakeup</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_executor_manager_thread_wakeup</span><span class="s3">,</span>
            <span class="s1">reducers</span><span class="s3">=</span><span class="s1">job_reducers</span><span class="s3">,</span>
            <span class="s1">ctx</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_context</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s0"># Killed worker processes can produce spurious &quot;broken pipe&quot;</span>
        <span class="s0"># tracebacks in the queue's own worker thread. But we detect killed</span>
        <span class="s0"># processes anyway, so silence the tracebacks.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_call_queue</span><span class="s3">.</span><span class="s1">_ignore_epipe </span><span class="s3">= </span><span class="s5">True</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_result_queue </span><span class="s3">= </span><span class="s1">SimpleQueue</span><span class="s3">(</span>
            <span class="s1">reducers</span><span class="s3">=</span><span class="s1">result_reducers</span><span class="s3">, </span><span class="s1">ctx</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_context</span>
        <span class="s3">)</span>

    <span class="s5">def </span><span class="s1">_start_executor_manager_thread</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_executor_manager_thread </span><span class="s5">is None</span><span class="s3">:</span>
            <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">&quot;_start_executor_manager_thread called&quot;</span><span class="s3">)</span>

            <span class="s0"># Start the processes so that their sentinels are known.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_executor_manager_thread </span><span class="s3">= </span><span class="s1">_ExecutorManagerThread</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_executor_manager_thread</span><span class="s3">.</span><span class="s1">start</span><span class="s3">()</span>

            <span class="s0"># register this executor in a mechanism that ensures it will wakeup</span>
            <span class="s0"># when the interpreter is exiting.</span>
            <span class="s1">_threads_wakeups</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_executor_manager_thread</span><span class="s3">] = (</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_shutdown_lock</span><span class="s3">,</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_executor_manager_thread_wakeup</span><span class="s3">,</span>
            <span class="s3">)</span>

            <span class="s5">global </span><span class="s1">process_pool_executor_at_exit</span>
            <span class="s5">if </span><span class="s1">process_pool_executor_at_exit </span><span class="s5">is None</span><span class="s3">:</span>
                <span class="s0"># Ensure that the _python_exit function will be called before</span>
                <span class="s0"># the multiprocessing.Queue._close finalizers which have an</span>
                <span class="s0"># exitpriority of 10.</span>

                <span class="s5">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">version_info </span><span class="s3">&lt; (</span><span class="s6">3</span><span class="s3">, </span><span class="s6">9</span><span class="s3">):</span>
                    <span class="s1">process_pool_executor_at_exit </span><span class="s3">= </span><span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">Finalize</span><span class="s3">(</span>
                        <span class="s5">None</span><span class="s3">, </span><span class="s1">_python_exit</span><span class="s3">, </span><span class="s1">exitpriority</span><span class="s3">=</span><span class="s6">20</span>
                    <span class="s3">)</span>
                <span class="s5">else</span><span class="s3">:</span>
                    <span class="s1">process_pool_executor_at_exit </span><span class="s3">= </span><span class="s1">threading</span><span class="s3">.</span><span class="s1">_register_atexit</span><span class="s3">(</span>
                        <span class="s1">_python_exit</span>
                    <span class="s3">)</span>

    <span class="s5">def </span><span class="s1">_adjust_process_count</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">while </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_processes</span><span class="s3">) &lt; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_max_workers</span><span class="s3">:</span>
            <span class="s1">worker_exit_lock </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_context</span><span class="s3">.</span><span class="s1">BoundedSemaphore</span><span class="s3">(</span><span class="s6">1</span><span class="s3">)</span>
            <span class="s1">args </span><span class="s3">= (</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_call_queue</span><span class="s3">,</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_result_queue</span><span class="s3">,</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_initializer</span><span class="s3">,</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_initargs</span><span class="s3">,</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_processes_management_lock</span><span class="s3">,</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_timeout</span><span class="s3">,</span>
                <span class="s1">worker_exit_lock</span><span class="s3">,</span>
                <span class="s1">_CURRENT_DEPTH </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">,</span>
            <span class="s3">)</span>
            <span class="s1">worker_exit_lock</span><span class="s3">.</span><span class="s1">acquire</span><span class="s3">()</span>
            <span class="s5">try</span><span class="s3">:</span>
                <span class="s0"># Try to spawn the process with some environment variable to</span>
                <span class="s0"># overwrite but it only works with the loky context for now.</span>
                <span class="s1">p </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_context</span><span class="s3">.</span><span class="s1">Process</span><span class="s3">(</span>
                    <span class="s1">target</span><span class="s3">=</span><span class="s1">_process_worker</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=</span><span class="s1">args</span><span class="s3">, </span><span class="s1">env</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_env</span>
                <span class="s3">)</span>
            <span class="s5">except </span><span class="s1">TypeError</span><span class="s3">:</span>
                <span class="s1">p </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_context</span><span class="s3">.</span><span class="s1">Process</span><span class="s3">(</span><span class="s1">target</span><span class="s3">=</span><span class="s1">_process_worker</span><span class="s3">, </span><span class="s1">args</span><span class="s3">=</span><span class="s1">args</span><span class="s3">)</span>
            <span class="s1">p</span><span class="s3">.</span><span class="s1">_worker_exit_lock </span><span class="s3">= </span><span class="s1">worker_exit_lock</span>
            <span class="s1">p</span><span class="s3">.</span><span class="s1">start</span><span class="s3">()</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_processes</span><span class="s3">[</span><span class="s1">p</span><span class="s3">.</span><span class="s1">pid</span><span class="s3">] = </span><span class="s1">p</span>
        <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span>
            <span class="s4">f&quot;Adjusted process count to </span><span class="s5">{</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_max_workers</span><span class="s5">}</span><span class="s4">: &quot;</span>
            <span class="s4">f&quot;</span><span class="s5">{</span><span class="s3">[(</span><span class="s1">p</span><span class="s3">.</span><span class="s1">name</span><span class="s3">, </span><span class="s1">pid</span><span class="s3">) </span><span class="s5">for </span><span class="s1">pid</span><span class="s3">, </span><span class="s1">p </span><span class="s5">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_processes</span><span class="s3">.</span><span class="s1">items</span><span class="s3">()]</span><span class="s5">}</span><span class="s4">&quot;</span>
        <span class="s3">)</span>

    <span class="s5">def </span><span class="s1">_ensure_executor_running</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">&quot;&quot;&quot;ensures all workers and management thread are running&quot;&quot;&quot;</span>
        <span class="s5">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_processes_management_lock</span><span class="s3">:</span>
            <span class="s5">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_processes</span><span class="s3">) != </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_max_workers</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_adjust_process_count</span><span class="s3">()</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_start_executor_manager_thread</span><span class="s3">()</span>

    <span class="s5">def </span><span class="s1">submit</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, *</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s5">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flags</span><span class="s3">.</span><span class="s1">shutdown_lock</span><span class="s3">:</span>
            <span class="s5">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flags</span><span class="s3">.</span><span class="s1">broken </span><span class="s5">is not None</span><span class="s3">:</span>
                <span class="s5">raise </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flags</span><span class="s3">.</span><span class="s1">broken</span>
            <span class="s5">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_flags</span><span class="s3">.</span><span class="s1">shutdown</span><span class="s3">:</span>
                <span class="s5">raise </span><span class="s1">ShutdownExecutorError</span><span class="s3">(</span>
                    <span class="s4">&quot;cannot schedule new futures after shutdown&quot;</span>
                <span class="s3">)</span>

            <span class="s0"># Cannot submit a new calls once the interpreter is shutting down.</span>
            <span class="s0"># This check avoids spawning new processes at exit.</span>
            <span class="s5">if </span><span class="s1">_global_shutdown</span><span class="s3">:</span>
                <span class="s5">raise </span><span class="s1">RuntimeError</span><span class="s3">(</span>
                    <span class="s4">&quot;cannot schedule new futures after &quot; &quot;interpreter shutdown&quot;</span>
                <span class="s3">)</span>

            <span class="s1">f </span><span class="s3">= </span><span class="s1">Future</span><span class="s3">()</span>
            <span class="s1">w </span><span class="s3">= </span><span class="s1">_WorkItem</span><span class="s3">(</span><span class="s1">f</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">kwargs</span><span class="s3">)</span>

            <span class="s1">self</span><span class="s3">.</span><span class="s1">_pending_work_items</span><span class="s3">[</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_queue_count</span><span class="s3">] = </span><span class="s1">w</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_work_ids</span><span class="s3">.</span><span class="s1">put</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_queue_count</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_queue_count </span><span class="s3">+= </span><span class="s6">1</span>
            <span class="s0"># Wake up queue management thread</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_executor_manager_thread_wakeup</span><span class="s3">.</span><span class="s1">wakeup</span><span class="s3">()</span>

            <span class="s1">self</span><span class="s3">.</span><span class="s1">_ensure_executor_running</span><span class="s3">()</span>
            <span class="s5">return </span><span class="s1">f</span>

    <span class="s1">submit</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= </span><span class="s1">Executor</span><span class="s3">.</span><span class="s1">submit</span><span class="s3">.</span><span class="s1">__doc__</span>

    <span class="s5">def </span><span class="s1">map</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">, *</span><span class="s1">iterables</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s2">&quot;&quot;&quot;Returns an iterator equivalent to map(fn, iter). 
 
        Args: 
            fn: A callable that will take as many arguments as there are 
                passed iterables. 
            timeout: The maximum number of seconds to wait. If None, then there 
                is no limit on the wait time. 
            chunksize: If greater than one, the iterables will be chopped into 
                chunks of size chunksize and submitted to the process pool. 
                If set to one, the items in the list will be sent one at a 
                time. 
 
        Returns: 
            An iterator equivalent to: map(func, *iterables) but the calls may 
            be evaluated out-of-order. 
 
        Raises: 
            TimeoutError: If the entire result iterator could not be generated 
                before the given timeout. 
            Exception: If fn(*args) raises for any values. 
        &quot;&quot;&quot;</span>
        <span class="s1">timeout </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;timeout&quot;</span><span class="s3">, </span><span class="s5">None</span><span class="s3">)</span>
        <span class="s1">chunksize </span><span class="s3">= </span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s4">&quot;chunksize&quot;</span><span class="s3">, </span><span class="s6">1</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">chunksize </span><span class="s3">&lt; </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;chunksize must be &gt;= 1.&quot;</span><span class="s3">)</span>

        <span class="s1">results </span><span class="s3">= </span><span class="s1">super</span><span class="s3">().</span><span class="s1">map</span><span class="s3">(</span>
            <span class="s1">partial</span><span class="s3">(</span><span class="s1">_process_chunk</span><span class="s3">, </span><span class="s1">fn</span><span class="s3">),</span>
            <span class="s1">_get_chunks</span><span class="s3">(</span><span class="s1">chunksize</span><span class="s3">, *</span><span class="s1">iterables</span><span class="s3">),</span>
            <span class="s1">timeout</span><span class="s3">=</span><span class="s1">timeout</span><span class="s3">,</span>
        <span class="s3">)</span>
        <span class="s5">return </span><span class="s1">_chain_from_iterable_of_lists</span><span class="s3">(</span><span class="s1">results</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">shutdown</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">wait</span><span class="s3">=</span><span class="s5">True</span><span class="s3">, </span><span class="s1">kill_workers</span><span class="s3">=</span><span class="s5">False</span><span class="s3">):</span>
        <span class="s1">mp</span><span class="s3">.</span><span class="s1">util</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s4">f&quot;shutting down executor </span><span class="s5">{</span><span class="s1">self</span><span class="s5">}</span><span class="s4">&quot;</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">_flags</span><span class="s3">.</span><span class="s1">flag_as_shutting_down</span><span class="s3">(</span><span class="s1">kill_workers</span><span class="s3">)</span>
        <span class="s1">executor_manager_thread </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_executor_manager_thread</span>
        <span class="s1">executor_manager_thread_wakeup </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_executor_manager_thread_wakeup</span>

        <span class="s5">if </span><span class="s1">executor_manager_thread_wakeup </span><span class="s5">is not None</span><span class="s3">:</span>
            <span class="s0"># Wake up queue management thread</span>
            <span class="s5">with </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_shutdown_lock</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_executor_manager_thread_wakeup</span><span class="s3">.</span><span class="s1">wakeup</span><span class="s3">()</span>

        <span class="s5">if </span><span class="s1">executor_manager_thread </span><span class="s5">is not None and </span><span class="s1">wait</span><span class="s3">:</span>
            <span class="s0"># This locks avoids concurrent join if the interpreter</span>
            <span class="s0"># is shutting down.</span>
            <span class="s5">with </span><span class="s1">_global_shutdown_lock</span><span class="s3">:</span>
                <span class="s1">executor_manager_thread</span><span class="s3">.</span><span class="s1">join</span><span class="s3">()</span>
                <span class="s1">_threads_wakeups</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s1">executor_manager_thread</span><span class="s3">, </span><span class="s5">None</span><span class="s3">)</span>

        <span class="s0"># To reduce the risk of opening too many files, remove references to</span>
        <span class="s0"># objects that use file descriptors.</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_executor_manager_thread </span><span class="s3">= </span><span class="s5">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_executor_manager_thread_wakeup </span><span class="s3">= </span><span class="s5">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_call_queue </span><span class="s3">= </span><span class="s5">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_result_queue </span><span class="s3">= </span><span class="s5">None</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_processes_management_lock </span><span class="s3">= </span><span class="s5">None</span>

    <span class="s1">shutdown</span><span class="s3">.</span><span class="s1">__doc__ </span><span class="s3">= </span><span class="s1">Executor</span><span class="s3">.</span><span class="s1">shutdown</span><span class="s3">.</span><span class="s1">__doc__</span>
</pre>
</body>
</html>