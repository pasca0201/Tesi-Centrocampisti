<html>
<head>
<title>test_short_time_fft.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_short_time_fft.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Unit tests for module `_short_time_fft`. 
 
This file's structure loosely groups the tests into the following sequential 
categories: 
 
1. Test function `_calc_dual_canonical_window`. 
2. Test for invalid parameters and exceptions in `ShortTimeFFT` (until the 
    `test_from_window` function). 
3. Test algorithmic properties of STFT/ISTFT. Some tests were ported from 
   ``test_spectral.py``. 
 
Notes 
----- 
* Mypy 0.990 does interpret the line:: 
 
        from scipy.stats import norm as normal_distribution 
 
  incorrectly (but the code works), hence a ``type: ignore`` was appended. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">product</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">cast</span><span class="s3">, </span><span class="s1">get_args</span><span class="s3">, </span><span class="s1">Literal</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">testing </span><span class="s2">import </span><span class="s1">assert_allclose</span><span class="s3">, </span><span class="s1">assert_equal</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">fft </span><span class="s2">import </span><span class="s1">fftshift</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">stats </span><span class="s2">import </span><span class="s1">norm </span><span class="s2">as </span><span class="s1">normal_distribution  </span><span class="s4"># type: ignore</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">signal </span><span class="s2">import </span><span class="s1">get_window</span><span class="s3">, </span><span class="s1">welch</span><span class="s3">, </span><span class="s1">stft</span><span class="s3">, </span><span class="s1">istft</span><span class="s3">, </span><span class="s1">spectrogram</span>

<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">signal</span><span class="s3">.</span><span class="s1">_short_time_fft </span><span class="s2">import </span><span class="s1">FFT_MODE_TYPE</span><span class="s3">, </span><span class="s1">\</span>
    <span class="s1">_calc_dual_canonical_window</span><span class="s3">, </span><span class="s1">ShortTimeFFT</span><span class="s3">, </span><span class="s1">PAD_TYPE</span>
<span class="s2">from </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">signal</span><span class="s3">.</span><span class="s1">windows </span><span class="s2">import </span><span class="s1">gaussian</span>


<span class="s2">def </span><span class="s1">test__calc_dual_canonical_window_roundtrip</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Test dual window calculation with a round trip to verify duality. 
 
    Note that this works only for canonical window pairs (having minimal 
    energy) like a Gaussian. 
 
    The window is the same as in the example of `from ShortTimeFFT.from_dual`. 
    &quot;&quot;&quot;</span>
    <span class="s1">win </span><span class="s3">= </span><span class="s1">gaussian</span><span class="s3">(</span><span class="s5">51</span><span class="s3">, </span><span class="s1">std</span><span class="s3">=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">sym</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">d_win </span><span class="s3">= </span><span class="s1">_calc_dual_canonical_window</span><span class="s3">(</span><span class="s1">win</span><span class="s3">, </span><span class="s5">10</span><span class="s3">)</span>
    <span class="s1">win2 </span><span class="s3">= </span><span class="s1">_calc_dual_canonical_window</span><span class="s3">(</span><span class="s1">d_win</span><span class="s3">, </span><span class="s5">10</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">win2</span><span class="s3">, </span><span class="s1">win</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test__calc_dual_canonical_window_exceptions</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Raise all exceptions in `_calc_dual_canonical_window`.&quot;&quot;&quot;</span>
    <span class="s4"># Verify that calculation can fail:</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;hop=5 is larger than window len.*&quot;</span><span class="s3">):</span>
        <span class="s1">_calc_dual_canonical_window</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">4</span><span class="s3">), </span><span class="s5">5</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;.* Transform not invertible!&quot;</span><span class="s3">):</span>
        <span class="s1">_calc_dual_canonical_window</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">.1</span><span class="s3">, </span><span class="s5">.2</span><span class="s3">, </span><span class="s5">.3</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]), </span><span class="s5">4</span><span class="s3">)</span>

    <span class="s4"># Verify that parameter `win` may not be integers:</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Parameter 'win' cannot be of int.*&quot;</span><span class="s3">):</span>
        <span class="s1">_calc_dual_canonical_window</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">4</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">int</span><span class="s3">), </span><span class="s5">1</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_invalid_initializer_parameters</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Verify that exceptions get raised on invalid parameters when 
    instantiating ShortTimeFFT. &quot;&quot;&quot;</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">r&quot;Parameter win must be 1d, &quot; </span><span class="s3">+</span>
                                         <span class="s6">r&quot;but win.shape=\(2, 2\)!&quot;</span><span class="s3">):</span>
        <span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Parameter win must have &quot; </span><span class="s3">+</span>
                                         <span class="s6">&quot;finite entries&quot;</span><span class="s3">):</span>
        <span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">1</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">]), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Parameter hop=0 is not &quot; </span><span class="s3">+</span>
                                         <span class="s6">&quot;an integer &gt;= 1!&quot;</span><span class="s3">):</span>
        <span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">4</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Parameter hop=2.0 is not &quot; </span><span class="s3">+</span>
                                         <span class="s6">&quot;an integer &gt;= 1!&quot;</span><span class="s3">):</span>
        <span class="s4"># noinspection PyTypeChecker</span>
        <span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">4</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">2.0</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">r&quot;dual_win.shape=\(5,\) must equal &quot; </span><span class="s3">+</span>
                                         <span class="s6">r&quot;win.shape=\(4,\)!&quot;</span><span class="s3">):</span>
        <span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">4</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">2</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">dual_win</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">5</span><span class="s3">))</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Parameter dual_win must be &quot; </span><span class="s3">+</span>
                                         <span class="s6">&quot;a finite array!&quot;</span><span class="s3">):</span>
        <span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">3</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">2</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">,</span>
                     <span class="s1">dual_win</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">]))</span>


<span class="s2">def </span><span class="s1">test_exceptions_properties_methods</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Verify that exceptions get raised when setting properties or calling 
    method of ShortTimeFFT to/with invalid values.&quot;&quot;&quot;</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">8</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Sampling interval T=-1 must be &quot; </span><span class="s3">+</span>
                                         <span class="s6">&quot;positive!&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">T </span><span class="s3">= -</span><span class="s5">1</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Sampling frequency fs=-1 must be &quot; </span><span class="s3">+</span>
                                         <span class="s6">&quot;positive!&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">fs </span><span class="s3">= -</span><span class="s5">1</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;fft_mode='invalid_typ' not in &quot; </span><span class="s3">+</span>
                                         <span class="s6">r&quot;\('twosided', 'centered', &quot; </span><span class="s3">+</span>
                                         <span class="s6">r&quot;'onesided', 'onesided2X'\)!&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">fft_mode </span><span class="s3">= </span><span class="s6">'invalid_typ'</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;For scaling is None, &quot; </span><span class="s3">+</span>
                                         <span class="s6">&quot;fft_mode='onesided2X' is invalid.*&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">fft_mode </span><span class="s3">= </span><span class="s6">'onesided2X'</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Attribute mfft=7 needs to be &quot; </span><span class="s3">+</span>
                                         <span class="s6">&quot;at least the window length.*&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">mfft </span><span class="s3">= </span><span class="s5">7</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;scaling='invalid' not in.*&quot;</span><span class="s3">):</span>
        <span class="s4"># noinspection PyTypeChecker</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">scale_to</span><span class="s3">(</span><span class="s6">'invalid'</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;phase_shift=3.0 has the unit .*&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">phase_shift </span><span class="s3">= </span><span class="s5">3.0</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;-mfft &lt; phase_shift &lt; mfft &quot; </span><span class="s3">+</span>
                                         <span class="s6">&quot;does not hold.*&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">phase_shift </span><span class="s3">= </span><span class="s5">2</span><span class="s3">*</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">mfft</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Parameter padding='invalid' not.*&quot;</span><span class="s3">):</span>
        <span class="s4"># noinspection PyTypeChecker</span>
        <span class="s1">g </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">_x_slices</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s5">16</span><span class="s3">), </span><span class="s1">k_off</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">p0</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">p1</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">padding</span><span class="s3">=</span><span class="s6">'invalid'</span><span class="s3">)</span>
        <span class="s1">next</span><span class="s3">(</span><span class="s1">g</span><span class="s3">)  </span><span class="s4"># execute generator</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Trend type must be 'linear' &quot; </span><span class="s3">+</span>
                                         <span class="s6">&quot;or 'constant'&quot;</span><span class="s3">):</span>
        <span class="s4"># noinspection PyTypeChecker</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft_detrend</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s5">16</span><span class="s3">), </span><span class="s1">detr</span><span class="s3">=</span><span class="s6">'invalid'</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Parameter detr=nan is not a str, &quot; </span><span class="s3">+</span>
                                         <span class="s6">&quot;function or None!&quot;</span><span class="s3">):</span>
        <span class="s4"># noinspection PyTypeChecker</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft_detrend</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s5">16</span><span class="s3">), </span><span class="s1">detr</span><span class="s3">=</span><span class="s1">np</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Invalid Parameter p0=0, p1=200.*&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">p_range</span><span class="s3">(</span><span class="s5">100</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">200</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;f_axis=0 may not be equal to &quot; </span><span class="s3">+</span>
                                         <span class="s6">&quot;t_axis=0!&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">f_pts</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)), </span><span class="s1">t_axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">f_axis</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">r&quot;S.shape\[f_axis\]=2 must be equal&quot; </span><span class="s3">+</span>
                                         <span class="s6">&quot; to self.f_pts=5.*&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)))</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">r&quot;S.shape\[t_axis\]=1 needs to have&quot; </span><span class="s3">+</span>
                                         <span class="s6">&quot; at least 2 slices.*&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">f_pts</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)))</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">r&quot;.*\(k1=100\) &lt;= \(k_max=12\) &quot; </span><span class="s3">+</span>
                                         <span class="s6">&quot;is false!$&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">f_pts</span><span class="s3">, </span><span class="s5">3</span><span class="s3">)), </span><span class="s1">k1</span><span class="s3">=</span><span class="s5">100</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">r&quot;\(k1=1\) - \(k0=0\) = 1 has to &quot; </span><span class="s3">+</span>
                                         <span class="s6">&quot;be at least.* length 4!&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">f_pts</span><span class="s3">, </span><span class="s5">3</span><span class="s3">)), </span><span class="s1">k0</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">r&quot;Parameter axes_seq='invalid' &quot; </span><span class="s3">+</span>
                                         <span class="s6">r&quot;not in \['tf', 'ft'\]!&quot;</span><span class="s3">):</span>
        <span class="s4"># noinspection PyTypeChecker</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">extent</span><span class="s3">(</span><span class="s1">n</span><span class="s3">=</span><span class="s5">100</span><span class="s3">, </span><span class="s1">axes_seq</span><span class="s3">=</span><span class="s6">'invalid'</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Attribute fft_mode=twosided must.*&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">fft_mode </span><span class="s3">= </span><span class="s6">'twosided'</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">extent</span><span class="s3">(</span><span class="s1">n</span><span class="s3">=</span><span class="s5">100</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">'m'</span><span class="s3">, (</span><span class="s6">'onesided'</span><span class="s3">, </span><span class="s6">'onesided2X'</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">test_exceptions_fft_mode_complex_win</span><span class="s3">(</span><span class="s1">m</span><span class="s3">: </span><span class="s1">FFT_MODE_TYPE</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Verify that one-sided spectra are not allowed with complex-valued 
    windows or with complex-valued signals. 
 
    The reason being, the `rfft` function only accepts real-valued input. 
    &quot;&quot;&quot;</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">,</span>
                       <span class="s1">match</span><span class="s3">=</span><span class="s6">f&quot;One-sided spectra, i.e., fft_mode='</span><span class="s2">{</span><span class="s1">m</span><span class="s2">}</span><span class="s6">'.*&quot;</span><span class="s3">):</span>
        <span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">8</span><span class="s3">)*</span><span class="s5">1j</span><span class="s3">, </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">fft_mode</span><span class="s3">=</span><span class="s1">m</span><span class="s3">)</span>

    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">8</span><span class="s3">)*</span><span class="s5">1j</span><span class="s3">, </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">fft_mode</span><span class="s3">=</span><span class="s6">'twosided'</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">,</span>
                       <span class="s1">match</span><span class="s3">=</span><span class="s6">f&quot;One-sided spectra, i.e., fft_mode='</span><span class="s2">{</span><span class="s1">m</span><span class="s2">}</span><span class="s6">'.*&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">fft_mode </span><span class="s3">= </span><span class="s1">m</span>

    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">8</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">scale_to</span><span class="s3">=</span><span class="s6">'psd'</span><span class="s3">, </span><span class="s1">fft_mode</span><span class="s3">=</span><span class="s6">'onesided'</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Complex-valued `x` not allowed for self.*&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">8</span><span class="s3">)*</span><span class="s5">1j</span><span class="s3">)</span>
    <span class="s1">SFT</span><span class="s3">.</span><span class="s1">fft_mode </span><span class="s3">= </span><span class="s6">'onesided2X'</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">&quot;Complex-valued `x` not allowed for self.*&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">8</span><span class="s3">)*</span><span class="s5">1j</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_invalid_fft_mode_RuntimeError</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Ensure exception gets raised when property `fft_mode` is invalid. &quot;&quot;&quot;</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">8</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">SFT</span><span class="s3">.</span><span class="s1">_fft_mode </span><span class="s3">= </span><span class="s6">'invalid_typ'</span>

    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">RuntimeError</span><span class="s3">):</span>
        <span class="s1">_ </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">f</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">RuntimeError</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">_fft_func</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">8</span><span class="s3">))</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">RuntimeError</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">_ifft_func</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">8</span><span class="s3">))</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">'win_params, Nx'</span><span class="s3">, [((</span><span class="s6">'gaussian'</span><span class="s3">, </span><span class="s5">2.</span><span class="s3">), </span><span class="s5">9</span><span class="s3">),  </span><span class="s4"># in docstr</span>
                                            <span class="s3">(</span><span class="s6">'triang'</span><span class="s3">, </span><span class="s5">7</span><span class="s3">),</span>
                                            <span class="s3">((</span><span class="s6">'kaiser'</span><span class="s3">, </span><span class="s5">4.0</span><span class="s3">), </span><span class="s5">9</span><span class="s3">),</span>
                                            <span class="s3">((</span><span class="s6">'exponential'</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s5">1.</span><span class="s3">), </span><span class="s5">9</span><span class="s3">),</span>
                                            <span class="s3">(</span><span class="s5">4.0</span><span class="s3">, </span><span class="s5">9</span><span class="s3">)])</span>
<span class="s2">def </span><span class="s1">test_from_window</span><span class="s3">(</span><span class="s1">win_params</span><span class="s3">, </span><span class="s1">Nx</span><span class="s3">: </span><span class="s1">int</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Verify that `from_window()` handles parameters correctly. 
 
    The window parameterizations are documented in the `get_window` docstring. 
    &quot;&quot;&quot;</span>
    <span class="s1">w_sym</span><span class="s3">, </span><span class="s1">fs </span><span class="s3">= </span><span class="s1">get_window</span><span class="s3">(</span><span class="s1">win_params</span><span class="s3">, </span><span class="s1">Nx</span><span class="s3">, </span><span class="s1">fftbins</span><span class="s3">=</span><span class="s2">False</span><span class="s3">), </span><span class="s5">16.</span>
    <span class="s1">w_per </span><span class="s3">= </span><span class="s1">get_window</span><span class="s3">(</span><span class="s1">win_params</span><span class="s3">, </span><span class="s1">Nx</span><span class="s3">, </span><span class="s1">fftbins</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>
    <span class="s1">SFT0 </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">w_sym</span><span class="s3">, </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">3</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s1">fs</span><span class="s3">, </span><span class="s1">fft_mode</span><span class="s3">=</span><span class="s6">'twosided'</span><span class="s3">,</span>
                        <span class="s1">scale_to</span><span class="s3">=</span><span class="s6">'psd'</span><span class="s3">, </span><span class="s1">phase_shift</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">nperseg </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">w_sym</span><span class="s3">)</span>
    <span class="s1">noverlap </span><span class="s3">= </span><span class="s1">nperseg </span><span class="s3">- </span><span class="s1">SFT0</span><span class="s3">.</span><span class="s1">hop</span>
    <span class="s1">SFT1 </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">.</span><span class="s1">from_window</span><span class="s3">(</span><span class="s1">win_params</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">nperseg</span><span class="s3">, </span><span class="s1">noverlap</span><span class="s3">,</span>
                                    <span class="s1">symmetric_win</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">fft_mode</span><span class="s3">=</span><span class="s6">'twosided'</span><span class="s3">,</span>
                                    <span class="s1">scale_to</span><span class="s3">=</span><span class="s6">'psd'</span><span class="s3">, </span><span class="s1">phase_shift</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s4"># periodic window:</span>
    <span class="s1">SFT2 </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">.</span><span class="s1">from_window</span><span class="s3">(</span><span class="s1">win_params</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">nperseg</span><span class="s3">, </span><span class="s1">noverlap</span><span class="s3">,</span>
                                    <span class="s1">symmetric_win</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">fft_mode</span><span class="s3">=</span><span class="s6">'twosided'</span><span class="s3">,</span>
                                    <span class="s1">scale_to</span><span class="s3">=</span><span class="s6">'psd'</span><span class="s3">, </span><span class="s1">phase_shift</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s4"># Be informative when comparing instances:</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">SFT1</span><span class="s3">.</span><span class="s1">win</span><span class="s3">, </span><span class="s1">SFT0</span><span class="s3">.</span><span class="s1">win</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">SFT2</span><span class="s3">.</span><span class="s1">win</span><span class="s3">, </span><span class="s1">w_per </span><span class="s3">/ </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">w_per</span><span class="s3">**</span><span class="s5">2</span><span class="s3">) * </span><span class="s1">fs</span><span class="s3">))</span>
    <span class="s2">for </span><span class="s1">n_ </span><span class="s2">in </span><span class="s3">(</span><span class="s6">'hop'</span><span class="s3">, </span><span class="s6">'T'</span><span class="s3">, </span><span class="s6">'fft_mode'</span><span class="s3">, </span><span class="s6">'mfft'</span><span class="s3">, </span><span class="s6">'scaling'</span><span class="s3">, </span><span class="s6">'phase_shift'</span><span class="s3">):</span>
        <span class="s1">v0</span><span class="s3">, </span><span class="s1">v1</span><span class="s3">, </span><span class="s1">v2 </span><span class="s3">= (</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">SFT_</span><span class="s3">, </span><span class="s1">n_</span><span class="s3">) </span><span class="s2">for </span><span class="s1">SFT_ </span><span class="s2">in </span><span class="s3">(</span><span class="s1">SFT0</span><span class="s3">, </span><span class="s1">SFT1</span><span class="s3">, </span><span class="s1">SFT2</span><span class="s3">))</span>
        <span class="s2">assert </span><span class="s1">v1 </span><span class="s3">== </span><span class="s1">v0</span><span class="s3">, </span><span class="s6">f&quot;SFT1.</span><span class="s2">{</span><span class="s1">n_</span><span class="s2">}</span><span class="s6">=</span><span class="s2">{</span><span class="s1">v1</span><span class="s2">} </span><span class="s6">does not equal SFT0.</span><span class="s2">{</span><span class="s1">n_</span><span class="s2">}</span><span class="s6">=</span><span class="s2">{</span><span class="s1">v0</span><span class="s2">}</span><span class="s6">&quot;</span>
        <span class="s2">assert </span><span class="s1">v2 </span><span class="s3">== </span><span class="s1">v0</span><span class="s3">, </span><span class="s6">f&quot;SFT2.</span><span class="s2">{</span><span class="s1">n_</span><span class="s2">}</span><span class="s6">=</span><span class="s2">{</span><span class="s1">v2</span><span class="s2">} </span><span class="s6">does not equal SFT0.</span><span class="s2">{</span><span class="s1">n_</span><span class="s2">}</span><span class="s6">=</span><span class="s2">{</span><span class="s1">v0</span><span class="s2">}</span><span class="s6">&quot;</span>


<span class="s2">def </span><span class="s1">test_dual_win_roundtrip</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Verify the duality of `win` and `dual_win`. 
 
    Note that this test does not work for arbitrary windows, since dual windows 
    are not unique. It always works for invertible STFTs if the windows do not 
    overlap. 
    &quot;&quot;&quot;</span>
    <span class="s4"># Non-standard values for keyword arguments (except for `scale_to`):</span>
    <span class="s1">kw </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">fft_mode</span><span class="s3">=</span><span class="s6">'twosided'</span><span class="s3">, </span><span class="s1">mfft</span><span class="s3">=</span><span class="s5">8</span><span class="s3">, </span><span class="s1">scale_to</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
              <span class="s1">phase_shift</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">SFT0 </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">4</span><span class="s3">), **</span><span class="s1">kw</span><span class="s3">)</span>
    <span class="s1">SFT1 </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">.</span><span class="s1">from_dual</span><span class="s3">(</span><span class="s1">SFT0</span><span class="s3">.</span><span class="s1">dual_win</span><span class="s3">, **</span><span class="s1">kw</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">SFT1</span><span class="s3">.</span><span class="s1">dual_win</span><span class="s3">, </span><span class="s1">SFT0</span><span class="s3">.</span><span class="s1">win</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">'scale_to, fac_psd, fac_mag'</span><span class="s3">,</span>
                         <span class="s3">[(</span><span class="s2">None</span><span class="s3">, </span><span class="s5">0.25</span><span class="s3">, </span><span class="s5">0.125</span><span class="s3">),</span>
                          <span class="s3">(</span><span class="s6">'magnitude'</span><span class="s3">, </span><span class="s5">2.0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">),</span>
                          <span class="s3">(</span><span class="s6">'psd'</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">)])</span>
<span class="s2">def </span><span class="s1">test_scaling</span><span class="s3">(</span><span class="s1">scale_to</span><span class="s3">: </span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'magnitude'</span><span class="s3">, </span><span class="s6">'psd'</span><span class="s3">], </span><span class="s1">fac_psd</span><span class="s3">, </span><span class="s1">fac_mag</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Verify scaling calculations. 
 
    * Verify passing `scale_to`parameter  to ``__init__(). 
    * Roundtrip while changing scaling factor. 
    &quot;&quot;&quot;</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">4</span><span class="s3">) * </span><span class="s5">2</span><span class="s3">, </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">scale_to</span><span class="s3">=</span><span class="s1">scale_to</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">fac_psd </span><span class="s3">== </span><span class="s1">fac_psd</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">fac_magnitude </span><span class="s3">== </span><span class="s1">fac_mag</span>
    <span class="s4"># increase coverage by accessing properties twice:</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">fac_psd </span><span class="s3">== </span><span class="s1">fac_psd</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">fac_magnitude </span><span class="s3">== </span><span class="s1">fac_mag</span>

    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">fft</span><span class="s3">.</span><span class="s1">irfft</span><span class="s3">([</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">])  </span><span class="s4"># periodic signal</span>
    <span class="s1">Sx </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">Sx_mag</span><span class="s3">, </span><span class="s1">Sx_psd </span><span class="s3">= </span><span class="s1">Sx </span><span class="s3">* </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">fac_magnitude</span><span class="s3">, </span><span class="s1">Sx </span><span class="s3">* </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">fac_psd</span>

    <span class="s1">SFT</span><span class="s3">.</span><span class="s1">scale_to</span><span class="s3">(</span><span class="s6">'magnitude'</span><span class="s3">)</span>
    <span class="s1">x_mag </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sx_mag</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">))</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">x_mag</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>

    <span class="s1">SFT</span><span class="s3">.</span><span class="s1">scale_to</span><span class="s3">(</span><span class="s6">'psd'</span><span class="s3">)</span>
    <span class="s1">x_psd </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sx_psd</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">))</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">x_psd</span><span class="s3">, </span><span class="s1">x</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_scale_to</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Verify `scale_to()` method.&quot;&quot;&quot;</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">4</span><span class="s3">) * </span><span class="s5">2</span><span class="s3">, </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">scale_to</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>

    <span class="s1">SFT</span><span class="s3">.</span><span class="s1">scale_to</span><span class="s3">(</span><span class="s6">'magnitude'</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">scaling </span><span class="s3">== </span><span class="s6">'magnitude'</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">fac_psd </span><span class="s3">== </span><span class="s5">2.0</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">fac_magnitude </span><span class="s3">== </span><span class="s5">1</span>

    <span class="s1">SFT</span><span class="s3">.</span><span class="s1">scale_to</span><span class="s3">(</span><span class="s6">'psd'</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">scaling </span><span class="s3">== </span><span class="s6">'psd'</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">fac_psd </span><span class="s3">== </span><span class="s5">1</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">fac_magnitude </span><span class="s3">== </span><span class="s5">0.5</span>

    <span class="s1">SFT</span><span class="s3">.</span><span class="s1">scale_to</span><span class="s3">(</span><span class="s6">'psd'</span><span class="s3">)  </span><span class="s4"># needed for coverage</span>

    <span class="s2">for </span><span class="s1">scale</span><span class="s3">, </span><span class="s1">s_fac </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">((</span><span class="s6">'magnitude'</span><span class="s3">, </span><span class="s6">'psd'</span><span class="s3">), (</span><span class="s5">8</span><span class="s3">, </span><span class="s5">4</span><span class="s3">)):</span>
        <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">4</span><span class="s3">) * </span><span class="s5">2</span><span class="s3">, </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">scale_to</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">dual_win </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">dual_win</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">scale_to</span><span class="s3">(</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">Literal</span><span class="s3">[</span><span class="s6">'magnitude'</span><span class="s3">, </span><span class="s6">'psd'</span><span class="s3">], </span><span class="s1">scale</span><span class="s3">))</span>
        <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">dual_win</span><span class="s3">, </span><span class="s1">dual_win </span><span class="s3">* </span><span class="s1">s_fac</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_x_slices_padding</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Verify padding. 
 
    The reference arrays were taken from  the docstrings of `zero_ext`, 
    `const_ext`, `odd_ext()`, and `even_ext()` from the _array_tools module. 
    &quot;&quot;&quot;</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">5</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">], [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">16</span><span class="s3">]], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">float</span><span class="s3">)</span>
    <span class="s1">d </span><span class="s3">= {</span><span class="s6">'zeros'</span><span class="s3">: [[[</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">], [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">4</span><span class="s3">]],</span>
                   <span class="s3">[[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">], [</span><span class="s5">4</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">16</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">]]],</span>
         <span class="s6">'edge'</span><span class="s3">: [[[</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">], [</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">4</span><span class="s3">]],</span>
                  <span class="s3">[[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">5</span><span class="s3">], [</span><span class="s5">4</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">16</span><span class="s3">, </span><span class="s5">16</span><span class="s3">, </span><span class="s5">16</span><span class="s3">]]],</span>
         <span class="s6">'even'</span><span class="s3">: [[[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">], [</span><span class="s5">4</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">4</span><span class="s3">]],</span>
                  <span class="s3">[[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">3</span><span class="s3">], [</span><span class="s5">4</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">16</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">4</span><span class="s3">]]],</span>
         <span class="s6">'odd'</span><span class="s3">: [[[-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">], [-</span><span class="s5">4</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">4</span><span class="s3">]],</span>
                 <span class="s3">[[</span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">7</span><span class="s3">], [</span><span class="s5">4</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s5">16</span><span class="s3">, </span><span class="s5">23</span><span class="s3">, </span><span class="s5">28</span><span class="s3">]]]}</span>
    <span class="s2">for </span><span class="s1">p_</span><span class="s3">, </span><span class="s1">xx </span><span class="s2">in </span><span class="s1">d</span><span class="s3">.</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s1">gen </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">_x_slices</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s1">padding</span><span class="s3">=</span><span class="s1">cast</span><span class="s3">(</span><span class="s1">PAD_TYPE</span><span class="s3">, </span><span class="s1">p_</span><span class="s3">))</span>
        <span class="s1">yy </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">y_</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">() </span><span class="s2">for </span><span class="s1">y_ </span><span class="s2">in </span><span class="s1">gen</span><span class="s3">])  </span><span class="s4"># due to inplace copying</span>
        <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">yy</span><span class="s3">, </span><span class="s1">xx</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s6">f&quot;Failed '</span><span class="s2">{</span><span class="s1">p_</span><span class="s2">}</span><span class="s6">' padding.&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_invertible</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Verify `invertible` property. &quot;&quot;&quot;</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">8</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">invertible</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">8</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">9</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">assert not </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">invertible</span>


<span class="s2">def </span><span class="s1">test_border_values</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Ensure that minimum and maximum values of slices are correct.&quot;&quot;&quot;</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">8</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">p_min </span><span class="s3">== </span><span class="s5">0</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">k_min </span><span class="s3">== -</span><span class="s5">4</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">lower_border_end </span><span class="s3">== (</span><span class="s5">4</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">lower_border_end </span><span class="s3">== (</span><span class="s5">4</span><span class="s3">, </span><span class="s5">1</span><span class="s3">)  </span><span class="s4"># needed to test caching</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">p_max</span><span class="s3">(</span><span class="s5">10</span><span class="s3">) == </span><span class="s5">4</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">k_max</span><span class="s3">(</span><span class="s5">10</span><span class="s3">) == </span><span class="s5">16</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">upper_border_begin</span><span class="s3">(</span><span class="s5">10</span><span class="s3">) == (</span><span class="s5">4</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_border_values_exotic</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Ensure that the border calculations are correct for windows with 
    zeros. &quot;&quot;&quot;</span>
    <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1.</span><span class="s3">])</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">lower_border_end </span><span class="s3">== (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">flip</span><span class="s3">(</span><span class="s1">w</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">20</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">upper_border_begin</span><span class="s3">(</span><span class="s5">4</span><span class="s3">) == (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">)</span>

    <span class="s1">SFT</span><span class="s3">.</span><span class="s1">_hop </span><span class="s3">= -</span><span class="s5">1  </span><span class="s4"># provoke unreachable line</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">RuntimeError</span><span class="s3">):</span>
        <span class="s1">_ </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">k_max</span><span class="s3">(</span><span class="s5">4</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">RuntimeError</span><span class="s3">):</span>
        <span class="s1">_ </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">k_min</span>


<span class="s2">def </span><span class="s1">test_t</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Verify that the times of the slices are correct. &quot;&quot;&quot;</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">8</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">T </span><span class="s3">== </span><span class="s5">1</span><span class="s3">/</span><span class="s5">2</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">fs </span><span class="s3">== </span><span class="s5">2.</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">delta_t </span><span class="s3">== </span><span class="s5">4 </span><span class="s3">* </span><span class="s5">1</span><span class="s3">/</span><span class="s5">2</span>
    <span class="s1">t_stft </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">p_max</span><span class="s3">(</span><span class="s5">10</span><span class="s3">)) * </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">delta_t</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">t</span><span class="s3">(</span><span class="s5">10</span><span class="s3">), </span><span class="s1">t_stft</span><span class="s3">)</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">t</span><span class="s3">(</span><span class="s5">10</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">3</span><span class="s3">), </span><span class="s1">t_stft</span><span class="s3">[</span><span class="s5">1</span><span class="s3">:</span><span class="s5">3</span><span class="s3">])</span>
    <span class="s1">SFT</span><span class="s3">.</span><span class="s1">T </span><span class="s3">= </span><span class="s5">1</span><span class="s3">/</span><span class="s5">4</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">T </span><span class="s3">== </span><span class="s5">1</span><span class="s3">/</span><span class="s5">4</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">fs </span><span class="s3">== </span><span class="s5">4</span>
    <span class="s1">SFT</span><span class="s3">.</span><span class="s1">fs </span><span class="s3">= </span><span class="s5">1</span><span class="s3">/</span><span class="s5">8</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">fs </span><span class="s3">== </span><span class="s5">1</span><span class="s3">/</span><span class="s5">8</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">T </span><span class="s3">== </span><span class="s5">8</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">'fft_mode, f'</span><span class="s3">,</span>
                         <span class="s3">[(</span><span class="s6">'onesided'</span><span class="s3">, [</span><span class="s5">0.</span><span class="s3">, </span><span class="s5">1.</span><span class="s3">, </span><span class="s5">2.</span><span class="s3">]),</span>
                          <span class="s3">(</span><span class="s6">'onesided2X'</span><span class="s3">, [</span><span class="s5">0.</span><span class="s3">, </span><span class="s5">1.</span><span class="s3">, </span><span class="s5">2.</span><span class="s3">]),</span>
                          <span class="s3">(</span><span class="s6">'twosided'</span><span class="s3">, [</span><span class="s5">0.</span><span class="s3">, </span><span class="s5">1.</span><span class="s3">, </span><span class="s5">2.</span><span class="s3">, -</span><span class="s5">2.</span><span class="s3">, -</span><span class="s5">1.</span><span class="s3">]),</span>
                          <span class="s3">(</span><span class="s6">'centered'</span><span class="s3">, [-</span><span class="s5">2.</span><span class="s3">, -</span><span class="s5">1.</span><span class="s3">, </span><span class="s5">0.</span><span class="s3">, </span><span class="s5">1.</span><span class="s3">, </span><span class="s5">2.</span><span class="s3">])])</span>
<span class="s2">def </span><span class="s1">test_f</span><span class="s3">(</span><span class="s1">fft_mode</span><span class="s3">: </span><span class="s1">FFT_MODE_TYPE</span><span class="s3">, </span><span class="s1">f</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Verify the frequency values property `f`.&quot;&quot;&quot;</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">5</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">5</span><span class="s3">, </span><span class="s1">fft_mode</span><span class="s3">=</span><span class="s1">fft_mode</span><span class="s3">,</span>
                       <span class="s1">scale_to</span><span class="s3">=</span><span class="s6">'psd'</span><span class="s3">)</span>
    <span class="s1">assert_equal</span><span class="s3">(</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">f</span><span class="s3">, </span><span class="s1">f</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_extent</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Ensure that the `extent()` method is correct. &quot;&quot;&quot;</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">32</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">32</span><span class="s3">, </span><span class="s1">fft_mode</span><span class="s3">=</span><span class="s6">'onesided'</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">extent</span><span class="s3">(</span><span class="s5">100</span><span class="s3">, </span><span class="s6">'tf'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">) == (-</span><span class="s5">0.375</span><span class="s3">, </span><span class="s5">3.625</span><span class="s3">, </span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">17.0</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">extent</span><span class="s3">(</span><span class="s5">100</span><span class="s3">, </span><span class="s6">'ft'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">) == (</span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">17.0</span><span class="s3">, -</span><span class="s5">0.375</span><span class="s3">, </span><span class="s5">3.625</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">extent</span><span class="s3">(</span><span class="s5">100</span><span class="s3">, </span><span class="s6">'tf'</span><span class="s3">, </span><span class="s2">True</span><span class="s3">) == (-</span><span class="s5">0.4375</span><span class="s3">, </span><span class="s5">3.5625</span><span class="s3">, -</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">16.5</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">extent</span><span class="s3">(</span><span class="s5">100</span><span class="s3">, </span><span class="s6">'ft'</span><span class="s3">, </span><span class="s2">True</span><span class="s3">) == (-</span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">16.5</span><span class="s3">, -</span><span class="s5">0.4375</span><span class="s3">, </span><span class="s5">3.5625</span><span class="s3">)</span>

    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">32</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">32</span><span class="s3">, </span><span class="s1">fft_mode</span><span class="s3">=</span><span class="s6">'centered'</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">extent</span><span class="s3">(</span><span class="s5">100</span><span class="s3">, </span><span class="s6">'tf'</span><span class="s3">, </span><span class="s2">False</span><span class="s3">) == (-</span><span class="s5">0.375</span><span class="s3">, </span><span class="s5">3.625</span><span class="s3">, -</span><span class="s5">16.0</span><span class="s3">, </span><span class="s5">15.0</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_spectrogram</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Verify spectrogram and cross-spectrogram methods. &quot;&quot;&quot;</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">8</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">10</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">10</span><span class="s3">)</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">Y </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">spectrogram</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">X</span><span class="s3">.</span><span class="s1">real</span><span class="s3">**</span><span class="s5">2</span><span class="s3">+</span><span class="s1">X</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">**</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">spectrogram</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">), </span><span class="s1">X </span><span class="s3">* </span><span class="s1">Y</span><span class="s3">.</span><span class="s1">conj</span><span class="s3">())</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">'n'</span><span class="s3">, [</span><span class="s5">8</span><span class="s3">, </span><span class="s5">9</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_fft_func_roundtrip</span><span class="s3">(</span><span class="s1">n</span><span class="s3">: </span><span class="s1">int</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Test roundtrip `ifft_func(fft_func(x)) == x` for all permutations of 
    relevant parameters. &quot;&quot;&quot;</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">seed</span><span class="s3">(</span><span class="s5">2394795</span><span class="s3">)</span>
    <span class="s1">x0 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">rand</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">w</span><span class="s3">, </span><span class="s1">h_n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n</span><span class="s3">), </span><span class="s5">4</span>

    <span class="s1">pp </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span>
        <span class="s1">fft_mode</span><span class="s3">=</span><span class="s1">get_args</span><span class="s3">(</span><span class="s1">FFT_MODE_TYPE</span><span class="s3">),</span>
        <span class="s1">mfft</span><span class="s3">=[</span><span class="s2">None</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n</span><span class="s3">+</span><span class="s5">2</span><span class="s3">],</span>
        <span class="s1">scaling</span><span class="s3">=[</span><span class="s2">None</span><span class="s3">, </span><span class="s6">'magnitude'</span><span class="s3">, </span><span class="s6">'psd'</span><span class="s3">],</span>
        <span class="s1">phase_shift</span><span class="s3">=[</span><span class="s2">None</span><span class="s3">, -</span><span class="s1">n</span><span class="s3">+</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">n </span><span class="s3">// </span><span class="s5">2</span><span class="s3">, </span><span class="s1">n</span><span class="s3">-</span><span class="s5">1</span><span class="s3">])</span>
    <span class="s2">for </span><span class="s1">f_typ</span><span class="s3">, </span><span class="s1">mfft</span><span class="s3">, </span><span class="s1">scaling</span><span class="s3">, </span><span class="s1">phase_shift </span><span class="s2">in </span><span class="s1">product</span><span class="s3">(*</span><span class="s1">pp</span><span class="s3">.</span><span class="s1">values</span><span class="s3">()):</span>
        <span class="s2">if </span><span class="s1">f_typ </span><span class="s3">== </span><span class="s6">'onesided2X' </span><span class="s2">and </span><span class="s1">scaling </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">continue  </span><span class="s4"># this combination is forbidden</span>
        <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">h_n</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s1">n</span><span class="s3">, </span><span class="s1">fft_mode</span><span class="s3">=</span><span class="s1">f_typ</span><span class="s3">, </span><span class="s1">mfft</span><span class="s3">=</span><span class="s1">mfft</span><span class="s3">,</span>
                           <span class="s1">scale_to</span><span class="s3">=</span><span class="s1">scaling</span><span class="s3">, </span><span class="s1">phase_shift</span><span class="s3">=</span><span class="s1">phase_shift</span><span class="s3">)</span>
        <span class="s1">X0 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">_fft_func</span><span class="s3">(</span><span class="s1">x0</span><span class="s3">)</span>
        <span class="s1">x1 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">_ifft_func</span><span class="s3">(</span><span class="s1">X0</span><span class="s3">)</span>
        <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">x0</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s6">&quot;_fft_func() roundtrip failed for &quot; </span><span class="s3">+</span>
                        <span class="s6">f&quot;</span><span class="s2">{</span><span class="s1">f_typ</span><span class="s3">=</span><span class="s2">}</span><span class="s6">, </span><span class="s2">{</span><span class="s1">mfft</span><span class="s3">=</span><span class="s2">}</span><span class="s6">, </span><span class="s2">{</span><span class="s1">scaling</span><span class="s3">=</span><span class="s2">}</span><span class="s6">, </span><span class="s2">{</span><span class="s1">phase_shift</span><span class="s3">=</span><span class="s2">}</span><span class="s6">&quot;</span><span class="s3">)</span>

    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">h_n</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">SFT</span><span class="s3">.</span><span class="s1">_fft_mode </span><span class="s3">= </span><span class="s6">'invalid_fft'  </span><span class="s4"># type: ignore</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">RuntimeError</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">_fft_func</span><span class="s3">(</span><span class="s1">x0</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">RuntimeError</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">_ifft_func</span><span class="s3">(</span><span class="s1">x0</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">'i'</span><span class="s3">, </span><span class="s1">range</span><span class="s3">(</span><span class="s5">19</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">test_impulse_roundtrip</span><span class="s3">(</span><span class="s1">i</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Roundtrip for an impulse being at different positions `i`.&quot;&quot;&quot;</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s5">19</span>
    <span class="s1">w</span><span class="s3">, </span><span class="s1">h_n </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">8</span><span class="s3">), </span><span class="s5">3</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s5">1</span>

    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">hop</span><span class="s3">=</span><span class="s1">h_n</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">scale_to</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">phase_shift</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>
    <span class="s1">Sx </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s4"># test slicing the input signal into two parts:</span>
    <span class="s1">n_q </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">nearest_k_p</span><span class="s3">(</span><span class="s1">n </span><span class="s3">// </span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">Sx0 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[:</span><span class="s1">n_q</span><span class="s3">], </span><span class="s1">padding</span><span class="s3">=</span><span class="s6">'zeros'</span><span class="s3">)</span>
    <span class="s1">Sx1 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">n_q</span><span class="s3">:], </span><span class="s1">padding</span><span class="s3">=</span><span class="s6">'zeros'</span><span class="s3">)</span>
    <span class="s1">q0_ub </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">upper_border_begin</span><span class="s3">(</span><span class="s1">n_q</span><span class="s3">)[</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">p_min</span>
    <span class="s1">q1_le </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">lower_border_end</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] - </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">p_min</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">Sx0</span><span class="s3">[:, :</span><span class="s1">q0_ub</span><span class="s3">], </span><span class="s1">Sx</span><span class="s3">[:, :</span><span class="s1">q0_ub</span><span class="s3">], </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s6">f&quot;</span><span class="s2">{</span><span class="s1">i</span><span class="s3">=</span><span class="s2">}</span><span class="s6">&quot;</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">Sx1</span><span class="s3">[:, </span><span class="s1">q1_le</span><span class="s3">:], </span><span class="s1">Sx</span><span class="s3">[:, </span><span class="s1">q1_le</span><span class="s3">-</span><span class="s1">Sx1</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]:],</span>
                    <span class="s1">err_msg</span><span class="s3">=</span><span class="s6">f&quot;</span><span class="s2">{</span><span class="s1">i</span><span class="s3">=</span><span class="s2">}</span><span class="s6">&quot;</span><span class="s3">)</span>

    <span class="s1">Sx01 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">hstack</span><span class="s3">((</span><span class="s1">Sx0</span><span class="s3">[:, :</span><span class="s1">q0_ub</span><span class="s3">],</span>
                      <span class="s1">Sx0</span><span class="s3">[:, </span><span class="s1">q0_ub</span><span class="s3">:] + </span><span class="s1">Sx1</span><span class="s3">[:, :</span><span class="s1">q1_le</span><span class="s3">],</span>
                      <span class="s1">Sx1</span><span class="s3">[:, </span><span class="s1">q1_le</span><span class="s3">:]))</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">Sx</span><span class="s3">, </span><span class="s1">Sx01</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s5">1e-8</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s6">f&quot;</span><span class="s2">{</span><span class="s1">i</span><span class="s3">=</span><span class="s2">}</span><span class="s6">&quot;</span><span class="s3">)</span>

    <span class="s1">y </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sx</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s5">1e-8</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s6">f&quot;</span><span class="s2">{</span><span class="s1">i</span><span class="s3">=</span><span class="s2">}</span><span class="s6">&quot;</span><span class="s3">)</span>
    <span class="s1">y0 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sx</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">n</span><span class="s3">//</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[:</span><span class="s1">n</span><span class="s3">//</span><span class="s5">2</span><span class="s3">], </span><span class="s1">y0</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s5">1e-8</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s6">f&quot;</span><span class="s2">{</span><span class="s1">i</span><span class="s3">=</span><span class="s2">}</span><span class="s6">&quot;</span><span class="s3">)</span>
    <span class="s1">y1 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sx</span><span class="s3">, </span><span class="s1">n </span><span class="s3">// </span><span class="s5">2</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[</span><span class="s1">n </span><span class="s3">// </span><span class="s5">2</span><span class="s3">:], </span><span class="s1">y1</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s5">1e-8</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s6">f&quot;</span><span class="s2">{</span><span class="s1">i</span><span class="s3">=</span><span class="s2">}</span><span class="s6">&quot;</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">'hop'</span><span class="s3">, [</span><span class="s5">1</span><span class="s3">, </span><span class="s5">7</span><span class="s3">, </span><span class="s5">8</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_asymmetric_window_roundtrip</span><span class="s3">(</span><span class="s1">hop</span><span class="s3">: </span><span class="s1">int</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;An asymmetric window could uncover indexing problems. &quot;&quot;&quot;</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">seed</span><span class="s3">(</span><span class="s5">23371</span><span class="s3">)</span>

    <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">16</span><span class="s3">) / </span><span class="s5">8  </span><span class="s4"># must be of type float</span>
    <span class="s1">w</span><span class="s3">[</span><span class="s1">len</span><span class="s3">(</span><span class="s1">w</span><span class="s3">)//</span><span class="s5">2</span><span class="s3">:] = </span><span class="s5">1</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">hop</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>

    <span class="s1">x </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randn</span><span class="s3">(</span><span class="s5">64</span><span class="s3">)</span>
    <span class="s1">Sx </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">x1 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sx</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">))</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s6">&quot;Roundtrip for asymmetric window with &quot; </span><span class="s3">+</span>
                                    <span class="s6">f&quot; </span><span class="s2">{</span><span class="s1">hop</span><span class="s3">=</span><span class="s2">} </span><span class="s6">failed!&quot;</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">'m_num'</span><span class="s3">, [</span><span class="s5">6</span><span class="s3">, </span><span class="s5">7</span><span class="s3">])</span>
<span class="s2">def </span><span class="s1">test_minimal_length_signal</span><span class="s3">(</span><span class="s1">m_num</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Verify that the shortest allowed signal works. &quot;&quot;&quot;</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">m_num</span><span class="s3">), </span><span class="s1">m_num</span><span class="s3">//</span><span class="s5">2</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">(</span><span class="s1">m_num</span><span class="s3">/</span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">Sx </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">x1 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sx</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s6">f&quot;Roundtrip minimal length signal (</span><span class="s2">{</span><span class="s1">n</span><span class="s3">=</span><span class="s2">}</span><span class="s6">)&quot; </span><span class="s3">+</span>
                                   <span class="s6">f&quot; for </span><span class="s2">{</span><span class="s1">m_num</span><span class="s2">} </span><span class="s6">sample window failed!&quot;</span><span class="s3">)</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">rf&quot;len\(x\)=</span><span class="s2">{</span><span class="s1">n</span><span class="s3">-</span><span class="s5">1</span><span class="s2">} </span><span class="s6">must be &gt;= ceil.*&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">[:-</span><span class="s5">1</span><span class="s3">])</span>
    <span class="s2">with </span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">raises</span><span class="s3">(</span><span class="s1">ValueError</span><span class="s3">, </span><span class="s1">match</span><span class="s3">=</span><span class="s6">rf&quot;S.shape\[t_axis\]=</span><span class="s2">{</span><span class="s1">Sx</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]-</span><span class="s5">1</span><span class="s2">}</span><span class="s6">&quot;</span>
                       <span class="s6">f&quot; needs to have at least </span><span class="s2">{</span><span class="s1">Sx</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]</span><span class="s2">} </span><span class="s6">slices&quot;</span><span class="s3">):</span>
        <span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sx</span><span class="s3">[:, :-</span><span class="s5">1</span><span class="s3">], </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">n</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_tutorial_stft_sliding_win</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Verify example in &quot;Sliding Windows&quot; subsection from the &quot;User Guide&quot;. 
 
    In :ref:`tutorial_stft_sliding_win` (file ``signal.rst``) of the 
    :ref:`user_guide` the behavior the border behavior of 
    ``ShortTimeFFT(np.ones(6), 2, fs=1)`` with a 50 sample signal is discussed. 
    This test verifies the presented indexes. 
    &quot;&quot;&quot;</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">6</span><span class="s3">), </span><span class="s5">2</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>

    <span class="s4"># Lower border:</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">m_num_mid </span><span class="s3">== </span><span class="s5">3</span><span class="s3">, </span><span class="s6">f&quot;Slice middle is not 3 but </span><span class="s2">{</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">m_num_mid</span><span class="s3">=</span><span class="s2">}</span><span class="s6">&quot;</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">p_min </span><span class="s3">== -</span><span class="s5">1</span><span class="s3">, </span><span class="s6">f&quot;Lowest slice </span><span class="s2">{</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">p_min</span><span class="s3">=</span><span class="s2">} </span><span class="s6">is not -1&quot;</span>
    <span class="s2">assert </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">k_min </span><span class="s3">== -</span><span class="s5">5</span><span class="s3">, </span><span class="s6">f&quot;Lowest slice sample </span><span class="s2">{</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">p_min</span><span class="s3">=</span><span class="s2">} </span><span class="s6">is not -5&quot;</span>
    <span class="s1">k_lb</span><span class="s3">, </span><span class="s1">p_lb </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">lower_border_end</span>
    <span class="s2">assert </span><span class="s1">p_lb </span><span class="s3">== </span><span class="s5">2</span><span class="s3">, </span><span class="s6">f&quot;First unaffected slice </span><span class="s2">{</span><span class="s1">p_lb</span><span class="s3">=</span><span class="s2">} </span><span class="s6">is not 2&quot;</span>
    <span class="s2">assert </span><span class="s1">k_lb </span><span class="s3">== </span><span class="s5">5</span><span class="s3">, </span><span class="s6">f&quot;First unaffected sample </span><span class="s2">{</span><span class="s1">k_lb</span><span class="s3">=</span><span class="s2">} </span><span class="s6">is not 5&quot;</span>

    <span class="s1">n </span><span class="s3">= </span><span class="s5">50  </span><span class="s4"># upper signal border</span>
    <span class="s2">assert </span><span class="s3">(</span><span class="s1">p_max </span><span class="s3">:= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">p_max</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)) == </span><span class="s5">27</span><span class="s3">, </span><span class="s6">f&quot;Last slice </span><span class="s2">{</span><span class="s1">p_max</span><span class="s3">=</span><span class="s2">} </span><span class="s6">must be 27&quot;</span>
    <span class="s2">assert </span><span class="s3">(</span><span class="s1">k_max </span><span class="s3">:= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">k_max</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)) == </span><span class="s5">55</span><span class="s3">, </span><span class="s6">f&quot;Last sample </span><span class="s2">{</span><span class="s1">k_max</span><span class="s3">=</span><span class="s2">} </span><span class="s6">must be 55&quot;</span>
    <span class="s1">k_ub</span><span class="s3">, </span><span class="s1">p_ub </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">upper_border_begin</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">p_ub </span><span class="s3">== </span><span class="s5">24</span><span class="s3">, </span><span class="s6">f&quot;First upper border slice </span><span class="s2">{</span><span class="s1">p_ub</span><span class="s3">=</span><span class="s2">} </span><span class="s6">must be 24&quot;</span>
    <span class="s2">assert </span><span class="s1">k_ub </span><span class="s3">== </span><span class="s5">45</span><span class="s3">, </span><span class="s6">f&quot;First upper border slice </span><span class="s2">{</span><span class="s1">k_ub</span><span class="s3">=</span><span class="s2">} </span><span class="s6">must be 45&quot;</span>


<span class="s2">def </span><span class="s1">test_tutorial_stft_legacy_stft</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Verify STFT example in &quot;Comparison with Legacy Implementation&quot; from the 
    &quot;User Guide&quot;. 
 
    In :ref:`tutorial_stft_legacy_stft` (file ``signal.rst``) of the 
    :ref:`user_guide` the legacy and the new implementation are compared. 
    &quot;&quot;&quot;</span>
    <span class="s1">fs</span><span class="s3">, </span><span class="s1">N </span><span class="s3">= </span><span class="s5">200</span><span class="s3">, </span><span class="s5">1001  </span><span class="s4"># # 200 Hz sampling rate for 5 s signal</span>
    <span class="s1">t_z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">N</span><span class="s3">) / </span><span class="s1">fs  </span><span class="s4"># time indexes for signal</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">2j</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s5">70 </span><span class="s3">* (</span><span class="s1">t_z </span><span class="s3">- </span><span class="s5">0.2 </span><span class="s3">* </span><span class="s1">t_z </span><span class="s3">** </span><span class="s5">2</span><span class="s3">))  </span><span class="s4"># complex-valued chirp</span>

    <span class="s1">nperseg</span><span class="s3">, </span><span class="s1">noverlap </span><span class="s3">= </span><span class="s5">50</span><span class="s3">, </span><span class="s5">40</span>
    <span class="s1">win </span><span class="s3">= (</span><span class="s6">'gaussian'</span><span class="s3">, </span><span class="s5">1e-2 </span><span class="s3">* </span><span class="s1">fs</span><span class="s3">)  </span><span class="s4"># Gaussian with 0.01 s standard deviation</span>

    <span class="s4"># Legacy STFT:</span>
    <span class="s1">f0_u</span><span class="s3">, </span><span class="s1">t0</span><span class="s3">, </span><span class="s1">Sz0_u </span><span class="s3">= </span><span class="s1">stft</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">win</span><span class="s3">, </span><span class="s1">nperseg</span><span class="s3">, </span><span class="s1">noverlap</span><span class="s3">,</span>
                           <span class="s1">return_onesided</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">scaling</span><span class="s3">=</span><span class="s6">'spectrum'</span><span class="s3">)</span>
    <span class="s1">Sz0 </span><span class="s3">= </span><span class="s1">fftshift</span><span class="s3">(</span><span class="s1">Sz0_u</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s4"># New STFT:</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">.</span><span class="s1">from_window</span><span class="s3">(</span><span class="s1">win</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">nperseg</span><span class="s3">, </span><span class="s1">noverlap</span><span class="s3">,</span>
                                   <span class="s1">fft_mode</span><span class="s3">=</span><span class="s6">'centered'</span><span class="s3">,</span>
                                   <span class="s1">scale_to</span><span class="s3">=</span><span class="s6">'magnitude'</span><span class="s3">, </span><span class="s1">phase_shift</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>
    <span class="s1">Sz1 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>

    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">Sz0</span><span class="s3">, </span><span class="s1">Sz1</span><span class="s3">[:, </span><span class="s5">2</span><span class="s3">:-</span><span class="s5">1</span><span class="s3">])</span>

    <span class="s1">assert_allclose</span><span class="s3">((</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">Sz1</span><span class="s3">[:, </span><span class="s5">1</span><span class="s3">]).</span><span class="s1">min</span><span class="s3">(), </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">Sz1</span><span class="s3">[:, </span><span class="s5">1</span><span class="s3">]).</span><span class="s1">max</span><span class="s3">()),</span>
                    <span class="s3">(</span><span class="s5">6.925060911593139e-07</span><span class="s3">, </span><span class="s5">8.00271269218721e-07</span><span class="s3">))</span>

    <span class="s1">t0_r</span><span class="s3">, </span><span class="s1">z0_r </span><span class="s3">= </span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sz0_u</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">win</span><span class="s3">, </span><span class="s1">nperseg</span><span class="s3">, </span><span class="s1">noverlap</span><span class="s3">, </span><span class="s1">input_onesided</span><span class="s3">=</span><span class="s2">False</span><span class="s3">,</span>
                       <span class="s1">scaling</span><span class="s3">=</span><span class="s6">'spectrum'</span><span class="s3">)</span>
    <span class="s1">z1_r </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sz1</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">N</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">z0_r</span><span class="s3">) == </span><span class="s1">N </span><span class="s3">+ </span><span class="s5">9</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">z0_r</span><span class="s3">[:</span><span class="s1">N</span><span class="s3">], </span><span class="s1">z</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">z1_r</span><span class="s3">, </span><span class="s1">z</span><span class="s3">)</span>

    <span class="s4">#  Spectrogram is just the absolute square of th STFT:</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">spectrogram</span><span class="s3">(</span><span class="s1">z</span><span class="s3">), </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">Sz1</span><span class="s3">) ** </span><span class="s5">2</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_tutorial_stft_legacy_spectrogram</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Verify spectrogram example in &quot;Comparison with Legacy Implementation&quot; 
    from the &quot;User Guide&quot;. 
 
    In :ref:`tutorial_stft_legacy_stft` (file ``signal.rst``) of the 
    :ref:`user_guide` the legacy and the new implementation are compared. 
    &quot;&quot;&quot;</span>
    <span class="s1">fs</span><span class="s3">, </span><span class="s1">N </span><span class="s3">= </span><span class="s5">200</span><span class="s3">, </span><span class="s5">1001  </span><span class="s4"># 200 Hz sampling rate for almost 5 s signal</span>
    <span class="s1">t_z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">N</span><span class="s3">) / </span><span class="s1">fs  </span><span class="s4"># time indexes for signal</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">2j</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">*</span><span class="s5">70 </span><span class="s3">* (</span><span class="s1">t_z </span><span class="s3">- </span><span class="s5">0.2</span><span class="s3">*</span><span class="s1">t_z</span><span class="s3">**</span><span class="s5">2</span><span class="s3">))  </span><span class="s4"># complex-valued sweep</span>

    <span class="s1">nperseg</span><span class="s3">, </span><span class="s1">noverlap </span><span class="s3">= </span><span class="s5">50</span><span class="s3">, </span><span class="s5">40</span>
    <span class="s1">win </span><span class="s3">= (</span><span class="s6">'gaussian'</span><span class="s3">, </span><span class="s5">1e-2 </span><span class="s3">* </span><span class="s1">fs</span><span class="s3">)  </span><span class="s4"># Gaussian with 0.01 s standard dev.</span>

    <span class="s4"># Legacy spectrogram:</span>
    <span class="s1">f2_u</span><span class="s3">, </span><span class="s1">t2</span><span class="s3">, </span><span class="s1">Sz2_u </span><span class="s3">= </span><span class="s1">spectrogram</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">win</span><span class="s3">, </span><span class="s1">nperseg</span><span class="s3">, </span><span class="s1">noverlap</span><span class="s3">, </span><span class="s1">detrend</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                                  <span class="s1">return_onesided</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">scaling</span><span class="s3">=</span><span class="s6">'spectrum'</span><span class="s3">,</span>
                                  <span class="s1">mode</span><span class="s3">=</span><span class="s6">'complex'</span><span class="s3">)</span>

    <span class="s1">f2</span><span class="s3">, </span><span class="s1">Sz2 </span><span class="s3">= </span><span class="s1">fftshift</span><span class="s3">(</span><span class="s1">f2_u</span><span class="s3">), </span><span class="s1">fftshift</span><span class="s3">(</span><span class="s1">Sz2_u</span><span class="s3">, </span><span class="s1">axes</span><span class="s3">=</span><span class="s5">0</span><span class="s3">)</span>

    <span class="s4"># New STFT:</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">.</span><span class="s1">from_window</span><span class="s3">(</span><span class="s1">win</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">nperseg</span><span class="s3">, </span><span class="s1">noverlap</span><span class="s3">,</span>
                                   <span class="s1">fft_mode</span><span class="s3">=</span><span class="s6">'centered'</span><span class="s3">, </span><span class="s1">scale_to</span><span class="s3">=</span><span class="s6">'magnitude'</span><span class="s3">,</span>
                                   <span class="s1">phase_shift</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>
    <span class="s1">Sz3 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">p0</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">p1</span><span class="s3">=(</span><span class="s1">N</span><span class="s3">-</span><span class="s1">noverlap</span><span class="s3">) // </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">hop</span><span class="s3">, </span><span class="s1">k_offset</span><span class="s3">=</span><span class="s1">nperseg </span><span class="s3">// </span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">t3 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">t</span><span class="s3">(</span><span class="s1">N</span><span class="s3">, </span><span class="s1">p0</span><span class="s3">=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">p1</span><span class="s3">=(</span><span class="s1">N</span><span class="s3">-</span><span class="s1">noverlap</span><span class="s3">) // </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">hop</span><span class="s3">, </span><span class="s1">k_offset</span><span class="s3">=</span><span class="s1">nperseg </span><span class="s3">// </span><span class="s5">2</span><span class="s3">)</span>

    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">t2</span><span class="s3">, </span><span class="s1">t3</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">f2</span><span class="s3">, </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">f</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">Sz2</span><span class="s3">, </span><span class="s1">Sz3</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_permute_axes</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Verify correctness of four-dimensional signal by permuting its 
    shape. &quot;&quot;&quot;</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s5">25</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">ones</span><span class="s3">(</span><span class="s5">8</span><span class="s3">)/</span><span class="s5">8</span><span class="s3">, </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">3</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">x0 </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">Sx0 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">x0</span><span class="s3">)</span>
    <span class="s1">Sx0 </span><span class="s3">= </span><span class="s1">Sx0</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">((</span><span class="s1">Sx0</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">Sx0</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[-</span><span class="s5">1</span><span class="s3">]))</span>
    <span class="s1">SxT </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">Sx0</span><span class="s3">, (</span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">), (-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s3">))</span>

    <span class="s1">atol </span><span class="s3">= </span><span class="s5">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">win</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">resolution</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s5">4</span><span class="s3">):</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">x0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">roll</span><span class="s3">((</span><span class="s1">n</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">), </span><span class="s1">i</span><span class="s3">))</span>
        <span class="s1">Sy </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">i</span><span class="s3">)</span>
        <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">Sy</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">Sx0</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">i</span><span class="s3">))</span>

        <span class="s1">yb0 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sy</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">n</span><span class="s3">, </span><span class="s1">f_axis</span><span class="s3">=</span><span class="s1">i</span><span class="s3">)</span>
        <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">yb0</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s1">atol</span><span class="s3">)</span>
        <span class="s4"># explicit t-axis parameter (for coverage):</span>
        <span class="s1">yb1 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sy</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">n</span><span class="s3">, </span><span class="s1">f_axis</span><span class="s3">=</span><span class="s1">i</span><span class="s3">, </span><span class="s1">t_axis</span><span class="s3">=</span><span class="s1">Sy</span><span class="s3">.</span><span class="s1">ndim</span><span class="s3">-</span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">yb1</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s1">atol</span><span class="s3">)</span>

        <span class="s1">SyT </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">Sy</span><span class="s3">, (</span><span class="s1">i</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">), (-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">i</span><span class="s3">))</span>
        <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">SyT</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">moveaxis</span><span class="s3">(</span><span class="s1">SxT</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">i</span><span class="s3">))</span>

        <span class="s1">ybT </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">SyT</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">n</span><span class="s3">, </span><span class="s1">t_axis</span><span class="s3">=</span><span class="s1">i</span><span class="s3">, </span><span class="s1">f_axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">)</span>
        <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">ybT</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s1">atol</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">&quot;fft_mode&quot;</span><span class="s3">,</span>
                         <span class="s3">(</span><span class="s6">'twosided'</span><span class="s3">, </span><span class="s6">'centered'</span><span class="s3">, </span><span class="s6">'onesided'</span><span class="s3">, </span><span class="s6">'onesided2X'</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">test_roundtrip_multidimensional</span><span class="s3">(</span><span class="s1">fft_mode</span><span class="s3">: </span><span class="s1">FFT_MODE_TYPE</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Test roundtrip of a multidimensional input signal versus its components. 
 
    This test can uncover potential problems with `fftshift()`. 
    &quot;&quot;&quot;</span>
    <span class="s1">n </span><span class="s3">= </span><span class="s5">9</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">4</span><span class="s3">*</span><span class="s1">n</span><span class="s3">*</span><span class="s5">2</span><span class="s3">).</span><span class="s1">reshape</span><span class="s3">(</span><span class="s5">4</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s5">2</span><span class="s3">)</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">get_window</span><span class="s3">(</span><span class="s6">'hann'</span><span class="s3">, </span><span class="s5">4</span><span class="s3">), </span><span class="s1">hop</span><span class="s3">=</span><span class="s5">2</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">,</span>
                       <span class="s1">scale_to</span><span class="s3">=</span><span class="s6">'magnitude'</span><span class="s3">, </span><span class="s1">fft_mode</span><span class="s3">=</span><span class="s1">fft_mode</span><span class="s3">)</span>
    <span class="s1">Sx </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">y </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sx</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">n</span><span class="s3">, </span><span class="s1">f_axis</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">t_axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">y</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s6">'Multidim. roundtrip failed!'</span><span class="s3">)</span>

    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j </span><span class="s2">in </span><span class="s1">product</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]), </span><span class="s1">range</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">2</span><span class="s3">])):</span>
        <span class="s1">y_ </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sx</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, :, </span><span class="s1">j</span><span class="s3">, :], </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">n</span><span class="s3">)</span>
        <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">y_</span><span class="s3">, </span><span class="s1">x</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, :, </span><span class="s1">j</span><span class="s3">], </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s6">&quot;Multidim. roundtrip for component &quot; </span><span class="s3">+</span>
                        <span class="s6">f&quot;x[</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s6">, :, </span><span class="s2">{</span><span class="s1">j</span><span class="s2">}</span><span class="s6">] and </span><span class="s2">{</span><span class="s1">fft_mode</span><span class="s3">=</span><span class="s2">} </span><span class="s6">failed!&quot;</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">'window, n, nperseg, noverlap'</span><span class="s3">,</span>
                         <span class="s3">[(</span><span class="s6">'boxcar'</span><span class="s3">, </span><span class="s5">100</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),     </span><span class="s4"># Test no overlap</span>
                          <span class="s3">(</span><span class="s6">'boxcar'</span><span class="s3">, </span><span class="s5">100</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">9</span><span class="s3">),     </span><span class="s4"># Test high overlap</span>
                          <span class="s3">(</span><span class="s6">'bartlett'</span><span class="s3">, </span><span class="s5">101</span><span class="s3">, </span><span class="s5">51</span><span class="s3">, </span><span class="s5">26</span><span class="s3">),  </span><span class="s4"># Test odd nperseg</span>
                          <span class="s3">(</span><span class="s6">'hann'</span><span class="s3">, </span><span class="s5">1024</span><span class="s3">, </span><span class="s5">256</span><span class="s3">, </span><span class="s5">128</span><span class="s3">),   </span><span class="s4"># Test defaults</span>
                          <span class="s3">((</span><span class="s6">'tukey'</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">), </span><span class="s5">1152</span><span class="s3">, </span><span class="s5">256</span><span class="s3">, </span><span class="s5">64</span><span class="s3">),  </span><span class="s4"># Test Tukey</span>
                          <span class="s3">(</span><span class="s6">'hann'</span><span class="s3">, </span><span class="s5">1024</span><span class="s3">, </span><span class="s5">256</span><span class="s3">, </span><span class="s5">255</span><span class="s3">),   </span><span class="s4"># Test overlapped hann</span>
                          <span class="s3">(</span><span class="s6">'boxcar'</span><span class="s3">, </span><span class="s5">100</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">3</span><span class="s3">),     </span><span class="s4"># NOLA True, COLA False</span>
                          <span class="s3">(</span><span class="s6">'bartlett'</span><span class="s3">, </span><span class="s5">101</span><span class="s3">, </span><span class="s5">51</span><span class="s3">, </span><span class="s5">37</span><span class="s3">),  </span><span class="s4"># NOLA True, COLA False</span>
                          <span class="s3">(</span><span class="s6">'hann'</span><span class="s3">, </span><span class="s5">1024</span><span class="s3">, </span><span class="s5">256</span><span class="s3">, </span><span class="s5">127</span><span class="s3">),   </span><span class="s4"># NOLA True, COLA False</span>
                          <span class="s4"># NOLA True, COLA False:</span>
                          <span class="s3">((</span><span class="s6">'tukey'</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">), </span><span class="s5">1152</span><span class="s3">, </span><span class="s5">256</span><span class="s3">, </span><span class="s5">14</span><span class="s3">),</span>
                          <span class="s3">(</span><span class="s6">'hann'</span><span class="s3">, </span><span class="s5">1024</span><span class="s3">, </span><span class="s5">256</span><span class="s3">, </span><span class="s5">5</span><span class="s3">)])    </span><span class="s4"># NOLA True, COLA False</span>
<span class="s2">def </span><span class="s1">test_roundtrip_windows</span><span class="s3">(</span><span class="s1">window</span><span class="s3">, </span><span class="s1">n</span><span class="s3">: </span><span class="s1">int</span><span class="s3">, </span><span class="s1">nperseg</span><span class="s3">: </span><span class="s1">int</span><span class="s3">, </span><span class="s1">noverlap</span><span class="s3">: </span><span class="s1">int</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Roundtrip test adapted from `test_spectral.TestSTFT`. 
 
    The parameters are taken from the methods test_roundtrip_real(), 
    test_roundtrip_nola_not_cola(), test_roundtrip_float32(), 
    test_roundtrip_complex(). 
    &quot;&quot;&quot;</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">seed</span><span class="s3">(</span><span class="s5">2394655</span><span class="s3">)</span>

    <span class="s1">w </span><span class="s3">= </span><span class="s1">get_window</span><span class="s3">(</span><span class="s1">window</span><span class="s3">, </span><span class="s1">nperseg</span><span class="s3">)</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">w</span><span class="s3">, </span><span class="s1">nperseg </span><span class="s3">- </span><span class="s1">noverlap</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">fft_mode</span><span class="s3">=</span><span class="s6">'twosided'</span><span class="s3">,</span>
                       <span class="s1">phase_shift</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>

    <span class="s1">z </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randn</span><span class="s3">(</span><span class="s1">n</span><span class="s3">) + </span><span class="s5">10j </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randn</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">Sz </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s1">z1 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sz</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">z</span><span class="s3">))</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">z1</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s6">&quot;Roundtrip for complex values failed&quot;</span><span class="s3">)</span>

    <span class="s1">x </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randn</span><span class="s3">(</span><span class="s1">n</span><span class="s3">)</span>
    <span class="s1">Sx </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">x1 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sx</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">z</span><span class="s3">))</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">x1</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s6">&quot;Roundtrip for float values failed&quot;</span><span class="s3">)</span>

    <span class="s1">x32 </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">)</span>
    <span class="s1">Sx32 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">x32</span><span class="s3">)</span>
    <span class="s1">x32_1 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sx32</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x32</span><span class="s3">))</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">x32</span><span class="s3">, </span><span class="s1">x32_1</span><span class="s3">,</span>
                    <span class="s1">err_msg</span><span class="s3">=</span><span class="s6">&quot;Roundtrip for 32 Bit float values failed&quot;</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">'signal_type'</span><span class="s3">, (</span><span class="s6">'real'</span><span class="s3">, </span><span class="s6">'complex'</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">test_roundtrip_complex_window</span><span class="s3">(</span><span class="s1">signal_type</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Test roundtrip for complex-valued window function 
 
    The purpose of this test is to check if the dual window is calculated 
    correctly for complex-valued windows. 
    &quot;&quot;&quot;</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">seed</span><span class="s3">(</span><span class="s5">1354654</span><span class="s3">)</span>
    <span class="s1">win </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">2j</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">linspace</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">, </span><span class="s5">8</span><span class="s3">))</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">win</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">fft_mode</span><span class="s3">=</span><span class="s6">'twosided'</span><span class="s3">)</span>

    <span class="s1">z </span><span class="s3">= </span><span class="s5">10 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randn</span><span class="s3">(</span><span class="s5">11</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">signal_type </span><span class="s3">== </span><span class="s6">'complex'</span><span class="s3">:</span>
        <span class="s1">z </span><span class="s3">= </span><span class="s1">z </span><span class="s3">+ </span><span class="s5">2j </span><span class="s3">* </span><span class="s1">z</span>
    <span class="s1">Sz </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
    <span class="s1">z1 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sz</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">len</span><span class="s3">(</span><span class="s1">z</span><span class="s3">))</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">z1</span><span class="s3">,</span>
                    <span class="s1">err_msg</span><span class="s3">=</span><span class="s6">&quot;Roundtrip for complex-valued window failed&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">test_average_all_segments</span><span class="s3">():</span>
    <span class="s0">&quot;&quot;&quot;Compare `welch` function with stft mean. 
 
    Ported from `TestSpectrogram.test_average_all_segments` from file 
    ``test__spectral.py``. 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randn</span><span class="s3">(</span><span class="s5">1024</span><span class="s3">)</span>

    <span class="s1">fs </span><span class="s3">= </span><span class="s5">1.0</span>
    <span class="s1">window </span><span class="s3">= (</span><span class="s6">'tukey'</span><span class="s3">, </span><span class="s5">0.25</span><span class="s3">)</span>
    <span class="s1">nperseg</span><span class="s3">, </span><span class="s1">noverlap </span><span class="s3">= </span><span class="s5">16</span><span class="s3">, </span><span class="s5">2</span>
    <span class="s1">fw</span><span class="s3">, </span><span class="s1">Pw </span><span class="s3">= </span><span class="s1">welch</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">window</span><span class="s3">, </span><span class="s1">nperseg</span><span class="s3">, </span><span class="s1">noverlap</span><span class="s3">)</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">.</span><span class="s1">from_window</span><span class="s3">(</span><span class="s1">window</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">, </span><span class="s1">nperseg</span><span class="s3">, </span><span class="s1">noverlap</span><span class="s3">,</span>
                                   <span class="s1">fft_mode</span><span class="s3">=</span><span class="s6">'onesided2X'</span><span class="s3">, </span><span class="s1">scale_to</span><span class="s3">=</span><span class="s6">'psd'</span><span class="s3">,</span>
                                   <span class="s1">phase_shift</span><span class="s3">=</span><span class="s2">None</span><span class="s3">)</span>
    <span class="s4"># `welch` positions the window differently than the STFT:</span>
    <span class="s1">P </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">spectrogram</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">detr</span><span class="s3">=</span><span class="s6">'constant'</span><span class="s3">, </span><span class="s1">p0</span><span class="s3">=</span><span class="s5">0</span><span class="s3">,</span>
                        <span class="s1">p1</span><span class="s3">=(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)-</span><span class="s1">noverlap</span><span class="s3">)//</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">hop</span><span class="s3">, </span><span class="s1">k_offset</span><span class="s3">=</span><span class="s1">nperseg</span><span class="s3">//</span><span class="s5">2</span><span class="s3">)</span>

    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">f</span><span class="s3">, </span><span class="s1">fw</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">mean</span><span class="s3">(</span><span class="s1">P</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">), </span><span class="s1">Pw</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">'window, N, nperseg, noverlap, mfft'</span><span class="s3">,</span>
                         <span class="s4"># from test_roundtrip_padded_FFT:</span>
                         <span class="s3">[(</span><span class="s6">'hann'</span><span class="s3">, </span><span class="s5">1024</span><span class="s3">, </span><span class="s5">256</span><span class="s3">, </span><span class="s5">128</span><span class="s3">, </span><span class="s5">512</span><span class="s3">),</span>
                          <span class="s3">(</span><span class="s6">'hann'</span><span class="s3">, </span><span class="s5">1024</span><span class="s3">, </span><span class="s5">256</span><span class="s3">, </span><span class="s5">128</span><span class="s3">, </span><span class="s5">501</span><span class="s3">),</span>
                          <span class="s3">(</span><span class="s6">'boxcar'</span><span class="s3">, </span><span class="s5">100</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">33</span><span class="s3">),</span>
                          <span class="s3">((</span><span class="s6">'tukey'</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">), </span><span class="s5">1152</span><span class="s3">, </span><span class="s5">256</span><span class="s3">, </span><span class="s5">64</span><span class="s3">, </span><span class="s5">1024</span><span class="s3">),</span>
                          <span class="s4"># from test_roundtrip_padded_signal:</span>
                          <span class="s3">(</span><span class="s6">'boxcar'</span><span class="s3">, </span><span class="s5">101</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
                          <span class="s3">(</span><span class="s6">'hann'</span><span class="s3">, </span><span class="s5">1000</span><span class="s3">, </span><span class="s5">256</span><span class="s3">, </span><span class="s5">128</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
                          <span class="s4"># from test_roundtrip_boundary_extension:</span>
                          <span class="s3">(</span><span class="s6">'boxcar'</span><span class="s3">, </span><span class="s5">100</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s2">None</span><span class="s3">),</span>
                          <span class="s3">(</span><span class="s6">'boxcar'</span><span class="s3">, </span><span class="s5">100</span><span class="s3">, </span><span class="s5">10</span><span class="s3">, </span><span class="s5">9</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)])</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">'padding'</span><span class="s3">, </span><span class="s1">get_args</span><span class="s3">(</span><span class="s1">PAD_TYPE</span><span class="s3">))</span>
<span class="s2">def </span><span class="s1">test_stft_padding_roundtrip</span><span class="s3">(</span><span class="s1">window</span><span class="s3">, </span><span class="s1">N</span><span class="s3">: </span><span class="s1">int</span><span class="s3">, </span><span class="s1">nperseg</span><span class="s3">: </span><span class="s1">int</span><span class="s3">, </span><span class="s1">noverlap</span><span class="s3">: </span><span class="s1">int</span><span class="s3">,</span>
                                <span class="s1">mfft</span><span class="s3">: </span><span class="s1">int</span><span class="s3">, </span><span class="s1">padding</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Test the parameter 'padding' of `stft` with roundtrips. 
 
    The STFT parametrizations were taken from the methods 
    `test_roundtrip_padded_FFT`, `test_roundtrip_padded_signal` and 
    `test_roundtrip_boundary_extension` from class `TestSTFT` in  file 
    ``test_spectral.py``. Note that the ShortTimeFFT does not need the 
    concept of &quot;boundary extension&quot;. 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">normal_distribution</span><span class="s3">.</span><span class="s1">rvs</span><span class="s3">(</span><span class="s1">size</span><span class="s3">=</span><span class="s1">N</span><span class="s3">, </span><span class="s1">random_state</span><span class="s3">=</span><span class="s5">2909</span><span class="s3">)  </span><span class="s4"># real signal</span>
    <span class="s1">z </span><span class="s3">= </span><span class="s1">x </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(</span><span class="s5">1j </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">/ </span><span class="s5">4</span><span class="s3">)  </span><span class="s4"># complex signal</span>

    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">.</span><span class="s1">from_window</span><span class="s3">(</span><span class="s1">window</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">nperseg</span><span class="s3">, </span><span class="s1">noverlap</span><span class="s3">,</span>
                                   <span class="s1">fft_mode</span><span class="s3">=</span><span class="s6">'twosided'</span><span class="s3">, </span><span class="s1">mfft</span><span class="s3">=</span><span class="s1">mfft</span><span class="s3">)</span>
    <span class="s1">Sx </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">padding</span><span class="s3">=</span><span class="s1">padding</span><span class="s3">)</span>
    <span class="s1">x1 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sx</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">N</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">x1</span><span class="s3">, </span><span class="s1">x</span><span class="s3">,</span>
                    <span class="s1">err_msg</span><span class="s3">=</span><span class="s6">f&quot;Failed real roundtrip with '</span><span class="s2">{</span><span class="s1">padding</span><span class="s2">}</span><span class="s6">' padding&quot;</span><span class="s3">)</span>

    <span class="s1">Sz </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">z</span><span class="s3">, </span><span class="s1">padding</span><span class="s3">=</span><span class="s1">padding</span><span class="s3">)</span>
    <span class="s1">z1 </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">Sz</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">N</span><span class="s3">)</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">z1</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">err_msg</span><span class="s3">=</span><span class="s6">&quot;Failed complex roundtrip with &quot; </span><span class="s3">+</span>
                    <span class="s6">f&quot; '</span><span class="s2">{</span><span class="s1">padding</span><span class="s2">}</span><span class="s6">' padding&quot;</span><span class="s3">)</span>


<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">'N_x'</span><span class="s3">, (</span><span class="s5">128</span><span class="s3">, </span><span class="s5">129</span><span class="s3">, </span><span class="s5">255</span><span class="s3">, </span><span class="s5">256</span><span class="s3">, </span><span class="s5">1337</span><span class="s3">))  </span><span class="s4"># signal length</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">'w_size'</span><span class="s3">, (</span><span class="s5">128</span><span class="s3">, </span><span class="s5">256</span><span class="s3">))  </span><span class="s4"># window length</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">'t_step'</span><span class="s3">, (</span><span class="s5">4</span><span class="s3">, </span><span class="s5">64</span><span class="s3">))  </span><span class="s4"># SFT time hop</span>
<span class="s3">@</span><span class="s1">pytest</span><span class="s3">.</span><span class="s1">mark</span><span class="s3">.</span><span class="s1">parametrize</span><span class="s3">(</span><span class="s6">'f_c'</span><span class="s3">, (</span><span class="s5">7.</span><span class="s3">, </span><span class="s5">23.</span><span class="s3">))  </span><span class="s4"># frequency of input sine</span>
<span class="s2">def </span><span class="s1">test_energy_conservation</span><span class="s3">(</span><span class="s1">N_x</span><span class="s3">: </span><span class="s1">int</span><span class="s3">, </span><span class="s1">w_size</span><span class="s3">: </span><span class="s1">int</span><span class="s3">, </span><span class="s1">t_step</span><span class="s3">: </span><span class="s1">int</span><span class="s3">, </span><span class="s1">f_c</span><span class="s3">: </span><span class="s1">float</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Test if a `psd`-scaled STFT conserves the L2 norm. 
 
    This test is adapted from MNE-Python [1]_. Besides being battle-tested, 
    this test has the benefit of using non-standard window including 
    non-positive values and a 2d input signal. 
 
    Since `ShortTimeFFT` requires the signal length `N_x` to be at least the 
    window length `w_size`, the parameter `N_x` was changed from 
    ``(127, 128, 255, 256, 1337)`` to ``(128, 129, 255, 256, 1337)`` to be 
    more useful. 
 
    .. [1] File ``test_stft.py`` of MNE-Python 
        https://github.com/mne-tools/mne-python/blob/main/mne/time_frequency/tests/test_stft.py 
    &quot;&quot;&quot;</span>
    <span class="s1">window </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sin</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s5">.5</span><span class="s3">, </span><span class="s1">w_size </span><span class="s3">+ </span><span class="s5">.5</span><span class="s3">) / </span><span class="s1">w_size </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">)</span>
    <span class="s1">SFT </span><span class="s3">= </span><span class="s1">ShortTimeFFT</span><span class="s3">(</span><span class="s1">window</span><span class="s3">, </span><span class="s1">t_step</span><span class="s3">, </span><span class="s1">fs</span><span class="s3">=</span><span class="s5">1000</span><span class="s3">, </span><span class="s1">fft_mode</span><span class="s3">=</span><span class="s6">'onesided2X'</span><span class="s3">,</span>
                       <span class="s1">scale_to</span><span class="s3">=</span><span class="s6">'psd'</span><span class="s3">)</span>
    <span class="s1">atol </span><span class="s3">= </span><span class="s5">2</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">window</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">).</span><span class="s1">resolution</span>
    <span class="s1">N_x </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">N_x</span><span class="s3">, </span><span class="s1">w_size</span><span class="s3">)  </span><span class="s4"># minimal sing</span>
    <span class="s4"># Test with low frequency signal</span>
    <span class="s1">t </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">arange</span><span class="s3">(</span><span class="s1">N_x</span><span class="s3">).</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sin</span><span class="s3">(</span><span class="s5">2 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">* </span><span class="s1">f_c </span><span class="s3">* </span><span class="s1">t </span><span class="s3">* </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">T</span><span class="s3">)</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s1">x</span><span class="s3">, </span><span class="s1">x </span><span class="s3">+ </span><span class="s5">1.</span><span class="s3">])</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">xp </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">N_x</span><span class="s3">)</span>

    <span class="s1">max_freq </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">f</span><span class="s3">[</span><span class="s1">np</span><span class="s3">.</span><span class="s1">argmax</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">X</span><span class="s3">[</span><span class="s5">0</span><span class="s3">]) ** </span><span class="s5">2</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s5">1</span><span class="s3">))]</span>

    <span class="s2">assert </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] == </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">f_pts</span>
    <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">f </span><span class="s3">&gt;= </span><span class="s5">0.</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">max_freq </span><span class="s3">- </span><span class="s1">f_c</span><span class="s3">) &lt; </span><span class="s5">1.</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s1">atol</span><span class="s3">)</span>

    <span class="s4"># check L2-norm squared (i.e., energy) conservation:</span>
    <span class="s1">E_x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">x</span><span class="s3">**</span><span class="s5">2</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">) * </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">T  </span><span class="s4"># numerical integration</span>
    <span class="s1">aX2 </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">real</span><span class="s3">**</span><span class="s5">2 </span><span class="s3">+ </span><span class="s1">X</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">.</span><span class="s1">real</span><span class="s3">**</span><span class="s5">2</span>
    <span class="s1">E_X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">aX2</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">) * </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">delta_t</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">) * </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">delta_f</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">E_X</span><span class="s3">, </span><span class="s1">E_x</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s1">atol</span><span class="s3">)</span>

    <span class="s4"># Test with random signal</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">seed</span><span class="s3">(</span><span class="s5">2392795</span><span class="s3">)</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">randn</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s1">N_x</span><span class="s3">)</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">xp </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">N_x</span><span class="s3">)</span>

    <span class="s2">assert </span><span class="s1">X</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s5">1</span><span class="s3">] == </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">f_pts</span>
    <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">f </span><span class="s3">&gt;= </span><span class="s5">0.</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">np</span><span class="s3">.</span><span class="s1">abs</span><span class="s3">(</span><span class="s1">max_freq </span><span class="s3">- </span><span class="s1">f_c</span><span class="s3">) &lt; </span><span class="s5">1.</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s1">atol</span><span class="s3">)</span>

    <span class="s4"># check L2-norm squared (i.e., energy) conservation:</span>
    <span class="s1">E_x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">x</span><span class="s3">**</span><span class="s5">2</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">) * </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">T  </span><span class="s4"># numeric integration</span>
    <span class="s1">aX2 </span><span class="s3">= </span><span class="s1">X</span><span class="s3">.</span><span class="s1">real </span><span class="s3">** </span><span class="s5">2 </span><span class="s3">+ </span><span class="s1">X</span><span class="s3">.</span><span class="s1">imag</span><span class="s3">.</span><span class="s1">real </span><span class="s3">** </span><span class="s5">2</span>
    <span class="s1">E_X </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">aX2</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">) * </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">delta_t</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=-</span><span class="s5">1</span><span class="s3">) * </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">delta_f</span>
    <span class="s1">assert_allclose</span><span class="s3">(</span><span class="s1">E_X</span><span class="s3">, </span><span class="s1">E_x</span><span class="s3">, </span><span class="s1">atol</span><span class="s3">=</span><span class="s1">atol</span><span class="s3">)</span>

    <span class="s4"># Try with empty array</span>
    <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s5">0</span><span class="s3">, </span><span class="s1">N_x</span><span class="s3">))</span>
    <span class="s1">X </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">stft</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
    <span class="s1">xp </span><span class="s3">= </span><span class="s1">SFT</span><span class="s3">.</span><span class="s1">istft</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">k1</span><span class="s3">=</span><span class="s1">N_x</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span>
</pre>
</body>
</html>