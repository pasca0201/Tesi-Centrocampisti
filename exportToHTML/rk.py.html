<html>
<head>
<title>rk.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #2aacb8;}
.s5 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
rk.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">base </span><span class="s0">import </span><span class="s1">OdeSolver</span><span class="s2">, </span><span class="s1">DenseOutput</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">common </span><span class="s0">import </span><span class="s2">(</span><span class="s1">validate_max_step</span><span class="s2">, </span><span class="s1">validate_tol</span><span class="s2">, </span><span class="s1">select_initial_step</span><span class="s2">,</span>
                     <span class="s1">norm</span><span class="s2">, </span><span class="s1">warn_extraneous</span><span class="s2">, </span><span class="s1">validate_first_step</span><span class="s2">)</span>
<span class="s0">from </span><span class="s2">. </span><span class="s0">import </span><span class="s1">dop853_coefficients</span>

<span class="s3"># Multiply steps computed from asymptotic behaviour of errors by this.</span>
<span class="s1">SAFETY </span><span class="s2">= </span><span class="s4">0.9</span>

<span class="s1">MIN_FACTOR </span><span class="s2">= </span><span class="s4">0.2  </span><span class="s3"># Minimum allowed decrease in a step size.</span>
<span class="s1">MAX_FACTOR </span><span class="s2">= </span><span class="s4">10  </span><span class="s3"># Maximum allowed increase in a step size.</span>


<span class="s0">def </span><span class="s1">rk_step</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">K</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Perform a single Runge-Kutta step. 
 
    This function computes a prediction of an explicit Runge-Kutta method and 
    also estimates the error of a less accurate method. 
 
    Notation for Butcher tableau is as in [1]_. 
 
    Parameters 
    ---------- 
    fun : callable 
        Right-hand side of the system. 
    t : float 
        Current time. 
    y : ndarray, shape (n,) 
        Current state. 
    f : ndarray, shape (n,) 
        Current value of the derivative, i.e., ``fun(x, y)``. 
    h : float 
        Step to use. 
    A : ndarray, shape (n_stages, n_stages) 
        Coefficients for combining previous RK stages to compute the next 
        stage. For explicit methods the coefficients at and above the main 
        diagonal are zeros. 
    B : ndarray, shape (n_stages,) 
        Coefficients for combining RK stages for computing the final 
        prediction. 
    C : ndarray, shape (n_stages,) 
        Coefficients for incrementing time for consecutive RK stages. 
        The value for the first stage is always zero. 
    K : ndarray, shape (n_stages + 1, n) 
        Storage array for putting RK stages here. Stages are stored in rows. 
        The last row is a linear combination of the previous rows with 
        coefficients 
 
    Returns 
    ------- 
    y_new : ndarray, shape (n,) 
        Solution at t + h computed with a higher accuracy. 
    f_new : ndarray, shape (n,) 
        Derivative ``fun(t + h, y_new)``. 
 
    References 
    ---------- 
    .. [1] E. Hairer, S. P. Norsett G. Wanner, &quot;Solving Ordinary Differential 
           Equations I: Nonstiff Problems&quot;, Sec. II.4. 
    &quot;&quot;&quot;</span>
    <span class="s1">K</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] = </span><span class="s1">f</span>
    <span class="s0">for </span><span class="s1">s</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">c</span><span class="s2">) </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">A</span><span class="s2">[</span><span class="s4">1</span><span class="s2">:], </span><span class="s1">C</span><span class="s2">[</span><span class="s4">1</span><span class="s2">:]), </span><span class="s1">start</span><span class="s2">=</span><span class="s4">1</span><span class="s2">):</span>
        <span class="s1">dy </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">K</span><span class="s2">[:</span><span class="s1">s</span><span class="s2">].</span><span class="s1">T</span><span class="s2">, </span><span class="s1">a</span><span class="s2">[:</span><span class="s1">s</span><span class="s2">]) * </span><span class="s1">h</span>
        <span class="s1">K</span><span class="s2">[</span><span class="s1">s</span><span class="s2">] = </span><span class="s1">fun</span><span class="s2">(</span><span class="s1">t </span><span class="s2">+ </span><span class="s1">c </span><span class="s2">* </span><span class="s1">h</span><span class="s2">, </span><span class="s1">y </span><span class="s2">+ </span><span class="s1">dy</span><span class="s2">)</span>

    <span class="s1">y_new </span><span class="s2">= </span><span class="s1">y </span><span class="s2">+ </span><span class="s1">h </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">K</span><span class="s2">[:-</span><span class="s4">1</span><span class="s2">].</span><span class="s1">T</span><span class="s2">, </span><span class="s1">B</span><span class="s2">)</span>
    <span class="s1">f_new </span><span class="s2">= </span><span class="s1">fun</span><span class="s2">(</span><span class="s1">t </span><span class="s2">+ </span><span class="s1">h</span><span class="s2">, </span><span class="s1">y_new</span><span class="s2">)</span>

    <span class="s1">K</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">] = </span><span class="s1">f_new</span>

    <span class="s0">return </span><span class="s1">y_new</span><span class="s2">, </span><span class="s1">f_new</span>


<span class="s0">class </span><span class="s1">RungeKutta</span><span class="s2">(</span><span class="s1">OdeSolver</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Base class for explicit Runge-Kutta methods.&quot;&quot;&quot;</span>
    <span class="s1">C</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray </span><span class="s2">= </span><span class="s1">NotImplemented</span>
    <span class="s1">A</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray </span><span class="s2">= </span><span class="s1">NotImplemented</span>
    <span class="s1">B</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray </span><span class="s2">= </span><span class="s1">NotImplemented</span>
    <span class="s1">E</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray </span><span class="s2">= </span><span class="s1">NotImplemented</span>
    <span class="s1">P</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray </span><span class="s2">= </span><span class="s1">NotImplemented</span>
    <span class="s1">order</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s1">NotImplemented</span>
    <span class="s1">error_estimator_order</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s1">NotImplemented</span>
    <span class="s1">n_stages</span><span class="s2">: </span><span class="s1">int </span><span class="s2">= </span><span class="s1">NotImplemented</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">t0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">t_bound</span><span class="s2">, </span><span class="s1">max_step</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">,</span>
                 <span class="s1">rtol</span><span class="s2">=</span><span class="s4">1e-3</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">vectorized</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
                 <span class="s1">first_step</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, **</span><span class="s1">extraneous</span><span class="s2">):</span>
        <span class="s1">warn_extraneous</span><span class="s2">(</span><span class="s1">extraneous</span><span class="s2">)</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">, </span><span class="s1">t0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">t_bound</span><span class="s2">, </span><span class="s1">vectorized</span><span class="s2">,</span>
                         <span class="s1">support_complex</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">y_old </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">max_step </span><span class="s2">= </span><span class="s1">validate_max_step</span><span class="s2">(</span><span class="s1">max_step</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">atol </span><span class="s2">= </span><span class="s1">validate_tol</span><span class="s2">(</span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">n</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">f </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fun</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">t</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">y</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">first_step </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">h_abs </span><span class="s2">= </span><span class="s1">select_initial_step</span><span class="s2">(</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">fun</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">t</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">y</span><span class="s2">, </span><span class="s1">t_bound</span><span class="s2">, </span><span class="s1">max_step</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">f</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">direction</span><span class="s2">,</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">error_estimator_order</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">atol</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">h_abs </span><span class="s2">= </span><span class="s1">validate_first_step</span><span class="s2">(</span><span class="s1">first_step</span><span class="s2">, </span><span class="s1">t0</span><span class="s2">, </span><span class="s1">t_bound</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">K </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">n_stages </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">n</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">y</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">error_exponent </span><span class="s2">= -</span><span class="s4">1 </span><span class="s2">/ (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">error_estimator_order </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">h_previous </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_estimate_error</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">K</span><span class="s2">, </span><span class="s1">h</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">K</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">E</span><span class="s2">) * </span><span class="s1">h</span>

    <span class="s0">def </span><span class="s1">_estimate_error_norm</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">K</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">norm</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_estimate_error</span><span class="s2">(</span><span class="s1">K</span><span class="s2">, </span><span class="s1">h</span><span class="s2">) / </span><span class="s1">scale</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_step_impl</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">t </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">t</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">y</span>

        <span class="s1">max_step </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">max_step</span>
        <span class="s1">rtol </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">rtol</span>
        <span class="s1">atol </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">atol</span>

        <span class="s1">min_step </span><span class="s2">= </span><span class="s4">10 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">nextafter</span><span class="s2">(</span><span class="s1">t</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">direction </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">) - </span><span class="s1">t</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">h_abs </span><span class="s2">&gt; </span><span class="s1">max_step</span><span class="s2">:</span>
            <span class="s1">h_abs </span><span class="s2">= </span><span class="s1">max_step</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">h_abs </span><span class="s2">&lt; </span><span class="s1">min_step</span><span class="s2">:</span>
            <span class="s1">h_abs </span><span class="s2">= </span><span class="s1">min_step</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">h_abs </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">h_abs</span>

        <span class="s1">step_accepted </span><span class="s2">= </span><span class="s0">False</span>
        <span class="s1">step_rejected </span><span class="s2">= </span><span class="s0">False</span>

        <span class="s0">while not </span><span class="s1">step_accepted</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">h_abs </span><span class="s2">&lt; </span><span class="s1">min_step</span><span class="s2">:</span>
                <span class="s0">return False</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">TOO_SMALL_STEP</span>

            <span class="s1">h </span><span class="s2">= </span><span class="s1">h_abs </span><span class="s2">* </span><span class="s1">self</span><span class="s2">.</span><span class="s1">direction</span>
            <span class="s1">t_new </span><span class="s2">= </span><span class="s1">t </span><span class="s2">+ </span><span class="s1">h</span>

            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">direction </span><span class="s2">* (</span><span class="s1">t_new </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">t_bound</span><span class="s2">) &gt; </span><span class="s4">0</span><span class="s2">:</span>
                <span class="s1">t_new </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">t_bound</span>

            <span class="s1">h </span><span class="s2">= </span><span class="s1">t_new </span><span class="s2">- </span><span class="s1">t</span>
            <span class="s1">h_abs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">h</span><span class="s2">)</span>

            <span class="s1">y_new</span><span class="s2">, </span><span class="s1">f_new </span><span class="s2">= </span><span class="s1">rk_step</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">fun</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">f</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">A</span><span class="s2">,</span>
                                   <span class="s1">self</span><span class="s2">.</span><span class="s1">B</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">C</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">K</span><span class="s2">)</span>
            <span class="s1">scale </span><span class="s2">= </span><span class="s1">atol </span><span class="s2">+ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">y</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">y_new</span><span class="s2">)) * </span><span class="s1">rtol</span>
            <span class="s1">error_norm </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_estimate_error_norm</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">K</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">error_norm </span><span class="s2">&lt; </span><span class="s4">1</span><span class="s2">:</span>
                <span class="s0">if </span><span class="s1">error_norm </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
                    <span class="s1">factor </span><span class="s2">= </span><span class="s1">MAX_FACTOR</span>
                <span class="s0">else</span><span class="s2">:</span>
                    <span class="s1">factor </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">MAX_FACTOR</span><span class="s2">,</span>
                                 <span class="s1">SAFETY </span><span class="s2">* </span><span class="s1">error_norm </span><span class="s2">** </span><span class="s1">self</span><span class="s2">.</span><span class="s1">error_exponent</span><span class="s2">)</span>

                <span class="s0">if </span><span class="s1">step_rejected</span><span class="s2">:</span>
                    <span class="s1">factor </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">factor</span><span class="s2">)</span>

                <span class="s1">h_abs </span><span class="s2">*= </span><span class="s1">factor</span>

                <span class="s1">step_accepted </span><span class="s2">= </span><span class="s0">True</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">h_abs </span><span class="s2">*= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">MIN_FACTOR</span><span class="s2">,</span>
                             <span class="s1">SAFETY </span><span class="s2">* </span><span class="s1">error_norm </span><span class="s2">** </span><span class="s1">self</span><span class="s2">.</span><span class="s1">error_exponent</span><span class="s2">)</span>
                <span class="s1">step_rejected </span><span class="s2">= </span><span class="s0">True</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">h_previous </span><span class="s2">= </span><span class="s1">h</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">y_old </span><span class="s2">= </span><span class="s1">y</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">t </span><span class="s2">= </span><span class="s1">t_new</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">y </span><span class="s2">= </span><span class="s1">y_new</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">h_abs </span><span class="s2">= </span><span class="s1">h_abs</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">f </span><span class="s2">= </span><span class="s1">f_new</span>

        <span class="s0">return True</span><span class="s2">, </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_dense_output_impl</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">Q </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">K</span><span class="s2">.</span><span class="s1">T</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">P</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">RkDenseOutput</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">t_old</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">t</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">y_old</span><span class="s2">, </span><span class="s1">Q</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">RK23</span><span class="s2">(</span><span class="s1">RungeKutta</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Explicit Runge-Kutta method of order 3(2). 
 
    This uses the Bogacki-Shampine pair of formulas [1]_. The error is controlled 
    assuming accuracy of the second-order method, but steps are taken using the 
    third-order accurate formula (local extrapolation is done). A cubic Hermite 
    polynomial is used for the dense output. 
 
    Can be applied in the complex domain. 
 
    Parameters 
    ---------- 
    fun : callable 
        Right-hand side of the system: the time derivative of the state ``y`` 
        at time ``t``. The calling signature is ``fun(t, y)``, where ``t`` is a 
        scalar and ``y`` is an ndarray with ``len(y) = len(y0)``. ``fun`` must 
        return an array of the same shape as ``y``. See `vectorized` for more 
        information. 
    t0 : float 
        Initial time. 
    y0 : array_like, shape (n,) 
        Initial state. 
    t_bound : float 
        Boundary time - the integration won't continue beyond it. It also 
        determines the direction of the integration. 
    first_step : float or None, optional 
        Initial step size. Default is ``None`` which means that the algorithm 
        should choose. 
    max_step : float, optional 
        Maximum allowed step size. Default is np.inf, i.e., the step size is not 
        bounded and determined solely by the solver. 
    rtol, atol : float and array_like, optional 
        Relative and absolute tolerances. The solver keeps the local error 
        estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a 
        relative accuracy (number of correct digits), while `atol` controls 
        absolute accuracy (number of correct decimal places). To achieve the 
        desired `rtol`, set `atol` to be smaller than the smallest value that 
        can be expected from ``rtol * abs(y)`` so that `rtol` dominates the 
        allowable error. If `atol` is larger than ``rtol * abs(y)`` the 
        number of correct digits is not guaranteed. Conversely, to achieve the 
        desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller 
        than `atol`. If components of y have different scales, it might be 
        beneficial to set different `atol` values for different components by 
        passing array_like with shape (n,) for `atol`. Default values are 
        1e-3 for `rtol` and 1e-6 for `atol`. 
    vectorized : bool, optional 
        Whether `fun` may be called in a vectorized fashion. False (default) 
        is recommended for this solver. 
 
        If ``vectorized`` is False, `fun` will always be called with ``y`` of 
        shape ``(n,)``, where ``n = len(y0)``. 
 
        If ``vectorized`` is True, `fun` may be called with ``y`` of shape 
        ``(n, k)``, where ``k`` is an integer. In this case, `fun` must behave 
        such that ``fun(t, y)[:, i] == fun(t, y[:, i])`` (i.e. each column of 
        the returned array is the time derivative of the state corresponding 
        with a column of ``y``). 
 
        Setting ``vectorized=True`` allows for faster finite difference 
        approximation of the Jacobian by methods 'Radau' and 'BDF', but 
        will result in slower execution for this solver. 
 
    Attributes 
    ---------- 
    n : int 
        Number of equations. 
    status : string 
        Current status of the solver: 'running', 'finished' or 'failed'. 
    t_bound : float 
        Boundary time. 
    direction : float 
        Integration direction: +1 or -1. 
    t : float 
        Current time. 
    y : ndarray 
        Current state. 
    t_old : float 
        Previous time. None if no steps were made yet. 
    step_size : float 
        Size of the last successful step. None if no steps were made yet. 
    nfev : int 
        Number evaluations of the system's right-hand side. 
    njev : int 
        Number of evaluations of the Jacobian. 
        Is always 0 for this solver as it does not use the Jacobian. 
    nlu : int 
        Number of LU decompositions. Is always 0 for this solver. 
 
    References 
    ---------- 
    .. [1] P. Bogacki, L.F. Shampine, &quot;A 3(2) Pair of Runge-Kutta Formulas&quot;, 
           Appl. Math. Lett. Vol. 2, No. 4. pp. 321-325, 1989. 
    &quot;&quot;&quot;</span>
    <span class="s1">order </span><span class="s2">= </span><span class="s4">3</span>
    <span class="s1">error_estimator_order </span><span class="s2">= </span><span class="s4">2</span>
    <span class="s1">n_stages </span><span class="s2">= </span><span class="s4">3</span>
    <span class="s1">C </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">/</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">/</span><span class="s4">4</span><span class="s2">])</span>
    <span class="s1">A </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">1</span><span class="s2">/</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">/</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s2">]</span>
    <span class="s2">])</span>
    <span class="s1">B </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s4">2</span><span class="s2">/</span><span class="s4">9</span><span class="s2">, </span><span class="s4">1</span><span class="s2">/</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">/</span><span class="s4">9</span><span class="s2">])</span>
    <span class="s1">E </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s4">5</span><span class="s2">/</span><span class="s4">72</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">/</span><span class="s4">12</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">/</span><span class="s4">9</span><span class="s2">, </span><span class="s4">1</span><span class="s2">/</span><span class="s4">8</span><span class="s2">])</span>
    <span class="s1">P </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s4">1</span><span class="s2">, -</span><span class="s4">4 </span><span class="s2">/ </span><span class="s4">3</span><span class="s2">, </span><span class="s4">5 </span><span class="s2">/ </span><span class="s4">9</span><span class="s2">],</span>
                  <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, -</span><span class="s4">2</span><span class="s2">/</span><span class="s4">3</span><span class="s2">],</span>
                  <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s2">/</span><span class="s4">3</span><span class="s2">, -</span><span class="s4">8</span><span class="s2">/</span><span class="s4">9</span><span class="s2">],</span>
                  <span class="s2">[</span><span class="s4">0</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">]])</span>


<span class="s0">class </span><span class="s1">RK45</span><span class="s2">(</span><span class="s1">RungeKutta</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Explicit Runge-Kutta method of order 5(4). 
 
    This uses the Dormand-Prince pair of formulas [1]_. The error is controlled 
    assuming accuracy of the fourth-order method accuracy, but steps are taken 
    using the fifth-order accurate formula (local extrapolation is done). 
    A quartic interpolation polynomial is used for the dense output [2]_. 
 
    Can be applied in the complex domain. 
 
    Parameters 
    ---------- 
    fun : callable 
        Right-hand side of the system. The calling signature is ``fun(t, y)``. 
        Here ``t`` is a scalar, and there are two options for the ndarray ``y``: 
        It can either have shape (n,); then ``fun`` must return array_like with 
        shape (n,). Alternatively it can have shape (n, k); then ``fun`` 
        must return an array_like with shape (n, k), i.e., each column 
        corresponds to a single column in ``y``. The choice between the two 
        options is determined by `vectorized` argument (see below). 
    t0 : float 
        Initial time. 
    y0 : array_like, shape (n,) 
        Initial state. 
    t_bound : float 
        Boundary time - the integration won't continue beyond it. It also 
        determines the direction of the integration. 
    first_step : float or None, optional 
        Initial step size. Default is ``None`` which means that the algorithm 
        should choose. 
    max_step : float, optional 
        Maximum allowed step size. Default is np.inf, i.e., the step size is not 
        bounded and determined solely by the solver. 
    rtol, atol : float and array_like, optional 
        Relative and absolute tolerances. The solver keeps the local error 
        estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a 
        relative accuracy (number of correct digits), while `atol` controls 
        absolute accuracy (number of correct decimal places). To achieve the 
        desired `rtol`, set `atol` to be smaller than the smallest value that 
        can be expected from ``rtol * abs(y)`` so that `rtol` dominates the 
        allowable error. If `atol` is larger than ``rtol * abs(y)`` the 
        number of correct digits is not guaranteed. Conversely, to achieve the 
        desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller 
        than `atol`. If components of y have different scales, it might be 
        beneficial to set different `atol` values for different components by 
        passing array_like with shape (n,) for `atol`. Default values are 
        1e-3 for `rtol` and 1e-6 for `atol`. 
    vectorized : bool, optional 
        Whether `fun` is implemented in a vectorized fashion. Default is False. 
 
    Attributes 
    ---------- 
    n : int 
        Number of equations. 
    status : string 
        Current status of the solver: 'running', 'finished' or 'failed'. 
    t_bound : float 
        Boundary time. 
    direction : float 
        Integration direction: +1 or -1. 
    t : float 
        Current time. 
    y : ndarray 
        Current state. 
    t_old : float 
        Previous time. None if no steps were made yet. 
    step_size : float 
        Size of the last successful step. None if no steps were made yet. 
    nfev : int 
        Number evaluations of the system's right-hand side. 
    njev : int 
        Number of evaluations of the Jacobian. 
        Is always 0 for this solver as it does not use the Jacobian. 
    nlu : int 
        Number of LU decompositions. Is always 0 for this solver. 
 
    References 
    ---------- 
    .. [1] J. R. Dormand, P. J. Prince, &quot;A family of embedded Runge-Kutta 
           formulae&quot;, Journal of Computational and Applied Mathematics, Vol. 6, 
           No. 1, pp. 19-26, 1980. 
    .. [2] L. W. Shampine, &quot;Some Practical Runge-Kutta Formulas&quot;, Mathematics 
           of Computation,, Vol. 46, No. 173, pp. 135-150, 1986. 
    &quot;&quot;&quot;</span>
    <span class="s1">order </span><span class="s2">= </span><span class="s4">5</span>
    <span class="s1">error_estimator_order </span><span class="s2">= </span><span class="s4">4</span>
    <span class="s1">n_stages </span><span class="s2">= </span><span class="s4">6</span>
    <span class="s1">C </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">/</span><span class="s4">5</span><span class="s2">, </span><span class="s4">3</span><span class="s2">/</span><span class="s4">10</span><span class="s2">, </span><span class="s4">4</span><span class="s2">/</span><span class="s4">5</span><span class="s2">, </span><span class="s4">8</span><span class="s2">/</span><span class="s4">9</span><span class="s2">, </span><span class="s4">1</span><span class="s2">])</span>
    <span class="s1">A </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">1</span><span class="s2">/</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">3</span><span class="s2">/</span><span class="s4">40</span><span class="s2">, </span><span class="s4">9</span><span class="s2">/</span><span class="s4">40</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">44</span><span class="s2">/</span><span class="s4">45</span><span class="s2">, -</span><span class="s4">56</span><span class="s2">/</span><span class="s4">15</span><span class="s2">, </span><span class="s4">32</span><span class="s2">/</span><span class="s4">9</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">19372</span><span class="s2">/</span><span class="s4">6561</span><span class="s2">, -</span><span class="s4">25360</span><span class="s2">/</span><span class="s4">2187</span><span class="s2">, </span><span class="s4">64448</span><span class="s2">/</span><span class="s4">6561</span><span class="s2">, -</span><span class="s4">212</span><span class="s2">/</span><span class="s4">729</span><span class="s2">, </span><span class="s4">0</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">9017</span><span class="s2">/</span><span class="s4">3168</span><span class="s2">, -</span><span class="s4">355</span><span class="s2">/</span><span class="s4">33</span><span class="s2">, </span><span class="s4">46732</span><span class="s2">/</span><span class="s4">5247</span><span class="s2">, </span><span class="s4">49</span><span class="s2">/</span><span class="s4">176</span><span class="s2">, -</span><span class="s4">5103</span><span class="s2">/</span><span class="s4">18656</span><span class="s2">]</span>
    <span class="s2">])</span>
    <span class="s1">B </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s4">35</span><span class="s2">/</span><span class="s4">384</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">500</span><span class="s2">/</span><span class="s4">1113</span><span class="s2">, </span><span class="s4">125</span><span class="s2">/</span><span class="s4">192</span><span class="s2">, -</span><span class="s4">2187</span><span class="s2">/</span><span class="s4">6784</span><span class="s2">, </span><span class="s4">11</span><span class="s2">/</span><span class="s4">84</span><span class="s2">])</span>
    <span class="s1">E </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([-</span><span class="s4">71</span><span class="s2">/</span><span class="s4">57600</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">71</span><span class="s2">/</span><span class="s4">16695</span><span class="s2">, -</span><span class="s4">71</span><span class="s2">/</span><span class="s4">1920</span><span class="s2">, </span><span class="s4">17253</span><span class="s2">/</span><span class="s4">339200</span><span class="s2">, -</span><span class="s4">22</span><span class="s2">/</span><span class="s4">525</span><span class="s2">,</span>
                  <span class="s4">1</span><span class="s2">/</span><span class="s4">40</span><span class="s2">])</span>
    <span class="s3"># Corresponds to the optimum value of c_6 from [2]_.</span>
    <span class="s1">P </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span>
        <span class="s2">[</span><span class="s4">1</span><span class="s2">, -</span><span class="s4">8048581381</span><span class="s2">/</span><span class="s4">2820520608</span><span class="s2">, </span><span class="s4">8663915743</span><span class="s2">/</span><span class="s4">2820520608</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s4">12715105075</span><span class="s2">/</span><span class="s4">11282082432</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">131558114200</span><span class="s2">/</span><span class="s4">32700410799</span><span class="s2">, -</span><span class="s4">68118460800</span><span class="s2">/</span><span class="s4">10900136933</span><span class="s2">,</span>
         <span class="s4">87487479700</span><span class="s2">/</span><span class="s4">32700410799</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, -</span><span class="s4">1754552775</span><span class="s2">/</span><span class="s4">470086768</span><span class="s2">, </span><span class="s4">14199869525</span><span class="s2">/</span><span class="s4">1410260304</span><span class="s2">,</span>
         <span class="s2">-</span><span class="s4">10690763975</span><span class="s2">/</span><span class="s4">1880347072</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">127303824393</span><span class="s2">/</span><span class="s4">49829197408</span><span class="s2">, -</span><span class="s4">318862633887</span><span class="s2">/</span><span class="s4">49829197408</span><span class="s2">,</span>
         <span class="s4">701980252875 </span><span class="s2">/ </span><span class="s4">199316789632</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, -</span><span class="s4">282668133</span><span class="s2">/</span><span class="s4">205662961</span><span class="s2">, </span><span class="s4">2019193451</span><span class="s2">/</span><span class="s4">616988883</span><span class="s2">, -</span><span class="s4">1453857185</span><span class="s2">/</span><span class="s4">822651844</span><span class="s2">],</span>
        <span class="s2">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">40617522</span><span class="s2">/</span><span class="s4">29380423</span><span class="s2">, -</span><span class="s4">110615467</span><span class="s2">/</span><span class="s4">29380423</span><span class="s2">, </span><span class="s4">69997945</span><span class="s2">/</span><span class="s4">29380423</span><span class="s2">]])</span>


<span class="s0">class </span><span class="s1">DOP853</span><span class="s2">(</span><span class="s1">RungeKutta</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Explicit Runge-Kutta method of order 8. 
 
    This is a Python implementation of &quot;DOP853&quot; algorithm originally written 
    in Fortran [1]_, [2]_. Note that this is not a literal translation, but 
    the algorithmic core and coefficients are the same. 
 
    Can be applied in the complex domain. 
 
    Parameters 
    ---------- 
    fun : callable 
        Right-hand side of the system. The calling signature is ``fun(t, y)``. 
        Here, ``t`` is a scalar, and there are two options for the ndarray ``y``: 
        It can either have shape (n,); then ``fun`` must return array_like with 
        shape (n,). Alternatively it can have shape (n, k); then ``fun`` 
        must return an array_like with shape (n, k), i.e. each column 
        corresponds to a single column in ``y``. The choice between the two 
        options is determined by `vectorized` argument (see below). 
    t0 : float 
        Initial time. 
    y0 : array_like, shape (n,) 
        Initial state. 
    t_bound : float 
        Boundary time - the integration won't continue beyond it. It also 
        determines the direction of the integration. 
    first_step : float or None, optional 
        Initial step size. Default is ``None`` which means that the algorithm 
        should choose. 
    max_step : float, optional 
        Maximum allowed step size. Default is np.inf, i.e. the step size is not 
        bounded and determined solely by the solver. 
    rtol, atol : float and array_like, optional 
        Relative and absolute tolerances. The solver keeps the local error 
        estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a 
        relative accuracy (number of correct digits), while `atol` controls 
        absolute accuracy (number of correct decimal places). To achieve the 
        desired `rtol`, set `atol` to be smaller than the smallest value that 
        can be expected from ``rtol * abs(y)`` so that `rtol` dominates the 
        allowable error. If `atol` is larger than ``rtol * abs(y)`` the 
        number of correct digits is not guaranteed. Conversely, to achieve the 
        desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller 
        than `atol`. If components of y have different scales, it might be 
        beneficial to set different `atol` values for different components by 
        passing array_like with shape (n,) for `atol`. Default values are 
        1e-3 for `rtol` and 1e-6 for `atol`. 
    vectorized : bool, optional 
        Whether `fun` is implemented in a vectorized fashion. Default is False. 
 
    Attributes 
    ---------- 
    n : int 
        Number of equations. 
    status : string 
        Current status of the solver: 'running', 'finished' or 'failed'. 
    t_bound : float 
        Boundary time. 
    direction : float 
        Integration direction: +1 or -1. 
    t : float 
        Current time. 
    y : ndarray 
        Current state. 
    t_old : float 
        Previous time. None if no steps were made yet. 
    step_size : float 
        Size of the last successful step. None if no steps were made yet. 
    nfev : int 
        Number evaluations of the system's right-hand side. 
    njev : int 
        Number of evaluations of the Jacobian. Is always 0 for this solver 
        as it does not use the Jacobian. 
    nlu : int 
        Number of LU decompositions. Is always 0 for this solver. 
 
    References 
    ---------- 
    .. [1] E. Hairer, S. P. Norsett G. Wanner, &quot;Solving Ordinary Differential 
           Equations I: Nonstiff Problems&quot;, Sec. II. 
    .. [2] `Page with original Fortran code of DOP853 
            &lt;http://www.unige.ch/~hairer/software.html&gt;`_. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_stages </span><span class="s2">= </span><span class="s1">dop853_coefficients</span><span class="s2">.</span><span class="s1">N_STAGES</span>
    <span class="s1">order </span><span class="s2">= </span><span class="s4">8</span>
    <span class="s1">error_estimator_order </span><span class="s2">= </span><span class="s4">7</span>
    <span class="s1">A </span><span class="s2">= </span><span class="s1">dop853_coefficients</span><span class="s2">.</span><span class="s1">A</span><span class="s2">[:</span><span class="s1">n_stages</span><span class="s2">, :</span><span class="s1">n_stages</span><span class="s2">]</span>
    <span class="s1">B </span><span class="s2">= </span><span class="s1">dop853_coefficients</span><span class="s2">.</span><span class="s1">B</span>
    <span class="s1">C </span><span class="s2">= </span><span class="s1">dop853_coefficients</span><span class="s2">.</span><span class="s1">C</span><span class="s2">[:</span><span class="s1">n_stages</span><span class="s2">]</span>
    <span class="s1">E3 </span><span class="s2">= </span><span class="s1">dop853_coefficients</span><span class="s2">.</span><span class="s1">E3</span>
    <span class="s1">E5 </span><span class="s2">= </span><span class="s1">dop853_coefficients</span><span class="s2">.</span><span class="s1">E5</span>
    <span class="s1">D </span><span class="s2">= </span><span class="s1">dop853_coefficients</span><span class="s2">.</span><span class="s1">D</span>

    <span class="s1">A_EXTRA </span><span class="s2">= </span><span class="s1">dop853_coefficients</span><span class="s2">.</span><span class="s1">A</span><span class="s2">[</span><span class="s1">n_stages </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">:]</span>
    <span class="s1">C_EXTRA </span><span class="s2">= </span><span class="s1">dop853_coefficients</span><span class="s2">.</span><span class="s1">C</span><span class="s2">[</span><span class="s1">n_stages </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">:]</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">t0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">t_bound</span><span class="s2">, </span><span class="s1">max_step</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">inf</span><span class="s2">,</span>
                 <span class="s1">rtol</span><span class="s2">=</span><span class="s4">1e-3</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">vectorized</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
                 <span class="s1">first_step</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, **</span><span class="s1">extraneous</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">fun</span><span class="s2">, </span><span class="s1">t0</span><span class="s2">, </span><span class="s1">y0</span><span class="s2">, </span><span class="s1">t_bound</span><span class="s2">, </span><span class="s1">max_step</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">,</span>
                         <span class="s1">vectorized</span><span class="s2">, </span><span class="s1">first_step</span><span class="s2">, **</span><span class="s1">extraneous</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">K_extended </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s1">dop853_coefficients</span><span class="s2">.</span><span class="s1">N_STAGES_EXTENDED</span><span class="s2">,</span>
                                    <span class="s1">self</span><span class="s2">.</span><span class="s1">n</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">y</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">K </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">K_extended</span><span class="s2">[:</span><span class="s1">self</span><span class="s2">.</span><span class="s1">n_stages </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">_estimate_error</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">K</span><span class="s2">, </span><span class="s1">h</span><span class="s2">):  </span><span class="s3"># Left for testing purposes.</span>
        <span class="s1">err5 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">K</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">E5</span><span class="s2">)</span>
        <span class="s1">err3 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">K</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">E3</span><span class="s2">)</span>
        <span class="s1">denom </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">hypot</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">err5</span><span class="s2">), </span><span class="s4">0.1 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">err3</span><span class="s2">))</span>
        <span class="s1">correction_factor </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones_like</span><span class="s2">(</span><span class="s1">err5</span><span class="s2">)</span>
        <span class="s1">mask </span><span class="s2">= </span><span class="s1">denom </span><span class="s2">&gt; </span><span class="s4">0</span>
        <span class="s1">correction_factor</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">] = </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">err5</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]) / </span><span class="s1">denom</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">h </span><span class="s2">* </span><span class="s1">err5 </span><span class="s2">* </span><span class="s1">correction_factor</span>

    <span class="s0">def </span><span class="s1">_estimate_error_norm</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">K</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">):</span>
        <span class="s1">err5 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">K</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">E5</span><span class="s2">) / </span><span class="s1">scale</span>
        <span class="s1">err3 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">K</span><span class="s2">.</span><span class="s1">T</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">E3</span><span class="s2">) / </span><span class="s1">scale</span>
        <span class="s1">err5_norm_2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">err5</span><span class="s2">)**</span><span class="s4">2</span>
        <span class="s1">err3_norm_2 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">err3</span><span class="s2">)**</span><span class="s4">2</span>
        <span class="s0">if </span><span class="s1">err5_norm_2 </span><span class="s2">== </span><span class="s4">0 </span><span class="s0">and </span><span class="s1">err3_norm_2 </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s4">0.0</span>
        <span class="s1">denom </span><span class="s2">= </span><span class="s1">err5_norm_2 </span><span class="s2">+ </span><span class="s4">0.01 </span><span class="s2">* </span><span class="s1">err3_norm_2</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">h</span><span class="s2">) * </span><span class="s1">err5_norm_2 </span><span class="s2">/ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">denom </span><span class="s2">* </span><span class="s1">len</span><span class="s2">(</span><span class="s1">scale</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">_dense_output_impl</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">K </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">K_extended</span>
        <span class="s1">h </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">h_previous</span>
        <span class="s0">for </span><span class="s1">s</span><span class="s2">, (</span><span class="s1">a</span><span class="s2">, </span><span class="s1">c</span><span class="s2">) </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">A_EXTRA</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">C_EXTRA</span><span class="s2">),</span>
                                   <span class="s1">start</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">n_stages </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">):</span>
            <span class="s1">dy </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">K</span><span class="s2">[:</span><span class="s1">s</span><span class="s2">].</span><span class="s1">T</span><span class="s2">, </span><span class="s1">a</span><span class="s2">[:</span><span class="s1">s</span><span class="s2">]) * </span><span class="s1">h</span>
            <span class="s1">K</span><span class="s2">[</span><span class="s1">s</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">fun</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">t_old </span><span class="s2">+ </span><span class="s1">c </span><span class="s2">* </span><span class="s1">h</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">y_old </span><span class="s2">+ </span><span class="s1">dy</span><span class="s2">)</span>

        <span class="s1">F </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">((</span><span class="s1">dop853_coefficients</span><span class="s2">.</span><span class="s1">INTERPOLATOR_POWER</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">n</span><span class="s2">),</span>
                     <span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">y_old</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s1">f_old </span><span class="s2">= </span><span class="s1">K</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s1">delta_y </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">y </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">y_old</span>

        <span class="s1">F</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] = </span><span class="s1">delta_y</span>
        <span class="s1">F</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] = </span><span class="s1">h </span><span class="s2">* </span><span class="s1">f_old </span><span class="s2">- </span><span class="s1">delta_y</span>
        <span class="s1">F</span><span class="s2">[</span><span class="s4">2</span><span class="s2">] = </span><span class="s4">2 </span><span class="s2">* </span><span class="s1">delta_y </span><span class="s2">- </span><span class="s1">h </span><span class="s2">* (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">f </span><span class="s2">+ </span><span class="s1">f_old</span><span class="s2">)</span>
        <span class="s1">F</span><span class="s2">[</span><span class="s4">3</span><span class="s2">:] = </span><span class="s1">h </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">D</span><span class="s2">, </span><span class="s1">K</span><span class="s2">)</span>

        <span class="s0">return </span><span class="s1">Dop853DenseOutput</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">t_old</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">t</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">y_old</span><span class="s2">, </span><span class="s1">F</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">RkDenseOutput</span><span class="s2">(</span><span class="s1">DenseOutput</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">t_old</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">y_old</span><span class="s2">, </span><span class="s1">Q</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">t_old</span><span class="s2">, </span><span class="s1">t</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">h </span><span class="s2">= </span><span class="s1">t </span><span class="s2">- </span><span class="s1">t_old</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">Q </span><span class="s2">= </span><span class="s1">Q</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">order </span><span class="s2">= </span><span class="s1">Q</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] - </span><span class="s4">1</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">y_old </span><span class="s2">= </span><span class="s1">y_old</span>

    <span class="s0">def </span><span class="s1">_call_impl</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">t</span><span class="s2">):</span>
        <span class="s1">x </span><span class="s2">= (</span><span class="s1">t </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">t_old</span><span class="s2">) / </span><span class="s1">self</span><span class="s2">.</span><span class="s1">h</span>
        <span class="s0">if </span><span class="s1">t</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s1">p </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">tile</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">order </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">)</span>
            <span class="s1">p </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cumprod</span><span class="s2">(</span><span class="s1">p</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">p </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">tile</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">order </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">))</span>
            <span class="s1">p </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cumprod</span><span class="s2">(</span><span class="s1">p</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s4">0</span><span class="s2">)</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">h </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dot</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">Q</span><span class="s2">, </span><span class="s1">p</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">y</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">2</span><span class="s2">:</span>
            <span class="s1">y </span><span class="s2">+= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">y_old</span><span class="s2">[:, </span><span class="s0">None</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">y </span><span class="s2">+= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">y_old</span>

        <span class="s0">return </span><span class="s1">y</span>


<span class="s0">class </span><span class="s1">Dop853DenseOutput</span><span class="s2">(</span><span class="s1">DenseOutput</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">t_old</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">y_old</span><span class="s2">, </span><span class="s1">F</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">t_old</span><span class="s2">, </span><span class="s1">t</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">h </span><span class="s2">= </span><span class="s1">t </span><span class="s2">- </span><span class="s1">t_old</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">F </span><span class="s2">= </span><span class="s1">F</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">y_old </span><span class="s2">= </span><span class="s1">y_old</span>

    <span class="s0">def </span><span class="s1">_call_impl</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">t</span><span class="s2">):</span>
        <span class="s1">x </span><span class="s2">= (</span><span class="s1">t </span><span class="s2">- </span><span class="s1">self</span><span class="s2">.</span><span class="s1">t_old</span><span class="s2">) / </span><span class="s1">self</span><span class="s2">.</span><span class="s1">h</span>

        <span class="s0">if </span><span class="s1">t</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
            <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">y_old</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">x</span><span class="s2">[:, </span><span class="s0">None</span><span class="s2">]</span>
            <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">y_old</span><span class="s2">)), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">y_old</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">f </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">reversed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">F</span><span class="s2">)):</span>
            <span class="s1">y </span><span class="s2">+= </span><span class="s1">f</span>
            <span class="s0">if </span><span class="s1">i </span><span class="s2">% </span><span class="s4">2 </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
                <span class="s1">y </span><span class="s2">*= </span><span class="s1">x</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">y </span><span class="s2">*= </span><span class="s4">1 </span><span class="s2">- </span><span class="s1">x</span>
        <span class="s1">y </span><span class="s2">+= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">y_old</span>

        <span class="s0">return </span><span class="s1">y</span><span class="s2">.</span><span class="s1">T</span>
</pre>
</body>
</html>