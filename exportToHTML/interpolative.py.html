<html>
<head>
<title>interpolative.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
interpolative.py</font>
</center></td></tr></table>
<pre><span class="s0">#******************************************************************************</span>
<span class="s0">#   Copyright (C) 2013 Kenneth L. Ho</span>
<span class="s0">#</span>
<span class="s0">#   Redistribution and use in source and binary forms, with or without</span>
<span class="s0">#   modification, are permitted provided that the following conditions are met:</span>
<span class="s0">#</span>
<span class="s0">#   Redistributions of source code must retain the above copyright notice, this</span>
<span class="s0">#   list of conditions and the following disclaimer. Redistributions in binary</span>
<span class="s0">#   form must reproduce the above copyright notice, this list of conditions and</span>
<span class="s0">#   the following disclaimer in the documentation and/or other materials</span>
<span class="s0">#   provided with the distribution.</span>
<span class="s0">#</span>
<span class="s0">#   None of the names of the copyright holders may be used to endorse or</span>
<span class="s0">#   promote products derived from this software without specific prior written</span>
<span class="s0">#   permission.</span>
<span class="s0">#</span>
<span class="s0">#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="s0">#   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="s0">#   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="s0">#   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span class="s0">#   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="s0">#   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="s0">#   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="s0">#   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="s0">#   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="s0">#   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="s0">#   POSSIBILITY OF SUCH DAMAGE.</span>
<span class="s0">#******************************************************************************</span>

<span class="s0"># Python module for interfacing with `id_dist`.</span>

<span class="s2">r&quot;&quot;&quot; 
====================================================================== 
Interpolative matrix decomposition (:mod:`scipy.linalg.interpolative`) 
====================================================================== 
 
.. moduleauthor:: Kenneth L. Ho &lt;klho@stanford.edu&gt; 
 
.. versionadded:: 0.13 
 
.. currentmodule:: scipy.linalg.interpolative 
 
An interpolative decomposition (ID) of a matrix :math:`A \in 
\mathbb{C}^{m \times n}` of rank :math:`k \leq \min \{ m, n \}` is a 
factorization 
 
.. math:: 
  A \Pi = 
  \begin{bmatrix} 
   A \Pi_{1} &amp; A \Pi_{2} 
  \end{bmatrix} = 
  A \Pi_{1} 
  \begin{bmatrix} 
   I &amp; T 
  \end{bmatrix}, 
 
where :math:`\Pi = [\Pi_{1}, \Pi_{2}]` is a permutation matrix with 
:math:`\Pi_{1} \in \{ 0, 1 \}^{n \times k}`, i.e., :math:`A \Pi_{2} = 
A \Pi_{1} T`. This can equivalently be written as :math:`A = BP`, 
where :math:`B = A \Pi_{1}` and :math:`P = [I, T] \Pi^{\mathsf{T}}` 
are the *skeleton* and *interpolation matrices*, respectively. 
 
If :math:`A` does not have exact rank :math:`k`, then there exists an 
approximation in the form of an ID such that :math:`A = BP + E`, where 
:math:`\| E \| \sim \sigma_{k + 1}` is on the order of the :math:`(k + 
1)`-th largest singular value of :math:`A`. Note that :math:`\sigma_{k 
+ 1}` is the best possible error for a rank-:math:`k` approximation 
and, in fact, is achieved by the singular value decomposition (SVD) 
:math:`A \approx U S V^{*}`, where :math:`U \in \mathbb{C}^{m \times 
k}` and :math:`V \in \mathbb{C}^{n \times k}` have orthonormal columns 
and :math:`S = \mathop{\mathrm{diag}} (\sigma_{i}) \in \mathbb{C}^{k 
\times k}` is diagonal with nonnegative entries. The principal 
advantages of using an ID over an SVD are that: 
 
- it is cheaper to construct; 
- it preserves the structure of :math:`A`; and 
- it is more efficient to compute with in light of the identity submatrix of :math:`P`. 
 
Routines 
======== 
 
Main functionality: 
 
.. autosummary:: 
   :toctree: generated/ 
 
   interp_decomp 
   reconstruct_matrix_from_id 
   reconstruct_interp_matrix 
   reconstruct_skel_matrix 
   id_to_svd 
   svd 
   estimate_spectral_norm 
   estimate_spectral_norm_diff 
   estimate_rank 
 
Support functions: 
 
.. autosummary:: 
   :toctree: generated/ 
 
   seed 
   rand 
 
 
References 
========== 
 
This module uses the ID software package [1]_ by Martinsson, Rokhlin, 
Shkolnisky, and Tygert, which is a Fortran library for computing IDs 
using various algorithms, including the rank-revealing QR approach of 
[2]_ and the more recent randomized methods described in [3]_, [4]_, 
and [5]_. This module exposes its functionality in a way convenient 
for Python users. Note that this module does not add any functionality 
beyond that of organizing a simpler and more consistent interface. 
 
We advise the user to consult also the `documentation for the ID package 
&lt;http://tygert.com/id_doc.4.pdf&gt;`_. 
 
.. [1] P.G. Martinsson, V. Rokhlin, Y. Shkolnisky, M. Tygert. &quot;ID: a 
    software package for low-rank approximation of matrices via interpolative 
    decompositions, version 0.2.&quot; http://tygert.com/id_doc.4.pdf. 
 
.. [2] H. Cheng, Z. Gimbutas, P.G. Martinsson, V. Rokhlin. &quot;On the 
    compression of low rank matrices.&quot; *SIAM J. Sci. Comput.* 26 (4): 1389--1404, 
    2005. :doi:`10.1137/030602678`. 
 
.. [3] E. Liberty, F. Woolfe, P.G. Martinsson, V. Rokhlin, M. 
    Tygert. &quot;Randomized algorithms for the low-rank approximation of matrices.&quot; 
    *Proc. Natl. Acad. Sci. U.S.A.* 104 (51): 20167--20172, 2007. 
    :doi:`10.1073/pnas.0709640104`. 
 
.. [4] P.G. Martinsson, V. Rokhlin, M. Tygert. &quot;A randomized 
    algorithm for the decomposition of matrices.&quot; *Appl. Comput. Harmon. Anal.* 30 
    (1): 47--68,  2011. :doi:`10.1016/j.acha.2010.02.003`. 
 
.. [5] F. Woolfe, E. Liberty, V. Rokhlin, M. Tygert. &quot;A fast 
    randomized algorithm for the approximation of matrices.&quot; *Appl. Comput. 
    Harmon. Anal.* 25 (3): 335--366, 2008. :doi:`10.1016/j.acha.2007.12.002`. 
 
 
Tutorial 
======== 
 
Initializing 
------------ 
 
The first step is to import :mod:`scipy.linalg.interpolative` by issuing the 
command: 
 
&gt;&gt;&gt; import scipy.linalg.interpolative as sli 
 
Now let's build a matrix. For this, we consider a Hilbert matrix, which is well 
know to have low rank: 
 
&gt;&gt;&gt; from scipy.linalg import hilbert 
&gt;&gt;&gt; n = 1000 
&gt;&gt;&gt; A = hilbert(n) 
 
We can also do this explicitly via: 
 
&gt;&gt;&gt; import numpy as np 
&gt;&gt;&gt; n = 1000 
&gt;&gt;&gt; A = np.empty((n, n), order='F') 
&gt;&gt;&gt; for j in range(n): 
...     for i in range(n): 
...         A[i,j] = 1. / (i + j + 1) 
 
Note the use of the flag ``order='F'`` in :func:`numpy.empty`. This 
instantiates the matrix in Fortran-contiguous order and is important for 
avoiding data copying when passing to the backend. 
 
We then define multiplication routines for the matrix by regarding it as a 
:class:`scipy.sparse.linalg.LinearOperator`: 
 
&gt;&gt;&gt; from scipy.sparse.linalg import aslinearoperator 
&gt;&gt;&gt; L = aslinearoperator(A) 
 
This automatically sets up methods describing the action of the matrix and its 
adjoint on a vector. 
 
Computing an ID 
--------------- 
 
We have several choices of algorithm to compute an ID. These fall largely 
according to two dichotomies: 
 
1. how the matrix is represented, i.e., via its entries or via its action on a 
   vector; and 
2. whether to approximate it to a fixed relative precision or to a fixed rank. 
 
We step through each choice in turn below. 
 
In all cases, the ID is represented by three parameters: 
 
1. a rank ``k``; 
2. an index array ``idx``; and 
3. interpolation coefficients ``proj``. 
 
The ID is specified by the relation 
``np.dot(A[:,idx[:k]], proj) == A[:,idx[k:]]``. 
 
From matrix entries 
................... 
 
We first consider a matrix given in terms of its entries. 
 
To compute an ID to a fixed precision, type: 
 
&gt;&gt;&gt; eps = 1e-3 
&gt;&gt;&gt; k, idx, proj = sli.interp_decomp(A, eps) 
 
where ``eps &lt; 1`` is the desired precision. 
 
To compute an ID to a fixed rank, use: 
 
&gt;&gt;&gt; idx, proj = sli.interp_decomp(A, k) 
 
where ``k &gt;= 1`` is the desired rank. 
 
Both algorithms use random sampling and are usually faster than the 
corresponding older, deterministic algorithms, which can be accessed via the 
commands: 
 
&gt;&gt;&gt; k, idx, proj = sli.interp_decomp(A, eps, rand=False) 
 
and: 
 
&gt;&gt;&gt; idx, proj = sli.interp_decomp(A, k, rand=False) 
 
respectively. 
 
From matrix action 
.................. 
 
Now consider a matrix given in terms of its action on a vector as a 
:class:`scipy.sparse.linalg.LinearOperator`. 
 
To compute an ID to a fixed precision, type: 
 
&gt;&gt;&gt; k, idx, proj = sli.interp_decomp(L, eps) 
 
To compute an ID to a fixed rank, use: 
 
&gt;&gt;&gt; idx, proj = sli.interp_decomp(L, k) 
 
These algorithms are randomized. 
 
Reconstructing an ID 
-------------------- 
 
The ID routines above do not output the skeleton and interpolation matrices 
explicitly but instead return the relevant information in a more compact (and 
sometimes more useful) form. To build these matrices, write: 
 
&gt;&gt;&gt; B = sli.reconstruct_skel_matrix(A, k, idx) 
 
for the skeleton matrix and: 
 
&gt;&gt;&gt; P = sli.reconstruct_interp_matrix(idx, proj) 
 
for the interpolation matrix. The ID approximation can then be computed as: 
 
&gt;&gt;&gt; C = np.dot(B, P) 
 
This can also be constructed directly using: 
 
&gt;&gt;&gt; C = sli.reconstruct_matrix_from_id(B, idx, proj) 
 
without having to first compute ``P``. 
 
Alternatively, this can be done explicitly as well using: 
 
&gt;&gt;&gt; B = A[:,idx[:k]] 
&gt;&gt;&gt; P = np.hstack([np.eye(k), proj])[:,np.argsort(idx)] 
&gt;&gt;&gt; C = np.dot(B, P) 
 
Computing an SVD 
---------------- 
 
An ID can be converted to an SVD via the command: 
 
&gt;&gt;&gt; U, S, V = sli.id_to_svd(B, idx, proj) 
 
The SVD approximation is then: 
 
&gt;&gt;&gt; approx = U @ np.diag(S) @ V.conj().T 
 
The SVD can also be computed &quot;fresh&quot; by combining both the ID and conversion 
steps into one command. Following the various ID algorithms above, there are 
correspondingly various SVD algorithms that one can employ. 
 
From matrix entries 
................... 
 
We consider first SVD algorithms for a matrix given in terms of its entries. 
 
To compute an SVD to a fixed precision, type: 
 
&gt;&gt;&gt; U, S, V = sli.svd(A, eps) 
 
To compute an SVD to a fixed rank, use: 
 
&gt;&gt;&gt; U, S, V = sli.svd(A, k) 
 
Both algorithms use random sampling; for the deterministic versions, issue the 
keyword ``rand=False`` as above. 
 
From matrix action 
.................. 
 
Now consider a matrix given in terms of its action on a vector. 
 
To compute an SVD to a fixed precision, type: 
 
&gt;&gt;&gt; U, S, V = sli.svd(L, eps) 
 
To compute an SVD to a fixed rank, use: 
 
&gt;&gt;&gt; U, S, V = sli.svd(L, k) 
 
Utility routines 
---------------- 
 
Several utility routines are also available. 
 
To estimate the spectral norm of a matrix, use: 
 
&gt;&gt;&gt; snorm = sli.estimate_spectral_norm(A) 
 
This algorithm is based on the randomized power method and thus requires only 
matrix-vector products. The number of iterations to take can be set using the 
keyword ``its`` (default: ``its=20``). The matrix is interpreted as a 
:class:`scipy.sparse.linalg.LinearOperator`, but it is also valid to supply it 
as a :class:`numpy.ndarray`, in which case it is trivially converted using 
:func:`scipy.sparse.linalg.aslinearoperator`. 
 
The same algorithm can also estimate the spectral norm of the difference of two 
matrices ``A1`` and ``A2`` as follows: 
 
&gt;&gt;&gt; A1, A2 = A**2, A 
&gt;&gt;&gt; diff = sli.estimate_spectral_norm_diff(A1, A2) 
 
This is often useful for checking the accuracy of a matrix approximation. 
 
Some routines in :mod:`scipy.linalg.interpolative` require estimating the rank 
of a matrix as well. This can be done with either: 
 
&gt;&gt;&gt; k = sli.estimate_rank(A, eps) 
 
or: 
 
&gt;&gt;&gt; k = sli.estimate_rank(L, eps) 
 
depending on the representation. The parameter ``eps`` controls the definition 
of the numerical rank. 
 
Finally, the random number generation required for all randomized routines can 
be controlled via :func:`scipy.linalg.interpolative.seed`. To reset the seed 
values to their original values, use: 
 
&gt;&gt;&gt; sli.seed('default') 
 
To specify the seed values, use: 
 
&gt;&gt;&gt; s = 42 
&gt;&gt;&gt; sli.seed(s) 
 
where ``s`` must be an integer or array of 55 floats. If an integer, the array 
of floats is obtained by using ``numpy.random.rand`` with the given integer 
seed. 
 
To simply generate some random numbers, type: 
 
&gt;&gt;&gt; arr = sli.rand(n) 
 
where ``n`` is the number of random numbers to generate. 
 
Remarks 
------- 
 
The above functions all automatically detect the appropriate interface and work 
with both real and complex data types, passing input arguments to the proper 
backend routine. 
 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">linalg</span><span class="s4">.</span><span class="s1">_interpolative_backend </span><span class="s3">as </span><span class="s1">_backend</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">sys</span>

<span class="s1">__all__ </span><span class="s4">= [</span>
    <span class="s5">'estimate_rank'</span><span class="s4">,</span>
    <span class="s5">'estimate_spectral_norm'</span><span class="s4">,</span>
    <span class="s5">'estimate_spectral_norm_diff'</span><span class="s4">,</span>
    <span class="s5">'id_to_svd'</span><span class="s4">,</span>
    <span class="s5">'interp_decomp'</span><span class="s4">,</span>
    <span class="s5">'rand'</span><span class="s4">,</span>
    <span class="s5">'reconstruct_interp_matrix'</span><span class="s4">,</span>
    <span class="s5">'reconstruct_matrix_from_id'</span><span class="s4">,</span>
    <span class="s5">'reconstruct_skel_matrix'</span><span class="s4">,</span>
    <span class="s5">'seed'</span><span class="s4">,</span>
    <span class="s5">'svd'</span><span class="s4">,</span>
<span class="s4">]</span>

<span class="s1">_DTYPE_ERROR </span><span class="s4">= </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;invalid input dtype (input must be float64 or complex128)&quot;</span><span class="s4">)</span>
<span class="s1">_TYPE_ERROR </span><span class="s4">= </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;invalid input type (must be array or LinearOperator)&quot;</span><span class="s4">)</span>
<span class="s1">_32BIT_ERROR </span><span class="s4">= </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;interpolative decomposition on 32-bit systems &quot;</span>
                          <span class="s5">&quot;with complex128 is buggy&quot;</span><span class="s4">)</span>
<span class="s1">_IS_32BIT </span><span class="s4">= (</span><span class="s1">sys</span><span class="s4">.</span><span class="s1">maxsize </span><span class="s4">&lt; </span><span class="s6">2</span><span class="s4">**</span><span class="s6">32</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_is_real</span><span class="s4">(</span><span class="s1">A</span><span class="s4">):</span>
    <span class="s3">try</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">A</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">== </span><span class="s1">np</span><span class="s4">.</span><span class="s1">complex128</span><span class="s4">:</span>
            <span class="s3">return False</span>
        <span class="s3">elif </span><span class="s1">A</span><span class="s4">.</span><span class="s1">dtype </span><span class="s4">== </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">:</span>
            <span class="s3">return True</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">_DTYPE_ERROR</span>
    <span class="s3">except </span><span class="s1">AttributeError </span><span class="s3">as </span><span class="s1">e</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_TYPE_ERROR </span><span class="s3">from </span><span class="s1">e</span>


<span class="s3">def </span><span class="s1">seed</span><span class="s4">(</span><span class="s1">seed</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Seed the internal random number generator used in this ID package. 
 
    The generator is a lagged Fibonacci method with 55-element internal state. 
 
    Parameters 
    ---------- 
    seed : int, sequence, 'default', optional 
        If 'default', the random seed is reset to a default value. 
 
        If `seed` is a sequence containing 55 floating-point numbers 
        in range [0,1], these are used to set the internal state of 
        the generator. 
 
        If the value is an integer, the internal state is obtained 
        from `numpy.random.RandomState` (MT19937) with the integer 
        used as the initial seed. 
 
        If `seed` is omitted (None), ``numpy.random.rand`` is used to 
        initialize the generator. 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># For details, see :func:`_backend.id_srand`, :func:`_backend.id_srandi`,</span>
    <span class="s0"># and :func:`_backend.id_srando`.</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">seed</span><span class="s4">, </span><span class="s1">str</span><span class="s4">) </span><span class="s3">and </span><span class="s1">seed </span><span class="s4">== </span><span class="s5">'default'</span><span class="s4">:</span>
        <span class="s1">_backend</span><span class="s4">.</span><span class="s1">id_srando</span><span class="s4">()</span>
    <span class="s3">elif </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">seed</span><span class="s4">, </span><span class="s5">'__len__'</span><span class="s4">):</span>
        <span class="s1">state </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asfortranarray</span><span class="s4">(</span><span class="s1">seed</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">float</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">state</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">!= (</span><span class="s6">55</span><span class="s4">,):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;invalid input size&quot;</span><span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">state</span><span class="s4">.</span><span class="s1">min</span><span class="s4">() &lt; </span><span class="s6">0 </span><span class="s3">or </span><span class="s1">state</span><span class="s4">.</span><span class="s1">max</span><span class="s4">() &gt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;values not in range [0,1]&quot;</span><span class="s4">)</span>
        <span class="s1">_backend</span><span class="s4">.</span><span class="s1">id_srandi</span><span class="s4">(</span><span class="s1">state</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">seed </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">_backend</span><span class="s4">.</span><span class="s1">id_srandi</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">rand</span><span class="s4">(</span><span class="s6">55</span><span class="s4">))</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">rnd </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">random</span><span class="s4">.</span><span class="s1">RandomState</span><span class="s4">(</span><span class="s1">seed</span><span class="s4">)</span>
        <span class="s1">_backend</span><span class="s4">.</span><span class="s1">id_srandi</span><span class="s4">(</span><span class="s1">rnd</span><span class="s4">.</span><span class="s1">rand</span><span class="s4">(</span><span class="s6">55</span><span class="s4">))</span>


<span class="s3">def </span><span class="s1">rand</span><span class="s4">(*</span><span class="s1">shape</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Generate standard uniform pseudorandom numbers via a very efficient lagged 
    Fibonacci method. 
 
    This routine is used for all random number generation in this package and 
    can affect ID and SVD results. 
 
    Parameters 
    ---------- 
    *shape 
        Shape of output array 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># For details, see :func:`_backend.id_srand`, and :func:`_backend.id_srando`.</span>
    <span class="s3">return </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">id_srand</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">prod</span><span class="s4">(</span><span class="s1">shape</span><span class="s4">)).</span><span class="s1">reshape</span><span class="s4">(</span><span class="s1">shape</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">interp_decomp</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">eps_or_k</span><span class="s4">, </span><span class="s1">rand</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Compute ID of a matrix. 
 
    An ID of a matrix `A` is a factorization defined by a rank `k`, a column 
    index array `idx`, and interpolation coefficients `proj` such that:: 
 
        numpy.dot(A[:,idx[:k]], proj) = A[:,idx[k:]] 
 
    The original matrix can then be reconstructed as:: 
 
        numpy.hstack([A[:,idx[:k]], 
                                    numpy.dot(A[:,idx[:k]], proj)] 
                                )[:,numpy.argsort(idx)] 
 
    or via the routine :func:`reconstruct_matrix_from_id`. This can 
    equivalently be written as:: 
 
        numpy.dot(A[:,idx[:k]], 
                            numpy.hstack([numpy.eye(k), proj]) 
                          )[:,np.argsort(idx)] 
 
    in terms of the skeleton and interpolation matrices:: 
 
        B = A[:,idx[:k]] 
 
    and:: 
 
        P = numpy.hstack([numpy.eye(k), proj])[:,np.argsort(idx)] 
 
    respectively. See also :func:`reconstruct_interp_matrix` and 
    :func:`reconstruct_skel_matrix`. 
 
    The ID can be computed to any relative precision or rank (depending on the 
    value of `eps_or_k`). If a precision is specified (`eps_or_k &lt; 1`), then 
    this function has the output signature:: 
 
        k, idx, proj = interp_decomp(A, eps_or_k) 
 
    Otherwise, if a rank is specified (`eps_or_k &gt;= 1`), then the output 
    signature is:: 
 
        idx, proj = interp_decomp(A, eps_or_k) 
 
    ..  This function automatically detects the form of the input parameters 
        and passes them to the appropriate backend. For details, see 
        :func:`_backend.iddp_id`, :func:`_backend.iddp_aid`, 
        :func:`_backend.iddp_rid`, :func:`_backend.iddr_id`, 
        :func:`_backend.iddr_aid`, :func:`_backend.iddr_rid`, 
        :func:`_backend.idzp_id`, :func:`_backend.idzp_aid`, 
        :func:`_backend.idzp_rid`, :func:`_backend.idzr_id`, 
        :func:`_backend.idzr_aid`, and :func:`_backend.idzr_rid`. 
 
    Parameters 
    ---------- 
    A : :class:`numpy.ndarray` or :class:`scipy.sparse.linalg.LinearOperator` with `rmatvec` 
        Matrix to be factored 
    eps_or_k : float or int 
        Relative error (if `eps_or_k &lt; 1`) or rank (if `eps_or_k &gt;= 1`) of 
        approximation. 
    rand : bool, optional 
        Whether to use random sampling if `A` is of type :class:`numpy.ndarray` 
        (randomized algorithms are always used if `A` is of type 
        :class:`scipy.sparse.linalg.LinearOperator`). 
 
    Returns 
    ------- 
    k : int 
        Rank required to achieve specified relative precision if 
        `eps_or_k &lt; 1`. 
    idx : :class:`numpy.ndarray` 
        Column index array. 
    proj : :class:`numpy.ndarray` 
        Interpolation coefficients. 
    &quot;&quot;&quot;  </span><span class="s0"># numpy/numpydoc#87  # noqa: E501</span>
    <span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">linalg </span><span class="s3">import </span><span class="s1">LinearOperator</span>

    <span class="s1">real </span><span class="s4">= </span><span class="s1">_is_real</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">eps_or_k </span><span class="s4">&lt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s1">eps </span><span class="s4">= </span><span class="s1">eps_or_k</span>
            <span class="s3">if </span><span class="s1">rand</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">real</span><span class="s4">:</span>
                    <span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">iddp_aid</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">_IS_32BIT</span><span class="s4">:</span>
                        <span class="s3">raise </span><span class="s1">_32BIT_ERROR</span>
                    <span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idzp_aid</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">real</span><span class="s4">:</span>
                    <span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">iddp_id</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idzp_id</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">k</span><span class="s4">, </span><span class="s1">idx </span><span class="s4">- </span><span class="s6">1</span><span class="s4">, </span><span class="s1">proj</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">k </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">eps_or_k</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">rand</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">real</span><span class="s4">:</span>
                    <span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">iddr_aid</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">_IS_32BIT</span><span class="s4">:</span>
                        <span class="s3">raise </span><span class="s1">_32BIT_ERROR</span>
                    <span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idzr_aid</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">real</span><span class="s4">:</span>
                    <span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">iddr_id</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idzr_id</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">idx </span><span class="s4">- </span><span class="s6">1</span><span class="s4">, </span><span class="s1">proj</span>
    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">LinearOperator</span><span class="s4">):</span>
        <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span>
        <span class="s1">matveca </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">rmatvec</span>
        <span class="s3">if </span><span class="s1">eps_or_k </span><span class="s4">&lt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s1">eps </span><span class="s4">= </span><span class="s1">eps_or_k</span>
            <span class="s3">if </span><span class="s1">real</span><span class="s4">:</span>
                <span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">iddp_rid</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">_IS_32BIT</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">_32BIT_ERROR</span>
                <span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idzp_rid</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">k</span><span class="s4">, </span><span class="s1">idx </span><span class="s4">- </span><span class="s6">1</span><span class="s4">, </span><span class="s1">proj</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">k </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">eps_or_k</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">real</span><span class="s4">:</span>
                <span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">iddr_rid</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">_IS_32BIT</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">_32BIT_ERROR</span>
                <span class="s1">idx</span><span class="s4">, </span><span class="s1">proj </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idzr_rid</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">idx </span><span class="s4">- </span><span class="s6">1</span><span class="s4">, </span><span class="s1">proj</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_TYPE_ERROR</span>


<span class="s3">def </span><span class="s1">reconstruct_matrix_from_id</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reconstruct matrix from its ID. 
 
    A matrix `A` with skeleton matrix `B` and ID indices and coefficients `idx` 
    and `proj`, respectively, can be reconstructed as:: 
 
        numpy.hstack([B, numpy.dot(B, proj)])[:,numpy.argsort(idx)] 
 
    See also :func:`reconstruct_interp_matrix` and 
    :func:`reconstruct_skel_matrix`. 
 
    ..  This function automatically detects the matrix data type and calls the 
        appropriate backend. For details, see :func:`_backend.idd_reconid` and 
        :func:`_backend.idz_reconid`. 
 
    Parameters 
    ---------- 
    B : :class:`numpy.ndarray` 
        Skeleton matrix. 
    idx : :class:`numpy.ndarray` 
        Column index array. 
    proj : :class:`numpy.ndarray` 
        Interpolation coefficients. 
 
    Returns 
    ------- 
    :class:`numpy.ndarray` 
        Reconstructed matrix. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">_is_real</span><span class="s4">(</span><span class="s1">B</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idd_reconid</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">idx </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idz_reconid</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">idx </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">reconstruct_interp_matrix</span><span class="s4">(</span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reconstruct interpolation matrix from ID. 
 
    The interpolation matrix can be reconstructed from the ID indices and 
    coefficients `idx` and `proj`, respectively, as:: 
 
        P = numpy.hstack([numpy.eye(proj.shape[0]), proj])[:,numpy.argsort(idx)] 
 
    The original matrix can then be reconstructed from its skeleton matrix `B` 
    via:: 
 
        numpy.dot(B, P) 
 
    See also :func:`reconstruct_matrix_from_id` and 
    :func:`reconstruct_skel_matrix`. 
 
    ..  This function automatically detects the matrix data type and calls the 
        appropriate backend. For details, see :func:`_backend.idd_reconint` and 
        :func:`_backend.idz_reconint`. 
 
    Parameters 
    ---------- 
    idx : :class:`numpy.ndarray` 
        Column index array. 
    proj : :class:`numpy.ndarray` 
        Interpolation coefficients. 
 
    Returns 
    ------- 
    :class:`numpy.ndarray` 
        Interpolation matrix. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">_is_real</span><span class="s4">(</span><span class="s1">proj</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idd_reconint</span><span class="s4">(</span><span class="s1">idx </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idz_reconint</span><span class="s4">(</span><span class="s1">idx </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">reconstruct_skel_matrix</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Reconstruct skeleton matrix from ID. 
 
    The skeleton matrix can be reconstructed from the original matrix `A` and its 
    ID rank and indices `k` and `idx`, respectively, as:: 
 
        B = A[:,idx[:k]] 
 
    The original matrix can then be reconstructed via:: 
 
        numpy.hstack([B, numpy.dot(B, proj)])[:,numpy.argsort(idx)] 
 
    See also :func:`reconstruct_matrix_from_id` and 
    :func:`reconstruct_interp_matrix`. 
 
    ..  This function automatically detects the matrix data type and calls the 
        appropriate backend. For details, see :func:`_backend.idd_copycols` and 
        :func:`_backend.idz_copycols`. 
 
    Parameters 
    ---------- 
    A : :class:`numpy.ndarray` 
        Original matrix. 
    k : int 
        Rank of ID. 
    idx : :class:`numpy.ndarray` 
        Column index array. 
 
    Returns 
    ------- 
    :class:`numpy.ndarray` 
        Skeleton matrix. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">_is_real</span><span class="s4">(</span><span class="s1">A</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idd_copycols</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">idx </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idz_copycols</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">, </span><span class="s1">idx </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">id_to_svd</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">idx</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Convert ID to SVD. 
 
    The SVD reconstruction of a matrix with skeleton matrix `B` and ID indices and 
    coefficients `idx` and `proj`, respectively, is:: 
 
        U, S, V = id_to_svd(B, idx, proj) 
        A = numpy.dot(U, numpy.dot(numpy.diag(S), V.conj().T)) 
 
    See also :func:`svd`. 
 
    ..  This function automatically detects the matrix data type and calls the 
        appropriate backend. For details, see :func:`_backend.idd_id2svd` and 
        :func:`_backend.idz_id2svd`. 
 
    Parameters 
    ---------- 
    B : :class:`numpy.ndarray` 
        Skeleton matrix. 
    idx : :class:`numpy.ndarray` 
        Column index array. 
    proj : :class:`numpy.ndarray` 
        Interpolation coefficients. 
 
    Returns 
    ------- 
    U : :class:`numpy.ndarray` 
        Left singular vectors. 
    S : :class:`numpy.ndarray` 
        Singular values. 
    V : :class:`numpy.ndarray` 
        Right singular vectors. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">_is_real</span><span class="s4">(</span><span class="s1">B</span><span class="s4">):</span>
        <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idd_id2svd</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">idx </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idz_id2svd</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">idx </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">, </span><span class="s1">proj</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">S</span><span class="s4">, </span><span class="s1">V</span>


<span class="s3">def </span><span class="s1">estimate_spectral_norm</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">its</span><span class="s4">=</span><span class="s6">20</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate spectral norm of a matrix by the randomized power method. 
 
    ..  This function automatically detects the matrix data type and calls the 
        appropriate backend. For details, see :func:`_backend.idd_snorm` and 
        :func:`_backend.idz_snorm`. 
 
    Parameters 
    ---------- 
    A : :class:`scipy.sparse.linalg.LinearOperator` 
        Matrix given as a :class:`scipy.sparse.linalg.LinearOperator` with the 
        `matvec` and `rmatvec` methods (to apply the matrix and its adjoint). 
    its : int, optional 
        Number of power method iterations. 
 
    Returns 
    ------- 
    float 
        Spectral norm estimate. 
    &quot;&quot;&quot;</span>
    <span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">linalg </span><span class="s3">import </span><span class="s1">aslinearoperator</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">aslinearoperator</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s3">def </span><span class="s1">matvec</span><span class="s4">(</span><span class="s1">x</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">A</span><span class="s4">.</span><span class="s1">matvec</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">matveca</span><span class="s4">(</span><span class="s1">x</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">A</span><span class="s4">.</span><span class="s1">rmatvec</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">_is_real</span><span class="s4">(</span><span class="s1">A</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idd_snorm</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">, </span><span class="s1">its</span><span class="s4">=</span><span class="s1">its</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idz_snorm</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">, </span><span class="s1">its</span><span class="s4">=</span><span class="s1">its</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">estimate_spectral_norm_diff</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">B</span><span class="s4">, </span><span class="s1">its</span><span class="s4">=</span><span class="s6">20</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate spectral norm of the difference of two matrices by the randomized 
    power method. 
 
    ..  This function automatically detects the matrix data type and calls the 
        appropriate backend. For details, see :func:`_backend.idd_diffsnorm` and 
        :func:`_backend.idz_diffsnorm`. 
 
    Parameters 
    ---------- 
    A : :class:`scipy.sparse.linalg.LinearOperator` 
        First matrix given as a :class:`scipy.sparse.linalg.LinearOperator` with the 
        `matvec` and `rmatvec` methods (to apply the matrix and its adjoint). 
    B : :class:`scipy.sparse.linalg.LinearOperator` 
        Second matrix given as a :class:`scipy.sparse.linalg.LinearOperator` with 
        the `matvec` and `rmatvec` methods (to apply the matrix and its adjoint). 
    its : int, optional 
        Number of power method iterations. 
 
    Returns 
    ------- 
    float 
        Spectral norm estimate of matrix difference. 
    &quot;&quot;&quot;</span>
    <span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">linalg </span><span class="s3">import </span><span class="s1">aslinearoperator</span>
    <span class="s1">A </span><span class="s4">= </span><span class="s1">aslinearoperator</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>
    <span class="s1">B </span><span class="s4">= </span><span class="s1">aslinearoperator</span><span class="s4">(</span><span class="s1">B</span><span class="s4">)</span>
    <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s3">def </span><span class="s1">matvec1</span><span class="s4">(</span><span class="s1">x</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">A</span><span class="s4">.</span><span class="s1">matvec</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">matveca1</span><span class="s4">(</span><span class="s1">x</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">A</span><span class="s4">.</span><span class="s1">rmatvec</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">matvec2</span><span class="s4">(</span><span class="s1">x</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">B</span><span class="s4">.</span><span class="s1">matvec</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">matveca2</span><span class="s4">(</span><span class="s1">x</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">B</span><span class="s4">.</span><span class="s1">rmatvec</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">_is_real</span><span class="s4">(</span><span class="s1">A</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idd_diffsnorm</span><span class="s4">(</span>
            <span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca1</span><span class="s4">, </span><span class="s1">matveca2</span><span class="s4">, </span><span class="s1">matvec1</span><span class="s4">, </span><span class="s1">matvec2</span><span class="s4">, </span><span class="s1">its</span><span class="s4">=</span><span class="s1">its</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idz_diffsnorm</span><span class="s4">(</span>
            <span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca1</span><span class="s4">, </span><span class="s1">matveca2</span><span class="s4">, </span><span class="s1">matvec1</span><span class="s4">, </span><span class="s1">matvec2</span><span class="s4">, </span><span class="s1">its</span><span class="s4">=</span><span class="s1">its</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">svd</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">eps_or_k</span><span class="s4">, </span><span class="s1">rand</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute SVD of a matrix via an ID. 
 
    An SVD of a matrix `A` is a factorization:: 
 
        A = numpy.dot(U, numpy.dot(numpy.diag(S), V.conj().T)) 
 
    where `U` and `V` have orthonormal columns and `S` is nonnegative. 
 
    The SVD can be computed to any relative precision or rank (depending on the 
    value of `eps_or_k`). 
 
    See also :func:`interp_decomp` and :func:`id_to_svd`. 
 
    ..  This function automatically detects the form of the input parameters and 
        passes them to the appropriate backend. For details, see 
        :func:`_backend.iddp_svd`, :func:`_backend.iddp_asvd`, 
        :func:`_backend.iddp_rsvd`, :func:`_backend.iddr_svd`, 
        :func:`_backend.iddr_asvd`, :func:`_backend.iddr_rsvd`, 
        :func:`_backend.idzp_svd`, :func:`_backend.idzp_asvd`, 
        :func:`_backend.idzp_rsvd`, :func:`_backend.idzr_svd`, 
        :func:`_backend.idzr_asvd`, and :func:`_backend.idzr_rsvd`. 
 
    Parameters 
    ---------- 
    A : :class:`numpy.ndarray` or :class:`scipy.sparse.linalg.LinearOperator` 
        Matrix to be factored, given as either a :class:`numpy.ndarray` or a 
        :class:`scipy.sparse.linalg.LinearOperator` with the `matvec` and 
        `rmatvec` methods (to apply the matrix and its adjoint). 
    eps_or_k : float or int 
        Relative error (if `eps_or_k &lt; 1`) or rank (if `eps_or_k &gt;= 1`) of 
        approximation. 
    rand : bool, optional 
        Whether to use random sampling if `A` is of type :class:`numpy.ndarray` 
        (randomized algorithms are always used if `A` is of type 
        :class:`scipy.sparse.linalg.LinearOperator`). 
 
    Returns 
    ------- 
    U : :class:`numpy.ndarray` 
        Left singular vectors. 
    S : :class:`numpy.ndarray` 
        Singular values. 
    V : :class:`numpy.ndarray` 
        Right singular vectors. 
    &quot;&quot;&quot;</span>
    <span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">linalg </span><span class="s3">import </span><span class="s1">LinearOperator</span>

    <span class="s1">real </span><span class="s4">= </span><span class="s1">_is_real</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">eps_or_k </span><span class="s4">&lt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s1">eps </span><span class="s4">= </span><span class="s1">eps_or_k</span>
            <span class="s3">if </span><span class="s1">rand</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">real</span><span class="s4">:</span>
                    <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">iddp_asvd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">_IS_32BIT</span><span class="s4">:</span>
                        <span class="s3">raise </span><span class="s1">_32BIT_ERROR</span>
                    <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idzp_asvd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">real</span><span class="s4">:</span>
                    <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">iddp_svd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idzp_svd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">k </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">eps_or_k</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">k </span><span class="s4">&gt; </span><span class="s1">min</span><span class="s4">(</span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;Approximation rank </span><span class="s3">{</span><span class="s1">k</span><span class="s3">} </span><span class="s5">exceeds min(A.shape) = &quot;</span>
                                 <span class="s5">f&quot; </span><span class="s3">{</span><span class="s1">min</span><span class="s4">(</span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">)</span><span class="s3">} </span><span class="s5">&quot;</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">rand</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">real</span><span class="s4">:</span>
                    <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">iddr_asvd</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s3">if </span><span class="s1">_IS_32BIT</span><span class="s4">:</span>
                        <span class="s3">raise </span><span class="s1">_32BIT_ERROR</span>
                    <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idzr_asvd</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">real</span><span class="s4">:</span>
                    <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">iddr_svd</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idzr_svd</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">LinearOperator</span><span class="s4">):</span>
        <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span>
        <span class="s3">def </span><span class="s1">matvec</span><span class="s4">(</span><span class="s1">x</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">A</span><span class="s4">.</span><span class="s1">matvec</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
        <span class="s3">def </span><span class="s1">matveca</span><span class="s4">(</span><span class="s1">x</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">A</span><span class="s4">.</span><span class="s1">rmatvec</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">eps_or_k </span><span class="s4">&lt; </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s1">eps </span><span class="s4">= </span><span class="s1">eps_or_k</span>
            <span class="s3">if </span><span class="s1">real</span><span class="s4">:</span>
                <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">iddp_rsvd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">_IS_32BIT</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">_32BIT_ERROR</span>
                <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idzp_rsvd</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">k </span><span class="s4">= </span><span class="s1">int</span><span class="s4">(</span><span class="s1">eps_or_k</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">real</span><span class="s4">:</span>
                <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">iddr_rsvd</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">_IS_32BIT</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">_32BIT_ERROR</span>
                <span class="s1">U</span><span class="s4">, </span><span class="s1">V</span><span class="s4">, </span><span class="s1">S </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idzr_rsvd</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">, </span><span class="s1">matvec</span><span class="s4">, </span><span class="s1">k</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_TYPE_ERROR</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s4">, </span><span class="s1">S</span><span class="s4">, </span><span class="s1">V</span>


<span class="s3">def </span><span class="s1">estimate_rank</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">eps</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimate matrix rank to a specified relative precision using randomized 
    methods. 
 
    The matrix `A` can be given as either a :class:`numpy.ndarray` or a 
    :class:`scipy.sparse.linalg.LinearOperator`, with different algorithms used 
    for each case. If `A` is of type :class:`numpy.ndarray`, then the output 
    rank is typically about 8 higher than the actual numerical rank. 
 
    ..  This function automatically detects the form of the input parameters and 
        passes them to the appropriate backend. For details, 
        see :func:`_backend.idd_estrank`, :func:`_backend.idd_findrank`, 
        :func:`_backend.idz_estrank`, and :func:`_backend.idz_findrank`. 
 
    Parameters 
    ---------- 
    A : :class:`numpy.ndarray` or :class:`scipy.sparse.linalg.LinearOperator` 
        Matrix whose rank is to be estimated, given as either a 
        :class:`numpy.ndarray` or a :class:`scipy.sparse.linalg.LinearOperator` 
        with the `rmatvec` method (to apply the matrix adjoint). 
    eps : float 
        Relative error for numerical rank definition. 
 
    Returns 
    ------- 
    int 
        Estimated matrix rank. 
    &quot;&quot;&quot;</span>
    <span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">linalg </span><span class="s3">import </span><span class="s1">LinearOperator</span>

    <span class="s1">real </span><span class="s4">= </span><span class="s1">_is_real</span><span class="s4">(</span><span class="s1">A</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">real</span><span class="s4">:</span>
            <span class="s1">rank </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idd_estrank</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">rank </span><span class="s4">= </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idz_estrank</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">A</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">rank </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s0"># special return value for nearly full rank</span>
            <span class="s1">rank </span><span class="s4">= </span><span class="s1">min</span><span class="s4">(</span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">rank</span>
    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">A</span><span class="s4">, </span><span class="s1">LinearOperator</span><span class="s4">):</span>
        <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">shape</span>
        <span class="s1">matveca </span><span class="s4">= </span><span class="s1">A</span><span class="s4">.</span><span class="s1">rmatvec</span>
        <span class="s3">if </span><span class="s1">real</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idd_findrank</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_backend</span><span class="s4">.</span><span class="s1">idz_findrank</span><span class="s4">(</span><span class="s1">eps</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">matveca</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">_TYPE_ERROR</span>
</pre>
</body>
</html>