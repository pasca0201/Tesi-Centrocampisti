<html>
<head>
<title>_indexing.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_indexing.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numbers</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">UserList</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">compress</span><span class="s2">, </span><span class="s1">islice</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">sparse </span><span class="s0">import </span><span class="s1">issparse</span>

<span class="s0">from </span><span class="s2">.</span><span class="s1">_array_api </span><span class="s0">import </span><span class="s1">_is_numpy_namespace</span><span class="s2">, </span><span class="s1">get_namespace</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_param_validation </span><span class="s0">import </span><span class="s1">Interval</span><span class="s2">, </span><span class="s1">validate_params</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">extmath </span><span class="s0">import </span><span class="s1">_approximate_mode</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">validation </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">_is_arraylike_not_scalar</span><span class="s2">,</span>
    <span class="s1">_is_pandas_df</span><span class="s2">,</span>
    <span class="s1">_is_polars_df_or_series</span><span class="s2">,</span>
    <span class="s1">_use_interchange_protocol</span><span class="s2">,</span>
    <span class="s1">check_array</span><span class="s2">,</span>
    <span class="s1">check_consistent_length</span><span class="s2">,</span>
    <span class="s1">check_random_state</span><span class="s2">,</span>
<span class="s2">)</span>


<span class="s0">def </span><span class="s1">_array_indexing</span><span class="s2">(</span><span class="s1">array</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">key_dtype</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Index an array or scipy.sparse consistently across NumPy version.&quot;&quot;&quot;</span>
    <span class="s1">xp</span><span class="s2">, </span><span class="s1">is_array_api </span><span class="s2">= </span><span class="s1">get_namespace</span><span class="s2">(</span><span class="s1">array</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">is_array_api</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">xp</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span><span class="s1">array</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">issparse</span><span class="s2">(</span><span class="s1">array</span><span class="s2">) </span><span class="s0">and </span><span class="s1">key_dtype </span><span class="s2">== </span><span class="s4">&quot;bool&quot;</span><span class="s2">:</span>
        <span class="s1">key </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
        <span class="s1">key </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">array</span><span class="s2">[</span><span class="s1">key</span><span class="s2">, ...] </span><span class="s0">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s5">0 </span><span class="s0">else </span><span class="s1">array</span><span class="s2">[:, </span><span class="s1">key</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">_pandas_indexing</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">key_dtype</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Index a pandas dataframe or a series.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">_is_arraylike_not_scalar</span><span class="s2">(</span><span class="s1">key</span><span class="s2">):</span>
        <span class="s1">key </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">key_dtype </span><span class="s2">== </span><span class="s4">&quot;int&quot; </span><span class="s0">and not </span><span class="s2">(</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">) </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isscalar</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)):</span>
        <span class="s6"># using take() instead of iloc[] ensures the return value is a &quot;proper&quot;</span>
        <span class="s6"># copy that will not raise SettingWithCopyWarning</span>
        <span class="s0">return </span><span class="s1">X</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s6"># check whether we should index with loc or iloc</span>
        <span class="s1">indexer </span><span class="s2">= </span><span class="s1">X</span><span class="s2">.</span><span class="s1">iloc </span><span class="s0">if </span><span class="s1">key_dtype </span><span class="s2">== </span><span class="s4">&quot;int&quot; </span><span class="s0">else </span><span class="s1">X</span><span class="s2">.</span><span class="s1">loc</span>
        <span class="s0">return </span><span class="s1">indexer</span><span class="s2">[:, </span><span class="s1">key</span><span class="s2">] </span><span class="s0">if </span><span class="s1">axis </span><span class="s0">else </span><span class="s1">indexer</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">_list_indexing</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">key_dtype</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Index a Python list.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isscalar</span><span class="s2">(</span><span class="s1">key</span><span class="s2">) </span><span class="s0">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">):</span>
        <span class="s6"># key is a slice or a scalar</span>
        <span class="s0">return </span><span class="s1">X</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]</span>
    <span class="s0">if </span><span class="s1">key_dtype </span><span class="s2">== </span><span class="s4">&quot;bool&quot;</span><span class="s2">:</span>
        <span class="s6"># key is a boolean array-like</span>
        <span class="s0">return </span><span class="s1">list</span><span class="s2">(</span><span class="s1">compress</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">key</span><span class="s2">))</span>
    <span class="s6"># key is a integer array-like of key</span>
    <span class="s0">return </span><span class="s2">[</span><span class="s1">X</span><span class="s2">[</span><span class="s1">idx</span><span class="s2">] </span><span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">key</span><span class="s2">]</span>


<span class="s0">def </span><span class="s1">_polars_indexing</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">key_dtype</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Indexing X with polars interchange protocol.&quot;&quot;&quot;</span>
    <span class="s6"># Polars behavior is more consistent with lists</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">):</span>
        <span class="s6"># Convert each element of the array to a Python scalar</span>
        <span class="s1">key </span><span class="s2">= </span><span class="s1">key</span><span class="s2">.</span><span class="s1">tolist</span><span class="s2">()</span>
    <span class="s0">elif not </span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isscalar</span><span class="s2">(</span><span class="s1">key</span><span class="s2">) </span><span class="s0">or </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">)):</span>
        <span class="s1">key </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s6"># Here we are certain to have a polars DataFrame; which can be indexed with</span>
        <span class="s6"># integer and string scalar, and list of integer, string and boolean</span>
        <span class="s0">return </span><span class="s1">X</span><span class="s2">[:, </span><span class="s1">key</span><span class="s2">]</span>

    <span class="s0">if </span><span class="s1">key_dtype </span><span class="s2">== </span><span class="s4">&quot;bool&quot;</span><span class="s2">:</span>
        <span class="s6"># Boolean mask can be indexed in the same way for Series and DataFrame (axis=0)</span>
        <span class="s0">return </span><span class="s1">X</span><span class="s2">.</span><span class="s1">filter</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>

    <span class="s6"># Integer scalar and list of integer can be indexed in the same way for Series and</span>
    <span class="s6"># DataFrame (axis=0)</span>
    <span class="s1">X_indexed </span><span class="s2">= </span><span class="s1">X</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isscalar</span><span class="s2">(</span><span class="s1">key</span><span class="s2">) </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">X</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) == </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s6"># `X_indexed` is a DataFrame with a single row; we return a Series to be</span>
        <span class="s6"># consistent with pandas</span>
        <span class="s1">pl </span><span class="s2">= </span><span class="s1">sys</span><span class="s2">.</span><span class="s1">modules</span><span class="s2">[</span><span class="s4">&quot;polars&quot;</span><span class="s2">]</span>
        <span class="s0">return </span><span class="s1">pl</span><span class="s2">.</span><span class="s1">Series</span><span class="s2">(</span><span class="s1">X_indexed</span><span class="s2">.</span><span class="s1">row</span><span class="s2">(</span><span class="s5">0</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s1">X_indexed</span>


<span class="s0">def </span><span class="s1">_determine_key_type</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">accept_slice</span><span class="s2">=</span><span class="s0">True</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Determine the data type of key. 
 
    Parameters 
    ---------- 
    key : scalar, slice or array-like 
        The key from which we want to infer the data type. 
 
    accept_slice : bool, default=True 
        Whether or not to raise an error if the key is a slice. 
 
    Returns 
    ------- 
    dtype : {'int', 'str', 'bool', None} 
        Returns the data type of key. 
    &quot;&quot;&quot;</span>
    <span class="s1">err_msg </span><span class="s2">= (</span>
        <span class="s4">&quot;No valid specification of the columns. Only a scalar, list or &quot;</span>
        <span class="s4">&quot;slice of all integers or all strings, or boolean mask is &quot;</span>
        <span class="s4">&quot;allowed&quot;</span>
    <span class="s2">)</span>

    <span class="s1">dtype_to_str </span><span class="s2">= {</span><span class="s1">int</span><span class="s2">: </span><span class="s4">&quot;int&quot;</span><span class="s2">, </span><span class="s1">str</span><span class="s2">: </span><span class="s4">&quot;str&quot;</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">: </span><span class="s4">&quot;bool&quot;</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">: </span><span class="s4">&quot;bool&quot;</span><span class="s2">}</span>
    <span class="s1">array_dtype_to_str </span><span class="s2">= {</span>
        <span class="s4">&quot;i&quot;</span><span class="s2">: </span><span class="s4">&quot;int&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;u&quot;</span><span class="s2">: </span><span class="s4">&quot;int&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;b&quot;</span><span class="s2">: </span><span class="s4">&quot;bool&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;O&quot;</span><span class="s2">: </span><span class="s4">&quot;str&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;U&quot;</span><span class="s2">: </span><span class="s4">&quot;str&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;S&quot;</span><span class="s2">: </span><span class="s4">&quot;str&quot;</span><span class="s2">,</span>
    <span class="s2">}</span>

    <span class="s0">if </span><span class="s1">key </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">return None</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">dtype_to_str</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())):</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">dtype_to_str</span><span class="s2">[</span><span class="s1">type</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)]</span>
        <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">err_msg</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">):</span>
        <span class="s0">if not </span><span class="s1">accept_slice</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">TypeError</span><span class="s2">(</span>
                <span class="s4">&quot;Only array-like or scalar are supported. A Python slice was given.&quot;</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">key</span><span class="s2">.</span><span class="s1">start </span><span class="s0">is None and </span><span class="s1">key</span><span class="s2">.</span><span class="s1">stop </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">return None</span>
        <span class="s1">key_start_type </span><span class="s2">= </span><span class="s1">_determine_key_type</span><span class="s2">(</span><span class="s1">key</span><span class="s2">.</span><span class="s1">start</span><span class="s2">)</span>
        <span class="s1">key_stop_type </span><span class="s2">= </span><span class="s1">_determine_key_type</span><span class="s2">(</span><span class="s1">key</span><span class="s2">.</span><span class="s1">stop</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">key_start_type </span><span class="s0">is not None and </span><span class="s1">key_stop_type </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">key_start_type </span><span class="s2">!= </span><span class="s1">key_stop_type</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">err_msg</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">key_start_type </span><span class="s0">is not None</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">key_start_type</span>
        <span class="s0">return </span><span class="s1">key_stop_type</span>
    <span class="s6"># TODO(1.9) remove UserList when the force_int_remainder_cols param</span>
    <span class="s6"># of ColumnTransformer is removed</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, (</span><span class="s1">list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">UserList</span><span class="s2">)):</span>
        <span class="s1">unique_key </span><span class="s2">= </span><span class="s1">set</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
        <span class="s1">key_type </span><span class="s2">= {</span><span class="s1">_determine_key_type</span><span class="s2">(</span><span class="s1">elt</span><span class="s2">) </span><span class="s0">for </span><span class="s1">elt </span><span class="s0">in </span><span class="s1">unique_key</span><span class="s2">}</span>
        <span class="s0">if not </span><span class="s1">key_type</span><span class="s2">:</span>
            <span class="s0">return None</span>
        <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">key_type</span><span class="s2">) != </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">err_msg</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">key_type</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">()</span>
    <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s4">&quot;dtype&quot;</span><span class="s2">):</span>
        <span class="s1">xp</span><span class="s2">, </span><span class="s1">is_array_api </span><span class="s2">= </span><span class="s1">get_namespace</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
        <span class="s6"># NumPy arrays are special-cased in their own branch because the Array API</span>
        <span class="s6"># cannot handle object/string-based dtypes that are often used to index</span>
        <span class="s6"># columns of dataframes by names.</span>
        <span class="s0">if </span><span class="s1">is_array_api </span><span class="s0">and not </span><span class="s1">_is_numpy_namespace</span><span class="s2">(</span><span class="s1">xp</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">xp</span><span class="s2">.</span><span class="s1">isdtype</span><span class="s2">(</span><span class="s1">key</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s4">&quot;bool&quot;</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s4">&quot;bool&quot;</span>
            <span class="s0">elif </span><span class="s1">xp</span><span class="s2">.</span><span class="s1">isdtype</span><span class="s2">(</span><span class="s1">key</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s4">&quot;integral&quot;</span><span class="s2">):</span>
                <span class="s0">return </span><span class="s4">&quot;int&quot;</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">err_msg</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s0">return </span><span class="s1">array_dtype_to_str</span><span class="s2">[</span><span class="s1">key</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind</span><span class="s2">]</span>
            <span class="s0">except </span><span class="s1">KeyError</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">err_msg</span><span class="s2">)</span>
    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s1">err_msg</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_safe_indexing</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, *, </span><span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Return rows, items or columns of X using indices. 
 
    .. warning:: 
 
        This utility is documented, but **private**. This means that 
        backward compatibility might be broken without any deprecation 
        cycle. 
 
    Parameters 
    ---------- 
    X : array-like, sparse-matrix, list, pandas.DataFrame, pandas.Series 
        Data from which to sample rows, items or columns. `list` are only 
        supported when `axis=0`. 
    indices : bool, int, str, slice, array-like 
        - If `axis=0`, boolean and integer array-like, integer slice, 
          and scalar integer are supported. 
        - If `axis=1`: 
            - to select a single column, `indices` can be of `int` type for 
              all `X` types and `str` only for dataframe. The selected subset 
              will be 1D, unless `X` is a sparse matrix in which case it will 
              be 2D. 
            - to select multiples columns, `indices` can be one of the 
              following: `list`, `array`, `slice`. The type used in 
              these containers can be one of the following: `int`, 'bool' and 
              `str`. However, `str` is only supported when `X` is a dataframe. 
              The selected subset will be 2D. 
    axis : int, default=0 
        The axis along which `X` will be subsampled. `axis=0` will select 
        rows while `axis=1` will select columns. 
 
    Returns 
    ------- 
    subset 
        Subset of X on axis 0 or 1. 
 
    Notes 
    ----- 
    CSR, CSC, and LIL sparse matrices are supported. COO sparse matrices are 
    not supported. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.utils import _safe_indexing 
    &gt;&gt;&gt; data = np.array([[1, 2], [3, 4], [5, 6]]) 
    &gt;&gt;&gt; _safe_indexing(data, 0, axis=0)  # select the first row 
    array([1, 2]) 
    &gt;&gt;&gt; _safe_indexing(data, 0, axis=1)  # select the first column 
    array([1, 3, 5]) 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">indices </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">X</span>

    <span class="s0">if </span><span class="s1">axis </span><span class="s0">not in </span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">&quot;'axis' should be either 0 (to index rows) or 1 (to index &quot;</span>
            <span class="s4">&quot; column). Got {} instead.&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">)</span>
        <span class="s2">)</span>

    <span class="s1">indices_dtype </span><span class="s2">= </span><span class="s1">_determine_key_type</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">indices_dtype </span><span class="s2">== </span><span class="s4">&quot;str&quot;</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;String indexing is not supported with 'axis=0'&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">list</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;axis=1 is not supported for lists&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s5">1 </span><span class="s0">and </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s4">&quot;shape&quot;</span><span class="s2">) </span><span class="s0">and </span><span class="s1">len</span><span class="s2">(</span><span class="s1">X</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">) != </span><span class="s5">2</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">&quot;'X' should be a 2D NumPy array, 2D sparse matrix or &quot;</span>
            <span class="s4">&quot;dataframe when indexing the columns (i.e. 'axis=1'). &quot;</span>
            <span class="s4">&quot;Got {} instead with {} dimension(s).&quot;</span><span class="s2">.</span><span class="s1">format</span><span class="s2">(</span><span class="s1">type</span><span class="s2">(</span><span class="s1">X</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">X</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">))</span>
        <span class="s2">)</span>

    <span class="s0">if </span><span class="s2">(</span>
        <span class="s1">axis </span><span class="s2">== </span><span class="s5">1</span>
        <span class="s0">and </span><span class="s1">indices_dtype </span><span class="s2">== </span><span class="s4">&quot;str&quot;</span>
        <span class="s0">and not </span><span class="s2">(</span><span class="s1">_is_pandas_df</span><span class="s2">(</span><span class="s1">X</span><span class="s2">) </span><span class="s0">or </span><span class="s1">_use_interchange_protocol</span><span class="s2">(</span><span class="s1">X</span><span class="s2">))</span>
    <span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">&quot;Specifying the columns using strings is only supported for dataframes.&quot;</span>
        <span class="s2">)</span>

    <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s4">&quot;iloc&quot;</span><span class="s2">):</span>
        <span class="s6"># TODO: we should probably use _is_pandas_df_or_series(X) instead but this</span>
        <span class="s6"># would require updating some tests such as test_train_test_split_mock_pandas.</span>
        <span class="s0">return </span><span class="s1">_pandas_indexing</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indices_dtype</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">_is_polars_df_or_series</span><span class="s2">(</span><span class="s1">X</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">_polars_indexing</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indices_dtype</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s4">&quot;shape&quot;</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">_array_indexing</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indices_dtype</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">_list_indexing</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indices_dtype</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_safe_assign</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, *, </span><span class="s1">row_indexer</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">column_indexer</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Safe assignment to a numpy array, sparse matrix, or pandas dataframe. 
 
    Parameters 
    ---------- 
    X : {ndarray, sparse-matrix, dataframe} 
        Array to be modified. It is expected to be 2-dimensional. 
 
    values : ndarray 
        The values to be assigned to `X`. 
 
    row_indexer : array-like, dtype={int, bool}, default=None 
        A 1-dimensional array to select the rows of interest. If `None`, all 
        rows are selected. 
 
    column_indexer : array-like, dtype={int, bool}, default=None 
        A 1-dimensional array to select the columns of interest. If `None`, all 
        columns are selected. 
    &quot;&quot;&quot;</span>
    <span class="s1">row_indexer </span><span class="s2">= </span><span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">) </span><span class="s0">if </span><span class="s1">row_indexer </span><span class="s0">is None else </span><span class="s1">row_indexer</span>
    <span class="s1">column_indexer </span><span class="s2">= (</span>
        <span class="s1">slice</span><span class="s2">(</span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s0">None</span><span class="s2">) </span><span class="s0">if </span><span class="s1">column_indexer </span><span class="s0">is None else </span><span class="s1">column_indexer</span>
    <span class="s2">)</span>

    <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s4">&quot;iloc&quot;</span><span class="s2">):  </span><span class="s6"># pandas dataframe</span>
        <span class="s0">with </span><span class="s1">warnings</span><span class="s2">.</span><span class="s1">catch_warnings</span><span class="s2">():</span>
            <span class="s6"># pandas &gt;= 1.5 raises a warning when using iloc to set values in a column</span>
            <span class="s6"># that does not have the same type as the column being set. It happens</span>
            <span class="s6"># for instance when setting a categorical column with a string.</span>
            <span class="s6"># In the future the behavior won't change and the warning should disappear.</span>
            <span class="s6"># TODO(1.3): check if the warning is still raised or remove the filter.</span>
            <span class="s1">warnings</span><span class="s2">.</span><span class="s1">simplefilter</span><span class="s2">(</span><span class="s4">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">FutureWarning</span><span class="s2">)</span>
            <span class="s1">X</span><span class="s2">.</span><span class="s1">iloc</span><span class="s2">[</span><span class="s1">row_indexer</span><span class="s2">, </span><span class="s1">column_indexer</span><span class="s2">] = </span><span class="s1">values</span>
    <span class="s0">else</span><span class="s2">:  </span><span class="s6"># numpy array or sparse matrix</span>
        <span class="s1">X</span><span class="s2">[</span><span class="s1">row_indexer</span><span class="s2">, </span><span class="s1">column_indexer</span><span class="s2">] = </span><span class="s1">values</span>


<span class="s0">def </span><span class="s1">_get_column_indices_for_bool_or_int</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">n_columns</span><span class="s2">):</span>
    <span class="s6"># Convert key into list of positive integer indexes</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s1">idx </span><span class="s2">= </span><span class="s1">_safe_indexing</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n_columns</span><span class="s2">), </span><span class="s1">key</span><span class="s2">)</span>
    <span class="s0">except </span><span class="s1">IndexError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">f&quot;all features must be in [0, </span><span class="s0">{</span><span class="s1">n_columns </span><span class="s2">- </span><span class="s5">1</span><span class="s0">}</span><span class="s4">] or [-</span><span class="s0">{</span><span class="s1">n_columns</span><span class="s0">}</span><span class="s4">, 0]&quot;</span>
        <span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">).</span><span class="s1">tolist</span><span class="s2">()</span>


<span class="s0">def </span><span class="s1">_get_column_indices</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">key</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Get feature column indices for input data X and key. 
 
    For accepted values of `key`, see the docstring of 
    :func:`_safe_indexing`. 
    &quot;&quot;&quot;</span>
    <span class="s1">key_dtype </span><span class="s2">= </span><span class="s1">_determine_key_type</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">_use_interchange_protocol</span><span class="s2">(</span><span class="s1">X</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">_get_column_indices_interchange</span><span class="s2">(</span><span class="s1">X</span><span class="s2">.</span><span class="s1">__dataframe__</span><span class="s2">(), </span><span class="s1">key</span><span class="s2">, </span><span class="s1">key_dtype</span><span class="s2">)</span>

    <span class="s1">n_columns </span><span class="s2">= </span><span class="s1">X</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]</span>
    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, (</span><span class="s1">list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">)) </span><span class="s0">and not </span><span class="s1">key</span><span class="s2">:</span>
        <span class="s6"># we get an empty list</span>
        <span class="s0">return </span><span class="s2">[]</span>
    <span class="s0">elif </span><span class="s1">key_dtype </span><span class="s0">in </span><span class="s2">(</span><span class="s4">&quot;bool&quot;</span><span class="s2">, </span><span class="s4">&quot;int&quot;</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">_get_column_indices_for_bool_or_int</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">n_columns</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">all_columns </span><span class="s2">= </span><span class="s1">X</span><span class="s2">.</span><span class="s1">columns</span>
        <span class="s0">except </span><span class="s1">AttributeError</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">&quot;Specifying the columns using strings is only supported for dataframes.&quot;</span>
            <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">str</span><span class="s2">):</span>
            <span class="s1">columns </span><span class="s2">= [</span><span class="s1">key</span><span class="s2">]</span>
        <span class="s0">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">):</span>
            <span class="s1">start</span><span class="s2">, </span><span class="s1">stop </span><span class="s2">= </span><span class="s1">key</span><span class="s2">.</span><span class="s1">start</span><span class="s2">, </span><span class="s1">key</span><span class="s2">.</span><span class="s1">stop</span>
            <span class="s0">if </span><span class="s1">start </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">start </span><span class="s2">= </span><span class="s1">all_columns</span><span class="s2">.</span><span class="s1">get_loc</span><span class="s2">(</span><span class="s1">start</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">stop </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s6"># pandas indexing with strings is endpoint included</span>
                <span class="s1">stop </span><span class="s2">= </span><span class="s1">all_columns</span><span class="s2">.</span><span class="s1">get_loc</span><span class="s2">(</span><span class="s1">stop</span><span class="s2">) + </span><span class="s5">1</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">stop </span><span class="s2">= </span><span class="s1">n_columns </span><span class="s2">+ </span><span class="s5">1</span>
            <span class="s0">return </span><span class="s1">list</span><span class="s2">(</span><span class="s1">islice</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">n_columns</span><span class="s2">), </span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">))</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">columns </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">key</span><span class="s2">)</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">column_indices </span><span class="s2">= []</span>
            <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">columns</span><span class="s2">:</span>
                <span class="s1">col_idx </span><span class="s2">= </span><span class="s1">all_columns</span><span class="s2">.</span><span class="s1">get_loc</span><span class="s2">(</span><span class="s1">col</span><span class="s2">)</span>
                <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">col_idx</span><span class="s2">, </span><span class="s1">numbers</span><span class="s2">.</span><span class="s1">Integral</span><span class="s2">):</span>
                    <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                        <span class="s4">f&quot;Selected columns, </span><span class="s0">{</span><span class="s1">columns</span><span class="s0">}</span><span class="s4">, are not unique in dataframe&quot;</span>
                    <span class="s2">)</span>
                <span class="s1">column_indices</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">col_idx</span><span class="s2">)</span>

        <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;A given column is not a column of the dataframe&quot;</span><span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>

        <span class="s0">return </span><span class="s1">column_indices</span>


<span class="s0">def </span><span class="s1">_get_column_indices_interchange</span><span class="s2">(</span><span class="s1">X_interchange</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">key_dtype</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Same as _get_column_indices but for X with __dataframe__ protocol.&quot;&quot;&quot;</span>

    <span class="s1">n_columns </span><span class="s2">= </span><span class="s1">X_interchange</span><span class="s2">.</span><span class="s1">num_columns</span><span class="s2">()</span>

    <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, (</span><span class="s1">list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">)) </span><span class="s0">and not </span><span class="s1">key</span><span class="s2">:</span>
        <span class="s6"># we get an empty list</span>
        <span class="s0">return </span><span class="s2">[]</span>
    <span class="s0">elif </span><span class="s1">key_dtype </span><span class="s0">in </span><span class="s2">(</span><span class="s4">&quot;bool&quot;</span><span class="s2">, </span><span class="s4">&quot;int&quot;</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">_get_column_indices_for_bool_or_int</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">n_columns</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">column_names </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">X_interchange</span><span class="s2">.</span><span class="s1">column_names</span><span class="s2">())</span>

        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">key</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">):</span>
            <span class="s0">if </span><span class="s1">key</span><span class="s2">.</span><span class="s1">step </span><span class="s0">not in </span><span class="s2">[</span><span class="s5">1</span><span class="s2">, </span><span class="s0">None</span><span class="s2">]:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s4">&quot;key.step must be 1 or None&quot;</span><span class="s2">)</span>
            <span class="s1">start</span><span class="s2">, </span><span class="s1">stop </span><span class="s2">= </span><span class="s1">key</span><span class="s2">.</span><span class="s1">start</span><span class="s2">, </span><span class="s1">key</span><span class="s2">.</span><span class="s1">stop</span>
            <span class="s0">if </span><span class="s1">start </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">start </span><span class="s2">= </span><span class="s1">column_names</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">start</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">stop </span><span class="s0">is not None</span><span class="s2">:</span>
                <span class="s1">stop </span><span class="s2">= </span><span class="s1">column_names</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">stop</span><span class="s2">) + </span><span class="s5">1</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">stop </span><span class="s2">= </span><span class="s1">n_columns </span><span class="s2">+ </span><span class="s5">1</span>
            <span class="s0">return </span><span class="s1">list</span><span class="s2">(</span><span class="s1">islice</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">n_columns</span><span class="s2">), </span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">))</span>

        <span class="s1">selected_columns </span><span class="s2">= [</span><span class="s1">key</span><span class="s2">] </span><span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isscalar</span><span class="s2">(</span><span class="s1">key</span><span class="s2">) </span><span class="s0">else </span><span class="s1">key</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">column_names</span><span class="s2">.</span><span class="s1">index</span><span class="s2">(</span><span class="s1">col</span><span class="s2">) </span><span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">selected_columns</span><span class="s2">]</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;A given column is not a column of the dataframe&quot;</span><span class="s2">) </span><span class="s0">from </span><span class="s1">e</span>


<span class="s2">@</span><span class="s1">validate_params</span><span class="s2">(</span>
    <span class="s2">{</span>
        <span class="s4">&quot;replace&quot;</span><span class="s2">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s2">],</span>
        <span class="s4">&quot;n_samples&quot;</span><span class="s2">: [</span><span class="s1">Interval</span><span class="s2">(</span><span class="s1">numbers</span><span class="s2">.</span><span class="s1">Integral</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s1">closed</span><span class="s2">=</span><span class="s4">&quot;left&quot;</span><span class="s2">), </span><span class="s0">None</span><span class="s2">],</span>
        <span class="s4">&quot;random_state&quot;</span><span class="s2">: [</span><span class="s4">&quot;random_state&quot;</span><span class="s2">],</span>
        <span class="s4">&quot;stratify&quot;</span><span class="s2">: [</span><span class="s4">&quot;array-like&quot;</span><span class="s2">, </span><span class="s4">&quot;sparse matrix&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">],</span>
    <span class="s2">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">def </span><span class="s1">resample</span><span class="s2">(*</span><span class="s1">arrays</span><span class="s2">, </span><span class="s1">replace</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">stratify</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Resample arrays or sparse matrices in a consistent way. 
 
    The default strategy implements one step of the bootstrapping 
    procedure. 
 
    Parameters 
    ---------- 
    *arrays : sequence of array-like of shape (n_samples,) or \ 
            (n_samples, n_outputs) 
        Indexable data-structures can be arrays, lists, dataframes or scipy 
        sparse matrices with consistent first dimension. 
 
    replace : bool, default=True 
        Implements resampling with replacement. If False, this will implement 
        (sliced) random permutations. 
 
    n_samples : int, default=None 
        Number of samples to generate. If left to None this is 
        automatically set to the first dimension of the arrays. 
        If replace is False it should not be larger than the length of 
        arrays. 
 
    random_state : int, RandomState instance or None, default=None 
        Determines random number generation for shuffling 
        the data. 
        Pass an int for reproducible results across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    stratify : {array-like, sparse matrix} of shape (n_samples,) or \ 
            (n_samples, n_outputs), default=None 
        If not None, data is split in a stratified fashion, using this as 
        the class labels. 
 
    Returns 
    ------- 
    resampled_arrays : sequence of array-like of shape (n_samples,) or \ 
            (n_samples, n_outputs) 
        Sequence of resampled copies of the collections. The original arrays 
        are not impacted. 
 
    See Also 
    -------- 
    shuffle : Shuffle arrays or sparse matrices in a consistent way. 
 
    Examples 
    -------- 
    It is possible to mix sparse and dense arrays in the same run:: 
 
      &gt;&gt;&gt; import numpy as np 
      &gt;&gt;&gt; X = np.array([[1., 0.], [2., 1.], [0., 0.]]) 
      &gt;&gt;&gt; y = np.array([0, 1, 2]) 
 
      &gt;&gt;&gt; from scipy.sparse import coo_matrix 
      &gt;&gt;&gt; X_sparse = coo_matrix(X) 
 
      &gt;&gt;&gt; from sklearn.utils import resample 
      &gt;&gt;&gt; X, X_sparse, y = resample(X, X_sparse, y, random_state=0) 
      &gt;&gt;&gt; X 
      array([[1., 0.], 
             [2., 1.], 
             [1., 0.]]) 
 
      &gt;&gt;&gt; X_sparse 
      &lt;Compressed Sparse Row sparse matrix of dtype 'float64' 
          with 4 stored elements and shape (3, 2)&gt; 
 
      &gt;&gt;&gt; X_sparse.toarray() 
      array([[1., 0.], 
             [2., 1.], 
             [1., 0.]]) 
 
      &gt;&gt;&gt; y 
      array([0, 1, 0]) 
 
      &gt;&gt;&gt; resample(y, n_samples=2, random_state=0) 
      array([0, 1]) 
 
    Example using stratification:: 
 
      &gt;&gt;&gt; y = [0, 0, 1, 1, 1, 1, 1, 1, 1] 
      &gt;&gt;&gt; resample(y, n_samples=5, replace=False, stratify=y, 
      ...          random_state=0) 
      [1, 1, 1, 0, 1] 
    &quot;&quot;&quot;</span>
    <span class="s1">max_n_samples </span><span class="s2">= </span><span class="s1">n_samples</span>
    <span class="s1">random_state </span><span class="s2">= </span><span class="s1">check_random_state</span><span class="s2">(</span><span class="s1">random_state</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">arrays</span><span class="s2">) == </span><span class="s5">0</span><span class="s2">:</span>
        <span class="s0">return None</span>

    <span class="s1">first </span><span class="s2">= </span><span class="s1">arrays</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
    <span class="s1">n_samples </span><span class="s2">= </span><span class="s1">first</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] </span><span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">first</span><span class="s2">, </span><span class="s4">&quot;shape&quot;</span><span class="s2">) </span><span class="s0">else </span><span class="s1">len</span><span class="s2">(</span><span class="s1">first</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">max_n_samples </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">max_n_samples </span><span class="s2">= </span><span class="s1">n_samples</span>
    <span class="s0">elif </span><span class="s2">(</span><span class="s1">max_n_samples </span><span class="s2">&gt; </span><span class="s1">n_samples</span><span class="s2">) </span><span class="s0">and </span><span class="s2">(</span><span class="s0">not </span><span class="s1">replace</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
            <span class="s4">&quot;Cannot sample %d out of arrays with dim %d when replace is False&quot;</span>
            <span class="s2">% (</span><span class="s1">max_n_samples</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">)</span>
        <span class="s2">)</span>

    <span class="s1">check_consistent_length</span><span class="s2">(*</span><span class="s1">arrays</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">stratify </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">replace</span><span class="s2">:</span>
            <span class="s1">indices </span><span class="s2">= </span><span class="s1">random_state</span><span class="s2">.</span><span class="s1">randint</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">size</span><span class="s2">=(</span><span class="s1">max_n_samples</span><span class="s2">,))</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">)</span>
            <span class="s1">random_state</span><span class="s2">.</span><span class="s1">shuffle</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">)</span>
            <span class="s1">indices </span><span class="s2">= </span><span class="s1">indices</span><span class="s2">[:</span><span class="s1">max_n_samples</span><span class="s2">]</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s6"># Code adapted from StratifiedShuffleSplit()</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">check_array</span><span class="s2">(</span><span class="s1">stratify</span><span class="s2">, </span><span class="s1">ensure_2d</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s0">None</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">y</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s6"># for multi-label y, map each distinct row to a string repr</span>
            <span class="s6"># using join because str(row) uses an ellipsis if len(row) &gt; 1000</span>
            <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s4">&quot; &quot;</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s1">row</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s4">&quot;str&quot;</span><span class="s2">)) </span><span class="s0">for </span><span class="s1">row </span><span class="s0">in </span><span class="s1">y</span><span class="s2">])</span>

        <span class="s1">classes</span><span class="s2">, </span><span class="s1">y_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">unique</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">return_inverse</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">n_classes </span><span class="s2">= </span><span class="s1">classes</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>

        <span class="s1">class_counts </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">bincount</span><span class="s2">(</span><span class="s1">y_indices</span><span class="s2">)</span>

        <span class="s6"># Find the sorted list of instances for each class:</span>
        <span class="s6"># (np.unique above performs a sort, so code is O(n logn) already)</span>
        <span class="s1">class_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">argsort</span><span class="s2">(</span><span class="s1">y_indices</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">=</span><span class="s4">&quot;mergesort&quot;</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">class_counts</span><span class="s2">)[:-</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s2">)</span>

        <span class="s1">n_i </span><span class="s2">= </span><span class="s1">_approximate_mode</span><span class="s2">(</span><span class="s1">class_counts</span><span class="s2">, </span><span class="s1">max_n_samples</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">)</span>

        <span class="s1">indices </span><span class="s2">= []</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">n_classes</span><span class="s2">):</span>
            <span class="s1">indices_i </span><span class="s2">= </span><span class="s1">random_state</span><span class="s2">.</span><span class="s1">choice</span><span class="s2">(</span><span class="s1">class_indices</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">n_i</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">replace</span><span class="s2">=</span><span class="s1">replace</span><span class="s2">)</span>
            <span class="s1">indices</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">indices_i</span><span class="s2">)</span>

        <span class="s1">indices </span><span class="s2">= </span><span class="s1">random_state</span><span class="s2">.</span><span class="s1">permutation</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">)</span>

    <span class="s6"># convert sparse matrices to CSR for row-based indexing</span>
    <span class="s1">arrays </span><span class="s2">= [</span><span class="s1">a</span><span class="s2">.</span><span class="s1">tocsr</span><span class="s2">() </span><span class="s0">if </span><span class="s1">issparse</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) </span><span class="s0">else </span><span class="s1">a </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">arrays</span><span class="s2">]</span>
    <span class="s1">resampled_arrays </span><span class="s2">= [</span><span class="s1">_safe_indexing</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">arrays</span><span class="s2">]</span>
    <span class="s0">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">resampled_arrays</span><span class="s2">) == </span><span class="s5">1</span><span class="s2">:</span>
        <span class="s6"># syntactic sugar for the unit argument case</span>
        <span class="s0">return </span><span class="s1">resampled_arrays</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">resampled_arrays</span>


<span class="s0">def </span><span class="s1">shuffle</span><span class="s2">(*</span><span class="s1">arrays</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Shuffle arrays or sparse matrices in a consistent way. 
 
    This is a convenience alias to ``resample(*arrays, replace=False)`` to do 
    random permutations of the collections. 
 
    Parameters 
    ---------- 
    *arrays : sequence of indexable data-structures 
        Indexable data-structures can be arrays, lists, dataframes or scipy 
        sparse matrices with consistent first dimension. 
 
    random_state : int, RandomState instance or None, default=None 
        Determines random number generation for shuffling 
        the data. 
        Pass an int for reproducible results across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    n_samples : int, default=None 
        Number of samples to generate. If left to None this is 
        automatically set to the first dimension of the arrays.  It should 
        not be larger than the length of arrays. 
 
    Returns 
    ------- 
    shuffled_arrays : sequence of indexable data-structures 
        Sequence of shuffled copies of the collections. The original arrays 
        are not impacted. 
 
    See Also 
    -------- 
    resample : Resample arrays or sparse matrices in a consistent way. 
 
    Examples 
    -------- 
    It is possible to mix sparse and dense arrays in the same run:: 
 
      &gt;&gt;&gt; import numpy as np 
      &gt;&gt;&gt; X = np.array([[1., 0.], [2., 1.], [0., 0.]]) 
      &gt;&gt;&gt; y = np.array([0, 1, 2]) 
 
      &gt;&gt;&gt; from scipy.sparse import coo_matrix 
      &gt;&gt;&gt; X_sparse = coo_matrix(X) 
 
      &gt;&gt;&gt; from sklearn.utils import shuffle 
      &gt;&gt;&gt; X, X_sparse, y = shuffle(X, X_sparse, y, random_state=0) 
      &gt;&gt;&gt; X 
      array([[0., 0.], 
             [2., 1.], 
             [1., 0.]]) 
 
      &gt;&gt;&gt; X_sparse 
      &lt;Compressed Sparse Row sparse matrix of dtype 'float64' 
          with 3 stored elements and shape (3, 2)&gt; 
 
      &gt;&gt;&gt; X_sparse.toarray() 
      array([[0., 0.], 
             [2., 1.], 
             [1., 0.]]) 
 
      &gt;&gt;&gt; y 
      array([2, 1, 0]) 
 
      &gt;&gt;&gt; shuffle(y, n_samples=2, random_state=0) 
      array([0, 1]) 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">resample</span><span class="s2">(</span>
        <span class="s2">*</span><span class="s1">arrays</span><span class="s2">, </span><span class="s1">replace</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">=</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">=</span><span class="s1">random_state</span>
    <span class="s2">)</span>
</pre>
</body>
</html>