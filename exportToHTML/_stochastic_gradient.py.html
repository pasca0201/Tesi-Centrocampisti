<html>
<head>
<title>_stochastic_gradient.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_stochastic_gradient.py</font>
</center></td></tr></table>
<pre><span class="s0"># Authors: Peter Prettenhofer &lt;peter.prettenhofer@gmail.com&gt; (main author)</span>
<span class="s0">#          Mathieu Blondel (partial_fit support)</span>
<span class="s0">#</span>
<span class="s0"># License: BSD 3 clause</span>
<span class="s2">&quot;&quot;&quot;Classification, regression and One-Class SVM using Stochastic Gradient 
Descent (SGD). 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">from </span><span class="s1">abc </span><span class="s3">import </span><span class="s1">ABCMeta</span><span class="s4">, </span><span class="s1">abstractmethod</span>
<span class="s3">from </span><span class="s1">numbers </span><span class="s3">import </span><span class="s1">Integral</span><span class="s4">, </span><span class="s1">Real</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>

<span class="s3">from </span><span class="s4">..</span><span class="s1">base </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">BaseEstimator</span><span class="s4">,</span>
    <span class="s1">OutlierMixin</span><span class="s4">,</span>
    <span class="s1">RegressorMixin</span><span class="s4">,</span>
    <span class="s1">_fit_context</span><span class="s4">,</span>
    <span class="s1">clone</span><span class="s4">,</span>
    <span class="s1">is_classifier</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">exceptions </span><span class="s3">import </span><span class="s1">ConvergenceWarning</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">model_selection </span><span class="s3">import </span><span class="s1">ShuffleSplit</span><span class="s4">, </span><span class="s1">StratifiedShuffleSplit</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils </span><span class="s3">import </span><span class="s1">check_random_state</span><span class="s4">, </span><span class="s1">compute_class_weight</span><span class="s4">, </span><span class="s1">deprecated</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_param_validation </span><span class="s3">import </span><span class="s1">Hidden</span><span class="s4">, </span><span class="s1">Interval</span><span class="s4">, </span><span class="s1">StrOptions</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">extmath </span><span class="s3">import </span><span class="s1">safe_sparse_dot</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">metaestimators </span><span class="s3">import </span><span class="s1">available_if</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">multiclass </span><span class="s3">import </span><span class="s1">_check_partial_fit_first_call</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">parallel </span><span class="s3">import </span><span class="s1">Parallel</span><span class="s4">, </span><span class="s1">delayed</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">validation </span><span class="s3">import </span><span class="s1">_check_sample_weight</span><span class="s4">, </span><span class="s1">check_is_fitted</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_base </span><span class="s3">import </span><span class="s1">LinearClassifierMixin</span><span class="s4">, </span><span class="s1">SparseCoefMixin</span><span class="s4">, </span><span class="s1">make_dataset</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_sgd_fast </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">EpsilonInsensitive</span><span class="s4">,</span>
    <span class="s1">Hinge</span><span class="s4">,</span>
    <span class="s1">Huber</span><span class="s4">,</span>
    <span class="s1">Log</span><span class="s4">,</span>
    <span class="s1">ModifiedHuber</span><span class="s4">,</span>
    <span class="s1">SquaredEpsilonInsensitive</span><span class="s4">,</span>
    <span class="s1">SquaredHinge</span><span class="s4">,</span>
    <span class="s1">SquaredLoss</span><span class="s4">,</span>
    <span class="s1">_plain_sgd32</span><span class="s4">,</span>
    <span class="s1">_plain_sgd64</span><span class="s4">,</span>
<span class="s4">)</span>

<span class="s1">LEARNING_RATE_TYPES </span><span class="s4">= {</span>
    <span class="s5">&quot;constant&quot;</span><span class="s4">: </span><span class="s6">1</span><span class="s4">,</span>
    <span class="s5">&quot;optimal&quot;</span><span class="s4">: </span><span class="s6">2</span><span class="s4">,</span>
    <span class="s5">&quot;invscaling&quot;</span><span class="s4">: </span><span class="s6">3</span><span class="s4">,</span>
    <span class="s5">&quot;adaptive&quot;</span><span class="s4">: </span><span class="s6">4</span><span class="s4">,</span>
    <span class="s5">&quot;pa1&quot;</span><span class="s4">: </span><span class="s6">5</span><span class="s4">,</span>
    <span class="s5">&quot;pa2&quot;</span><span class="s4">: </span><span class="s6">6</span><span class="s4">,</span>
<span class="s4">}</span>

<span class="s1">PENALTY_TYPES </span><span class="s4">= {</span><span class="s5">&quot;none&quot;</span><span class="s4">: </span><span class="s6">0</span><span class="s4">, </span><span class="s5">&quot;l2&quot;</span><span class="s4">: </span><span class="s6">2</span><span class="s4">, </span><span class="s5">&quot;l1&quot;</span><span class="s4">: </span><span class="s6">1</span><span class="s4">, </span><span class="s5">&quot;elasticnet&quot;</span><span class="s4">: </span><span class="s6">3</span><span class="s4">}</span>

<span class="s1">DEFAULT_EPSILON </span><span class="s4">= </span><span class="s6">0.1</span>
<span class="s0"># Default value of ``epsilon`` parameter.</span>

<span class="s1">MAX_INT </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">iinfo</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">int32</span><span class="s4">).</span><span class="s1">max</span>


<span class="s3">class </span><span class="s1">_ValidationScoreCallback</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;Callback for early stopping based on validation score&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">estimator</span><span class="s4">, </span><span class="s1">X_val</span><span class="s4">, </span><span class="s1">y_val</span><span class="s4">, </span><span class="s1">sample_weight_val</span><span class="s4">, </span><span class="s1">classes</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">estimator </span><span class="s4">= </span><span class="s1">clone</span><span class="s4">(</span><span class="s1">estimator</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">estimator</span><span class="s4">.</span><span class="s1">t_ </span><span class="s4">= </span><span class="s6">1  </span><span class="s0"># to pass check_is_fitted</span>
        <span class="s3">if </span><span class="s1">classes </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">estimator</span><span class="s4">.</span><span class="s1">classes_ </span><span class="s4">= </span><span class="s1">classes</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">X_val </span><span class="s4">= </span><span class="s1">X_val</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">y_val </span><span class="s4">= </span><span class="s1">y_val</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">sample_weight_val </span><span class="s4">= </span><span class="s1">sample_weight_val</span>

    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">coef</span><span class="s4">, </span><span class="s1">intercept</span><span class="s4">):</span>
        <span class="s1">est </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">estimator</span>
        <span class="s1">est</span><span class="s4">.</span><span class="s1">coef_ </span><span class="s4">= </span><span class="s1">coef</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s1">est</span><span class="s4">.</span><span class="s1">intercept_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">intercept</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">est</span><span class="s4">.</span><span class="s1">score</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">X_val</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">y_val</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">sample_weight_val</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">BaseSGD</span><span class="s4">(</span><span class="s1">SparseCoefMixin</span><span class="s4">, </span><span class="s1">BaseEstimator</span><span class="s4">, </span><span class="s1">metaclass</span><span class="s4">=</span><span class="s1">ABCMeta</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Base class for SGD classification and regression.&quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
        <span class="s5">&quot;fit_intercept&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;max_iter&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;tol&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">), </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;shuffle&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;verbose&quot;</span><span class="s4">: [</span><span class="s5">&quot;verbose&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;random_state&quot;</span><span class="s4">: [</span><span class="s5">&quot;random_state&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;warm_start&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;average&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">), </span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
    <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">loss</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">penalty</span><span class="s4">=</span><span class="s5">&quot;l2&quot;</span><span class="s4">,</span>
        <span class="s1">alpha</span><span class="s4">=</span><span class="s6">0.0001</span><span class="s4">,</span>
        <span class="s1">C</span><span class="s4">=</span><span class="s6">1.0</span><span class="s4">,</span>
        <span class="s1">l1_ratio</span><span class="s4">=</span><span class="s6">0.15</span><span class="s4">,</span>
        <span class="s1">fit_intercept</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">max_iter</span><span class="s4">=</span><span class="s6">1000</span><span class="s4">,</span>
        <span class="s1">tol</span><span class="s4">=</span><span class="s6">1e-3</span><span class="s4">,</span>
        <span class="s1">shuffle</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
        <span class="s1">epsilon</span><span class="s4">=</span><span class="s6">0.1</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">learning_rate</span><span class="s4">=</span><span class="s5">&quot;optimal&quot;</span><span class="s4">,</span>
        <span class="s1">eta0</span><span class="s4">=</span><span class="s6">0.0</span><span class="s4">,</span>
        <span class="s1">power_t</span><span class="s4">=</span><span class="s6">0.5</span><span class="s4">,</span>
        <span class="s1">early_stopping</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">validation_fraction</span><span class="s4">=</span><span class="s6">0.1</span><span class="s4">,</span>
        <span class="s1">n_iter_no_change</span><span class="s4">=</span><span class="s6">5</span><span class="s4">,</span>
        <span class="s1">warm_start</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">average</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">loss </span><span class="s4">= </span><span class="s1">loss</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">penalty </span><span class="s4">= </span><span class="s1">penalty</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">learning_rate </span><span class="s4">= </span><span class="s1">learning_rate</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">epsilon </span><span class="s4">= </span><span class="s1">epsilon</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">alpha </span><span class="s4">= </span><span class="s1">alpha</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">C </span><span class="s4">= </span><span class="s1">C</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">l1_ratio </span><span class="s4">= </span><span class="s1">l1_ratio</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">fit_intercept </span><span class="s4">= </span><span class="s1">fit_intercept</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">shuffle </span><span class="s4">= </span><span class="s1">shuffle</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">random_state </span><span class="s4">= </span><span class="s1">random_state</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">verbose </span><span class="s4">= </span><span class="s1">verbose</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">eta0 </span><span class="s4">= </span><span class="s1">eta0</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">power_t </span><span class="s4">= </span><span class="s1">power_t</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">early_stopping </span><span class="s4">= </span><span class="s1">early_stopping</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">validation_fraction </span><span class="s4">= </span><span class="s1">validation_fraction</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_iter_no_change </span><span class="s4">= </span><span class="s1">n_iter_no_change</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">warm_start </span><span class="s4">= </span><span class="s1">warm_start</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">= </span><span class="s1">average</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">max_iter </span><span class="s4">= </span><span class="s1">max_iter</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">tol </span><span class="s4">= </span><span class="s1">tol</span>

    <span class="s4">@</span><span class="s1">abstractmethod</span>
    <span class="s3">def </span><span class="s1">fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Fit model.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">_more_validate_params</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">for_partial_fit</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Validate input params.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">early_stopping </span><span class="s3">and </span><span class="s1">for_partial_fit</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;early_stopping should be False with partial_fit&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">learning_rate </span><span class="s3">in </span><span class="s4">(</span><span class="s5">&quot;constant&quot;</span><span class="s4">, </span><span class="s5">&quot;invscaling&quot;</span><span class="s4">, </span><span class="s5">&quot;adaptive&quot;</span><span class="s4">)</span>
            <span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">eta0 </span><span class="s4">&lt;= </span><span class="s6">0.0</span>
        <span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;eta0 must be &gt; 0&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">learning_rate </span><span class="s4">== </span><span class="s5">&quot;optimal&quot; </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">alpha </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;alpha must be &gt; 0 since &quot;</span>
                <span class="s5">&quot;learning_rate is 'optimal'. alpha is used &quot;</span>
                <span class="s5">&quot;to compute the optimal learning rate.&quot;</span>
            <span class="s4">)</span>

        <span class="s0"># raises ValueError if not registered</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_get_penalty_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">penalty</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_get_learning_rate_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">learning_rate</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_get_loss_function</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">loss</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Get concrete ``LossFunction`` object for str ``loss``.&quot;&quot;&quot;</span>
        <span class="s1">loss_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss_functions</span><span class="s4">[</span><span class="s1">loss</span><span class="s4">]</span>
        <span class="s1">loss_class</span><span class="s4">, </span><span class="s1">args </span><span class="s4">= </span><span class="s1">loss_</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">loss_</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:]</span>
        <span class="s3">if </span><span class="s1">loss </span><span class="s3">in </span><span class="s4">(</span><span class="s5">&quot;huber&quot;</span><span class="s4">, </span><span class="s5">&quot;epsilon_insensitive&quot;</span><span class="s4">, </span><span class="s5">&quot;squared_epsilon_insensitive&quot;</span><span class="s4">):</span>
            <span class="s1">args </span><span class="s4">= (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">epsilon</span><span class="s4">,)</span>
        <span class="s3">return </span><span class="s1">loss_class</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_get_learning_rate_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">learning_rate</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">LEARNING_RATE_TYPES</span><span class="s4">[</span><span class="s1">learning_rate</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">_get_penalty_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">penalty</span><span class="s4">):</span>
        <span class="s1">penalty </span><span class="s4">= </span><span class="s1">str</span><span class="s4">(</span><span class="s1">penalty</span><span class="s4">).</span><span class="s1">lower</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">PENALTY_TYPES</span><span class="s4">[</span><span class="s1">penalty</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">_allocate_parameter_mem</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">n_classes</span><span class="s4">,</span>
        <span class="s1">n_features</span><span class="s4">,</span>
        <span class="s1">input_dtype</span><span class="s4">,</span>
        <span class="s1">coef_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">intercept_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">one_class</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Allocate mem for parameters; initialize if provided.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">n_classes </span><span class="s4">&gt; </span><span class="s6">2</span><span class="s4">:</span>
            <span class="s0"># allocate coef_ for multi-class</span>
            <span class="s3">if </span><span class="s1">coef_init </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">coef_init </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">coef_init</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">input_dtype</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">coef_init</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">!= (</span><span class="s1">n_classes</span><span class="s4">, </span><span class="s1">n_features</span><span class="s4">):</span>
                    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Provided ``coef_`` does not match dataset. &quot;</span><span class="s4">)</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">coef_ </span><span class="s4">= </span><span class="s1">coef_init</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">coef_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span>
                    <span class="s4">(</span><span class="s1">n_classes</span><span class="s4">, </span><span class="s1">n_features</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">input_dtype</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span>
                <span class="s4">)</span>

            <span class="s0"># allocate intercept_ for multi-class</span>
            <span class="s3">if </span><span class="s1">intercept_init </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">intercept_init </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span>
                    <span class="s1">intercept_init</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">input_dtype</span>
                <span class="s4">)</span>
                <span class="s3">if </span><span class="s1">intercept_init</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">!= (</span><span class="s1">n_classes</span><span class="s4">,):</span>
                    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Provided intercept_init does not match dataset.&quot;</span><span class="s4">)</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_ </span><span class="s4">= </span><span class="s1">intercept_init</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_classes</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">input_dtype</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s0"># allocate coef_</span>
            <span class="s3">if </span><span class="s1">coef_init </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">coef_init </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">coef_init</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">input_dtype</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">)</span>
                <span class="s1">coef_init </span><span class="s4">= </span><span class="s1">coef_init</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">()</span>
                <span class="s3">if </span><span class="s1">coef_init</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">!= (</span><span class="s1">n_features</span><span class="s4">,):</span>
                    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Provided coef_init does not match dataset.&quot;</span><span class="s4">)</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">coef_ </span><span class="s4">= </span><span class="s1">coef_init</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">coef_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_features</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">input_dtype</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">)</span>

            <span class="s0"># allocate intercept_</span>
            <span class="s3">if </span><span class="s1">intercept_init </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">intercept_init </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">intercept_init</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">input_dtype</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">intercept_init</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">!= (</span><span class="s6">1</span><span class="s4">,) </span><span class="s3">and </span><span class="s1">intercept_init</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">!= ():</span>
                    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Provided intercept_init does not match dataset.&quot;</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">one_class</span><span class="s4">:</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">offset_ </span><span class="s4">= </span><span class="s1">intercept_init</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">(</span>
                        <span class="s6">1</span><span class="s4">,</span>
                    <span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_ </span><span class="s4">= </span><span class="s1">intercept_init</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">(</span>
                        <span class="s6">1</span><span class="s4">,</span>
                    <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">one_class</span><span class="s4">:</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">offset_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">input_dtype</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">input_dtype</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">)</span>

        <span class="s0"># initialize average parameters</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_coef </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">coef_</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_average_coef </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">coef_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">input_dtype</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span>
            <span class="s4">)</span>
            <span class="s3">if </span><span class="s1">one_class</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_intercept </span><span class="s4">= </span><span class="s6">1 </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">offset_</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_intercept </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_</span>

            <span class="s1">self</span><span class="s4">.</span><span class="s1">_average_intercept </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_intercept</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">input_dtype</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_make_validation_split</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_mask</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Split the dataset between training set and validation set. 
 
        Parameters 
        ---------- 
        y : ndarray of shape (n_samples, ) 
            Target values. 
 
        sample_mask : ndarray of shape (n_samples, ) 
            A boolean array indicating whether each sample should be included 
            for validation set. 
 
        Returns 
        ------- 
        validation_mask : ndarray of shape (n_samples, ) 
            Equal to True on the validation set, False on the training set. 
        &quot;&quot;&quot;</span>
        <span class="s1">n_samples </span><span class="s4">= </span><span class="s1">y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s1">validation_mask </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">bool_</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">early_stopping</span><span class="s4">:</span>
            <span class="s0"># use the full set for training, with an empty validation set</span>
            <span class="s3">return </span><span class="s1">validation_mask</span>

        <span class="s3">if </span><span class="s1">is_classifier</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
            <span class="s1">splitter_type </span><span class="s4">= </span><span class="s1">StratifiedShuffleSplit</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">splitter_type </span><span class="s4">= </span><span class="s1">ShuffleSplit</span>
        <span class="s1">cv </span><span class="s4">= </span><span class="s1">splitter_type</span><span class="s4">(</span>
            <span class="s1">test_size</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">validation_fraction</span><span class="s4">, </span><span class="s1">random_state</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">random_state</span>
        <span class="s4">)</span>
        <span class="s1">idx_train</span><span class="s4">, </span><span class="s1">idx_val </span><span class="s4">= </span><span class="s1">next</span><span class="s4">(</span><span class="s1">cv</span><span class="s4">.</span><span class="s1">split</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">shape</span><span class="s4">=(</span><span class="s1">y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s6">1</span><span class="s4">)), </span><span class="s1">y</span><span class="s4">))</span>

        <span class="s3">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">any</span><span class="s4">(</span><span class="s1">sample_mask</span><span class="s4">[</span><span class="s1">idx_val</span><span class="s4">]):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;The sample weights for validation set are all zero, consider using a&quot;</span>
                <span class="s5">&quot; different random state.&quot;</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">idx_train</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s6">0 </span><span class="s3">or </span><span class="s1">idx_val</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;Splitting %d samples into a train set and a validation set &quot;</span>
                <span class="s5">&quot;with validation_fraction=%r led to an empty set (%d and %d &quot;</span>
                <span class="s5">&quot;samples). Please either change validation_fraction, increase &quot;</span>
                <span class="s5">&quot;number of samples, or disable early_stopping.&quot;</span>
                <span class="s4">% (</span>
                    <span class="s1">n_samples</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">validation_fraction</span><span class="s4">,</span>
                    <span class="s1">idx_train</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">],</span>
                    <span class="s1">idx_val</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">],</span>
                <span class="s4">)</span>
            <span class="s4">)</span>

        <span class="s1">validation_mask</span><span class="s4">[</span><span class="s1">idx_val</span><span class="s4">] = </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s1">validation_mask</span>

    <span class="s3">def </span><span class="s1">_make_validation_score_cb</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">validation_mask</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s1">classes</span><span class="s4">=</span><span class="s3">None</span>
    <span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">early_stopping</span><span class="s4">:</span>
            <span class="s3">return None</span>

        <span class="s3">return </span><span class="s1">_ValidationScoreCallback</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">X</span><span class="s4">[</span><span class="s1">validation_mask</span><span class="s4">],</span>
            <span class="s1">y</span><span class="s4">[</span><span class="s1">validation_mask</span><span class="s4">],</span>
            <span class="s1">sample_weight</span><span class="s4">[</span><span class="s1">validation_mask</span><span class="s4">],</span>
            <span class="s1">classes</span><span class="s4">=</span><span class="s1">classes</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s0"># TODO(1.6): Remove</span>
    <span class="s0"># mypy error: Decorated property not supported</span>
    <span class="s4">@</span><span class="s1">deprecated</span><span class="s4">(  </span><span class="s0"># type: ignore</span>
        <span class="s5">&quot;Attribute `loss_function_` was deprecated in version 1.4 and will be removed &quot;</span>
        <span class="s5">&quot;in 1.6.&quot;</span>
    <span class="s4">)</span>
    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">loss_function_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_loss_function_</span>


<span class="s3">def </span><span class="s1">_prepare_fit_binary</span><span class="s4">(</span><span class="s1">est</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">input_dtye</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Initialization for fit_binary. 
 
    Returns y, coef, intercept, average_coef, average_intercept. 
    &quot;&quot;&quot;</span>
    <span class="s1">y_i </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">(</span><span class="s1">y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">input_dtye</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">)</span>
    <span class="s1">y_i</span><span class="s4">[</span><span class="s1">y </span><span class="s4">!= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]] = -</span><span class="s6">1.0</span>
    <span class="s1">average_intercept </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s1">average_coef </span><span class="s4">= </span><span class="s3">None</span>

    <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">est</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">) == </span><span class="s6">2</span><span class="s4">:</span>
        <span class="s3">if not </span><span class="s1">est</span><span class="s4">.</span><span class="s1">average</span><span class="s4">:</span>
            <span class="s1">coef </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">coef_</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">()</span>
            <span class="s1">intercept </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">intercept_</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">coef </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">_standard_coef</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">()</span>
            <span class="s1">intercept </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">_standard_intercept</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
            <span class="s1">average_coef </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">_average_coef</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">()</span>
            <span class="s1">average_intercept </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">_average_intercept</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">if not </span><span class="s1">est</span><span class="s4">.</span><span class="s1">average</span><span class="s4">:</span>
            <span class="s1">coef </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">coef_</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
            <span class="s1">intercept </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">intercept_</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">coef </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">_standard_coef</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
            <span class="s1">intercept </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">_standard_intercept</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
            <span class="s1">average_coef </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">_average_coef</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>
            <span class="s1">average_intercept </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">_average_intercept</span><span class="s4">[</span><span class="s1">i</span><span class="s4">]</span>

    <span class="s3">return </span><span class="s1">y_i</span><span class="s4">, </span><span class="s1">coef</span><span class="s4">, </span><span class="s1">intercept</span><span class="s4">, </span><span class="s1">average_coef</span><span class="s4">, </span><span class="s1">average_intercept</span>


<span class="s3">def </span><span class="s1">fit_binary</span><span class="s4">(</span>
    <span class="s1">est</span><span class="s4">,</span>
    <span class="s1">i</span><span class="s4">,</span>
    <span class="s1">X</span><span class="s4">,</span>
    <span class="s1">y</span><span class="s4">,</span>
    <span class="s1">alpha</span><span class="s4">,</span>
    <span class="s1">C</span><span class="s4">,</span>
    <span class="s1">learning_rate</span><span class="s4">,</span>
    <span class="s1">max_iter</span><span class="s4">,</span>
    <span class="s1">pos_weight</span><span class="s4">,</span>
    <span class="s1">neg_weight</span><span class="s4">,</span>
    <span class="s1">sample_weight</span><span class="s4">,</span>
    <span class="s1">validation_mask</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Fit a single binary classifier. 
 
    The i'th class is considered the &quot;positive&quot; class. 
 
    Parameters 
    ---------- 
    est : Estimator object 
        The estimator to fit 
 
    i : int 
        Index of the positive class 
 
    X : numpy array or sparse matrix of shape [n_samples,n_features] 
        Training data 
 
    y : numpy array of shape [n_samples, ] 
        Target values 
 
    alpha : float 
        The regularization parameter 
 
    C : float 
        Maximum step size for passive aggressive 
 
    learning_rate : str 
        The learning rate. Accepted values are 'constant', 'optimal', 
        'invscaling', 'pa1' and 'pa2'. 
 
    max_iter : int 
        The maximum number of iterations (epochs) 
 
    pos_weight : float 
        The weight of the positive class 
 
    neg_weight : float 
        The weight of the negative class 
 
    sample_weight : numpy array of shape [n_samples, ] 
        The weight of each sample 
 
    validation_mask : numpy array of shape [n_samples, ], default=None 
        Precomputed validation mask in case _fit_binary is called in the 
        context of a one-vs-rest reduction. 
 
    random_state : int, RandomState instance, default=None 
        If int, random_state is the seed used by the random number generator; 
        If RandomState instance, random_state is the random number generator; 
        If None, the random number generator is the RandomState instance used 
        by `np.random`. 
    &quot;&quot;&quot;</span>
    <span class="s0"># if average is not true, average_coef, and average_intercept will be</span>
    <span class="s0"># unused</span>
    <span class="s1">y_i</span><span class="s4">, </span><span class="s1">coef</span><span class="s4">, </span><span class="s1">intercept</span><span class="s4">, </span><span class="s1">average_coef</span><span class="s4">, </span><span class="s1">average_intercept </span><span class="s4">= </span><span class="s1">_prepare_fit_binary</span><span class="s4">(</span>
        <span class="s1">est</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">i</span><span class="s4">, </span><span class="s1">input_dtye</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span>
    <span class="s4">)</span>
    <span class="s3">assert </span><span class="s1">y_i</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s1">y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s1">sample_weight</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

    <span class="s1">random_state </span><span class="s4">= </span><span class="s1">check_random_state</span><span class="s4">(</span><span class="s1">random_state</span><span class="s4">)</span>
    <span class="s1">dataset</span><span class="s4">, </span><span class="s1">intercept_decay </span><span class="s4">= </span><span class="s1">make_dataset</span><span class="s4">(</span>
        <span class="s1">X</span><span class="s4">, </span><span class="s1">y_i</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span>
    <span class="s4">)</span>

    <span class="s1">penalty_type </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">_get_penalty_type</span><span class="s4">(</span><span class="s1">est</span><span class="s4">.</span><span class="s1">penalty</span><span class="s4">)</span>
    <span class="s1">learning_rate_type </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">_get_learning_rate_type</span><span class="s4">(</span><span class="s1">learning_rate</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">validation_mask </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">validation_mask </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">_make_validation_split</span><span class="s4">(</span><span class="s1">y_i</span><span class="s4">, </span><span class="s1">sample_mask</span><span class="s4">=</span><span class="s1">sample_weight </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">)</span>
    <span class="s1">classes </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">([-</span><span class="s6">1</span><span class="s4">, </span><span class="s6">1</span><span class="s4">], </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">y_i</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)</span>
    <span class="s1">validation_score_cb </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">_make_validation_score_cb</span><span class="s4">(</span>
        <span class="s1">validation_mask</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y_i</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s1">classes</span><span class="s4">=</span><span class="s1">classes</span>
    <span class="s4">)</span>

    <span class="s0"># numpy mtrand expects a C long which is a signed 32 bit integer under</span>
    <span class="s0"># Windows</span>
    <span class="s1">seed </span><span class="s4">= </span><span class="s1">random_state</span><span class="s4">.</span><span class="s1">randint</span><span class="s4">(</span><span class="s1">MAX_INT</span><span class="s4">)</span>

    <span class="s1">tol </span><span class="s4">= </span><span class="s1">est</span><span class="s4">.</span><span class="s1">tol </span><span class="s3">if </span><span class="s1">est</span><span class="s4">.</span><span class="s1">tol </span><span class="s3">is not None else </span><span class="s4">-</span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span>

    <span class="s1">_plain_sgd </span><span class="s4">= </span><span class="s1">_get_plain_sgd_function</span><span class="s4">(</span><span class="s1">input_dtype</span><span class="s4">=</span><span class="s1">coef</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)</span>
    <span class="s1">coef</span><span class="s4">, </span><span class="s1">intercept</span><span class="s4">, </span><span class="s1">average_coef</span><span class="s4">, </span><span class="s1">average_intercept</span><span class="s4">, </span><span class="s1">n_iter_ </span><span class="s4">= </span><span class="s1">_plain_sgd</span><span class="s4">(</span>
        <span class="s1">coef</span><span class="s4">,</span>
        <span class="s1">intercept</span><span class="s4">,</span>
        <span class="s1">average_coef</span><span class="s4">,</span>
        <span class="s1">average_intercept</span><span class="s4">,</span>
        <span class="s1">est</span><span class="s4">.</span><span class="s1">_loss_function_</span><span class="s4">,</span>
        <span class="s1">penalty_type</span><span class="s4">,</span>
        <span class="s1">alpha</span><span class="s4">,</span>
        <span class="s1">C</span><span class="s4">,</span>
        <span class="s1">est</span><span class="s4">.</span><span class="s1">l1_ratio</span><span class="s4">,</span>
        <span class="s1">dataset</span><span class="s4">,</span>
        <span class="s1">validation_mask</span><span class="s4">,</span>
        <span class="s1">est</span><span class="s4">.</span><span class="s1">early_stopping</span><span class="s4">,</span>
        <span class="s1">validation_score_cb</span><span class="s4">,</span>
        <span class="s1">int</span><span class="s4">(</span><span class="s1">est</span><span class="s4">.</span><span class="s1">n_iter_no_change</span><span class="s4">),</span>
        <span class="s1">max_iter</span><span class="s4">,</span>
        <span class="s1">tol</span><span class="s4">,</span>
        <span class="s1">int</span><span class="s4">(</span><span class="s1">est</span><span class="s4">.</span><span class="s1">fit_intercept</span><span class="s4">),</span>
        <span class="s1">int</span><span class="s4">(</span><span class="s1">est</span><span class="s4">.</span><span class="s1">verbose</span><span class="s4">),</span>
        <span class="s1">int</span><span class="s4">(</span><span class="s1">est</span><span class="s4">.</span><span class="s1">shuffle</span><span class="s4">),</span>
        <span class="s1">seed</span><span class="s4">,</span>
        <span class="s1">pos_weight</span><span class="s4">,</span>
        <span class="s1">neg_weight</span><span class="s4">,</span>
        <span class="s1">learning_rate_type</span><span class="s4">,</span>
        <span class="s1">est</span><span class="s4">.</span><span class="s1">eta0</span><span class="s4">,</span>
        <span class="s1">est</span><span class="s4">.</span><span class="s1">power_t</span><span class="s4">,</span>
        <span class="s6">0</span><span class="s4">,</span>
        <span class="s1">est</span><span class="s4">.</span><span class="s1">t_</span><span class="s4">,</span>
        <span class="s1">intercept_decay</span><span class="s4">,</span>
        <span class="s1">est</span><span class="s4">.</span><span class="s1">average</span><span class="s4">,</span>
    <span class="s4">)</span>

    <span class="s3">if </span><span class="s1">est</span><span class="s4">.</span><span class="s1">average</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">est</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">) == </span><span class="s6">2</span><span class="s4">:</span>
            <span class="s1">est</span><span class="s4">.</span><span class="s1">_average_intercept</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] = </span><span class="s1">average_intercept</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">est</span><span class="s4">.</span><span class="s1">_average_intercept</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s1">average_intercept</span>

    <span class="s3">return </span><span class="s1">coef</span><span class="s4">, </span><span class="s1">intercept</span><span class="s4">, </span><span class="s1">n_iter_</span>


<span class="s3">def </span><span class="s1">_get_plain_sgd_function</span><span class="s4">(</span><span class="s1">input_dtype</span><span class="s4">):</span>
    <span class="s3">return </span><span class="s1">_plain_sgd32 </span><span class="s3">if </span><span class="s1">input_dtype </span><span class="s4">== </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32 </span><span class="s3">else </span><span class="s1">_plain_sgd64</span>


<span class="s3">class </span><span class="s1">BaseSGDClassifier</span><span class="s4">(</span><span class="s1">LinearClassifierMixin</span><span class="s4">, </span><span class="s1">BaseSGD</span><span class="s4">, </span><span class="s1">metaclass</span><span class="s4">=</span><span class="s1">ABCMeta</span><span class="s4">):</span>
    <span class="s1">loss_functions </span><span class="s4">= {</span>
        <span class="s5">&quot;hinge&quot;</span><span class="s4">: (</span><span class="s1">Hinge</span><span class="s4">, </span><span class="s6">1.0</span><span class="s4">),</span>
        <span class="s5">&quot;squared_hinge&quot;</span><span class="s4">: (</span><span class="s1">SquaredHinge</span><span class="s4">, </span><span class="s6">1.0</span><span class="s4">),</span>
        <span class="s5">&quot;perceptron&quot;</span><span class="s4">: (</span><span class="s1">Hinge</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">),</span>
        <span class="s5">&quot;log_loss&quot;</span><span class="s4">: (</span><span class="s1">Log</span><span class="s4">,),</span>
        <span class="s5">&quot;modified_huber&quot;</span><span class="s4">: (</span><span class="s1">ModifiedHuber</span><span class="s4">,),</span>
        <span class="s5">&quot;squared_error&quot;</span><span class="s4">: (</span><span class="s1">SquaredLoss</span><span class="s4">,),</span>
        <span class="s5">&quot;huber&quot;</span><span class="s4">: (</span><span class="s1">Huber</span><span class="s4">, </span><span class="s1">DEFAULT_EPSILON</span><span class="s4">),</span>
        <span class="s5">&quot;epsilon_insensitive&quot;</span><span class="s4">: (</span><span class="s1">EpsilonInsensitive</span><span class="s4">, </span><span class="s1">DEFAULT_EPSILON</span><span class="s4">),</span>
        <span class="s5">&quot;squared_epsilon_insensitive&quot;</span><span class="s4">: (</span><span class="s1">SquaredEpsilonInsensitive</span><span class="s4">, </span><span class="s1">DEFAULT_EPSILON</span><span class="s4">),</span>
    <span class="s4">}</span>

    <span class="s1">_parameter_constraints</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
        <span class="s4">**</span><span class="s1">BaseSGD</span><span class="s4">.</span><span class="s1">_parameter_constraints</span><span class="s4">,</span>
        <span class="s5">&quot;loss&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s1">loss_functions</span><span class="s4">))],</span>
        <span class="s5">&quot;early_stopping&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;validation_fraction&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;neither&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;n_iter_no_change&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;n_jobs&quot;</span><span class="s4">: [</span><span class="s1">Integral</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;class_weight&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;balanced&quot;</span><span class="s4">}), </span><span class="s1">dict</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
    <span class="s4">}</span>

    <span class="s4">@</span><span class="s1">abstractmethod</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">loss</span><span class="s4">=</span><span class="s5">&quot;hinge&quot;</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">penalty</span><span class="s4">=</span><span class="s5">&quot;l2&quot;</span><span class="s4">,</span>
        <span class="s1">alpha</span><span class="s4">=</span><span class="s6">0.0001</span><span class="s4">,</span>
        <span class="s1">l1_ratio</span><span class="s4">=</span><span class="s6">0.15</span><span class="s4">,</span>
        <span class="s1">fit_intercept</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">max_iter</span><span class="s4">=</span><span class="s6">1000</span><span class="s4">,</span>
        <span class="s1">tol</span><span class="s4">=</span><span class="s6">1e-3</span><span class="s4">,</span>
        <span class="s1">shuffle</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
        <span class="s1">epsilon</span><span class="s4">=</span><span class="s1">DEFAULT_EPSILON</span><span class="s4">,</span>
        <span class="s1">n_jobs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">learning_rate</span><span class="s4">=</span><span class="s5">&quot;optimal&quot;</span><span class="s4">,</span>
        <span class="s1">eta0</span><span class="s4">=</span><span class="s6">0.0</span><span class="s4">,</span>
        <span class="s1">power_t</span><span class="s4">=</span><span class="s6">0.5</span><span class="s4">,</span>
        <span class="s1">early_stopping</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">validation_fraction</span><span class="s4">=</span><span class="s6">0.1</span><span class="s4">,</span>
        <span class="s1">n_iter_no_change</span><span class="s4">=</span><span class="s6">5</span><span class="s4">,</span>
        <span class="s1">class_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">warm_start</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">average</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span>
            <span class="s1">loss</span><span class="s4">=</span><span class="s1">loss</span><span class="s4">,</span>
            <span class="s1">penalty</span><span class="s4">=</span><span class="s1">penalty</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">=</span><span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">l1_ratio</span><span class="s4">=</span><span class="s1">l1_ratio</span><span class="s4">,</span>
            <span class="s1">fit_intercept</span><span class="s4">=</span><span class="s1">fit_intercept</span><span class="s4">,</span>
            <span class="s1">max_iter</span><span class="s4">=</span><span class="s1">max_iter</span><span class="s4">,</span>
            <span class="s1">tol</span><span class="s4">=</span><span class="s1">tol</span><span class="s4">,</span>
            <span class="s1">shuffle</span><span class="s4">=</span><span class="s1">shuffle</span><span class="s4">,</span>
            <span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">,</span>
            <span class="s1">epsilon</span><span class="s4">=</span><span class="s1">epsilon</span><span class="s4">,</span>
            <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">=</span><span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">eta0</span><span class="s4">=</span><span class="s1">eta0</span><span class="s4">,</span>
            <span class="s1">power_t</span><span class="s4">=</span><span class="s1">power_t</span><span class="s4">,</span>
            <span class="s1">early_stopping</span><span class="s4">=</span><span class="s1">early_stopping</span><span class="s4">,</span>
            <span class="s1">validation_fraction</span><span class="s4">=</span><span class="s1">validation_fraction</span><span class="s4">,</span>
            <span class="s1">n_iter_no_change</span><span class="s4">=</span><span class="s1">n_iter_no_change</span><span class="s4">,</span>
            <span class="s1">warm_start</span><span class="s4">=</span><span class="s1">warm_start</span><span class="s4">,</span>
            <span class="s1">average</span><span class="s4">=</span><span class="s1">average</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">class_weight </span><span class="s4">= </span><span class="s1">class_weight</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs </span><span class="s4">= </span><span class="s1">n_jobs</span>

    <span class="s3">def </span><span class="s1">_partial_fit</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">X</span><span class="s4">,</span>
        <span class="s1">y</span><span class="s4">,</span>
        <span class="s1">alpha</span><span class="s4">,</span>
        <span class="s1">C</span><span class="s4">,</span>
        <span class="s1">loss</span><span class="s4">,</span>
        <span class="s1">learning_rate</span><span class="s4">,</span>
        <span class="s1">max_iter</span><span class="s4">,</span>
        <span class="s1">classes</span><span class="s4">,</span>
        <span class="s1">sample_weight</span><span class="s4">,</span>
        <span class="s1">coef_init</span><span class="s4">,</span>
        <span class="s1">intercept_init</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">first_call </span><span class="s4">= </span><span class="s3">not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;classes_&quot;</span><span class="s4">)</span>
        <span class="s1">X</span><span class="s4">, </span><span class="s1">y </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">y</span><span class="s4">,</span>
            <span class="s1">accept_sparse</span><span class="s4">=</span><span class="s5">&quot;csr&quot;</span><span class="s4">,</span>
            <span class="s1">dtype</span><span class="s4">=[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">],</span>
            <span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">,</span>
            <span class="s1">accept_large_sparse</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">reset</span><span class="s4">=</span><span class="s1">first_call</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">first_call</span><span class="s4">:</span>
            <span class="s0"># TODO(1.7) remove 0 from average parameter constraint</span>
            <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">average</span><span class="s4">, (</span><span class="s1">bool</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">bool_</span><span class="s4">)) </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
                <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                    <span class="s4">(</span>
                        <span class="s5">&quot;Passing average=0 to disable averaging is deprecated and will&quot;</span>
                        <span class="s5">&quot; be removed in 1.7. Please use average=False instead.&quot;</span>
                    <span class="s4">),</span>
                    <span class="s1">FutureWarning</span><span class="s4">,</span>
                <span class="s4">)</span>

        <span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_features </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span>

        <span class="s1">_check_partial_fit_first_call</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">classes</span><span class="s4">)</span>

        <span class="s1">n_classes </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

        <span class="s0"># Allocate datastructures from input arguments</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_expanded_class_weight </span><span class="s4">= </span><span class="s1">compute_class_weight</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">class_weight</span><span class="s4">, </span><span class="s1">classes</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s1">y</span>
        <span class="s4">)</span>
        <span class="s1">sample_weight </span><span class="s4">= </span><span class="s1">_check_sample_weight</span><span class="s4">(</span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;coef_&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">is None or </span><span class="s1">coef_init </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_allocate_parameter_mem</span><span class="s4">(</span>
                <span class="s1">n_classes</span><span class="s4">=</span><span class="s1">n_classes</span><span class="s4">,</span>
                <span class="s1">n_features</span><span class="s4">=</span><span class="s1">n_features</span><span class="s4">,</span>
                <span class="s1">input_dtype</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">,</span>
                <span class="s1">coef_init</span><span class="s4">=</span><span class="s1">coef_init</span><span class="s4">,</span>
                <span class="s1">intercept_init</span><span class="s4">=</span><span class="s1">intercept_init</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">n_features </span><span class="s4">!= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">coef_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;Number of features %d does not match previous data %d.&quot;</span>
                <span class="s4">% (</span><span class="s1">n_features</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">coef_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">])</span>
            <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_loss_function_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_loss_function</span><span class="s4">(</span><span class="s1">loss</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;t_&quot;</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">t_ </span><span class="s4">= </span><span class="s6">1.0</span>

        <span class="s0"># delegate to concrete training procedure</span>
        <span class="s3">if </span><span class="s1">n_classes </span><span class="s4">&gt; </span><span class="s6">2</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_fit_multiclass</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">,</span>
                <span class="s1">y</span><span class="s4">,</span>
                <span class="s1">alpha</span><span class="s4">=</span><span class="s1">alpha</span><span class="s4">,</span>
                <span class="s1">C</span><span class="s4">=</span><span class="s1">C</span><span class="s4">,</span>
                <span class="s1">learning_rate</span><span class="s4">=</span><span class="s1">learning_rate</span><span class="s4">,</span>
                <span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">,</span>
                <span class="s1">max_iter</span><span class="s4">=</span><span class="s1">max_iter</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">n_classes </span><span class="s4">== </span><span class="s6">2</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_fit_binary</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">,</span>
                <span class="s1">y</span><span class="s4">,</span>
                <span class="s1">alpha</span><span class="s4">=</span><span class="s1">alpha</span><span class="s4">,</span>
                <span class="s1">C</span><span class="s4">=</span><span class="s1">C</span><span class="s4">,</span>
                <span class="s1">learning_rate</span><span class="s4">=</span><span class="s1">learning_rate</span><span class="s4">,</span>
                <span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">,</span>
                <span class="s1">max_iter</span><span class="s4">=</span><span class="s1">max_iter</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;The number of classes has to be greater than one; got %d class&quot;</span>
                <span class="s4">% </span><span class="s1">n_classes</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_fit</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">X</span><span class="s4">,</span>
        <span class="s1">y</span><span class="s4">,</span>
        <span class="s1">alpha</span><span class="s4">,</span>
        <span class="s1">C</span><span class="s4">,</span>
        <span class="s1">loss</span><span class="s4">,</span>
        <span class="s1">learning_rate</span><span class="s4">,</span>
        <span class="s1">coef_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">intercept_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;classes_&quot;</span><span class="s4">):</span>
            <span class="s0"># delete the attribute otherwise _partial_fit thinks it's not the first call</span>
            <span class="s1">delattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;classes_&quot;</span><span class="s4">)</span>

        <span class="s0"># TODO(1.7) remove 0 from average parameter constraint</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">average</span><span class="s4">, (</span><span class="s1">bool</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">bool_</span><span class="s4">)) </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                <span class="s4">(</span>
                    <span class="s5">&quot;Passing average=0 to disable averaging is deprecated and will be &quot;</span>
                    <span class="s5">&quot;removed in 1.7. Please use average=False instead.&quot;</span>
                <span class="s4">),</span>
                <span class="s1">FutureWarning</span><span class="s4">,</span>
            <span class="s4">)</span>

        <span class="s0"># labels can be encoded as float, int, or string literals</span>
        <span class="s0"># np.unique sorts in asc order; largest class id is positive class</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span><span class="s1">y</span><span class="s4">=</span><span class="s1">y</span><span class="s4">)</span>
        <span class="s1">classes </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">unique</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">warm_start </span><span class="s3">and </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;coef_&quot;</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">coef_init </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">coef_init </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">coef_</span>
            <span class="s3">if </span><span class="s1">intercept_init </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">intercept_init </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">coef_ </span><span class="s4">= </span><span class="s3">None</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_ </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_coef </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">coef_</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_intercept </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_average_coef </span><span class="s4">= </span><span class="s3">None</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_average_intercept </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s0"># Clear iteration count for multiple call to fit.</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">t_ </span><span class="s4">= </span><span class="s6">1.0</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_partial_fit</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">y</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">C</span><span class="s4">,</span>
            <span class="s1">loss</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">max_iter</span><span class="s4">,</span>
            <span class="s1">classes</span><span class="s4">,</span>
            <span class="s1">sample_weight</span><span class="s4">,</span>
            <span class="s1">coef_init</span><span class="s4">,</span>
            <span class="s1">intercept_init</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">tol </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">tol </span><span class="s4">&gt; -</span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span>
            <span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_iter_ </span><span class="s4">== </span><span class="s1">self</span><span class="s4">.</span><span class="s1">max_iter</span>
        <span class="s4">):</span>
            <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                <span class="s4">(</span>
                    <span class="s5">&quot;Maximum number of iteration reached before &quot;</span>
                    <span class="s5">&quot;convergence. Consider increasing max_iter to &quot;</span>
                    <span class="s5">&quot;improve the fit.&quot;</span>
                <span class="s4">),</span>
                <span class="s1">ConvergenceWarning</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_fit_binary</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">alpha</span><span class="s4">, </span><span class="s1">C</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s1">learning_rate</span><span class="s4">, </span><span class="s1">max_iter</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Fit a binary classifier on X and y.&quot;&quot;&quot;</span>
        <span class="s1">coef</span><span class="s4">, </span><span class="s1">intercept</span><span class="s4">, </span><span class="s1">n_iter_ </span><span class="s4">= </span><span class="s1">fit_binary</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s6">1</span><span class="s4">,</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">y</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">C</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">max_iter</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_expanded_class_weight</span><span class="s4">[</span><span class="s6">1</span><span class="s4">],</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_expanded_class_weight</span><span class="s4">[</span><span class="s6">0</span><span class="s4">],</span>
            <span class="s1">sample_weight</span><span class="s4">,</span>
            <span class="s1">random_state</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">random_state</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">t_ </span><span class="s4">+= </span><span class="s1">n_iter_ </span><span class="s4">* </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_iter_ </span><span class="s4">= </span><span class="s1">n_iter_</span>

        <span class="s0"># need to be 2d</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">&lt;= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">t_ </span><span class="s4">- </span><span class="s6">1</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">coef_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_average_coef</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">)</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_average_intercept</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">coef_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_coef</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">)</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_intercept </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">intercept</span><span class="s4">)</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_intercept</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">coef_ </span><span class="s4">= </span><span class="s1">coef</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">)</span>
            <span class="s0"># intercept is a float, need to convert it to an array of length 1</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">intercept</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_fit_multiclass</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">alpha</span><span class="s4">, </span><span class="s1">C</span><span class="s4">, </span><span class="s1">learning_rate</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s1">max_iter</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Fit a multi-class classifier by combining binary classifiers 
 
        Each binary classifier predicts one class versus all others. This 
        strategy is called OvA (One versus All) or OvR (One versus Rest). 
        &quot;&quot;&quot;</span>
        <span class="s0"># Precompute the validation split using the multiclass labels</span>
        <span class="s0"># to ensure proper balancing of the classes.</span>
        <span class="s1">validation_mask </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_make_validation_split</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_mask</span><span class="s4">=</span><span class="s1">sample_weight </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">)</span>

        <span class="s0"># Use joblib to fit OvA in parallel.</span>
        <span class="s0"># Pick the random seed for each job outside of fit_binary to avoid</span>
        <span class="s0"># sharing the estimator random state between threads which could lead</span>
        <span class="s0"># to non-deterministic behavior</span>
        <span class="s1">random_state </span><span class="s4">= </span><span class="s1">check_random_state</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">random_state</span><span class="s4">)</span>
        <span class="s1">seeds </span><span class="s4">= </span><span class="s1">random_state</span><span class="s4">.</span><span class="s1">randint</span><span class="s4">(</span><span class="s1">MAX_INT</span><span class="s4">, </span><span class="s1">size</span><span class="s4">=</span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">))</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">Parallel</span><span class="s4">(</span>
            <span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs</span><span class="s4">, </span><span class="s1">verbose</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose</span><span class="s4">, </span><span class="s1">require</span><span class="s4">=</span><span class="s5">&quot;sharedmem&quot;</span>
        <span class="s4">)(</span>
            <span class="s1">delayed</span><span class="s4">(</span><span class="s1">fit_binary</span><span class="s4">)(</span>
                <span class="s1">self</span><span class="s4">,</span>
                <span class="s1">i</span><span class="s4">,</span>
                <span class="s1">X</span><span class="s4">,</span>
                <span class="s1">y</span><span class="s4">,</span>
                <span class="s1">alpha</span><span class="s4">,</span>
                <span class="s1">C</span><span class="s4">,</span>
                <span class="s1">learning_rate</span><span class="s4">,</span>
                <span class="s1">max_iter</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_expanded_class_weight</span><span class="s4">[</span><span class="s1">i</span><span class="s4">],</span>
                <span class="s6">1.0</span><span class="s4">,</span>
                <span class="s1">sample_weight</span><span class="s4">,</span>
                <span class="s1">validation_mask</span><span class="s4">=</span><span class="s1">validation_mask</span><span class="s4">,</span>
                <span class="s1">random_state</span><span class="s4">=</span><span class="s1">seed</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">seed </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">seeds</span><span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s0"># take the maximum of n_iter_ over every binary fit</span>
        <span class="s1">n_iter_ </span><span class="s4">= </span><span class="s6">0.0</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s4">, (</span><span class="s1">_</span><span class="s4">, </span><span class="s1">intercept</span><span class="s4">, </span><span class="s1">n_iter_i</span><span class="s4">) </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">result</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_</span><span class="s4">[</span><span class="s1">i</span><span class="s4">] = </span><span class="s1">intercept</span>
            <span class="s1">n_iter_ </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s1">n_iter_</span><span class="s4">, </span><span class="s1">n_iter_i</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">t_ </span><span class="s4">+= </span><span class="s1">n_iter_ </span><span class="s4">* </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_iter_ </span><span class="s4">= </span><span class="s1">n_iter_</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">&lt;= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">t_ </span><span class="s4">- </span><span class="s6">1.0</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">coef_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_average_coef</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_average_intercept</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">coef_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_coef</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_intercept </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_</span><span class="s4">)</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_intercept</span>

    <span class="s4">@</span><span class="s1">_fit_context</span><span class="s4">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">partial_fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">classes</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Perform one epoch of stochastic gradient descent on given samples. 
 
        Internally, this method uses ``max_iter = 1``. Therefore, it is not 
        guaranteed that a minimum of the cost function is reached after calling 
        it once. Matters such as objective convergence, early stopping, and 
        learning rate adjustments should be handled by the user. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix}, shape (n_samples, n_features) 
            Subset of the training data. 
 
        y : ndarray of shape (n_samples,) 
            Subset of the target values. 
 
        classes : ndarray of shape (n_classes,), default=None 
            Classes across all calls to partial_fit. 
            Can be obtained by via `np.unique(y_all)`, where y_all is the 
            target vector of the entire dataset. 
            This argument is required for the first call to partial_fit 
            and can be omitted in the subsequent calls. 
            Note that y doesn't need to contain all labels in `classes`. 
 
        sample_weight : array-like, shape (n_samples,), default=None 
            Weights applied to individual samples. 
            If not provided, uniform weights are assumed. 
 
        Returns 
        ------- 
        self : object 
            Returns an instance of self. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;classes_&quot;</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_more_validate_params</span><span class="s4">(</span><span class="s1">for_partial_fit</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">class_weight </span><span class="s4">== </span><span class="s5">&quot;balanced&quot;</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                    <span class="s5">&quot;class_weight '{0}' is not supported for &quot;</span>
                    <span class="s5">&quot;partial_fit. In order to use 'balanced' weights,&quot;</span>
                    <span class="s5">&quot; use compute_class_weight('{0}', &quot;</span>
                    <span class="s5">&quot;classes=classes, y=y). &quot;</span>
                    <span class="s5">&quot;In place of y you can use a large enough sample &quot;</span>
                    <span class="s5">&quot;of the full training set target to properly &quot;</span>
                    <span class="s5">&quot;estimate the class frequency distributions. &quot;</span>
                    <span class="s5">&quot;Pass the resulting weights as the class_weight &quot;</span>
                    <span class="s5">&quot;parameter.&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">class_weight</span><span class="s4">)</span>
                <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_partial_fit</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">y</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">C</span><span class="s4">=</span><span class="s6">1.0</span><span class="s4">,</span>
            <span class="s1">loss</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">max_iter</span><span class="s4">=</span><span class="s6">1</span><span class="s4">,</span>
            <span class="s1">classes</span><span class="s4">=</span><span class="s1">classes</span><span class="s4">,</span>
            <span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">,</span>
            <span class="s1">coef_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
            <span class="s1">intercept_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_fit_context</span><span class="s4">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">coef_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">intercept_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Fit linear model with Stochastic Gradient Descent. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix}, shape (n_samples, n_features) 
            Training data. 
 
        y : ndarray of shape (n_samples,) 
            Target values. 
 
        coef_init : ndarray of shape (n_classes, n_features), default=None 
            The initial coefficients to warm-start the optimization. 
 
        intercept_init : ndarray of shape (n_classes,), default=None 
            The initial intercept to warm-start the optimization. 
 
        sample_weight : array-like, shape (n_samples,), default=None 
            Weights applied to individual samples. 
            If not provided, uniform weights are assumed. These weights will 
            be multiplied with class_weight (passed through the 
            constructor) if class_weight is specified. 
 
        Returns 
        ------- 
        self : object 
            Returns an instance of self. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_more_validate_params</span><span class="s4">()</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fit</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">y</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">C</span><span class="s4">=</span><span class="s6">1.0</span><span class="s4">,</span>
            <span class="s1">loss</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">coef_init</span><span class="s4">=</span><span class="s1">coef_init</span><span class="s4">,</span>
            <span class="s1">intercept_init</span><span class="s4">=</span><span class="s1">intercept_init</span><span class="s4">,</span>
            <span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">,</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">SGDClassifier</span><span class="s4">(</span><span class="s1">BaseSGDClassifier</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Linear classifiers (SVM, logistic regression, etc.) with SGD training. 
 
    This estimator implements regularized linear models with stochastic 
    gradient descent (SGD) learning: the gradient of the loss is estimated 
    each sample at a time and the model is updated along the way with a 
    decreasing strength schedule (aka learning rate). SGD allows minibatch 
    (online/out-of-core) learning via the `partial_fit` method. 
    For best results using the default learning rate schedule, the data should 
    have zero mean and unit variance. 
 
    This implementation works with data represented as dense or sparse arrays 
    of floating point values for the features. The model it fits can be 
    controlled with the loss parameter; by default, it fits a linear support 
    vector machine (SVM). 
 
    The regularizer is a penalty added to the loss function that shrinks model 
    parameters towards the zero vector using either the squared euclidean norm 
    L2 or the absolute norm L1 or a combination of both (Elastic Net). If the 
    parameter update crosses the 0.0 value because of the regularizer, the 
    update is truncated to 0.0 to allow for learning sparse models and achieve 
    online feature selection. 
 
    Read more in the :ref:`User Guide &lt;sgd&gt;`. 
 
    Parameters 
    ---------- 
    loss : {'hinge', 'log_loss', 'modified_huber', 'squared_hinge',\ 
        'perceptron', 'squared_error', 'huber', 'epsilon_insensitive',\ 
        'squared_epsilon_insensitive'}, default='hinge' 
        The loss function to be used. 
 
        - 'hinge' gives a linear SVM. 
        - 'log_loss' gives logistic regression, a probabilistic classifier. 
        - 'modified_huber' is another smooth loss that brings tolerance to 
          outliers as well as probability estimates. 
        - 'squared_hinge' is like hinge but is quadratically penalized. 
        - 'perceptron' is the linear loss used by the perceptron algorithm. 
        - The other losses, 'squared_error', 'huber', 'epsilon_insensitive' and 
          'squared_epsilon_insensitive' are designed for regression but can be useful 
          in classification as well; see 
          :class:`~sklearn.linear_model.SGDRegressor` for a description. 
 
        More details about the losses formulas can be found in the 
        :ref:`User Guide &lt;sgd_mathematical_formulation&gt;`. 
 
    penalty : {'l2', 'l1', 'elasticnet', None}, default='l2' 
        The penalty (aka regularization term) to be used. Defaults to 'l2' 
        which is the standard regularizer for linear SVM models. 'l1' and 
        'elasticnet' might bring sparsity to the model (feature selection) 
        not achievable with 'l2'. No penalty is added when set to `None`. 
 
    alpha : float, default=0.0001 
        Constant that multiplies the regularization term. The higher the 
        value, the stronger the regularization. Also used to compute the 
        learning rate when `learning_rate` is set to 'optimal'. 
        Values must be in the range `[0.0, inf)`. 
 
    l1_ratio : float, default=0.15 
        The Elastic Net mixing parameter, with 0 &lt;= l1_ratio &lt;= 1. 
        l1_ratio=0 corresponds to L2 penalty, l1_ratio=1 to L1. 
        Only used if `penalty` is 'elasticnet'. 
        Values must be in the range `[0.0, 1.0]`. 
 
    fit_intercept : bool, default=True 
        Whether the intercept should be estimated or not. If False, the 
        data is assumed to be already centered. 
 
    max_iter : int, default=1000 
        The maximum number of passes over the training data (aka epochs). 
        It only impacts the behavior in the ``fit`` method, and not the 
        :meth:`partial_fit` method. 
        Values must be in the range `[1, inf)`. 
 
        .. versionadded:: 0.19 
 
    tol : float or None, default=1e-3 
        The stopping criterion. If it is not None, training will stop 
        when (loss &gt; best_loss - tol) for ``n_iter_no_change`` consecutive 
        epochs. 
        Convergence is checked against the training loss or the 
        validation loss depending on the `early_stopping` parameter. 
        Values must be in the range `[0.0, inf)`. 
 
        .. versionadded:: 0.19 
 
    shuffle : bool, default=True 
        Whether or not the training data should be shuffled after each epoch. 
 
    verbose : int, default=0 
        The verbosity level. 
        Values must be in the range `[0, inf)`. 
 
    epsilon : float, default=0.1 
        Epsilon in the epsilon-insensitive loss functions; only if `loss` is 
        'huber', 'epsilon_insensitive', or 'squared_epsilon_insensitive'. 
        For 'huber', determines the threshold at which it becomes less 
        important to get the prediction exactly right. 
        For epsilon-insensitive, any differences between the current prediction 
        and the correct label are ignored if they are less than this threshold. 
        Values must be in the range `[0.0, inf)`. 
 
    n_jobs : int, default=None 
        The number of CPUs to use to do the OVA (One Versus All, for 
        multi-class problems) computation. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    random_state : int, RandomState instance, default=None 
        Used for shuffling the data, when ``shuffle`` is set to ``True``. 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
        Integer values must be in the range `[0, 2**32 - 1]`. 
 
    learning_rate : str, default='optimal' 
        The learning rate schedule: 
 
        - 'constant': `eta = eta0` 
        - 'optimal': `eta = 1.0 / (alpha * (t + t0))` 
          where `t0` is chosen by a heuristic proposed by Leon Bottou. 
        - 'invscaling': `eta = eta0 / pow(t, power_t)` 
        - 'adaptive': `eta = eta0`, as long as the training keeps decreasing. 
          Each time n_iter_no_change consecutive epochs fail to decrease the 
          training loss by tol or fail to increase validation score by tol if 
          `early_stopping` is `True`, the current learning rate is divided by 5. 
 
            .. versionadded:: 0.20 
                Added 'adaptive' option 
 
    eta0 : float, default=0.0 
        The initial learning rate for the 'constant', 'invscaling' or 
        'adaptive' schedules. The default value is 0.0 as eta0 is not used by 
        the default schedule 'optimal'. 
        Values must be in the range `[0.0, inf)`. 
 
    power_t : float, default=0.5 
        The exponent for inverse scaling learning rate. 
        Values must be in the range `(-inf, inf)`. 
 
    early_stopping : bool, default=False 
        Whether to use early stopping to terminate training when validation 
        score is not improving. If set to `True`, it will automatically set aside 
        a stratified fraction of training data as validation and terminate 
        training when validation score returned by the `score` method is not 
        improving by at least tol for n_iter_no_change consecutive epochs. 
 
        .. versionadded:: 0.20 
            Added 'early_stopping' option 
 
    validation_fraction : float, default=0.1 
        The proportion of training data to set aside as validation set for 
        early stopping. Must be between 0 and 1. 
        Only used if `early_stopping` is True. 
        Values must be in the range `(0.0, 1.0)`. 
 
        .. versionadded:: 0.20 
            Added 'validation_fraction' option 
 
    n_iter_no_change : int, default=5 
        Number of iterations with no improvement to wait before stopping 
        fitting. 
        Convergence is checked against the training loss or the 
        validation loss depending on the `early_stopping` parameter. 
        Integer values must be in the range `[1, max_iter)`. 
 
        .. versionadded:: 0.20 
            Added 'n_iter_no_change' option 
 
    class_weight : dict, {class_label: weight} or &quot;balanced&quot;, default=None 
        Preset for the class_weight fit parameter. 
 
        Weights associated with classes. If not given, all classes 
        are supposed to have weight one. 
 
        The &quot;balanced&quot; mode uses the values of y to automatically adjust 
        weights inversely proportional to class frequencies in the input data 
        as ``n_samples / (n_classes * np.bincount(y))``. 
 
    warm_start : bool, default=False 
        When set to True, reuse the solution of the previous call to fit as 
        initialization, otherwise, just erase the previous solution. 
        See :term:`the Glossary &lt;warm_start&gt;`. 
 
        Repeatedly calling fit or partial_fit when warm_start is True can 
        result in a different solution than when calling fit a single time 
        because of the way the data is shuffled. 
        If a dynamic learning rate is used, the learning rate is adapted 
        depending on the number of samples already seen. Calling ``fit`` resets 
        this counter, while ``partial_fit`` will result in increasing the 
        existing counter. 
 
    average : bool or int, default=False 
        When set to `True`, computes the averaged SGD weights across all 
        updates and stores the result in the ``coef_`` attribute. If set to 
        an int greater than 1, averaging will begin once the total number of 
        samples seen reaches `average`. So ``average=10`` will begin 
        averaging after seeing 10 samples. 
        Integer values must be in the range `[1, n_samples]`. 
 
    Attributes 
    ---------- 
    coef_ : ndarray of shape (1, n_features) if n_classes == 2 else \ 
            (n_classes, n_features) 
        Weights assigned to the features. 
 
    intercept_ : ndarray of shape (1,) if n_classes == 2 else (n_classes,) 
        Constants in decision function. 
 
    n_iter_ : int 
        The actual number of iterations before reaching the stopping criterion. 
        For multiclass fits, it is the maximum over every binary fit. 
 
    loss_function_ : concrete ``LossFunction`` 
 
        .. deprecated:: 1.4 
            Attribute `loss_function_` was deprecated in version 1.4 and will be 
            removed in 1.6. 
 
    classes_ : array of shape (n_classes,) 
 
    t_ : int 
        Number of weight updates performed during training. 
        Same as ``(n_iter_ * n_samples + 1)``. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    sklearn.svm.LinearSVC : Linear support vector classification. 
    LogisticRegression : Logistic regression. 
    Perceptron : Inherits from SGDClassifier. ``Perceptron()`` is equivalent to 
        ``SGDClassifier(loss=&quot;perceptron&quot;, eta0=1, learning_rate=&quot;constant&quot;, 
        penalty=None)``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.linear_model import SGDClassifier 
    &gt;&gt;&gt; from sklearn.preprocessing import StandardScaler 
    &gt;&gt;&gt; from sklearn.pipeline import make_pipeline 
    &gt;&gt;&gt; X = np.array([[-1, -1], [-2, -1], [1, 1], [2, 1]]) 
    &gt;&gt;&gt; Y = np.array([1, 1, 2, 2]) 
    &gt;&gt;&gt; # Always scale the input. The most convenient way is to use a pipeline. 
    &gt;&gt;&gt; clf = make_pipeline(StandardScaler(), 
    ...                     SGDClassifier(max_iter=1000, tol=1e-3)) 
    &gt;&gt;&gt; clf.fit(X, Y) 
    Pipeline(steps=[('standardscaler', StandardScaler()), 
                    ('sgdclassifier', SGDClassifier())]) 
    &gt;&gt;&gt; print(clf.predict([[-0.8, -1]])) 
    [1] 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
        <span class="s4">**</span><span class="s1">BaseSGDClassifier</span><span class="s4">.</span><span class="s1">_parameter_constraints</span><span class="s4">,</span>
        <span class="s5">&quot;penalty&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;l2&quot;</span><span class="s4">, </span><span class="s5">&quot;l1&quot;</span><span class="s4">, </span><span class="s5">&quot;elasticnet&quot;</span><span class="s4">}), </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;alpha&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;l1_ratio&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;both&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;power_t&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;neither&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;epsilon&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;learning_rate&quot;</span><span class="s4">: [</span>
            <span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;constant&quot;</span><span class="s4">, </span><span class="s5">&quot;optimal&quot;</span><span class="s4">, </span><span class="s5">&quot;invscaling&quot;</span><span class="s4">, </span><span class="s5">&quot;adaptive&quot;</span><span class="s4">}),</span>
            <span class="s1">Hidden</span><span class="s4">(</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;pa1&quot;</span><span class="s4">, </span><span class="s5">&quot;pa2&quot;</span><span class="s4">})),</span>
        <span class="s4">],</span>
        <span class="s5">&quot;eta0&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
    <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">loss</span><span class="s4">=</span><span class="s5">&quot;hinge&quot;</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">penalty</span><span class="s4">=</span><span class="s5">&quot;l2&quot;</span><span class="s4">,</span>
        <span class="s1">alpha</span><span class="s4">=</span><span class="s6">0.0001</span><span class="s4">,</span>
        <span class="s1">l1_ratio</span><span class="s4">=</span><span class="s6">0.15</span><span class="s4">,</span>
        <span class="s1">fit_intercept</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">max_iter</span><span class="s4">=</span><span class="s6">1000</span><span class="s4">,</span>
        <span class="s1">tol</span><span class="s4">=</span><span class="s6">1e-3</span><span class="s4">,</span>
        <span class="s1">shuffle</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
        <span class="s1">epsilon</span><span class="s4">=</span><span class="s1">DEFAULT_EPSILON</span><span class="s4">,</span>
        <span class="s1">n_jobs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">learning_rate</span><span class="s4">=</span><span class="s5">&quot;optimal&quot;</span><span class="s4">,</span>
        <span class="s1">eta0</span><span class="s4">=</span><span class="s6">0.0</span><span class="s4">,</span>
        <span class="s1">power_t</span><span class="s4">=</span><span class="s6">0.5</span><span class="s4">,</span>
        <span class="s1">early_stopping</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">validation_fraction</span><span class="s4">=</span><span class="s6">0.1</span><span class="s4">,</span>
        <span class="s1">n_iter_no_change</span><span class="s4">=</span><span class="s6">5</span><span class="s4">,</span>
        <span class="s1">class_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">warm_start</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">average</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span>
            <span class="s1">loss</span><span class="s4">=</span><span class="s1">loss</span><span class="s4">,</span>
            <span class="s1">penalty</span><span class="s4">=</span><span class="s1">penalty</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">=</span><span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">l1_ratio</span><span class="s4">=</span><span class="s1">l1_ratio</span><span class="s4">,</span>
            <span class="s1">fit_intercept</span><span class="s4">=</span><span class="s1">fit_intercept</span><span class="s4">,</span>
            <span class="s1">max_iter</span><span class="s4">=</span><span class="s1">max_iter</span><span class="s4">,</span>
            <span class="s1">tol</span><span class="s4">=</span><span class="s1">tol</span><span class="s4">,</span>
            <span class="s1">shuffle</span><span class="s4">=</span><span class="s1">shuffle</span><span class="s4">,</span>
            <span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">,</span>
            <span class="s1">epsilon</span><span class="s4">=</span><span class="s1">epsilon</span><span class="s4">,</span>
            <span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">n_jobs</span><span class="s4">,</span>
            <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">=</span><span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">eta0</span><span class="s4">=</span><span class="s1">eta0</span><span class="s4">,</span>
            <span class="s1">power_t</span><span class="s4">=</span><span class="s1">power_t</span><span class="s4">,</span>
            <span class="s1">early_stopping</span><span class="s4">=</span><span class="s1">early_stopping</span><span class="s4">,</span>
            <span class="s1">validation_fraction</span><span class="s4">=</span><span class="s1">validation_fraction</span><span class="s4">,</span>
            <span class="s1">n_iter_no_change</span><span class="s4">=</span><span class="s1">n_iter_no_change</span><span class="s4">,</span>
            <span class="s1">class_weight</span><span class="s4">=</span><span class="s1">class_weight</span><span class="s4">,</span>
            <span class="s1">warm_start</span><span class="s4">=</span><span class="s1">warm_start</span><span class="s4">,</span>
            <span class="s1">average</span><span class="s4">=</span><span class="s1">average</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_check_proba</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss </span><span class="s3">not in </span><span class="s4">(</span><span class="s5">&quot;log_loss&quot;</span><span class="s4">, </span><span class="s5">&quot;modified_huber&quot;</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">AttributeError</span><span class="s4">(</span>
                <span class="s5">&quot;probability estimates are not available for loss=%r&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss</span>
            <span class="s4">)</span>
        <span class="s3">return True</span>

    <span class="s4">@</span><span class="s1">available_if</span><span class="s4">(</span><span class="s1">_check_proba</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">predict_proba</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Probability estimates. 
 
        This method is only available for log loss and modified Huber loss. 
 
        Multiclass probability estimates are derived from binary (one-vs.-rest) 
        estimates by simple normalization, as recommended by Zadrozny and 
        Elkan. 
 
        Binary probability estimates for loss=&quot;modified_huber&quot; are given by 
        (clip(decision_function(X), -1, 1) + 1) / 2. For other loss functions 
        it is necessary to perform proper probability calibration by wrapping 
        the classifier with 
        :class:`~sklearn.calibration.CalibratedClassifierCV` instead. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix}, shape (n_samples, n_features) 
            Input data for prediction. 
 
        Returns 
        ------- 
        ndarray of shape (n_samples, n_classes) 
            Returns the probability of the sample for each class in the model, 
            where classes are ordered as they are in `self.classes_`. 
 
        References 
        ---------- 
        Zadrozny and Elkan, &quot;Transforming classifier scores into multiclass 
        probability estimates&quot;, SIGKDD'02, 
        https://dl.acm.org/doi/pdf/10.1145/775047.775151 
 
        The justification for the formula in the loss=&quot;modified_huber&quot; 
        case is in the appendix B in: 
        http://jmlr.csail.mit.edu/papers/volume2/zhang02c/zhang02c.pdf 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss </span><span class="s4">== </span><span class="s5">&quot;log_loss&quot;</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_predict_proba_lr</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss </span><span class="s4">== </span><span class="s5">&quot;modified_huber&quot;</span><span class="s4">:</span>
            <span class="s1">binary </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">) == </span><span class="s6">2</span>
            <span class="s1">scores </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">decision_function</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">binary</span><span class="s4">:</span>
                <span class="s1">prob2 </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">((</span><span class="s1">scores</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s6">2</span><span class="s4">))</span>
                <span class="s1">prob </span><span class="s4">= </span><span class="s1">prob2</span><span class="s4">[:, </span><span class="s6">1</span><span class="s4">]</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">prob </span><span class="s4">= </span><span class="s1">scores</span>

            <span class="s1">np</span><span class="s4">.</span><span class="s1">clip</span><span class="s4">(</span><span class="s1">scores</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s1">prob</span><span class="s4">)</span>
            <span class="s1">prob </span><span class="s4">+= </span><span class="s6">1.0</span>
            <span class="s1">prob </span><span class="s4">/= </span><span class="s6">2.0</span>

            <span class="s3">if </span><span class="s1">binary</span><span class="s4">:</span>
                <span class="s1">prob2</span><span class="s4">[:, </span><span class="s6">0</span><span class="s4">] -= </span><span class="s1">prob</span>
                <span class="s1">prob </span><span class="s4">= </span><span class="s1">prob2</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s0"># the above might assign zero to all classes, which doesn't</span>
                <span class="s0"># normalize neatly; work around this to produce uniform</span>
                <span class="s0"># probabilities</span>
                <span class="s1">prob_sum </span><span class="s4">= </span><span class="s1">prob</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s6">1</span><span class="s4">)</span>
                <span class="s1">all_zero </span><span class="s4">= </span><span class="s1">prob_sum </span><span class="s4">== </span><span class="s6">0</span>
                <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">any</span><span class="s4">(</span><span class="s1">all_zero</span><span class="s4">):</span>
                    <span class="s1">prob</span><span class="s4">[</span><span class="s1">all_zero</span><span class="s4">, :] = </span><span class="s6">1</span>
                    <span class="s1">prob_sum</span><span class="s4">[</span><span class="s1">all_zero</span><span class="s4">] = </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">)</span>

                <span class="s0"># normalize</span>
                <span class="s1">prob </span><span class="s4">/= </span><span class="s1">prob_sum</span><span class="s4">.</span><span class="s1">reshape</span><span class="s4">((</span><span class="s1">prob</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], -</span><span class="s6">1</span><span class="s4">))</span>

            <span class="s3">return </span><span class="s1">prob</span>

        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">(</span>
                <span class="s5">&quot;predict_(log_)proba only supported when&quot;</span>
                <span class="s5">&quot; loss='log_loss' or loss='modified_huber' &quot;</span>
                <span class="s5">&quot;(%r given)&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss</span>
            <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">available_if</span><span class="s4">(</span><span class="s1">_check_proba</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">predict_log_proba</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Log of probability estimates. 
 
        This method is only available for log loss and modified Huber loss. 
 
        When loss=&quot;modified_huber&quot;, probability estimates may be hard zeros 
        and ones, so taking the logarithm is not possible. 
 
        See ``predict_proba`` for details. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Input data for prediction. 
 
        Returns 
        ------- 
        T : array-like, shape (n_samples, n_classes) 
            Returns the log-probability of the sample for each class in the 
            model, where classes are ordered as they are in 
            `self.classes_`. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">log</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">predict_proba</span><span class="s4">(</span><span class="s1">X</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">_more_tags</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">{</span>
            <span class="s5">&quot;_xfail_checks&quot;</span><span class="s4">: {</span>
                <span class="s5">&quot;check_sample_weights_invariance&quot;</span><span class="s4">: (</span>
                    <span class="s5">&quot;zero sample_weight is not equivalent to removing samples&quot;</span>
                <span class="s4">),</span>
            <span class="s4">},</span>
            <span class="s5">&quot;preserves_dtype&quot;</span><span class="s4">: [</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">],</span>
        <span class="s4">}</span>


<span class="s3">class </span><span class="s1">BaseSGDRegressor</span><span class="s4">(</span><span class="s1">RegressorMixin</span><span class="s4">, </span><span class="s1">BaseSGD</span><span class="s4">):</span>
    <span class="s1">loss_functions </span><span class="s4">= {</span>
        <span class="s5">&quot;squared_error&quot;</span><span class="s4">: (</span><span class="s1">SquaredLoss</span><span class="s4">,),</span>
        <span class="s5">&quot;huber&quot;</span><span class="s4">: (</span><span class="s1">Huber</span><span class="s4">, </span><span class="s1">DEFAULT_EPSILON</span><span class="s4">),</span>
        <span class="s5">&quot;epsilon_insensitive&quot;</span><span class="s4">: (</span><span class="s1">EpsilonInsensitive</span><span class="s4">, </span><span class="s1">DEFAULT_EPSILON</span><span class="s4">),</span>
        <span class="s5">&quot;squared_epsilon_insensitive&quot;</span><span class="s4">: (</span><span class="s1">SquaredEpsilonInsensitive</span><span class="s4">, </span><span class="s1">DEFAULT_EPSILON</span><span class="s4">),</span>
    <span class="s4">}</span>

    <span class="s1">_parameter_constraints</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
        <span class="s4">**</span><span class="s1">BaseSGD</span><span class="s4">.</span><span class="s1">_parameter_constraints</span><span class="s4">,</span>
        <span class="s5">&quot;loss&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">(</span><span class="s1">set</span><span class="s4">(</span><span class="s1">loss_functions</span><span class="s4">))],</span>
        <span class="s5">&quot;early_stopping&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;validation_fraction&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;neither&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;n_iter_no_change&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
    <span class="s4">}</span>

    <span class="s4">@</span><span class="s1">abstractmethod</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">loss</span><span class="s4">=</span><span class="s5">&quot;squared_error&quot;</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">penalty</span><span class="s4">=</span><span class="s5">&quot;l2&quot;</span><span class="s4">,</span>
        <span class="s1">alpha</span><span class="s4">=</span><span class="s6">0.0001</span><span class="s4">,</span>
        <span class="s1">l1_ratio</span><span class="s4">=</span><span class="s6">0.15</span><span class="s4">,</span>
        <span class="s1">fit_intercept</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">max_iter</span><span class="s4">=</span><span class="s6">1000</span><span class="s4">,</span>
        <span class="s1">tol</span><span class="s4">=</span><span class="s6">1e-3</span><span class="s4">,</span>
        <span class="s1">shuffle</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
        <span class="s1">epsilon</span><span class="s4">=</span><span class="s1">DEFAULT_EPSILON</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">learning_rate</span><span class="s4">=</span><span class="s5">&quot;invscaling&quot;</span><span class="s4">,</span>
        <span class="s1">eta0</span><span class="s4">=</span><span class="s6">0.01</span><span class="s4">,</span>
        <span class="s1">power_t</span><span class="s4">=</span><span class="s6">0.25</span><span class="s4">,</span>
        <span class="s1">early_stopping</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">validation_fraction</span><span class="s4">=</span><span class="s6">0.1</span><span class="s4">,</span>
        <span class="s1">n_iter_no_change</span><span class="s4">=</span><span class="s6">5</span><span class="s4">,</span>
        <span class="s1">warm_start</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">average</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span>
            <span class="s1">loss</span><span class="s4">=</span><span class="s1">loss</span><span class="s4">,</span>
            <span class="s1">penalty</span><span class="s4">=</span><span class="s1">penalty</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">=</span><span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">l1_ratio</span><span class="s4">=</span><span class="s1">l1_ratio</span><span class="s4">,</span>
            <span class="s1">fit_intercept</span><span class="s4">=</span><span class="s1">fit_intercept</span><span class="s4">,</span>
            <span class="s1">max_iter</span><span class="s4">=</span><span class="s1">max_iter</span><span class="s4">,</span>
            <span class="s1">tol</span><span class="s4">=</span><span class="s1">tol</span><span class="s4">,</span>
            <span class="s1">shuffle</span><span class="s4">=</span><span class="s1">shuffle</span><span class="s4">,</span>
            <span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">,</span>
            <span class="s1">epsilon</span><span class="s4">=</span><span class="s1">epsilon</span><span class="s4">,</span>
            <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">=</span><span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">eta0</span><span class="s4">=</span><span class="s1">eta0</span><span class="s4">,</span>
            <span class="s1">power_t</span><span class="s4">=</span><span class="s1">power_t</span><span class="s4">,</span>
            <span class="s1">early_stopping</span><span class="s4">=</span><span class="s1">early_stopping</span><span class="s4">,</span>
            <span class="s1">validation_fraction</span><span class="s4">=</span><span class="s1">validation_fraction</span><span class="s4">,</span>
            <span class="s1">n_iter_no_change</span><span class="s4">=</span><span class="s1">n_iter_no_change</span><span class="s4">,</span>
            <span class="s1">warm_start</span><span class="s4">=</span><span class="s1">warm_start</span><span class="s4">,</span>
            <span class="s1">average</span><span class="s4">=</span><span class="s1">average</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_partial_fit</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">X</span><span class="s4">,</span>
        <span class="s1">y</span><span class="s4">,</span>
        <span class="s1">alpha</span><span class="s4">,</span>
        <span class="s1">C</span><span class="s4">,</span>
        <span class="s1">loss</span><span class="s4">,</span>
        <span class="s1">learning_rate</span><span class="s4">,</span>
        <span class="s1">max_iter</span><span class="s4">,</span>
        <span class="s1">sample_weight</span><span class="s4">,</span>
        <span class="s1">coef_init</span><span class="s4">,</span>
        <span class="s1">intercept_init</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">first_call </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;coef_&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">is None</span>
        <span class="s1">X</span><span class="s4">, </span><span class="s1">y </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">y</span><span class="s4">,</span>
            <span class="s1">accept_sparse</span><span class="s4">=</span><span class="s5">&quot;csr&quot;</span><span class="s4">,</span>
            <span class="s1">copy</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">,</span>
            <span class="s1">dtype</span><span class="s4">=[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">],</span>
            <span class="s1">accept_large_sparse</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">reset</span><span class="s4">=</span><span class="s1">first_call</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">y</span><span class="s4">.</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">copy</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">first_call</span><span class="s4">:</span>
            <span class="s0"># TODO(1.7) remove 0 from average parameter constraint</span>
            <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">average</span><span class="s4">, (</span><span class="s1">bool</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">bool_</span><span class="s4">)) </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
                <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                    <span class="s4">(</span>
                        <span class="s5">&quot;Passing average=0 to disable averaging is deprecated and will&quot;</span>
                        <span class="s5">&quot; be removed in 1.7. Please use average=False instead.&quot;</span>
                    <span class="s4">),</span>
                    <span class="s1">FutureWarning</span><span class="s4">,</span>
                <span class="s4">)</span>

        <span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_features </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span>

        <span class="s1">sample_weight </span><span class="s4">= </span><span class="s1">_check_sample_weight</span><span class="s4">(</span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)</span>

        <span class="s0"># Allocate datastructures from input arguments</span>
        <span class="s3">if </span><span class="s1">first_call</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_allocate_parameter_mem</span><span class="s4">(</span>
                <span class="s1">n_classes</span><span class="s4">=</span><span class="s6">1</span><span class="s4">,</span>
                <span class="s1">n_features</span><span class="s4">=</span><span class="s1">n_features</span><span class="s4">,</span>
                <span class="s1">input_dtype</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">,</span>
                <span class="s1">coef_init</span><span class="s4">=</span><span class="s1">coef_init</span><span class="s4">,</span>
                <span class="s1">intercept_init</span><span class="s4">=</span><span class="s1">intercept_init</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">&gt; </span><span class="s6">0 </span><span class="s3">and </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;_average_coef&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_average_coef </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_features</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_average_intercept </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_fit_regressor</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">alpha</span><span class="s4">, </span><span class="s1">C</span><span class="s4">, </span><span class="s1">loss</span><span class="s4">, </span><span class="s1">learning_rate</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s1">max_iter</span>
        <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_fit_context</span><span class="s4">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">partial_fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Perform one epoch of stochastic gradient descent on given samples. 
 
        Internally, this method uses ``max_iter = 1``. Therefore, it is not 
        guaranteed that a minimum of the cost function is reached after calling 
        it once. Matters such as objective convergence and early stopping 
        should be handled by the user. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix}, shape (n_samples, n_features) 
            Subset of training data. 
 
        y : numpy array of shape (n_samples,) 
            Subset of target values. 
 
        sample_weight : array-like, shape (n_samples,), default=None 
            Weights applied to individual samples. 
            If not provided, uniform weights are assumed. 
 
        Returns 
        ------- 
        self : object 
            Returns an instance of self. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;coef_&quot;</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_more_validate_params</span><span class="s4">(</span><span class="s1">for_partial_fit</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_partial_fit</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">y</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">C</span><span class="s4">=</span><span class="s6">1.0</span><span class="s4">,</span>
            <span class="s1">loss</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">max_iter</span><span class="s4">=</span><span class="s6">1</span><span class="s4">,</span>
            <span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">,</span>
            <span class="s1">coef_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
            <span class="s1">intercept_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_fit</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">X</span><span class="s4">,</span>
        <span class="s1">y</span><span class="s4">,</span>
        <span class="s1">alpha</span><span class="s4">,</span>
        <span class="s1">C</span><span class="s4">,</span>
        <span class="s1">loss</span><span class="s4">,</span>
        <span class="s1">learning_rate</span><span class="s4">,</span>
        <span class="s1">coef_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">intercept_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s0"># TODO(1.7) remove 0 from average parameter constraint</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">average</span><span class="s4">, (</span><span class="s1">bool</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">bool_</span><span class="s4">)) </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                <span class="s4">(</span>
                    <span class="s5">&quot;Passing average=0 to disable averaging is deprecated and will be &quot;</span>
                    <span class="s5">&quot;removed in 1.7. Please use average=False instead.&quot;</span>
                <span class="s4">),</span>
                <span class="s1">FutureWarning</span><span class="s4">,</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">warm_start </span><span class="s3">and </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;coef_&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">coef_init </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">coef_init </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">coef_</span>
            <span class="s3">if </span><span class="s1">intercept_init </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">intercept_init </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">coef_ </span><span class="s4">= </span><span class="s3">None</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_ </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s0"># Clear iteration count for multiple call to fit.</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">t_ </span><span class="s4">= </span><span class="s6">1.0</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_partial_fit</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">y</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">C</span><span class="s4">,</span>
            <span class="s1">loss</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">max_iter</span><span class="s4">,</span>
            <span class="s1">sample_weight</span><span class="s4">,</span>
            <span class="s1">coef_init</span><span class="s4">,</span>
            <span class="s1">intercept_init</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">tol </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">tol </span><span class="s4">&gt; -</span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span>
            <span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_iter_ </span><span class="s4">== </span><span class="s1">self</span><span class="s4">.</span><span class="s1">max_iter</span>
        <span class="s4">):</span>
            <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                <span class="s4">(</span>
                    <span class="s5">&quot;Maximum number of iteration reached before &quot;</span>
                    <span class="s5">&quot;convergence. Consider increasing max_iter to &quot;</span>
                    <span class="s5">&quot;improve the fit.&quot;</span>
                <span class="s4">),</span>
                <span class="s1">ConvergenceWarning</span><span class="s4">,</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_fit_context</span><span class="s4">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">coef_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">intercept_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Fit linear model with Stochastic Gradient Descent. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix}, shape (n_samples, n_features) 
            Training data. 
 
        y : ndarray of shape (n_samples,) 
            Target values. 
 
        coef_init : ndarray of shape (n_features,), default=None 
            The initial coefficients to warm-start the optimization. 
 
        intercept_init : ndarray of shape (1,), default=None 
            The initial intercept to warm-start the optimization. 
 
        sample_weight : array-like, shape (n_samples,), default=None 
            Weights applied to individual samples (1. for unweighted). 
 
        Returns 
        ------- 
        self : object 
            Fitted `SGDRegressor` estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_more_validate_params</span><span class="s4">()</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fit</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">y</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">C</span><span class="s4">=</span><span class="s6">1.0</span><span class="s4">,</span>
            <span class="s1">loss</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">coef_init</span><span class="s4">=</span><span class="s1">coef_init</span><span class="s4">,</span>
            <span class="s1">intercept_init</span><span class="s4">=</span><span class="s1">intercept_init</span><span class="s4">,</span>
            <span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_decision_function</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Predict using the linear model 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix}, shape (n_samples, n_features) 
 
        Returns 
        ------- 
        ndarray of shape (n_samples,) 
           Predicted target values per element in X. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

        <span class="s1">X </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">accept_sparse</span><span class="s4">=</span><span class="s5">&quot;csr&quot;</span><span class="s4">, </span><span class="s1">reset</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

        <span class="s1">scores </span><span class="s4">= </span><span class="s1">safe_sparse_dot</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">coef_</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">dense_output</span><span class="s4">=</span><span class="s3">True</span><span class="s4">) + </span><span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_</span>
        <span class="s3">return </span><span class="s1">scores</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">predict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Predict using the linear model. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix}, shape (n_samples, n_features) 
            Input data. 
 
        Returns 
        ------- 
        ndarray of shape (n_samples,) 
           Predicted target values per element in X. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_decision_function</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_fit_regressor</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">alpha</span><span class="s4">, </span><span class="s1">C</span><span class="s4">, </span><span class="s1">loss</span><span class="s4">, </span><span class="s1">learning_rate</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s1">max_iter</span>
    <span class="s4">):</span>
        <span class="s1">loss_function </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_loss_function</span><span class="s4">(</span><span class="s1">loss</span><span class="s4">)</span>
        <span class="s1">penalty_type </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_penalty_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">penalty</span><span class="s4">)</span>
        <span class="s1">learning_rate_type </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_learning_rate_type</span><span class="s4">(</span><span class="s1">learning_rate</span><span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;t_&quot;</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">t_ </span><span class="s4">= </span><span class="s6">1.0</span>

        <span class="s1">validation_mask </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_make_validation_split</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_mask</span><span class="s4">=</span><span class="s1">sample_weight </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">)</span>
        <span class="s1">validation_score_cb </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_make_validation_score_cb</span><span class="s4">(</span>
            <span class="s1">validation_mask</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span>
        <span class="s4">)</span>

        <span class="s1">random_state </span><span class="s4">= </span><span class="s1">check_random_state</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">random_state</span><span class="s4">)</span>
        <span class="s0"># numpy mtrand expects a C long which is a signed 32 bit integer under</span>
        <span class="s0"># Windows</span>
        <span class="s1">seed </span><span class="s4">= </span><span class="s1">random_state</span><span class="s4">.</span><span class="s1">randint</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">MAX_INT</span><span class="s4">)</span>

        <span class="s1">dataset</span><span class="s4">, </span><span class="s1">intercept_decay </span><span class="s4">= </span><span class="s1">make_dataset</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span>
        <span class="s4">)</span>

        <span class="s1">tol </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">tol </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">tol </span><span class="s3">is not None else </span><span class="s4">-</span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average</span><span class="s4">:</span>
            <span class="s1">coef </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_coef</span>
            <span class="s1">intercept </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_intercept</span>
            <span class="s1">average_coef </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_average_coef</span>
            <span class="s1">average_intercept </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_average_intercept</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">coef </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">coef_</span>
            <span class="s1">intercept </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_</span>
            <span class="s1">average_coef </span><span class="s4">= </span><span class="s3">None  </span><span class="s0"># Not used</span>
            <span class="s1">average_intercept </span><span class="s4">= [</span><span class="s6">0</span><span class="s4">]  </span><span class="s0"># Not used</span>

        <span class="s1">_plain_sgd </span><span class="s4">= </span><span class="s1">_get_plain_sgd_function</span><span class="s4">(</span><span class="s1">input_dtype</span><span class="s4">=</span><span class="s1">coef</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)</span>
        <span class="s1">coef</span><span class="s4">, </span><span class="s1">intercept</span><span class="s4">, </span><span class="s1">average_coef</span><span class="s4">, </span><span class="s1">average_intercept</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_iter_ </span><span class="s4">= </span><span class="s1">_plain_sgd</span><span class="s4">(</span>
            <span class="s1">coef</span><span class="s4">,</span>
            <span class="s1">intercept</span><span class="s4">[</span><span class="s6">0</span><span class="s4">],</span>
            <span class="s1">average_coef</span><span class="s4">,</span>
            <span class="s1">average_intercept</span><span class="s4">[</span><span class="s6">0</span><span class="s4">],</span>
            <span class="s1">loss_function</span><span class="s4">,</span>
            <span class="s1">penalty_type</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">C</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">l1_ratio</span><span class="s4">,</span>
            <span class="s1">dataset</span><span class="s4">,</span>
            <span class="s1">validation_mask</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">early_stopping</span><span class="s4">,</span>
            <span class="s1">validation_score_cb</span><span class="s4">,</span>
            <span class="s1">int</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_iter_no_change</span><span class="s4">),</span>
            <span class="s1">max_iter</span><span class="s4">,</span>
            <span class="s1">tol</span><span class="s4">,</span>
            <span class="s1">int</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">fit_intercept</span><span class="s4">),</span>
            <span class="s1">int</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose</span><span class="s4">),</span>
            <span class="s1">int</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">shuffle</span><span class="s4">),</span>
            <span class="s1">seed</span><span class="s4">,</span>
            <span class="s6">1.0</span><span class="s4">,</span>
            <span class="s6">1.0</span><span class="s4">,</span>
            <span class="s1">learning_rate_type</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">eta0</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">power_t</span><span class="s4">,</span>
            <span class="s6">0</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">t_</span><span class="s4">,</span>
            <span class="s1">intercept_decay</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">average</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">t_ </span><span class="s4">+= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_iter_ </span><span class="s4">* </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_average_intercept </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">average_intercept</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_intercept </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">intercept</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">&lt;= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">t_ </span><span class="s4">- </span><span class="s6">1.0</span><span class="s4">:</span>
                <span class="s0"># made enough updates for averaging to be taken into account</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">coef_ </span><span class="s4">= </span><span class="s1">average_coef</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">average_intercept</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">coef_ </span><span class="s4">= </span><span class="s1">coef</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">intercept</span><span class="s4">)</span>

        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">intercept_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">intercept</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">SGDRegressor</span><span class="s4">(</span><span class="s1">BaseSGDRegressor</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Linear model fitted by minimizing a regularized empirical loss with SGD. 
 
    SGD stands for Stochastic Gradient Descent: the gradient of the loss is 
    estimated each sample at a time and the model is updated along the way with 
    a decreasing strength schedule (aka learning rate). 
 
    The regularizer is a penalty added to the loss function that shrinks model 
    parameters towards the zero vector using either the squared euclidean norm 
    L2 or the absolute norm L1 or a combination of both (Elastic Net). If the 
    parameter update crosses the 0.0 value because of the regularizer, the 
    update is truncated to 0.0 to allow for learning sparse models and achieve 
    online feature selection. 
 
    This implementation works with data represented as dense numpy arrays of 
    floating point values for the features. 
 
    Read more in the :ref:`User Guide &lt;sgd&gt;`. 
 
    Parameters 
    ---------- 
    loss : str, default='squared_error' 
        The loss function to be used. The possible values are 'squared_error', 
        'huber', 'epsilon_insensitive', or 'squared_epsilon_insensitive' 
 
        The 'squared_error' refers to the ordinary least squares fit. 
        'huber' modifies 'squared_error' to focus less on getting outliers 
        correct by switching from squared to linear loss past a distance of 
        epsilon. 'epsilon_insensitive' ignores errors less than epsilon and is 
        linear past that; this is the loss function used in SVR. 
        'squared_epsilon_insensitive' is the same but becomes squared loss past 
        a tolerance of epsilon. 
 
        More details about the losses formulas can be found in the 
        :ref:`User Guide &lt;sgd_mathematical_formulation&gt;`. 
 
    penalty : {'l2', 'l1', 'elasticnet', None}, default='l2' 
        The penalty (aka regularization term) to be used. Defaults to 'l2' 
        which is the standard regularizer for linear SVM models. 'l1' and 
        'elasticnet' might bring sparsity to the model (feature selection) 
        not achievable with 'l2'. No penalty is added when set to `None`. 
 
    alpha : float, default=0.0001 
        Constant that multiplies the regularization term. The higher the 
        value, the stronger the regularization. Also used to compute the 
        learning rate when `learning_rate` is set to 'optimal'. 
        Values must be in the range `[0.0, inf)`. 
 
    l1_ratio : float, default=0.15 
        The Elastic Net mixing parameter, with 0 &lt;= l1_ratio &lt;= 1. 
        l1_ratio=0 corresponds to L2 penalty, l1_ratio=1 to L1. 
        Only used if `penalty` is 'elasticnet'. 
        Values must be in the range `[0.0, 1.0]`. 
 
    fit_intercept : bool, default=True 
        Whether the intercept should be estimated or not. If False, the 
        data is assumed to be already centered. 
 
    max_iter : int, default=1000 
        The maximum number of passes over the training data (aka epochs). 
        It only impacts the behavior in the ``fit`` method, and not the 
        :meth:`partial_fit` method. 
        Values must be in the range `[1, inf)`. 
 
        .. versionadded:: 0.19 
 
    tol : float or None, default=1e-3 
        The stopping criterion. If it is not None, training will stop 
        when (loss &gt; best_loss - tol) for ``n_iter_no_change`` consecutive 
        epochs. 
        Convergence is checked against the training loss or the 
        validation loss depending on the `early_stopping` parameter. 
        Values must be in the range `[0.0, inf)`. 
 
        .. versionadded:: 0.19 
 
    shuffle : bool, default=True 
        Whether or not the training data should be shuffled after each epoch. 
 
    verbose : int, default=0 
        The verbosity level. 
        Values must be in the range `[0, inf)`. 
 
    epsilon : float, default=0.1 
        Epsilon in the epsilon-insensitive loss functions; only if `loss` is 
        'huber', 'epsilon_insensitive', or 'squared_epsilon_insensitive'. 
        For 'huber', determines the threshold at which it becomes less 
        important to get the prediction exactly right. 
        For epsilon-insensitive, any differences between the current prediction 
        and the correct label are ignored if they are less than this threshold. 
        Values must be in the range `[0.0, inf)`. 
 
    random_state : int, RandomState instance, default=None 
        Used for shuffling the data, when ``shuffle`` is set to ``True``. 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    learning_rate : str, default='invscaling' 
        The learning rate schedule: 
 
        - 'constant': `eta = eta0` 
        - 'optimal': `eta = 1.0 / (alpha * (t + t0))` 
          where t0 is chosen by a heuristic proposed by Leon Bottou. 
        - 'invscaling': `eta = eta0 / pow(t, power_t)` 
        - 'adaptive': eta = eta0, as long as the training keeps decreasing. 
          Each time n_iter_no_change consecutive epochs fail to decrease the 
          training loss by tol or fail to increase validation score by tol if 
          early_stopping is True, the current learning rate is divided by 5. 
 
            .. versionadded:: 0.20 
                Added 'adaptive' option 
 
    eta0 : float, default=0.01 
        The initial learning rate for the 'constant', 'invscaling' or 
        'adaptive' schedules. The default value is 0.01. 
        Values must be in the range `[0.0, inf)`. 
 
    power_t : float, default=0.25 
        The exponent for inverse scaling learning rate. 
        Values must be in the range `(-inf, inf)`. 
 
    early_stopping : bool, default=False 
        Whether to use early stopping to terminate training when validation 
        score is not improving. If set to True, it will automatically set aside 
        a fraction of training data as validation and terminate 
        training when validation score returned by the `score` method is not 
        improving by at least `tol` for `n_iter_no_change` consecutive 
        epochs. 
 
        .. versionadded:: 0.20 
            Added 'early_stopping' option 
 
    validation_fraction : float, default=0.1 
        The proportion of training data to set aside as validation set for 
        early stopping. Must be between 0 and 1. 
        Only used if `early_stopping` is True. 
        Values must be in the range `(0.0, 1.0)`. 
 
        .. versionadded:: 0.20 
            Added 'validation_fraction' option 
 
    n_iter_no_change : int, default=5 
        Number of iterations with no improvement to wait before stopping 
        fitting. 
        Convergence is checked against the training loss or the 
        validation loss depending on the `early_stopping` parameter. 
        Integer values must be in the range `[1, max_iter)`. 
 
        .. versionadded:: 0.20 
            Added 'n_iter_no_change' option 
 
    warm_start : bool, default=False 
        When set to True, reuse the solution of the previous call to fit as 
        initialization, otherwise, just erase the previous solution. 
        See :term:`the Glossary &lt;warm_start&gt;`. 
 
        Repeatedly calling fit or partial_fit when warm_start is True can 
        result in a different solution than when calling fit a single time 
        because of the way the data is shuffled. 
        If a dynamic learning rate is used, the learning rate is adapted 
        depending on the number of samples already seen. Calling ``fit`` resets 
        this counter, while ``partial_fit``  will result in increasing the 
        existing counter. 
 
    average : bool or int, default=False 
        When set to True, computes the averaged SGD weights across all 
        updates and stores the result in the ``coef_`` attribute. If set to 
        an int greater than 1, averaging will begin once the total number of 
        samples seen reaches `average`. So ``average=10`` will begin 
        averaging after seeing 10 samples. 
 
    Attributes 
    ---------- 
    coef_ : ndarray of shape (n_features,) 
        Weights assigned to the features. 
 
    intercept_ : ndarray of shape (1,) 
        The intercept term. 
 
    n_iter_ : int 
        The actual number of iterations before reaching the stopping criterion. 
 
    t_ : int 
        Number of weight updates performed during training. 
        Same as ``(n_iter_ * n_samples + 1)``. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    HuberRegressor : Linear regression model that is robust to outliers. 
    Lars : Least Angle Regression model. 
    Lasso : Linear Model trained with L1 prior as regularizer. 
    RANSACRegressor : RANSAC (RANdom SAmple Consensus) algorithm. 
    Ridge : Linear least squares with l2 regularization. 
    sklearn.svm.SVR : Epsilon-Support Vector Regression. 
    TheilSenRegressor : Theil-Sen Estimator robust multivariate regression model. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.linear_model import SGDRegressor 
    &gt;&gt;&gt; from sklearn.pipeline import make_pipeline 
    &gt;&gt;&gt; from sklearn.preprocessing import StandardScaler 
    &gt;&gt;&gt; n_samples, n_features = 10, 5 
    &gt;&gt;&gt; rng = np.random.RandomState(0) 
    &gt;&gt;&gt; y = rng.randn(n_samples) 
    &gt;&gt;&gt; X = rng.randn(n_samples, n_features) 
    &gt;&gt;&gt; # Always scale the input. The most convenient way is to use a pipeline. 
    &gt;&gt;&gt; reg = make_pipeline(StandardScaler(), 
    ...                     SGDRegressor(max_iter=1000, tol=1e-3)) 
    &gt;&gt;&gt; reg.fit(X, y) 
    Pipeline(steps=[('standardscaler', StandardScaler()), 
                    ('sgdregressor', SGDRegressor())]) 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
        <span class="s4">**</span><span class="s1">BaseSGDRegressor</span><span class="s4">.</span><span class="s1">_parameter_constraints</span><span class="s4">,</span>
        <span class="s5">&quot;penalty&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;l2&quot;</span><span class="s4">, </span><span class="s5">&quot;l1&quot;</span><span class="s4">, </span><span class="s5">&quot;elasticnet&quot;</span><span class="s4">}), </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;alpha&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;l1_ratio&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;both&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;power_t&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;neither&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;learning_rate&quot;</span><span class="s4">: [</span>
            <span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;constant&quot;</span><span class="s4">, </span><span class="s5">&quot;optimal&quot;</span><span class="s4">, </span><span class="s5">&quot;invscaling&quot;</span><span class="s4">, </span><span class="s5">&quot;adaptive&quot;</span><span class="s4">}),</span>
            <span class="s1">Hidden</span><span class="s4">(</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;pa1&quot;</span><span class="s4">, </span><span class="s5">&quot;pa2&quot;</span><span class="s4">})),</span>
        <span class="s4">],</span>
        <span class="s5">&quot;epsilon&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;eta0&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
    <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">loss</span><span class="s4">=</span><span class="s5">&quot;squared_error&quot;</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">penalty</span><span class="s4">=</span><span class="s5">&quot;l2&quot;</span><span class="s4">,</span>
        <span class="s1">alpha</span><span class="s4">=</span><span class="s6">0.0001</span><span class="s4">,</span>
        <span class="s1">l1_ratio</span><span class="s4">=</span><span class="s6">0.15</span><span class="s4">,</span>
        <span class="s1">fit_intercept</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">max_iter</span><span class="s4">=</span><span class="s6">1000</span><span class="s4">,</span>
        <span class="s1">tol</span><span class="s4">=</span><span class="s6">1e-3</span><span class="s4">,</span>
        <span class="s1">shuffle</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
        <span class="s1">epsilon</span><span class="s4">=</span><span class="s1">DEFAULT_EPSILON</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">learning_rate</span><span class="s4">=</span><span class="s5">&quot;invscaling&quot;</span><span class="s4">,</span>
        <span class="s1">eta0</span><span class="s4">=</span><span class="s6">0.01</span><span class="s4">,</span>
        <span class="s1">power_t</span><span class="s4">=</span><span class="s6">0.25</span><span class="s4">,</span>
        <span class="s1">early_stopping</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">validation_fraction</span><span class="s4">=</span><span class="s6">0.1</span><span class="s4">,</span>
        <span class="s1">n_iter_no_change</span><span class="s4">=</span><span class="s6">5</span><span class="s4">,</span>
        <span class="s1">warm_start</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">average</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span>
            <span class="s1">loss</span><span class="s4">=</span><span class="s1">loss</span><span class="s4">,</span>
            <span class="s1">penalty</span><span class="s4">=</span><span class="s1">penalty</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">=</span><span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">l1_ratio</span><span class="s4">=</span><span class="s1">l1_ratio</span><span class="s4">,</span>
            <span class="s1">fit_intercept</span><span class="s4">=</span><span class="s1">fit_intercept</span><span class="s4">,</span>
            <span class="s1">max_iter</span><span class="s4">=</span><span class="s1">max_iter</span><span class="s4">,</span>
            <span class="s1">tol</span><span class="s4">=</span><span class="s1">tol</span><span class="s4">,</span>
            <span class="s1">shuffle</span><span class="s4">=</span><span class="s1">shuffle</span><span class="s4">,</span>
            <span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">,</span>
            <span class="s1">epsilon</span><span class="s4">=</span><span class="s1">epsilon</span><span class="s4">,</span>
            <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">=</span><span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">eta0</span><span class="s4">=</span><span class="s1">eta0</span><span class="s4">,</span>
            <span class="s1">power_t</span><span class="s4">=</span><span class="s1">power_t</span><span class="s4">,</span>
            <span class="s1">early_stopping</span><span class="s4">=</span><span class="s1">early_stopping</span><span class="s4">,</span>
            <span class="s1">validation_fraction</span><span class="s4">=</span><span class="s1">validation_fraction</span><span class="s4">,</span>
            <span class="s1">n_iter_no_change</span><span class="s4">=</span><span class="s1">n_iter_no_change</span><span class="s4">,</span>
            <span class="s1">warm_start</span><span class="s4">=</span><span class="s1">warm_start</span><span class="s4">,</span>
            <span class="s1">average</span><span class="s4">=</span><span class="s1">average</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_more_tags</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">{</span>
            <span class="s5">&quot;_xfail_checks&quot;</span><span class="s4">: {</span>
                <span class="s5">&quot;check_sample_weights_invariance&quot;</span><span class="s4">: (</span>
                    <span class="s5">&quot;zero sample_weight is not equivalent to removing samples&quot;</span>
                <span class="s4">),</span>
            <span class="s4">},</span>
            <span class="s5">&quot;preserves_dtype&quot;</span><span class="s4">: [</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">],</span>
        <span class="s4">}</span>


<span class="s3">class </span><span class="s1">SGDOneClassSVM</span><span class="s4">(</span><span class="s1">BaseSGD</span><span class="s4">, </span><span class="s1">OutlierMixin</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Solves linear One-Class SVM using Stochastic Gradient Descent. 
 
    This implementation is meant to be used with a kernel approximation 
    technique (e.g. `sklearn.kernel_approximation.Nystroem`) to obtain results 
    similar to `sklearn.svm.OneClassSVM` which uses a Gaussian kernel by 
    default. 
 
    Read more in the :ref:`User Guide &lt;sgd_online_one_class_svm&gt;`. 
 
    .. versionadded:: 1.0 
 
    Parameters 
    ---------- 
    nu : float, default=0.5 
        The nu parameter of the One Class SVM: an upper bound on the 
        fraction of training errors and a lower bound of the fraction of 
        support vectors. Should be in the interval (0, 1]. By default 0.5 
        will be taken. 
 
    fit_intercept : bool, default=True 
        Whether the intercept should be estimated or not. Defaults to True. 
 
    max_iter : int, default=1000 
        The maximum number of passes over the training data (aka epochs). 
        It only impacts the behavior in the ``fit`` method, and not the 
        `partial_fit`. Defaults to 1000. 
        Values must be in the range `[1, inf)`. 
 
    tol : float or None, default=1e-3 
        The stopping criterion. If it is not None, the iterations will stop 
        when (loss &gt; previous_loss - tol). Defaults to 1e-3. 
        Values must be in the range `[0.0, inf)`. 
 
    shuffle : bool, default=True 
        Whether or not the training data should be shuffled after each epoch. 
        Defaults to True. 
 
    verbose : int, default=0 
        The verbosity level. 
 
    random_state : int, RandomState instance or None, default=None 
        The seed of the pseudo random number generator to use when shuffling 
        the data.  If int, random_state is the seed used by the random number 
        generator; If RandomState instance, random_state is the random number 
        generator; If None, the random number generator is the RandomState 
        instance used by `np.random`. 
 
    learning_rate : {'constant', 'optimal', 'invscaling', 'adaptive'}, default='optimal' 
        The learning rate schedule to use with `fit`. (If using `partial_fit`, 
        learning rate must be controlled directly). 
 
        - 'constant': `eta = eta0` 
        - 'optimal': `eta = 1.0 / (alpha * (t + t0))` 
          where t0 is chosen by a heuristic proposed by Leon Bottou. 
        - 'invscaling': `eta = eta0 / pow(t, power_t)` 
        - 'adaptive': eta = eta0, as long as the training keeps decreasing. 
          Each time n_iter_no_change consecutive epochs fail to decrease the 
          training loss by tol or fail to increase validation score by tol if 
          early_stopping is True, the current learning rate is divided by 5. 
 
    eta0 : float, default=0.0 
        The initial learning rate for the 'constant', 'invscaling' or 
        'adaptive' schedules. The default value is 0.0 as eta0 is not used by 
        the default schedule 'optimal'. 
        Values must be in the range `[0.0, inf)`. 
 
    power_t : float, default=0.5 
        The exponent for inverse scaling learning rate. 
        Values must be in the range `(-inf, inf)`. 
 
    warm_start : bool, default=False 
        When set to True, reuse the solution of the previous call to fit as 
        initialization, otherwise, just erase the previous solution. 
        See :term:`the Glossary &lt;warm_start&gt;`. 
 
        Repeatedly calling fit or partial_fit when warm_start is True can 
        result in a different solution than when calling fit a single time 
        because of the way the data is shuffled. 
        If a dynamic learning rate is used, the learning rate is adapted 
        depending on the number of samples already seen. Calling ``fit`` resets 
        this counter, while ``partial_fit``  will result in increasing the 
        existing counter. 
 
    average : bool or int, default=False 
        When set to True, computes the averaged SGD weights and stores the 
        result in the ``coef_`` attribute. If set to an int greater than 1, 
        averaging will begin once the total number of samples seen reaches 
        average. So ``average=10`` will begin averaging after seeing 10 
        samples. 
 
    Attributes 
    ---------- 
    coef_ : ndarray of shape (1, n_features) 
        Weights assigned to the features. 
 
    offset_ : ndarray of shape (1,) 
        Offset used to define the decision function from the raw scores. 
        We have the relation: decision_function = score_samples - offset. 
 
    n_iter_ : int 
        The actual number of iterations to reach the stopping criterion. 
 
    t_ : int 
        Number of weight updates performed during training. 
        Same as ``(n_iter_ * n_samples + 1)``. 
 
    loss_function_ : concrete ``LossFunction`` 
 
        .. deprecated:: 1.4 
            ``loss_function_`` was deprecated in version 1.4 and will be removed in 
            1.6. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    sklearn.svm.OneClassSVM : Unsupervised Outlier Detection. 
 
    Notes 
    ----- 
    This estimator has a linear complexity in the number of training samples 
    and is thus better suited than the `sklearn.svm.OneClassSVM` 
    implementation for datasets with a large number of training samples (say 
    &gt; 10,000). 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn import linear_model 
    &gt;&gt;&gt; X = np.array([[-1, -1], [-2, -1], [1, 1], [2, 1]]) 
    &gt;&gt;&gt; clf = linear_model.SGDOneClassSVM(random_state=42) 
    &gt;&gt;&gt; clf.fit(X) 
    SGDOneClassSVM(random_state=42) 
 
    &gt;&gt;&gt; print(clf.predict([[4, 4]])) 
    [1] 
    &quot;&quot;&quot;</span>

    <span class="s1">loss_functions </span><span class="s4">= {</span><span class="s5">&quot;hinge&quot;</span><span class="s4">: (</span><span class="s1">Hinge</span><span class="s4">, </span><span class="s6">1.0</span><span class="s4">)}</span>

    <span class="s1">_parameter_constraints</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
        <span class="s4">**</span><span class="s1">BaseSGD</span><span class="s4">.</span><span class="s1">_parameter_constraints</span><span class="s4">,</span>
        <span class="s5">&quot;nu&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0.0</span><span class="s4">, </span><span class="s6">1.0</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;right&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;learning_rate&quot;</span><span class="s4">: [</span>
            <span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;constant&quot;</span><span class="s4">, </span><span class="s5">&quot;optimal&quot;</span><span class="s4">, </span><span class="s5">&quot;invscaling&quot;</span><span class="s4">, </span><span class="s5">&quot;adaptive&quot;</span><span class="s4">}),</span>
            <span class="s1">Hidden</span><span class="s4">(</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;pa1&quot;</span><span class="s4">, </span><span class="s5">&quot;pa2&quot;</span><span class="s4">})),</span>
        <span class="s4">],</span>
        <span class="s5">&quot;eta0&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;power_t&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Real</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;neither&quot;</span><span class="s4">)],</span>
    <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">nu</span><span class="s4">=</span><span class="s6">0.5</span><span class="s4">,</span>
        <span class="s1">fit_intercept</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">max_iter</span><span class="s4">=</span><span class="s6">1000</span><span class="s4">,</span>
        <span class="s1">tol</span><span class="s4">=</span><span class="s6">1e-3</span><span class="s4">,</span>
        <span class="s1">shuffle</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">verbose</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">learning_rate</span><span class="s4">=</span><span class="s5">&quot;optimal&quot;</span><span class="s4">,</span>
        <span class="s1">eta0</span><span class="s4">=</span><span class="s6">0.0</span><span class="s4">,</span>
        <span class="s1">power_t</span><span class="s4">=</span><span class="s6">0.5</span><span class="s4">,</span>
        <span class="s1">warm_start</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">average</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">nu </span><span class="s4">= </span><span class="s1">nu</span>
        <span class="s1">super</span><span class="s4">(</span><span class="s1">SGDOneClassSVM</span><span class="s4">, </span><span class="s1">self</span><span class="s4">).</span><span class="s1">__init__</span><span class="s4">(</span>
            <span class="s1">loss</span><span class="s4">=</span><span class="s5">&quot;hinge&quot;</span><span class="s4">,</span>
            <span class="s1">penalty</span><span class="s4">=</span><span class="s5">&quot;l2&quot;</span><span class="s4">,</span>
            <span class="s1">C</span><span class="s4">=</span><span class="s6">1.0</span><span class="s4">,</span>
            <span class="s1">l1_ratio</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
            <span class="s1">fit_intercept</span><span class="s4">=</span><span class="s1">fit_intercept</span><span class="s4">,</span>
            <span class="s1">max_iter</span><span class="s4">=</span><span class="s1">max_iter</span><span class="s4">,</span>
            <span class="s1">tol</span><span class="s4">=</span><span class="s1">tol</span><span class="s4">,</span>
            <span class="s1">shuffle</span><span class="s4">=</span><span class="s1">shuffle</span><span class="s4">,</span>
            <span class="s1">verbose</span><span class="s4">=</span><span class="s1">verbose</span><span class="s4">,</span>
            <span class="s1">epsilon</span><span class="s4">=</span><span class="s1">DEFAULT_EPSILON</span><span class="s4">,</span>
            <span class="s1">random_state</span><span class="s4">=</span><span class="s1">random_state</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">=</span><span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">eta0</span><span class="s4">=</span><span class="s1">eta0</span><span class="s4">,</span>
            <span class="s1">power_t</span><span class="s4">=</span><span class="s1">power_t</span><span class="s4">,</span>
            <span class="s1">early_stopping</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">validation_fraction</span><span class="s4">=</span><span class="s6">0.1</span><span class="s4">,</span>
            <span class="s1">n_iter_no_change</span><span class="s4">=</span><span class="s6">5</span><span class="s4">,</span>
            <span class="s1">warm_start</span><span class="s4">=</span><span class="s1">warm_start</span><span class="s4">,</span>
            <span class="s1">average</span><span class="s4">=</span><span class="s1">average</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_fit_one_class</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">alpha</span><span class="s4">, </span><span class="s1">C</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s1">learning_rate</span><span class="s4">, </span><span class="s1">max_iter</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Uses SGD implementation with X and y=np.ones(n_samples).&quot;&quot;&quot;</span>

        <span class="s0"># The One-Class SVM uses the SGD implementation with</span>
        <span class="s0"># y=np.ones(n_samples).</span>
        <span class="s1">n_samples </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ones</span><span class="s4">(</span><span class="s1">n_samples</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">)</span>

        <span class="s1">dataset</span><span class="s4">, </span><span class="s1">offset_decay </span><span class="s4">= </span><span class="s1">make_dataset</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">)</span>

        <span class="s1">penalty_type </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_penalty_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">penalty</span><span class="s4">)</span>
        <span class="s1">learning_rate_type </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_learning_rate_type</span><span class="s4">(</span><span class="s1">learning_rate</span><span class="s4">)</span>

        <span class="s0"># early stopping is set to False for the One-Class SVM. thus</span>
        <span class="s0"># validation_mask and validation_score_cb will be set to values</span>
        <span class="s0"># associated to early_stopping=False in _make_validation_split and</span>
        <span class="s0"># _make_validation_score_cb respectively.</span>
        <span class="s1">validation_mask </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_make_validation_split</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_mask</span><span class="s4">=</span><span class="s1">sample_weight </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">)</span>
        <span class="s1">validation_score_cb </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_make_validation_score_cb</span><span class="s4">(</span>
            <span class="s1">validation_mask</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">sample_weight</span>
        <span class="s4">)</span>

        <span class="s1">random_state </span><span class="s4">= </span><span class="s1">check_random_state</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">random_state</span><span class="s4">)</span>
        <span class="s0"># numpy mtrand expects a C long which is a signed 32 bit integer under</span>
        <span class="s0"># Windows</span>
        <span class="s1">seed </span><span class="s4">= </span><span class="s1">random_state</span><span class="s4">.</span><span class="s1">randint</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">iinfo</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">int32</span><span class="s4">).</span><span class="s1">max</span><span class="s4">)</span>

        <span class="s1">tol </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">tol </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">tol </span><span class="s3">is not None else </span><span class="s4">-</span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span>

        <span class="s1">one_class </span><span class="s4">= </span><span class="s6">1</span>
        <span class="s0"># There are no class weights for the One-Class SVM and they are</span>
        <span class="s0"># therefore set to 1.</span>
        <span class="s1">pos_weight </span><span class="s4">= </span><span class="s6">1</span>
        <span class="s1">neg_weight </span><span class="s4">= </span><span class="s6">1</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average</span><span class="s4">:</span>
            <span class="s1">coef </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_coef</span>
            <span class="s1">intercept </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_intercept</span>
            <span class="s1">average_coef </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_average_coef</span>
            <span class="s1">average_intercept </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_average_intercept</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">coef </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">coef_</span>
            <span class="s1">intercept </span><span class="s4">= </span><span class="s6">1 </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">offset_</span>
            <span class="s1">average_coef </span><span class="s4">= </span><span class="s3">None  </span><span class="s0"># Not used</span>
            <span class="s1">average_intercept </span><span class="s4">= [</span><span class="s6">0</span><span class="s4">]  </span><span class="s0"># Not used</span>

        <span class="s1">_plain_sgd </span><span class="s4">= </span><span class="s1">_get_plain_sgd_function</span><span class="s4">(</span><span class="s1">input_dtype</span><span class="s4">=</span><span class="s1">coef</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)</span>
        <span class="s1">coef</span><span class="s4">, </span><span class="s1">intercept</span><span class="s4">, </span><span class="s1">average_coef</span><span class="s4">, </span><span class="s1">average_intercept</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_iter_ </span><span class="s4">= </span><span class="s1">_plain_sgd</span><span class="s4">(</span>
            <span class="s1">coef</span><span class="s4">,</span>
            <span class="s1">intercept</span><span class="s4">[</span><span class="s6">0</span><span class="s4">],</span>
            <span class="s1">average_coef</span><span class="s4">,</span>
            <span class="s1">average_intercept</span><span class="s4">[</span><span class="s6">0</span><span class="s4">],</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_loss_function_</span><span class="s4">,</span>
            <span class="s1">penalty_type</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">C</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">l1_ratio</span><span class="s4">,</span>
            <span class="s1">dataset</span><span class="s4">,</span>
            <span class="s1">validation_mask</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">early_stopping</span><span class="s4">,</span>
            <span class="s1">validation_score_cb</span><span class="s4">,</span>
            <span class="s1">int</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_iter_no_change</span><span class="s4">),</span>
            <span class="s1">max_iter</span><span class="s4">,</span>
            <span class="s1">tol</span><span class="s4">,</span>
            <span class="s1">int</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">fit_intercept</span><span class="s4">),</span>
            <span class="s1">int</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">verbose</span><span class="s4">),</span>
            <span class="s1">int</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">shuffle</span><span class="s4">),</span>
            <span class="s1">seed</span><span class="s4">,</span>
            <span class="s1">neg_weight</span><span class="s4">,</span>
            <span class="s1">pos_weight</span><span class="s4">,</span>
            <span class="s1">learning_rate_type</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">eta0</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">power_t</span><span class="s4">,</span>
            <span class="s1">one_class</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">t_</span><span class="s4">,</span>
            <span class="s1">offset_decay</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">average</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">t_ </span><span class="s4">+= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_iter_ </span><span class="s4">* </span><span class="s1">n_samples</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_average_intercept </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">average_intercept</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_standard_intercept </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">intercept</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">&lt;= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">t_ </span><span class="s4">- </span><span class="s6">1.0</span><span class="s4">:</span>
                <span class="s0"># made enough updates for averaging to be taken into account</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">coef_ </span><span class="s4">= </span><span class="s1">average_coef</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">offset_ </span><span class="s4">= </span><span class="s6">1 </span><span class="s4">- </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">average_intercept</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">coef_ </span><span class="s4">= </span><span class="s1">coef</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">offset_ </span><span class="s4">= </span><span class="s6">1 </span><span class="s4">- </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">intercept</span><span class="s4">)</span>

        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">offset_ </span><span class="s4">= </span><span class="s6">1 </span><span class="s4">- </span><span class="s1">np</span><span class="s4">.</span><span class="s1">atleast_1d</span><span class="s4">(</span><span class="s1">intercept</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_partial_fit</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">X</span><span class="s4">,</span>
        <span class="s1">alpha</span><span class="s4">,</span>
        <span class="s1">C</span><span class="s4">,</span>
        <span class="s1">loss</span><span class="s4">,</span>
        <span class="s1">learning_rate</span><span class="s4">,</span>
        <span class="s1">max_iter</span><span class="s4">,</span>
        <span class="s1">sample_weight</span><span class="s4">,</span>
        <span class="s1">coef_init</span><span class="s4">,</span>
        <span class="s1">offset_init</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">first_call </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;coef_&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">is None</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s3">None</span><span class="s4">,</span>
            <span class="s1">accept_sparse</span><span class="s4">=</span><span class="s5">&quot;csr&quot;</span><span class="s4">,</span>
            <span class="s1">dtype</span><span class="s4">=[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">],</span>
            <span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">,</span>
            <span class="s1">accept_large_sparse</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
            <span class="s1">reset</span><span class="s4">=</span><span class="s1">first_call</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">first_call</span><span class="s4">:</span>
            <span class="s0"># TODO(1.7) remove 0 from average parameter constraint</span>
            <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">average</span><span class="s4">, (</span><span class="s1">bool</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">bool_</span><span class="s4">)) </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
                <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                    <span class="s4">(</span>
                        <span class="s5">&quot;Passing average=0 to disable averaging is deprecated and will&quot;</span>
                        <span class="s5">&quot; be removed in 1.7. Please use average=False instead.&quot;</span>
                    <span class="s4">),</span>
                    <span class="s1">FutureWarning</span><span class="s4">,</span>
                <span class="s4">)</span>

        <span class="s1">n_features </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>

        <span class="s0"># Allocate datastructures from input arguments</span>
        <span class="s1">sample_weight </span><span class="s4">= </span><span class="s1">_check_sample_weight</span><span class="s4">(</span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)</span>

        <span class="s0"># We use intercept = 1 - offset where intercept is the intercept of</span>
        <span class="s0"># the SGD implementation and offset is the offset of the One-Class SVM</span>
        <span class="s0"># optimization problem.</span>
        <span class="s3">if </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;coef_&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">is None or </span><span class="s1">coef_init </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_allocate_parameter_mem</span><span class="s4">(</span>
                <span class="s1">n_classes</span><span class="s4">=</span><span class="s6">1</span><span class="s4">,</span>
                <span class="s1">n_features</span><span class="s4">=</span><span class="s1">n_features</span><span class="s4">,</span>
                <span class="s1">input_dtype</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">,</span>
                <span class="s1">coef_init</span><span class="s4">=</span><span class="s1">coef_init</span><span class="s4">,</span>
                <span class="s1">intercept_init</span><span class="s4">=</span><span class="s1">offset_init</span><span class="s4">,</span>
                <span class="s1">one_class</span><span class="s4">=</span><span class="s6">1</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">n_features </span><span class="s4">!= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">coef_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;Number of features %d does not match previous data %d.&quot;</span>
                <span class="s4">% (</span><span class="s1">n_features</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">coef_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[-</span><span class="s6">1</span><span class="s4">])</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s3">and </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;_average_coef&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_average_coef </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_features</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_average_intercept </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">order</span><span class="s4">=</span><span class="s5">&quot;C&quot;</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_loss_function_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_loss_function</span><span class="s4">(</span><span class="s1">loss</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;t_&quot;</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">t_ </span><span class="s4">= </span><span class="s6">1.0</span>

        <span class="s0"># delegate to concrete training procedure</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_fit_one_class</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">=</span><span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">C</span><span class="s4">=</span><span class="s1">C</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">=</span><span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">,</span>
            <span class="s1">max_iter</span><span class="s4">=</span><span class="s1">max_iter</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_fit_context</span><span class="s4">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">partial_fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Fit linear One-Class SVM with Stochastic Gradient Descent. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix}, shape (n_samples, n_features) 
            Subset of the training data. 
        y : Ignored 
            Not used, present for API consistency by convention. 
 
        sample_weight : array-like, shape (n_samples,), optional 
            Weights applied to individual samples. 
            If not provided, uniform weights are assumed. 
 
        Returns 
        ------- 
        self : object 
            Returns a fitted instance of self. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;coef_&quot;</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_more_validate_params</span><span class="s4">(</span><span class="s1">for_partial_fit</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

        <span class="s1">alpha </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nu </span><span class="s4">/ </span><span class="s6">2</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_partial_fit</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">C</span><span class="s4">=</span><span class="s6">1.0</span><span class="s4">,</span>
            <span class="s1">loss</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">max_iter</span><span class="s4">=</span><span class="s6">1</span><span class="s4">,</span>
            <span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">,</span>
            <span class="s1">coef_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
            <span class="s1">offset_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_fit</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">X</span><span class="s4">,</span>
        <span class="s1">alpha</span><span class="s4">,</span>
        <span class="s1">C</span><span class="s4">,</span>
        <span class="s1">loss</span><span class="s4">,</span>
        <span class="s1">learning_rate</span><span class="s4">,</span>
        <span class="s1">coef_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">offset_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s0"># TODO(1.7) remove 0 from average parameter constraint</span>
        <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">average</span><span class="s4">, (</span><span class="s1">bool</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">bool_</span><span class="s4">)) </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">average </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                <span class="s4">(</span>
                    <span class="s5">&quot;Passing average=0 to disable averaging is deprecated and will be &quot;</span>
                    <span class="s5">&quot;removed in 1.7. Please use average=False instead.&quot;</span>
                <span class="s4">),</span>
                <span class="s1">FutureWarning</span><span class="s4">,</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">warm_start </span><span class="s3">and </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;coef_&quot;</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">coef_init </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">coef_init </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">coef_</span>
            <span class="s3">if </span><span class="s1">offset_init </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s1">offset_init </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">offset_</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">coef_ </span><span class="s4">= </span><span class="s3">None</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">offset_ </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s0"># Clear iteration count for multiple call to fit.</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">t_ </span><span class="s4">= </span><span class="s6">1.0</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_partial_fit</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">C</span><span class="s4">,</span>
            <span class="s1">loss</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">max_iter</span><span class="s4">,</span>
            <span class="s1">sample_weight</span><span class="s4">,</span>
            <span class="s1">coef_init</span><span class="s4">,</span>
            <span class="s1">offset_init</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">tol </span><span class="s3">is not None</span>
            <span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">tol </span><span class="s4">&gt; -</span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span>
            <span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_iter_ </span><span class="s4">== </span><span class="s1">self</span><span class="s4">.</span><span class="s1">max_iter</span>
        <span class="s4">):</span>
            <span class="s1">warnings</span><span class="s4">.</span><span class="s1">warn</span><span class="s4">(</span>
                <span class="s4">(</span>
                    <span class="s5">&quot;Maximum number of iteration reached before &quot;</span>
                    <span class="s5">&quot;convergence. Consider increasing max_iter to &quot;</span>
                    <span class="s5">&quot;improve the fit.&quot;</span>
                <span class="s4">),</span>
                <span class="s1">ConvergenceWarning</span><span class="s4">,</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_fit_context</span><span class="s4">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">coef_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">offset_init</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Fit linear One-Class SVM with Stochastic Gradient Descent. 
 
        This solves an equivalent optimization problem of the 
        One-Class SVM primal optimization problem and returns a weight vector 
        w and an offset rho such that the decision function is given by 
        &lt;w, x&gt; - rho. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix}, shape (n_samples, n_features) 
            Training data. 
        y : Ignored 
            Not used, present for API consistency by convention. 
 
        coef_init : array, shape (n_classes, n_features) 
            The initial coefficients to warm-start the optimization. 
 
        offset_init : array, shape (n_classes,) 
            The initial offset to warm-start the optimization. 
 
        sample_weight : array-like, shape (n_samples,), optional 
            Weights applied to individual samples. 
            If not provided, uniform weights are assumed. These weights will 
            be multiplied with class_weight (passed through the 
            constructor) if class_weight is specified. 
 
        Returns 
        ------- 
        self : object 
            Returns a fitted instance of self. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_more_validate_params</span><span class="s4">()</span>

        <span class="s1">alpha </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">nu </span><span class="s4">/ </span><span class="s6">2</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_fit</span><span class="s4">(</span>
            <span class="s1">X</span><span class="s4">,</span>
            <span class="s1">alpha</span><span class="s4">=</span><span class="s1">alpha</span><span class="s4">,</span>
            <span class="s1">C</span><span class="s4">=</span><span class="s6">1.0</span><span class="s4">,</span>
            <span class="s1">loss</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">loss</span><span class="s4">,</span>
            <span class="s1">learning_rate</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">learning_rate</span><span class="s4">,</span>
            <span class="s1">coef_init</span><span class="s4">=</span><span class="s1">coef_init</span><span class="s4">,</span>
            <span class="s1">offset_init</span><span class="s4">=</span><span class="s1">offset_init</span><span class="s4">,</span>
            <span class="s1">sample_weight</span><span class="s4">=</span><span class="s1">sample_weight</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">decision_function</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Signed distance to the separating hyperplane. 
 
        Signed distance is positive for an inlier and negative for an 
        outlier. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix}, shape (n_samples, n_features) 
            Testing data. 
 
        Returns 
        ------- 
        dec : array-like, shape (n_samples,) 
            Decision function values of the samples. 
        &quot;&quot;&quot;</span>

        <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;coef_&quot;</span><span class="s4">)</span>

        <span class="s1">X </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">accept_sparse</span><span class="s4">=</span><span class="s5">&quot;csr&quot;</span><span class="s4">, </span><span class="s1">reset</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
        <span class="s1">decisions </span><span class="s4">= </span><span class="s1">safe_sparse_dot</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">coef_</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">dense_output</span><span class="s4">=</span><span class="s3">True</span><span class="s4">) - </span><span class="s1">self</span><span class="s4">.</span><span class="s1">offset_</span>

        <span class="s3">return </span><span class="s1">decisions</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">score_samples</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Raw scoring function of the samples. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix}, shape (n_samples, n_features) 
            Testing data. 
 
        Returns 
        ------- 
        score_samples : array-like, shape (n_samples,) 
            Unshiffted scoring function values of the samples. 
        &quot;&quot;&quot;</span>
        <span class="s1">score_samples </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">decision_function</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) + </span><span class="s1">self</span><span class="s4">.</span><span class="s1">offset_</span>
        <span class="s3">return </span><span class="s1">score_samples</span>

    <span class="s3">def </span><span class="s1">predict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Return labels (1 inlier, -1 outlier) of the samples. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix}, shape (n_samples, n_features) 
            Testing data. 
 
        Returns 
        ------- 
        y : array, shape (n_samples,) 
            Labels of the samples. 
        &quot;&quot;&quot;</span>
        <span class="s1">y </span><span class="s4">= (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">decision_function</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) &gt;= </span><span class="s6">0</span><span class="s4">).</span><span class="s1">astype</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">int32</span><span class="s4">)</span>
        <span class="s1">y</span><span class="s4">[</span><span class="s1">y </span><span class="s4">== </span><span class="s6">0</span><span class="s4">] = -</span><span class="s6">1  </span><span class="s0"># for consistency with outlier detectors</span>
        <span class="s3">return </span><span class="s1">y</span>

    <span class="s3">def </span><span class="s1">_more_tags</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">{</span>
            <span class="s5">&quot;_xfail_checks&quot;</span><span class="s4">: {</span>
                <span class="s5">&quot;check_sample_weights_invariance&quot;</span><span class="s4">: (</span>
                    <span class="s5">&quot;zero sample_weight is not equivalent to removing samples&quot;</span>
                <span class="s4">)</span>
            <span class="s4">},</span>
            <span class="s5">&quot;preserves_dtype&quot;</span><span class="s4">: [</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float32</span><span class="s4">],</span>
        <span class="s4">}</span>
</pre>
</body>
</html>