<html>
<head>
<title>sparsefuncs.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sparsefuncs.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;A collection of utilities to work with sparse matrices and arrays.&quot;&quot;&quot;</span>

<span class="s2"># Authors: Manoj Kumar</span>
<span class="s2">#          Thomas Unterthiner</span>
<span class="s2">#          Giorgio Patrini</span>
<span class="s2">#</span>
<span class="s2"># License: BSD 3 clause</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse </span><span class="s3">as </span><span class="s1">sp</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse</span><span class="s4">.</span><span class="s1">linalg </span><span class="s3">import </span><span class="s1">LinearOperator</span>

<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">fixes </span><span class="s3">import </span><span class="s1">_sparse_min_max</span><span class="s4">, </span><span class="s1">_sparse_nan_min_max</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">validation </span><span class="s3">import </span><span class="s1">_check_sample_weight</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">sparsefuncs_fast </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">csc_mean_variance_axis0 </span><span class="s3">as </span><span class="s1">_csc_mean_var_axis0</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">sparsefuncs_fast </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">csr_mean_variance_axis0 </span><span class="s3">as </span><span class="s1">_csr_mean_var_axis0</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">sparsefuncs_fast </span><span class="s3">import </span><span class="s4">(</span>
    <span class="s1">incr_mean_variance_axis0 </span><span class="s3">as </span><span class="s1">_incr_mean_var_axis0</span><span class="s4">,</span>
<span class="s4">)</span>


<span class="s3">def </span><span class="s1">_raise_typeerror</span><span class="s4">(</span><span class="s1">X</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Raises a TypeError if X is not a CSR or CSC matrix&quot;&quot;&quot;</span>
    <span class="s1">input_type </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">format </span><span class="s3">if </span><span class="s1">sp</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">else </span><span class="s1">type</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">err </span><span class="s4">= </span><span class="s5">&quot;Expected a CSR or CSC sparse matrix, got %s.&quot; </span><span class="s4">% </span><span class="s1">input_type</span>
    <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s1">err</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_raise_error_wrong_axis</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">axis </span><span class="s3">not in </span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s6">1</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
            <span class="s5">&quot;Unknown axis value: %d. Use 0 for rows, or 1 for columns&quot; </span><span class="s4">% </span><span class="s1">axis</span>
        <span class="s4">)</span>


<span class="s3">def </span><span class="s1">inplace_csr_column_scale</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">scale</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Inplace column scaling of a CSR matrix. 
 
    Scale each feature of the data matrix by multiplying with specific scale 
    provided by the caller assuming a (n_samples, n_features) shape. 
 
    Parameters 
    ---------- 
    X : sparse matrix of shape (n_samples, n_features) 
        Matrix to normalize using the variance of the features. 
        It should be of CSR format. 
 
    scale : ndarray of shape (n_features,), dtype={np.float32, np.float64} 
        Array of precomputed feature-wise values to use for scaling. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.utils import sparsefuncs 
    &gt;&gt;&gt; from scipy import sparse 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; indptr = np.array([0, 3, 4, 4, 4]) 
    &gt;&gt;&gt; indices = np.array([0, 1, 2, 2]) 
    &gt;&gt;&gt; data = np.array([8, 1, 2, 5]) 
    &gt;&gt;&gt; scale = np.array([2, 3, 2]) 
    &gt;&gt;&gt; csr = sparse.csr_matrix((data, indices, indptr)) 
    &gt;&gt;&gt; csr.todense() 
    matrix([[8, 1, 2], 
            [0, 0, 5], 
            [0, 0, 0], 
            [0, 0, 0]]) 
    &gt;&gt;&gt; sparsefuncs.inplace_csr_column_scale(csr, scale) 
    &gt;&gt;&gt; csr.todense() 
    matrix([[16,  3,  4], 
            [ 0,  0, 10], 
            [ 0,  0,  0], 
            [ 0,  0,  0]]) 
    &quot;&quot;&quot;</span>
    <span class="s3">assert </span><span class="s1">scale</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>
    <span class="s1">X</span><span class="s4">.</span><span class="s1">data </span><span class="s4">*= </span><span class="s1">scale</span><span class="s4">.</span><span class="s1">take</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">indices</span><span class="s4">, </span><span class="s1">mode</span><span class="s4">=</span><span class="s5">&quot;clip&quot;</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">inplace_csr_row_scale</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">scale</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Inplace row scaling of a CSR matrix. 
 
    Scale each sample of the data matrix by multiplying with specific scale 
    provided by the caller assuming a (n_samples, n_features) shape. 
 
    Parameters 
    ---------- 
    X : sparse matrix of shape (n_samples, n_features) 
        Matrix to be scaled. It should be of CSR format. 
 
    scale : ndarray of float of shape (n_samples,) 
        Array of precomputed sample-wise values to use for scaling. 
    &quot;&quot;&quot;</span>
    <span class="s3">assert </span><span class="s1">scale</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] == </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
    <span class="s1">X</span><span class="s4">.</span><span class="s1">data </span><span class="s4">*= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">repeat</span><span class="s4">(</span><span class="s1">scale</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">diff</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">))</span>


<span class="s3">def </span><span class="s1">mean_variance_axis</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">, </span><span class="s1">weights</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">return_sum_weights</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute mean and variance along an axis on a CSR or CSC matrix. 
 
    Parameters 
    ---------- 
    X : sparse matrix of shape (n_samples, n_features) 
        Input data. It can be of CSR or CSC format. 
 
    axis : {0, 1} 
        Axis along which the axis should be computed. 
 
    weights : ndarray of shape (n_samples,) or (n_features,), default=None 
        If axis is set to 0 shape is (n_samples,) or 
        if axis is set to 1 shape is (n_features,). 
        If it is set to None, then samples are equally weighted. 
 
        .. versionadded:: 0.24 
 
    return_sum_weights : bool, default=False 
        If True, returns the sum of weights seen for each feature 
        if `axis=0` or each sample if `axis=1`. 
 
        .. versionadded:: 0.24 
 
    Returns 
    ------- 
 
    means : ndarray of shape (n_features,), dtype=floating 
        Feature-wise means. 
 
    variances : ndarray of shape (n_features,), dtype=floating 
        Feature-wise variances. 
 
    sum_weights : ndarray of shape (n_features,), dtype=floating 
        Returned if `return_sum_weights` is `True`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.utils import sparsefuncs 
    &gt;&gt;&gt; from scipy import sparse 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; indptr = np.array([0, 3, 4, 4, 4]) 
    &gt;&gt;&gt; indices = np.array([0, 1, 2, 2]) 
    &gt;&gt;&gt; data = np.array([8, 1, 2, 5]) 
    &gt;&gt;&gt; scale = np.array([2, 3, 2]) 
    &gt;&gt;&gt; csr = sparse.csr_matrix((data, indices, indptr)) 
    &gt;&gt;&gt; csr.todense() 
    matrix([[8, 1, 2], 
            [0, 0, 5], 
            [0, 0, 0], 
            [0, 0, 0]]) 
    &gt;&gt;&gt; sparsefuncs.mean_variance_axis(csr, axis=0) 
    (array([2.  , 0.25, 1.75]), array([12.    ,  0.1875,  4.1875])) 
    &quot;&quot;&quot;</span>
    <span class="s1">_raise_error_wrong_axis</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">sp</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">and </span><span class="s1">X</span><span class="s4">.</span><span class="s1">format </span><span class="s4">== </span><span class="s5">&quot;csr&quot;</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">axis </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_csr_mean_var_axis0</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">, </span><span class="s1">weights</span><span class="s4">=</span><span class="s1">weights</span><span class="s4">, </span><span class="s1">return_sum_weights</span><span class="s4">=</span><span class="s1">return_sum_weights</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_csc_mean_var_axis0</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">weights</span><span class="s4">=</span><span class="s1">weights</span><span class="s4">, </span><span class="s1">return_sum_weights</span><span class="s4">=</span><span class="s1">return_sum_weights</span>
            <span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">sp</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">and </span><span class="s1">X</span><span class="s4">.</span><span class="s1">format </span><span class="s4">== </span><span class="s5">&quot;csc&quot;</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">axis </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_csc_mean_var_axis0</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">, </span><span class="s1">weights</span><span class="s4">=</span><span class="s1">weights</span><span class="s4">, </span><span class="s1">return_sum_weights</span><span class="s4">=</span><span class="s1">return_sum_weights</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_csr_mean_var_axis0</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">weights</span><span class="s4">=</span><span class="s1">weights</span><span class="s4">, </span><span class="s1">return_sum_weights</span><span class="s4">=</span><span class="s1">return_sum_weights</span>
            <span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">_raise_typeerror</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">incr_mean_variance_axis</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, *, </span><span class="s1">axis</span><span class="s4">, </span><span class="s1">last_mean</span><span class="s4">, </span><span class="s1">last_var</span><span class="s4">, </span><span class="s1">last_n</span><span class="s4">, </span><span class="s1">weights</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute incremental mean and variance along an axis on a CSR or CSC matrix. 
 
    last_mean, last_var are the statistics computed at the last step by this 
    function. Both must be initialized to 0-arrays of the proper size, i.e. 
    the number of features in X. last_n is the number of samples encountered 
    until now. 
 
    Parameters 
    ---------- 
    X : CSR or CSC sparse matrix of shape (n_samples, n_features) 
        Input data. 
 
    axis : {0, 1} 
        Axis along which the axis should be computed. 
 
    last_mean : ndarray of shape (n_features,) or (n_samples,), dtype=floating 
        Array of means to update with the new data X. 
        Should be of shape (n_features,) if axis=0 or (n_samples,) if axis=1. 
 
    last_var : ndarray of shape (n_features,) or (n_samples,), dtype=floating 
        Array of variances to update with the new data X. 
        Should be of shape (n_features,) if axis=0 or (n_samples,) if axis=1. 
 
    last_n : float or ndarray of shape (n_features,) or (n_samples,), \ 
            dtype=floating 
        Sum of the weights seen so far, excluding the current weights 
        If not float, it should be of shape (n_features,) if 
        axis=0 or (n_samples,) if axis=1. If float it corresponds to 
        having same weights for all samples (or features). 
 
    weights : ndarray of shape (n_samples,) or (n_features,), default=None 
        If axis is set to 0 shape is (n_samples,) or 
        if axis is set to 1 shape is (n_features,). 
        If it is set to None, then samples are equally weighted. 
 
        .. versionadded:: 0.24 
 
    Returns 
    ------- 
    means : ndarray of shape (n_features,) or (n_samples,), dtype=floating 
        Updated feature-wise means if axis = 0 or 
        sample-wise means if axis = 1. 
 
    variances : ndarray of shape (n_features,) or (n_samples,), dtype=floating 
        Updated feature-wise variances if axis = 0 or 
        sample-wise variances if axis = 1. 
 
    n : ndarray of shape (n_features,) or (n_samples,), dtype=integral 
        Updated number of seen samples per feature if axis=0 
        or number of seen features per sample if axis=1. 
 
        If weights is not None, n is a sum of the weights of the seen 
        samples or features instead of the actual number of seen 
        samples or features. 
 
    Notes 
    ----- 
    NaNs are ignored in the algorithm. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.utils import sparsefuncs 
    &gt;&gt;&gt; from scipy import sparse 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; indptr = np.array([0, 3, 4, 4, 4]) 
    &gt;&gt;&gt; indices = np.array([0, 1, 2, 2]) 
    &gt;&gt;&gt; data = np.array([8, 1, 2, 5]) 
    &gt;&gt;&gt; scale = np.array([2, 3, 2]) 
    &gt;&gt;&gt; csr = sparse.csr_matrix((data, indices, indptr)) 
    &gt;&gt;&gt; csr.todense() 
    matrix([[8, 1, 2], 
            [0, 0, 5], 
            [0, 0, 0], 
            [0, 0, 0]]) 
    &gt;&gt;&gt; sparsefuncs.incr_mean_variance_axis( 
    ...     csr, axis=0, last_mean=np.zeros(3), last_var=np.zeros(3), last_n=2 
    ... ) 
    (array([1.3..., 0.1..., 1.1...]), array([8.8..., 0.1..., 3.4...]), 
    array([6., 6., 6.])) 
    &quot;&quot;&quot;</span>
    <span class="s1">_raise_error_wrong_axis</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">)</span>

    <span class="s3">if not </span><span class="s4">(</span><span class="s1">sp</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">and </span><span class="s1">X</span><span class="s4">.</span><span class="s1">format </span><span class="s3">in </span><span class="s4">(</span><span class="s5">&quot;csc&quot;</span><span class="s4">, </span><span class="s5">&quot;csr&quot;</span><span class="s4">)):</span>
        <span class="s1">_raise_typeerror</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">size</span><span class="s4">(</span><span class="s1">last_n</span><span class="s4">) == </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s1">last_n </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">full</span><span class="s4">(</span><span class="s1">last_mean</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">, </span><span class="s1">last_n</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">last_mean</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)</span>

    <span class="s3">if not </span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">size</span><span class="s4">(</span><span class="s1">last_mean</span><span class="s4">) == </span><span class="s1">np</span><span class="s4">.</span><span class="s1">size</span><span class="s4">(</span><span class="s1">last_var</span><span class="s4">) == </span><span class="s1">np</span><span class="s4">.</span><span class="s1">size</span><span class="s4">(</span><span class="s1">last_n</span><span class="s4">)):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;last_mean, last_var, last_n do not have the same shapes.&quot;</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">axis </span><span class="s4">== </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">size</span><span class="s4">(</span><span class="s1">last_mean</span><span class="s4">) != </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;If axis=1, then last_mean, last_n, last_var should be of &quot;</span>
                <span class="s5">f&quot;size n_samples </span><span class="s3">{</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span><span class="s3">} </span><span class="s5">(Got </span><span class="s3">{</span><span class="s1">np</span><span class="s4">.</span><span class="s1">size</span><span class="s4">(</span><span class="s1">last_mean</span><span class="s4">)</span><span class="s3">}</span><span class="s5">).&quot;</span>
            <span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:  </span><span class="s2"># axis == 0</span>
        <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">size</span><span class="s4">(</span><span class="s1">last_mean</span><span class="s4">) != </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;If axis=0, then last_mean, last_n, last_var should be of &quot;</span>
                <span class="s5">f&quot;size n_features </span><span class="s3">{</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span><span class="s3">} </span><span class="s5">(Got </span><span class="s3">{</span><span class="s1">np</span><span class="s4">.</span><span class="s1">size</span><span class="s4">(</span><span class="s1">last_mean</span><span class="s4">)</span><span class="s3">}</span><span class="s5">).&quot;</span>
            <span class="s4">)</span>

    <span class="s1">X </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">T </span><span class="s3">if </span><span class="s1">axis </span><span class="s4">== </span><span class="s6">1 </span><span class="s3">else </span><span class="s1">X</span>

    <span class="s3">if </span><span class="s1">weights </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s1">weights </span><span class="s4">= </span><span class="s1">_check_sample_weight</span><span class="s4">(</span><span class="s1">weights</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">_incr_mean_var_axis0</span><span class="s4">(</span>
        <span class="s1">X</span><span class="s4">, </span><span class="s1">last_mean</span><span class="s4">=</span><span class="s1">last_mean</span><span class="s4">, </span><span class="s1">last_var</span><span class="s4">=</span><span class="s1">last_var</span><span class="s4">, </span><span class="s1">last_n</span><span class="s4">=</span><span class="s1">last_n</span><span class="s4">, </span><span class="s1">weights</span><span class="s4">=</span><span class="s1">weights</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">inplace_column_scale</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">scale</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Inplace column scaling of a CSC/CSR matrix. 
 
    Scale each feature of the data matrix by multiplying with specific scale 
    provided by the caller assuming a (n_samples, n_features) shape. 
 
    Parameters 
    ---------- 
    X : sparse matrix of shape (n_samples, n_features) 
        Matrix to normalize using the variance of the features. It should be 
        of CSC or CSR format. 
 
    scale : ndarray of shape (n_features,), dtype={np.float32, np.float64} 
        Array of precomputed feature-wise values to use for scaling. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.utils import sparsefuncs 
    &gt;&gt;&gt; from scipy import sparse 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; indptr = np.array([0, 3, 4, 4, 4]) 
    &gt;&gt;&gt; indices = np.array([0, 1, 2, 2]) 
    &gt;&gt;&gt; data = np.array([8, 1, 2, 5]) 
    &gt;&gt;&gt; scale = np.array([2, 3, 2]) 
    &gt;&gt;&gt; csr = sparse.csr_matrix((data, indices, indptr)) 
    &gt;&gt;&gt; csr.todense() 
    matrix([[8, 1, 2], 
            [0, 0, 5], 
            [0, 0, 0], 
            [0, 0, 0]]) 
    &gt;&gt;&gt; sparsefuncs.inplace_column_scale(csr, scale) 
    &gt;&gt;&gt; csr.todense() 
    matrix([[16,  3,  4], 
            [ 0,  0, 10], 
            [ 0,  0,  0], 
            [ 0,  0,  0]]) 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">sp</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">and </span><span class="s1">X</span><span class="s4">.</span><span class="s1">format </span><span class="s4">== </span><span class="s5">&quot;csc&quot;</span><span class="s4">:</span>
        <span class="s1">inplace_csr_row_scale</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">scale</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">sp</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">and </span><span class="s1">X</span><span class="s4">.</span><span class="s1">format </span><span class="s4">== </span><span class="s5">&quot;csr&quot;</span><span class="s4">:</span>
        <span class="s1">inplace_csr_column_scale</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">scale</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">_raise_typeerror</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">inplace_row_scale</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">scale</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Inplace row scaling of a CSR or CSC matrix. 
 
    Scale each row of the data matrix by multiplying with specific scale 
    provided by the caller assuming a (n_samples, n_features) shape. 
 
    Parameters 
    ---------- 
    X : sparse matrix of shape (n_samples, n_features) 
        Matrix to be scaled. It should be of CSR or CSC format. 
 
    scale : ndarray of shape (n_features,), dtype={np.float32, np.float64} 
        Array of precomputed sample-wise values to use for scaling. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.utils import sparsefuncs 
    &gt;&gt;&gt; from scipy import sparse 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; indptr = np.array([0, 2, 3, 4, 5]) 
    &gt;&gt;&gt; indices = np.array([0, 1, 2, 3, 3]) 
    &gt;&gt;&gt; data = np.array([8, 1, 2, 5, 6]) 
    &gt;&gt;&gt; scale = np.array([2, 3, 4, 5]) 
    &gt;&gt;&gt; csr = sparse.csr_matrix((data, indices, indptr)) 
    &gt;&gt;&gt; csr.todense() 
    matrix([[8, 1, 0, 0], 
            [0, 0, 2, 0], 
            [0, 0, 0, 5], 
            [0, 0, 0, 6]]) 
    &gt;&gt;&gt; sparsefuncs.inplace_row_scale(csr, scale) 
    &gt;&gt;&gt; csr.todense() 
     matrix([[16,  2,  0,  0], 
             [ 0,  0,  6,  0], 
             [ 0,  0,  0, 20], 
             [ 0,  0,  0, 30]]) 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">sp</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">and </span><span class="s1">X</span><span class="s4">.</span><span class="s1">format </span><span class="s4">== </span><span class="s5">&quot;csc&quot;</span><span class="s4">:</span>
        <span class="s1">inplace_csr_column_scale</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">T</span><span class="s4">, </span><span class="s1">scale</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">sp</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">and </span><span class="s1">X</span><span class="s4">.</span><span class="s1">format </span><span class="s4">== </span><span class="s5">&quot;csr&quot;</span><span class="s4">:</span>
        <span class="s1">inplace_csr_row_scale</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">scale</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">_raise_typeerror</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">inplace_swap_row_csc</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Swap two rows of a CSC matrix in-place. 
 
    Parameters 
    ---------- 
    X : sparse matrix of shape (n_samples, n_features) 
        Matrix whose two rows are to be swapped. It should be of 
        CSC format. 
 
    m : int 
        Index of the row of X to be swapped. 
 
    n : int 
        Index of the row of X to be swapped. 
    &quot;&quot;&quot;</span>
    <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s4">[</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">t</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;m and n should be valid integers&quot;</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">m </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s1">m </span><span class="s4">+= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
    <span class="s3">if </span><span class="s1">n </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s1">n </span><span class="s4">+= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

    <span class="s1">m_mask </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">indices </span><span class="s4">== </span><span class="s1">m</span>
    <span class="s1">X</span><span class="s4">.</span><span class="s1">indices</span><span class="s4">[</span><span class="s1">X</span><span class="s4">.</span><span class="s1">indices </span><span class="s4">== </span><span class="s1">n</span><span class="s4">] = </span><span class="s1">m</span>
    <span class="s1">X</span><span class="s4">.</span><span class="s1">indices</span><span class="s4">[</span><span class="s1">m_mask</span><span class="s4">] = </span><span class="s1">n</span>


<span class="s3">def </span><span class="s1">inplace_swap_row_csr</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Swap two rows of a CSR matrix in-place. 
 
    Parameters 
    ---------- 
    X : sparse matrix of shape (n_samples, n_features) 
        Matrix whose two rows are to be swapped. It should be of 
        CSR format. 
 
    m : int 
        Index of the row of X to be swapped. 
 
    n : int 
        Index of the row of X to be swapped. 
    &quot;&quot;&quot;</span>
    <span class="s3">for </span><span class="s1">t </span><span class="s3">in </span><span class="s4">[</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">t</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">ndarray</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;m and n should be valid integers&quot;</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">m </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s1">m </span><span class="s4">+= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
    <span class="s3">if </span><span class="s1">n </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s1">n </span><span class="s4">+= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

    <span class="s2"># The following swapping makes life easier since m is assumed to be the</span>
    <span class="s2"># smaller integer below.</span>
    <span class="s3">if </span><span class="s1">m </span><span class="s4">&gt; </span><span class="s1">n</span><span class="s4">:</span>
        <span class="s1">m</span><span class="s4">, </span><span class="s1">n </span><span class="s4">= </span><span class="s1">n</span><span class="s4">, </span><span class="s1">m</span>

    <span class="s1">indptr </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">indptr</span>
    <span class="s1">m_start </span><span class="s4">= </span><span class="s1">indptr</span><span class="s4">[</span><span class="s1">m</span><span class="s4">]</span>
    <span class="s1">m_stop </span><span class="s4">= </span><span class="s1">indptr</span><span class="s4">[</span><span class="s1">m </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">]</span>
    <span class="s1">n_start </span><span class="s4">= </span><span class="s1">indptr</span><span class="s4">[</span><span class="s1">n</span><span class="s4">]</span>
    <span class="s1">n_stop </span><span class="s4">= </span><span class="s1">indptr</span><span class="s4">[</span><span class="s1">n </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">]</span>
    <span class="s1">nz_m </span><span class="s4">= </span><span class="s1">m_stop </span><span class="s4">- </span><span class="s1">m_start</span>
    <span class="s1">nz_n </span><span class="s4">= </span><span class="s1">n_stop </span><span class="s4">- </span><span class="s1">n_start</span>

    <span class="s3">if </span><span class="s1">nz_m </span><span class="s4">!= </span><span class="s1">nz_n</span><span class="s4">:</span>
        <span class="s2"># Modify indptr first</span>
        <span class="s1">X</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">[</span><span class="s1">m </span><span class="s4">+ </span><span class="s6">2 </span><span class="s4">: </span><span class="s1">n</span><span class="s4">] += </span><span class="s1">nz_n </span><span class="s4">- </span><span class="s1">nz_m</span>
        <span class="s1">X</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">[</span><span class="s1">m </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">] = </span><span class="s1">m_start </span><span class="s4">+ </span><span class="s1">nz_n</span>
        <span class="s1">X</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">[</span><span class="s1">n</span><span class="s4">] = </span><span class="s1">n_stop </span><span class="s4">- </span><span class="s1">nz_m</span>

    <span class="s1">X</span><span class="s4">.</span><span class="s1">indices </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">concatenate</span><span class="s4">(</span>
        <span class="s4">[</span>
            <span class="s1">X</span><span class="s4">.</span><span class="s1">indices</span><span class="s4">[:</span><span class="s1">m_start</span><span class="s4">],</span>
            <span class="s1">X</span><span class="s4">.</span><span class="s1">indices</span><span class="s4">[</span><span class="s1">n_start</span><span class="s4">:</span><span class="s1">n_stop</span><span class="s4">],</span>
            <span class="s1">X</span><span class="s4">.</span><span class="s1">indices</span><span class="s4">[</span><span class="s1">m_stop</span><span class="s4">:</span><span class="s1">n_start</span><span class="s4">],</span>
            <span class="s1">X</span><span class="s4">.</span><span class="s1">indices</span><span class="s4">[</span><span class="s1">m_start</span><span class="s4">:</span><span class="s1">m_stop</span><span class="s4">],</span>
            <span class="s1">X</span><span class="s4">.</span><span class="s1">indices</span><span class="s4">[</span><span class="s1">n_stop</span><span class="s4">:],</span>
        <span class="s4">]</span>
    <span class="s4">)</span>
    <span class="s1">X</span><span class="s4">.</span><span class="s1">data </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">concatenate</span><span class="s4">(</span>
        <span class="s4">[</span>
            <span class="s1">X</span><span class="s4">.</span><span class="s1">data</span><span class="s4">[:</span><span class="s1">m_start</span><span class="s4">],</span>
            <span class="s1">X</span><span class="s4">.</span><span class="s1">data</span><span class="s4">[</span><span class="s1">n_start</span><span class="s4">:</span><span class="s1">n_stop</span><span class="s4">],</span>
            <span class="s1">X</span><span class="s4">.</span><span class="s1">data</span><span class="s4">[</span><span class="s1">m_stop</span><span class="s4">:</span><span class="s1">n_start</span><span class="s4">],</span>
            <span class="s1">X</span><span class="s4">.</span><span class="s1">data</span><span class="s4">[</span><span class="s1">m_start</span><span class="s4">:</span><span class="s1">m_stop</span><span class="s4">],</span>
            <span class="s1">X</span><span class="s4">.</span><span class="s1">data</span><span class="s4">[</span><span class="s1">n_stop</span><span class="s4">:],</span>
        <span class="s4">]</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">inplace_swap_row</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Swap two rows of a CSC/CSR matrix in-place. 
 
    Parameters 
    ---------- 
    X : sparse matrix of shape (n_samples, n_features) 
        Matrix whose two rows are to be swapped. It should be of CSR or 
        CSC format. 
 
    m : int 
        Index of the row of X to be swapped. 
 
    n : int 
        Index of the row of X to be swapped. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.utils import sparsefuncs 
    &gt;&gt;&gt; from scipy import sparse 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; indptr = np.array([0, 2, 3, 3, 3]) 
    &gt;&gt;&gt; indices = np.array([0, 2, 2]) 
    &gt;&gt;&gt; data = np.array([8, 2, 5]) 
    &gt;&gt;&gt; csr = sparse.csr_matrix((data, indices, indptr)) 
    &gt;&gt;&gt; csr.todense() 
    matrix([[8, 0, 2], 
            [0, 0, 5], 
            [0, 0, 0], 
            [0, 0, 0]]) 
    &gt;&gt;&gt; sparsefuncs.inplace_swap_row(csr, 0, 1) 
    &gt;&gt;&gt; csr.todense() 
    matrix([[0, 0, 5], 
            [8, 0, 2], 
            [0, 0, 0], 
            [0, 0, 0]]) 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">sp</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">and </span><span class="s1">X</span><span class="s4">.</span><span class="s1">format </span><span class="s4">== </span><span class="s5">&quot;csc&quot;</span><span class="s4">:</span>
        <span class="s1">inplace_swap_row_csc</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">sp</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">and </span><span class="s1">X</span><span class="s4">.</span><span class="s1">format </span><span class="s4">== </span><span class="s5">&quot;csr&quot;</span><span class="s4">:</span>
        <span class="s1">inplace_swap_row_csr</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">_raise_typeerror</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">inplace_swap_column</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Swap two columns of a CSC/CSR matrix in-place. 
 
    Parameters 
    ---------- 
    X : sparse matrix of shape (n_samples, n_features) 
        Matrix whose two columns are to be swapped. It should be of 
        CSR or CSC format. 
 
    m : int 
        Index of the column of X to be swapped. 
 
    n : int 
        Index of the column of X to be swapped. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.utils import sparsefuncs 
    &gt;&gt;&gt; from scipy import sparse 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; indptr = np.array([0, 2, 3, 3, 3]) 
    &gt;&gt;&gt; indices = np.array([0, 2, 2]) 
    &gt;&gt;&gt; data = np.array([8, 2, 5]) 
    &gt;&gt;&gt; csr = sparse.csr_matrix((data, indices, indptr)) 
    &gt;&gt;&gt; csr.todense() 
    matrix([[8, 0, 2], 
            [0, 0, 5], 
            [0, 0, 0], 
            [0, 0, 0]]) 
    &gt;&gt;&gt; sparsefuncs.inplace_swap_column(csr, 0, 1) 
    &gt;&gt;&gt; csr.todense() 
    matrix([[0, 8, 2], 
            [0, 0, 5], 
            [0, 0, 0], 
            [0, 0, 0]]) 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">m </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s1">m </span><span class="s4">+= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>
    <span class="s3">if </span><span class="s1">n </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s1">n </span><span class="s4">+= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]</span>
    <span class="s3">if </span><span class="s1">sp</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">and </span><span class="s1">X</span><span class="s4">.</span><span class="s1">format </span><span class="s4">== </span><span class="s5">&quot;csc&quot;</span><span class="s4">:</span>
        <span class="s1">inplace_swap_row_csr</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">sp</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">and </span><span class="s1">X</span><span class="s4">.</span><span class="s1">format </span><span class="s4">== </span><span class="s5">&quot;csr&quot;</span><span class="s4">:</span>
        <span class="s1">inplace_swap_row_csc</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">_raise_typeerror</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">min_max_axis</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">, </span><span class="s1">ignore_nan</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute minimum and maximum along an axis on a CSR or CSC matrix. 
 
     Optionally ignore NaN values. 
 
    Parameters 
    ---------- 
    X : sparse matrix of shape (n_samples, n_features) 
        Input data. It should be of CSR or CSC format. 
 
    axis : {0, 1} 
        Axis along which the axis should be computed. 
 
    ignore_nan : bool, default=False 
        Ignore or passing through NaN values. 
 
        .. versionadded:: 0.20 
 
    Returns 
    ------- 
 
    mins : ndarray of shape (n_features,), dtype={np.float32, np.float64} 
        Feature-wise minima. 
 
    maxs : ndarray of shape (n_features,), dtype={np.float32, np.float64} 
        Feature-wise maxima. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">sp</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">and </span><span class="s1">X</span><span class="s4">.</span><span class="s1">format </span><span class="s3">in </span><span class="s4">(</span><span class="s5">&quot;csr&quot;</span><span class="s4">, </span><span class="s5">&quot;csc&quot;</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">ignore_nan</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_sparse_nan_min_max</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s1">axis</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_sparse_min_max</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s1">axis</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">_raise_typeerror</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">count_nonzero</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">sample_weight</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;A variant of X.getnnz() with extension to weighting on axis 0. 
 
    Useful in efficiently calculating multilabel metrics. 
 
    Parameters 
    ---------- 
    X : sparse matrix of shape (n_samples, n_labels) 
        Input data. It should be of CSR format. 
 
    axis : {0, 1}, default=None 
        The axis on which the data is aggregated. 
 
    sample_weight : array-like of shape (n_samples,), default=None 
        Weight for each row of X. 
 
    Returns 
    ------- 
    nnz : int, float, ndarray of shape (n_samples,) or ndarray of shape (n_features,) 
        Number of non-zero values in the array along a given axis. Otherwise, 
        the total number of non-zero values in the array is returned. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">axis </span><span class="s4">== -</span><span class="s6">1</span><span class="s4">:</span>
        <span class="s1">axis </span><span class="s4">= </span><span class="s6">1</span>
    <span class="s3">elif </span><span class="s1">axis </span><span class="s4">== -</span><span class="s6">2</span><span class="s4">:</span>
        <span class="s1">axis </span><span class="s4">= </span><span class="s6">0</span>
    <span class="s3">elif </span><span class="s1">X</span><span class="s4">.</span><span class="s1">format </span><span class="s4">!= </span><span class="s5">&quot;csr&quot;</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;Expected CSR sparse format, got {0}&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">format</span><span class="s4">))</span>

    <span class="s2"># We rely here on the fact that np.diff(Y.indptr) for a CSR</span>
    <span class="s2"># will return the number of nonzero entries in each row.</span>
    <span class="s2"># A bincount over Y.indices will return the number of nonzeros</span>
    <span class="s2"># in each column. See ``csr_matrix.getnnz`` in scipy &gt;= 0.14.</span>
    <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">sample_weight </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">X</span><span class="s4">.</span><span class="s1">nnz</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">diff</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">), </span><span class="s1">sample_weight</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">axis </span><span class="s4">== </span><span class="s6">1</span><span class="s4">:</span>
        <span class="s1">out </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">diff</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">sample_weight </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s2"># astype here is for consistency with axis=0 dtype</span>
            <span class="s3">return </span><span class="s1">out</span><span class="s4">.</span><span class="s1">astype</span><span class="s4">(</span><span class="s5">&quot;intp&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">out </span><span class="s4">* </span><span class="s1">sample_weight</span>
    <span class="s3">elif </span><span class="s1">axis </span><span class="s4">== </span><span class="s6">0</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">sample_weight </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">bincount</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">indices</span><span class="s4">, </span><span class="s1">minlength</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">])</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">weights </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">repeat</span><span class="s4">(</span><span class="s1">sample_weight</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">diff</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">indptr</span><span class="s4">))</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">bincount</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">indices</span><span class="s4">, </span><span class="s1">minlength</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">], </span><span class="s1">weights</span><span class="s4">=</span><span class="s1">weights</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;Unsupported axis: {0}&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">))</span>


<span class="s3">def </span><span class="s1">_get_median</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">n_zeros</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the median of data with n_zeros additional zeros. 
 
    This function is used to support sparse matrices; it modifies data 
    in-place. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_elems </span><span class="s4">= </span><span class="s1">len</span><span class="s4">(</span><span class="s1">data</span><span class="s4">) + </span><span class="s1">n_zeros</span>
    <span class="s3">if not </span><span class="s1">n_elems</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">nan</span>
    <span class="s1">n_negative </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">count_nonzero</span><span class="s4">(</span><span class="s1">data </span><span class="s4">&lt; </span><span class="s6">0</span><span class="s4">)</span>
    <span class="s1">middle</span><span class="s4">, </span><span class="s1">is_odd </span><span class="s4">= </span><span class="s1">divmod</span><span class="s4">(</span><span class="s1">n_elems</span><span class="s4">, </span><span class="s6">2</span><span class="s4">)</span>
    <span class="s1">data</span><span class="s4">.</span><span class="s1">sort</span><span class="s4">()</span>

    <span class="s3">if </span><span class="s1">is_odd</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">_get_elem_at_rank</span><span class="s4">(</span><span class="s1">middle</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">n_negative</span><span class="s4">, </span><span class="s1">n_zeros</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s4">(</span>
        <span class="s1">_get_elem_at_rank</span><span class="s4">(</span><span class="s1">middle </span><span class="s4">- </span><span class="s6">1</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">n_negative</span><span class="s4">, </span><span class="s1">n_zeros</span><span class="s4">)</span>
        <span class="s4">+ </span><span class="s1">_get_elem_at_rank</span><span class="s4">(</span><span class="s1">middle</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">n_negative</span><span class="s4">, </span><span class="s1">n_zeros</span><span class="s4">)</span>
    <span class="s4">) / </span><span class="s6">2.0</span>


<span class="s3">def </span><span class="s1">_get_elem_at_rank</span><span class="s4">(</span><span class="s1">rank</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">n_negative</span><span class="s4">, </span><span class="s1">n_zeros</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Find the value in data augmented with n_zeros for the given rank&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">rank </span><span class="s4">&lt; </span><span class="s1">n_negative</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">data</span><span class="s4">[</span><span class="s1">rank</span><span class="s4">]</span>
    <span class="s3">if </span><span class="s1">rank </span><span class="s4">- </span><span class="s1">n_negative </span><span class="s4">&lt; </span><span class="s1">n_zeros</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s6">0</span>
    <span class="s3">return </span><span class="s1">data</span><span class="s4">[</span><span class="s1">rank </span><span class="s4">- </span><span class="s1">n_zeros</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">csc_median_axis_0</span><span class="s4">(</span><span class="s1">X</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Find the median across axis 0 of a CSC matrix. 
 
    It is equivalent to doing np.median(X, axis=0). 
 
    Parameters 
    ---------- 
    X : sparse matrix of shape (n_samples, n_features) 
        Input data. It should be of CSC format. 
 
    Returns 
    ------- 
    median : ndarray of shape (n_features,) 
        Median. 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s4">(</span><span class="s1">sp</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">and </span><span class="s1">X</span><span class="s4">.</span><span class="s1">format </span><span class="s4">== </span><span class="s5">&quot;csc&quot;</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;Expected matrix of CSC format, got %s&quot; </span><span class="s4">% </span><span class="s1">X</span><span class="s4">.</span><span class="s1">format</span><span class="s4">)</span>

    <span class="s1">indptr </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">indptr</span>
    <span class="s1">n_samples</span><span class="s4">, </span><span class="s1">n_features </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span>
    <span class="s1">median </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros</span><span class="s4">(</span><span class="s1">n_features</span><span class="s4">)</span>

    <span class="s3">for </span><span class="s1">f_ind</span><span class="s4">, (</span><span class="s1">start</span><span class="s4">, </span><span class="s1">end</span><span class="s4">) </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">zip</span><span class="s4">(</span><span class="s1">indptr</span><span class="s4">[:-</span><span class="s6">1</span><span class="s4">], </span><span class="s1">indptr</span><span class="s4">[</span><span class="s6">1</span><span class="s4">:])):</span>
        <span class="s2"># Prevent modifying X in place</span>
        <span class="s1">data </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">X</span><span class="s4">.</span><span class="s1">data</span><span class="s4">[</span><span class="s1">start</span><span class="s4">:</span><span class="s1">end</span><span class="s4">])</span>
        <span class="s1">nz </span><span class="s4">= </span><span class="s1">n_samples </span><span class="s4">- </span><span class="s1">data</span><span class="s4">.</span><span class="s1">size</span>
        <span class="s1">median</span><span class="s4">[</span><span class="s1">f_ind</span><span class="s4">] = </span><span class="s1">_get_median</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">nz</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">median</span>


<span class="s3">def </span><span class="s1">_implicit_column_offset</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Create an implicitly offset linear operator. 
 
    This is used by PCA on sparse data to avoid densifying the whole data 
    matrix. 
 
    Params 
    ------ 
        X : sparse matrix of shape (n_samples, n_features) 
        offset : ndarray of shape (n_features,) 
 
    Returns 
    ------- 
    centered : LinearOperator 
    &quot;&quot;&quot;</span>
    <span class="s1">offset </span><span class="s4">= </span><span class="s1">offset</span><span class="s4">[</span><span class="s3">None</span><span class="s4">, :]</span>
    <span class="s1">XT </span><span class="s4">= </span><span class="s1">X</span><span class="s4">.</span><span class="s1">T</span>
    <span class="s3">return </span><span class="s1">LinearOperator</span><span class="s4">(</span>
        <span class="s1">matvec</span><span class="s4">=</span><span class="s3">lambda </span><span class="s1">x</span><span class="s4">: </span><span class="s1">X </span><span class="s4">@ </span><span class="s1">x </span><span class="s4">- </span><span class="s1">offset </span><span class="s4">@ </span><span class="s1">x</span><span class="s4">,</span>
        <span class="s1">matmat</span><span class="s4">=</span><span class="s3">lambda </span><span class="s1">x</span><span class="s4">: </span><span class="s1">X </span><span class="s4">@ </span><span class="s1">x </span><span class="s4">- </span><span class="s1">offset </span><span class="s4">@ </span><span class="s1">x</span><span class="s4">,</span>
        <span class="s1">rmatvec</span><span class="s4">=</span><span class="s3">lambda </span><span class="s1">x</span><span class="s4">: </span><span class="s1">XT </span><span class="s4">@ </span><span class="s1">x </span><span class="s4">- (</span><span class="s1">offset </span><span class="s4">* </span><span class="s1">x</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">()),</span>
        <span class="s1">rmatmat</span><span class="s4">=</span><span class="s3">lambda </span><span class="s1">x</span><span class="s4">: </span><span class="s1">XT </span><span class="s4">@ </span><span class="s1">x </span><span class="s4">- </span><span class="s1">offset</span><span class="s4">.</span><span class="s1">T </span><span class="s4">@ </span><span class="s1">x</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s6">0</span><span class="s4">)[</span><span class="s3">None</span><span class="s4">, :],</span>
        <span class="s1">dtype</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">dtype</span><span class="s4">,</span>
        <span class="s1">shape</span><span class="s4">=</span><span class="s1">X</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">,</span>
    <span class="s4">)</span>
</pre>
</body>
</html>