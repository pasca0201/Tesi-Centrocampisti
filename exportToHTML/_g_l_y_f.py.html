<html>
<head>
<title>_g_l_y_f.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_g_l_y_f.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;_g_l_y_f.py -- Converter classes for the 'glyf' table.&quot;&quot;&quot;</span>

<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">namedtuple</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">misc </span><span class="s2">import </span><span class="s1">sstruct</span>
<span class="s2">from </span><span class="s1">fontTools </span><span class="s2">import </span><span class="s1">ttLib</span>
<span class="s2">from </span><span class="s1">fontTools </span><span class="s2">import </span><span class="s1">version</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">transform </span><span class="s2">import </span><span class="s1">DecomposedTransform</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">textTools </span><span class="s2">import </span><span class="s1">tostr</span><span class="s3">, </span><span class="s1">safeEval</span><span class="s3">, </span><span class="s1">pad</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">arrayTools </span><span class="s2">import </span><span class="s1">updateBounds</span><span class="s3">, </span><span class="s1">pointInRect</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">bezierTools </span><span class="s2">import </span><span class="s1">calcQuadraticBounds</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">fixedTools </span><span class="s2">import </span><span class="s3">(</span>
    <span class="s1">fixedToFloat </span><span class="s2">as </span><span class="s1">fi2fl</span><span class="s3">,</span>
    <span class="s1">floatToFixed </span><span class="s2">as </span><span class="s1">fl2fi</span><span class="s3">,</span>
    <span class="s1">floatToFixedToStr </span><span class="s2">as </span><span class="s1">fl2str</span><span class="s3">,</span>
    <span class="s1">strToFixedToFloat </span><span class="s2">as </span><span class="s1">str2fl</span><span class="s3">,</span>
<span class="s3">)</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">roundTools </span><span class="s2">import </span><span class="s1">noRound</span><span class="s3">, </span><span class="s1">otRound</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">vector </span><span class="s2">import </span><span class="s1">Vector</span>
<span class="s2">from </span><span class="s1">numbers </span><span class="s2">import </span><span class="s1">Number</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">DefaultTable</span>
<span class="s2">from </span><span class="s3">. </span><span class="s2">import </span><span class="s1">ttProgram</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">struct</span>
<span class="s2">import </span><span class="s1">array</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">misc </span><span class="s2">import </span><span class="s1">xmlWriter</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">filenames </span><span class="s2">import </span><span class="s1">userNameToFileName</span>
<span class="s2">from </span><span class="s1">fontTools</span><span class="s3">.</span><span class="s1">misc</span><span class="s3">.</span><span class="s1">loggingTools </span><span class="s2">import </span><span class="s1">deprecateFunction</span>
<span class="s2">from </span><span class="s1">enum </span><span class="s2">import </span><span class="s1">IntFlag</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">from </span><span class="s1">types </span><span class="s2">import </span><span class="s1">SimpleNamespace</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Set</span>

<span class="s1">log </span><span class="s3">= </span><span class="s1">logging</span><span class="s3">.</span><span class="s1">getLogger</span><span class="s3">(</span><span class="s1">__name__</span><span class="s3">)</span>

<span class="s4"># We compute the version the same as is computed in ttlib/__init__</span>
<span class="s4"># so that we can write 'ttLibVersion' attribute of the glyf TTX files</span>
<span class="s4"># when glyf is written to separate files.</span>
<span class="s1">version </span><span class="s3">= </span><span class="s5">&quot;.&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">version</span><span class="s3">.</span><span class="s1">split</span><span class="s3">(</span><span class="s5">&quot;.&quot;</span><span class="s3">)[:</span><span class="s6">2</span><span class="s3">])</span>

<span class="s4">#</span>
<span class="s4"># The Apple and MS rasterizers behave differently for</span>
<span class="s4"># scaled composite components: one does scale first and then translate</span>
<span class="s4"># and the other does it vice versa. MS defined some flags to indicate</span>
<span class="s4"># the difference, but it seems nobody actually _sets_ those flags.</span>
<span class="s4">#</span>
<span class="s4"># Funny thing: Apple seems to _only_ do their thing in the</span>
<span class="s4"># WE_HAVE_A_SCALE (eg. Chicago) case, and not when it's WE_HAVE_AN_X_AND_Y_SCALE</span>
<span class="s4"># (eg. Charcoal)...</span>
<span class="s4">#</span>
<span class="s1">SCALE_COMPONENT_OFFSET_DEFAULT </span><span class="s3">= </span><span class="s6">0  </span><span class="s4"># 0 == MS, 1 == Apple</span>


<span class="s2">class </span><span class="s1">table__g_l_y_f</span><span class="s3">(</span><span class="s1">DefaultTable</span><span class="s3">.</span><span class="s1">DefaultTable</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Glyph Data Table 
 
    This class represents the `glyf &lt;https://docs.microsoft.com/en-us/typography/opentype/spec/glyf&gt;`_ 
    table, which contains outlines for glyphs in TrueType format. In many cases, 
    it is easier to access and manipulate glyph outlines through the ``GlyphSet`` 
    object returned from :py:meth:`fontTools.ttLib.ttFont.getGlyphSet`:: 
 
                    &gt;&gt; from fontTools.pens.boundsPen import BoundsPen 
                    &gt;&gt; glyphset = font.getGlyphSet() 
                    &gt;&gt; bp = BoundsPen(glyphset) 
                    &gt;&gt; glyphset[&quot;A&quot;].draw(bp) 
                    &gt;&gt; bp.bounds 
                    (19, 0, 633, 716) 
 
    However, this class can be used for low-level access to the ``glyf`` table data. 
    Objects of this class support dictionary-like access, mapping glyph names to 
    :py:class:`Glyph` objects:: 
 
                    &gt;&gt; glyf = font[&quot;glyf&quot;] 
                    &gt;&gt; len(glyf[&quot;Aacute&quot;].components) 
                    2 
 
    Note that when adding glyphs to the font via low-level access to the ``glyf`` 
    table, the new glyphs must also be added to the ``hmtx``/``vmtx`` table:: 
 
                    &gt;&gt; font[&quot;glyf&quot;][&quot;divisionslash&quot;] = Glyph() 
                    &gt;&gt; font[&quot;hmtx&quot;][&quot;divisionslash&quot;] = (640, 0) 
 
    &quot;&quot;&quot;</span>

    <span class="s1">dependencies </span><span class="s3">= [</span><span class="s5">&quot;fvar&quot;</span><span class="s3">]</span>

    <span class="s4"># this attribute controls the amount of padding applied to glyph data upon compile.</span>
    <span class="s4"># Glyph lenghts are aligned to multiples of the specified value.</span>
    <span class="s4"># Allowed values are (0, 1, 2, 4). '0' means no padding; '1' (default) also means</span>
    <span class="s4"># no padding, except for when padding would allow to use short loca offsets.</span>
    <span class="s1">padding </span><span class="s3">= </span><span class="s6">1</span>

    <span class="s2">def </span><span class="s1">decompile</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">axisTags </span><span class="s3">= (</span>
            <span class="s3">[</span><span class="s1">axis</span><span class="s3">.</span><span class="s1">axisTag </span><span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">ttFont</span><span class="s3">[</span><span class="s5">&quot;fvar&quot;</span><span class="s3">].</span><span class="s1">axes</span><span class="s3">] </span><span class="s2">if </span><span class="s5">&quot;fvar&quot; </span><span class="s2">in </span><span class="s1">ttFont </span><span class="s2">else </span><span class="s3">[]</span>
        <span class="s3">)</span>
        <span class="s1">loca </span><span class="s3">= </span><span class="s1">ttFont</span><span class="s3">[</span><span class="s5">&quot;loca&quot;</span><span class="s3">]</span>
        <span class="s1">pos </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">loca</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>
        <span class="s1">nextPos </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">noname </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s3">= {}</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">glyphOrder </span><span class="s3">= </span><span class="s1">glyphOrder </span><span class="s3">= </span><span class="s1">ttFont</span><span class="s3">.</span><span class="s1">getGlyphOrder</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_reverseGlyphOrder </span><span class="s3">= {}</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">loca</span><span class="s3">) - </span><span class="s6">1</span><span class="s3">):</span>
            <span class="s2">try</span><span class="s3">:</span>
                <span class="s1">glyphName </span><span class="s3">= </span><span class="s1">glyphOrder</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">except </span><span class="s1">IndexError</span><span class="s3">:</span>
                <span class="s1">noname </span><span class="s3">= </span><span class="s1">noname </span><span class="s3">+ </span><span class="s6">1</span>
                <span class="s1">glyphName </span><span class="s3">= </span><span class="s5">&quot;ttxautoglyph%s&quot; </span><span class="s3">% </span><span class="s1">i</span>
            <span class="s1">nextPos </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">loca</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">])</span>
            <span class="s1">glyphdata </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s1">pos</span><span class="s3">:</span><span class="s1">nextPos</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">glyphdata</span><span class="s3">) != (</span><span class="s1">nextPos </span><span class="s3">- </span><span class="s1">pos</span><span class="s3">):</span>
                <span class="s2">raise </span><span class="s1">ttLib</span><span class="s3">.</span><span class="s1">TTLibError</span><span class="s3">(</span><span class="s5">&quot;not enough 'glyf' table data&quot;</span><span class="s3">)</span>
            <span class="s1">glyph </span><span class="s3">= </span><span class="s1">Glyph</span><span class="s3">(</span><span class="s1">glyphdata</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">[</span><span class="s1">glyphName</span><span class="s3">] = </span><span class="s1">glyph</span>
            <span class="s1">pos </span><span class="s3">= </span><span class="s1">nextPos</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">data</span><span class="s3">) - </span><span class="s1">nextPos </span><span class="s3">&gt;= </span><span class="s6">4</span><span class="s3">:</span>
            <span class="s1">log</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span>
                <span class="s5">&quot;too much 'glyf' table data: expected %d, received %d bytes&quot;</span><span class="s3">,</span>
                <span class="s1">nextPos</span><span class="s3">,</span>
                <span class="s1">len</span><span class="s3">(</span><span class="s1">data</span><span class="s3">),</span>
            <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">noname</span><span class="s3">:</span>
            <span class="s1">log</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s5">&quot;%s glyphs have no name&quot;</span><span class="s3">, </span><span class="s1">noname</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">ttFont</span><span class="s3">.</span><span class="s1">lazy </span><span class="s2">is False</span><span class="s3">:  </span><span class="s4"># Be lazy for None and True</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">ensureDecompiled</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">ensureDecompiled</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">recurse</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s4"># The recurse argument is unused, but part of the signature of</span>
        <span class="s4"># ensureDecompiled across the library.</span>
        <span class="s2">for </span><span class="s1">glyph </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
            <span class="s1">glyph</span><span class="s3">.</span><span class="s1">expand</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">compile</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">axisTags </span><span class="s3">= (</span>
            <span class="s3">[</span><span class="s1">axis</span><span class="s3">.</span><span class="s1">axisTag </span><span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">ttFont</span><span class="s3">[</span><span class="s5">&quot;fvar&quot;</span><span class="s3">].</span><span class="s1">axes</span><span class="s3">] </span><span class="s2">if </span><span class="s5">&quot;fvar&quot; </span><span class="s2">in </span><span class="s1">ttFont </span><span class="s2">else </span><span class="s3">[]</span>
        <span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;glyphOrder&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">glyphOrder </span><span class="s3">= </span><span class="s1">ttFont</span><span class="s3">.</span><span class="s1">getGlyphOrder</span><span class="s3">()</span>
        <span class="s1">padding </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">padding</span>
        <span class="s2">assert </span><span class="s1">padding </span><span class="s2">in </span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s6">2</span><span class="s3">, </span><span class="s6">4</span><span class="s3">)</span>
        <span class="s1">locations </span><span class="s3">= []</span>
        <span class="s1">currentLocation </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">dataList </span><span class="s3">= []</span>
        <span class="s1">recalcBBoxes </span><span class="s3">= </span><span class="s1">ttFont</span><span class="s3">.</span><span class="s1">recalcBBoxes</span>
        <span class="s1">boundsDone </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">glyphName </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphOrder</span><span class="s3">:</span>
            <span class="s1">glyph </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">[</span><span class="s1">glyphName</span><span class="s3">]</span>
            <span class="s1">glyphData </span><span class="s3">= </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">recalcBBoxes</span><span class="s3">, </span><span class="s1">boundsDone</span><span class="s3">=</span><span class="s1">boundsDone</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">padding </span><span class="s3">&gt; </span><span class="s6">1</span><span class="s3">:</span>
                <span class="s1">glyphData </span><span class="s3">= </span><span class="s1">pad</span><span class="s3">(</span><span class="s1">glyphData</span><span class="s3">, </span><span class="s1">size</span><span class="s3">=</span><span class="s1">padding</span><span class="s3">)</span>
            <span class="s1">locations</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">currentLocation</span><span class="s3">)</span>
            <span class="s1">currentLocation </span><span class="s3">= </span><span class="s1">currentLocation </span><span class="s3">+ </span><span class="s1">len</span><span class="s3">(</span><span class="s1">glyphData</span><span class="s3">)</span>
            <span class="s1">dataList</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">glyphData</span><span class="s3">)</span>
        <span class="s1">locations</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">currentLocation</span><span class="s3">)</span>

        <span class="s2">if </span><span class="s1">padding </span><span class="s3">== </span><span class="s6">1 </span><span class="s2">and </span><span class="s1">currentLocation </span><span class="s3">&lt; </span><span class="s6">0x20000</span><span class="s3">:</span>
            <span class="s4"># See if we can pad any odd-lengthed glyphs to allow loca</span>
            <span class="s4"># table to use the short offsets.</span>
            <span class="s1">indices </span><span class="s3">= [</span>
                <span class="s1">i </span><span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">glyphData </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">dataList</span><span class="s3">) </span><span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">glyphData</span><span class="s3">) % </span><span class="s6">2 </span><span class="s3">== </span><span class="s6">1</span>
            <span class="s3">]</span>
            <span class="s2">if </span><span class="s1">indices </span><span class="s2">and </span><span class="s1">currentLocation </span><span class="s3">+ </span><span class="s1">len</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">) &lt; </span><span class="s6">0x20000</span><span class="s3">:</span>
                <span class="s4"># It fits.  Do it.</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">indices</span><span class="s3">:</span>
                    <span class="s1">dataList</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] += </span><span class="s7">b&quot;</span><span class="s2">\0</span><span class="s7">&quot;</span>
                <span class="s1">currentLocation </span><span class="s3">= </span><span class="s6">0</span>
                <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">glyphData </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">dataList</span><span class="s3">):</span>
                    <span class="s1">locations</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">currentLocation</span>
                    <span class="s1">currentLocation </span><span class="s3">+= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">glyphData</span><span class="s3">)</span>
                <span class="s1">locations</span><span class="s3">[</span><span class="s1">len</span><span class="s3">(</span><span class="s1">dataList</span><span class="s3">)] = </span><span class="s1">currentLocation</span>

        <span class="s1">data </span><span class="s3">= </span><span class="s7">b&quot;&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">dataList</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s5">&quot;loca&quot; </span><span class="s2">in </span><span class="s1">ttFont</span><span class="s3">:</span>
            <span class="s1">ttFont</span><span class="s3">[</span><span class="s5">&quot;loca&quot;</span><span class="s3">].</span><span class="s1">set</span><span class="s3">(</span><span class="s1">locations</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s5">&quot;maxp&quot; </span><span class="s2">in </span><span class="s1">ttFont</span><span class="s3">:</span>
            <span class="s1">ttFont</span><span class="s3">[</span><span class="s5">&quot;maxp&quot;</span><span class="s3">].</span><span class="s1">numGlyphs </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">data</span><span class="s3">:</span>
            <span class="s4"># As a special case when all glyph in the font are empty, add a zero byte</span>
            <span class="s4"># to the table, so that OTS doesnâ€™t reject it, and to make the table work</span>
            <span class="s4"># on Windows as well.</span>
            <span class="s4"># See https://github.com/khaledhosny/ots/issues/52</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s7">b&quot;</span><span class="s2">\0</span><span class="s7">&quot;</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">toXML</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">writer</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">, </span><span class="s1">splitGlyphs</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s1">notice </span><span class="s3">= (</span>
            <span class="s5">&quot;The xMin, yMin, xMax and yMax values</span><span class="s2">\n</span><span class="s5">&quot;</span>
            <span class="s5">&quot;will be recalculated by the compiler.&quot;</span>
        <span class="s3">)</span>
        <span class="s1">glyphNames </span><span class="s3">= </span><span class="s1">ttFont</span><span class="s3">.</span><span class="s1">getGlyphNames</span><span class="s3">()</span>
        <span class="s2">if not </span><span class="s1">splitGlyphs</span><span class="s3">:</span>
            <span class="s1">writer</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>
            <span class="s1">writer</span><span class="s3">.</span><span class="s1">comment</span><span class="s3">(</span><span class="s1">notice</span><span class="s3">)</span>
            <span class="s1">writer</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>
            <span class="s1">writer</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>
        <span class="s1">numGlyphs </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">glyphNames</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">splitGlyphs</span><span class="s3">:</span>
            <span class="s1">path</span><span class="s3">, </span><span class="s1">ext </span><span class="s3">= </span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">splitext</span><span class="s3">(</span><span class="s1">writer</span><span class="s3">.</span><span class="s1">file</span><span class="s3">.</span><span class="s1">name</span><span class="s3">)</span>
            <span class="s1">existingGlyphFiles </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">glyphName </span><span class="s2">in </span><span class="s1">glyphNames</span><span class="s3">:</span>
            <span class="s1">glyph </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">glyph </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">log</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span><span class="s5">&quot;glyph '%s' does not exist in glyf table&quot;</span><span class="s3">, </span><span class="s1">glyphName</span><span class="s3">)</span>
                <span class="s2">continue</span>
            <span class="s2">if </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">numberOfContours</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">splitGlyphs</span><span class="s3">:</span>
                    <span class="s1">glyphPath </span><span class="s3">= </span><span class="s1">userNameToFileName</span><span class="s3">(</span>
                        <span class="s1">tostr</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">, </span><span class="s5">&quot;utf-8&quot;</span><span class="s3">),</span>
                        <span class="s1">existingGlyphFiles</span><span class="s3">,</span>
                        <span class="s1">prefix</span><span class="s3">=</span><span class="s1">path </span><span class="s3">+ </span><span class="s5">&quot;.&quot;</span><span class="s3">,</span>
                        <span class="s1">suffix</span><span class="s3">=</span><span class="s1">ext</span><span class="s3">,</span>
                    <span class="s3">)</span>
                    <span class="s1">existingGlyphFiles</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">glyphPath</span><span class="s3">.</span><span class="s1">lower</span><span class="s3">())</span>
                    <span class="s1">glyphWriter </span><span class="s3">= </span><span class="s1">xmlWriter</span><span class="s3">.</span><span class="s1">XMLWriter</span><span class="s3">(</span>
                        <span class="s1">glyphPath</span><span class="s3">,</span>
                        <span class="s1">idlefunc</span><span class="s3">=</span><span class="s1">writer</span><span class="s3">.</span><span class="s1">idlefunc</span><span class="s3">,</span>
                        <span class="s1">newlinestr</span><span class="s3">=</span><span class="s1">writer</span><span class="s3">.</span><span class="s1">newlinestr</span><span class="s3">,</span>
                    <span class="s3">)</span>
                    <span class="s1">glyphWriter</span><span class="s3">.</span><span class="s1">begintag</span><span class="s3">(</span><span class="s5">&quot;ttFont&quot;</span><span class="s3">, </span><span class="s1">ttLibVersion</span><span class="s3">=</span><span class="s1">version</span><span class="s3">)</span>
                    <span class="s1">glyphWriter</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>
                    <span class="s1">glyphWriter</span><span class="s3">.</span><span class="s1">begintag</span><span class="s3">(</span><span class="s5">&quot;glyf&quot;</span><span class="s3">)</span>
                    <span class="s1">glyphWriter</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>
                    <span class="s1">glyphWriter</span><span class="s3">.</span><span class="s1">comment</span><span class="s3">(</span><span class="s1">notice</span><span class="s3">)</span>
                    <span class="s1">glyphWriter</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>
                    <span class="s1">writer</span><span class="s3">.</span><span class="s1">simpletag</span><span class="s3">(</span><span class="s5">&quot;TTGlyph&quot;</span><span class="s3">, </span><span class="s1">src</span><span class="s3">=</span><span class="s1">os</span><span class="s3">.</span><span class="s1">path</span><span class="s3">.</span><span class="s1">basename</span><span class="s3">(</span><span class="s1">glyphPath</span><span class="s3">))</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">glyphWriter </span><span class="s3">= </span><span class="s1">writer</span>
                <span class="s1">glyphWriter</span><span class="s3">.</span><span class="s1">begintag</span><span class="s3">(</span>
                    <span class="s5">&quot;TTGlyph&quot;</span><span class="s3">,</span>
                    <span class="s3">[</span>
                        <span class="s3">(</span><span class="s5">&quot;name&quot;</span><span class="s3">, </span><span class="s1">glyphName</span><span class="s3">),</span>
                        <span class="s3">(</span><span class="s5">&quot;xMin&quot;</span><span class="s3">, </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">xMin</span><span class="s3">),</span>
                        <span class="s3">(</span><span class="s5">&quot;yMin&quot;</span><span class="s3">, </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">yMin</span><span class="s3">),</span>
                        <span class="s3">(</span><span class="s5">&quot;xMax&quot;</span><span class="s3">, </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">xMax</span><span class="s3">),</span>
                        <span class="s3">(</span><span class="s5">&quot;yMax&quot;</span><span class="s3">, </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">yMax</span><span class="s3">),</span>
                    <span class="s3">],</span>
                <span class="s3">)</span>
                <span class="s1">glyphWriter</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>
                <span class="s1">glyph</span><span class="s3">.</span><span class="s1">toXML</span><span class="s3">(</span><span class="s1">glyphWriter</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">)</span>
                <span class="s1">glyphWriter</span><span class="s3">.</span><span class="s1">endtag</span><span class="s3">(</span><span class="s5">&quot;TTGlyph&quot;</span><span class="s3">)</span>
                <span class="s1">glyphWriter</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>
                <span class="s2">if </span><span class="s1">splitGlyphs</span><span class="s3">:</span>
                    <span class="s1">glyphWriter</span><span class="s3">.</span><span class="s1">endtag</span><span class="s3">(</span><span class="s5">&quot;glyf&quot;</span><span class="s3">)</span>
                    <span class="s1">glyphWriter</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>
                    <span class="s1">glyphWriter</span><span class="s3">.</span><span class="s1">endtag</span><span class="s3">(</span><span class="s5">&quot;ttFont&quot;</span><span class="s3">)</span>
                    <span class="s1">glyphWriter</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>
                    <span class="s1">glyphWriter</span><span class="s3">.</span><span class="s1">close</span><span class="s3">()</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">writer</span><span class="s3">.</span><span class="s1">simpletag</span><span class="s3">(</span><span class="s5">&quot;TTGlyph&quot;</span><span class="s3">, </span><span class="s1">name</span><span class="s3">=</span><span class="s1">glyphName</span><span class="s3">)</span>
                <span class="s1">writer</span><span class="s3">.</span><span class="s1">comment</span><span class="s3">(</span><span class="s5">&quot;contains no outline data&quot;</span><span class="s3">)</span>
                <span class="s2">if not </span><span class="s1">splitGlyphs</span><span class="s3">:</span>
                    <span class="s1">writer</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>
            <span class="s1">writer</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">fromXML</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">content</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s3">!= </span><span class="s5">&quot;TTGlyph&quot;</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;glyphs&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">glyphs </span><span class="s3">= {}</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;glyphOrder&quot;</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">glyphOrder </span><span class="s3">= </span><span class="s1">ttFont</span><span class="s3">.</span><span class="s1">getGlyphOrder</span><span class="s3">()</span>
        <span class="s1">glyphName </span><span class="s3">= </span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;name&quot;</span><span class="s3">]</span>
        <span class="s1">log</span><span class="s3">.</span><span class="s1">debug</span><span class="s3">(</span><span class="s5">&quot;unpacking glyph '%s'&quot;</span><span class="s3">, </span><span class="s1">glyphName</span><span class="s3">)</span>
        <span class="s1">glyph </span><span class="s3">= </span><span class="s1">Glyph</span><span class="s3">()</span>
        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s3">[</span><span class="s5">&quot;xMin&quot;</span><span class="s3">, </span><span class="s5">&quot;yMin&quot;</span><span class="s3">, </span><span class="s5">&quot;xMax&quot;</span><span class="s3">, </span><span class="s5">&quot;yMax&quot;</span><span class="s3">]:</span>
            <span class="s1">setattr</span><span class="s3">(</span><span class="s1">glyph</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">safeEval</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">, </span><span class="s5">&quot;0&quot;</span><span class="s3">)))</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">[</span><span class="s1">glyphName</span><span class="s3">] = </span><span class="s1">glyph</span>
        <span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">content</span><span class="s3">:</span>
            <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">element</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
                <span class="s2">continue</span>
            <span class="s1">name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">content </span><span class="s3">= </span><span class="s1">element</span>
            <span class="s1">glyph</span><span class="s3">.</span><span class="s1">fromXML</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">content</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">)</span>
        <span class="s2">if not </span><span class="s1">ttFont</span><span class="s3">.</span><span class="s1">recalcBBoxes</span><span class="s3">:</span>
            <span class="s1">glyph</span><span class="s3">.</span><span class="s1">compact</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s6">0</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">setGlyphOrder</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyphOrder</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Sets the glyph order 
 
        Args: 
                glyphOrder ([str]): List of glyph names in order. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">glyphOrder </span><span class="s3">= </span><span class="s1">glyphOrder</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_reverseGlyphOrder </span><span class="s3">= {}</span>

    <span class="s2">def </span><span class="s1">getGlyphName</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyphID</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Returns the name for the glyph with the given ID. 
 
        Raises a ``KeyError`` if the glyph name is not found in the font. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphOrder</span><span class="s3">[</span><span class="s1">glyphID</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">_buildReverseGlyphOrderDict</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_reverseGlyphOrder </span><span class="s3">= </span><span class="s1">d </span><span class="s3">= {}</span>
        <span class="s2">for </span><span class="s1">glyphID</span><span class="s3">, </span><span class="s1">glyphName </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphOrder</span><span class="s3">):</span>
            <span class="s1">d</span><span class="s3">[</span><span class="s1">glyphName</span><span class="s3">] = </span><span class="s1">glyphID</span>

    <span class="s2">def </span><span class="s1">getGlyphID</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyphName</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Returns the ID of the glyph with the given name. 
 
        Raises a ``ValueError`` if the glyph is not found in the font. 
        &quot;&quot;&quot;</span>
        <span class="s1">glyphOrder </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphOrder</span>
        <span class="s1">id </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;_reverseGlyphOrder&quot;</span><span class="s3">, {}).</span><span class="s1">get</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">id </span><span class="s2">is None or </span><span class="s1">id </span><span class="s3">&gt;= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">glyphOrder</span><span class="s3">) </span><span class="s2">or </span><span class="s1">glyphOrder</span><span class="s3">[</span><span class="s1">id</span><span class="s3">] != </span><span class="s1">glyphName</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_buildReverseGlyphOrderDict</span><span class="s3">()</span>
            <span class="s1">id </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_reverseGlyphOrder</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">id </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">id</span>

    <span class="s2">def </span><span class="s1">removeHinting</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Removes TrueType hints from all glyphs in the glyphset. 
 
        See :py:meth:`Glyph.removeHinting`. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">glyph </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">.</span><span class="s1">values</span><span class="s3">():</span>
            <span class="s1">glyph</span><span class="s3">.</span><span class="s1">removeHinting</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">has_key</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyphName</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">glyphName </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphs</span>

    <span class="s1">__contains__ </span><span class="s3">= </span><span class="s1">has_key</span>

    <span class="s2">def </span><span class="s1">get</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">default</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s1">glyph </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">default</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">glyph </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">glyph</span><span class="s3">.</span><span class="s1">expand</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">glyph</span>

    <span class="s2">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyphName</span><span class="s3">):</span>
        <span class="s1">glyph </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">[</span><span class="s1">glyphName</span><span class="s3">]</span>
        <span class="s1">glyph</span><span class="s3">.</span><span class="s1">expand</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">glyph</span>

    <span class="s2">def </span><span class="s1">__setitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">glyph</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">[</span><span class="s1">glyphName</span><span class="s3">] = </span><span class="s1">glyph</span>
        <span class="s2">if </span><span class="s1">glyphName </span><span class="s2">not in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphOrder</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">glyphOrder</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__delitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyphName</span><span class="s3">):</span>
        <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">[</span><span class="s1">glyphName</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">glyphOrder</span><span class="s3">.</span><span class="s1">remove</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__len__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphOrder</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">_getPhantomPoints</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">hMetrics</span><span class="s3">, </span><span class="s1">vMetrics</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Compute the four &quot;phantom points&quot; for the given glyph from its bounding box 
        and the horizontal and vertical advance widths and sidebearings stored in the 
        ttFont's &quot;hmtx&quot; and &quot;vmtx&quot; tables. 
 
        'hMetrics' should be ttFont['hmtx'].metrics. 
 
        'vMetrics' should be ttFont['vmtx'].metrics if there is &quot;vmtx&quot; or None otherwise. 
        If there is no vMetrics passed in, vertical phantom points are set to the zero coordinate. 
 
        https://docs.microsoft.com/en-us/typography/opentype/spec/tt_instructing_glyphs#phantoms 
        &quot;&quot;&quot;</span>
        <span class="s1">glyph </span><span class="s3">= </span><span class="s1">self</span><span class="s3">[</span><span class="s1">glyphName</span><span class="s3">]</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">glyph</span><span class="s3">, </span><span class="s5">&quot;xMin&quot;</span><span class="s3">):</span>
            <span class="s1">glyph</span><span class="s3">.</span><span class="s1">recalcBounds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>

        <span class="s1">horizontalAdvanceWidth</span><span class="s3">, </span><span class="s1">leftSideBearing </span><span class="s3">= </span><span class="s1">hMetrics</span><span class="s3">[</span><span class="s1">glyphName</span><span class="s3">]</span>
        <span class="s1">leftSideX </span><span class="s3">= </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">xMin </span><span class="s3">- </span><span class="s1">leftSideBearing</span>
        <span class="s1">rightSideX </span><span class="s3">= </span><span class="s1">leftSideX </span><span class="s3">+ </span><span class="s1">horizontalAdvanceWidth</span>

        <span class="s2">if </span><span class="s1">vMetrics</span><span class="s3">:</span>
            <span class="s1">verticalAdvanceWidth</span><span class="s3">, </span><span class="s1">topSideBearing </span><span class="s3">= </span><span class="s1">vMetrics</span><span class="s3">[</span><span class="s1">glyphName</span><span class="s3">]</span>
            <span class="s1">topSideY </span><span class="s3">= </span><span class="s1">topSideBearing </span><span class="s3">+ </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">yMax</span>
            <span class="s1">bottomSideY </span><span class="s3">= </span><span class="s1">topSideY </span><span class="s3">- </span><span class="s1">verticalAdvanceWidth</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">bottomSideY </span><span class="s3">= </span><span class="s1">topSideY </span><span class="s3">= </span><span class="s6">0</span>

        <span class="s2">return </span><span class="s3">[</span>
            <span class="s3">(</span><span class="s1">leftSideX</span><span class="s3">, </span><span class="s6">0</span><span class="s3">),</span>
            <span class="s3">(</span><span class="s1">rightSideX</span><span class="s3">, </span><span class="s6">0</span><span class="s3">),</span>
            <span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">topSideY</span><span class="s3">),</span>
            <span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">bottomSideY</span><span class="s3">),</span>
        <span class="s3">]</span>

    <span class="s2">def </span><span class="s1">_getCoordinatesAndControls</span><span class="s3">(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">hMetrics</span><span class="s3">, </span><span class="s1">vMetrics</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, *, </span><span class="s1">round</span><span class="s3">=</span><span class="s1">otRound</span>
    <span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Return glyph coordinates and controls as expected by &quot;gvar&quot; table. 
 
        The coordinates includes four &quot;phantom points&quot; for the glyph metrics, 
        as mandated by the &quot;gvar&quot; spec. 
 
        The glyph controls is a namedtuple with the following attributes: 
                - numberOfContours: -1 for composite glyphs. 
                - endPts: list of indices of end points for each contour in simple 
                glyphs, or component indices in composite glyphs (used for IUP 
                optimization). 
                - flags: array of contour point flags for simple glyphs (None for 
                composite glyphs). 
                - components: list of base glyph names (str) for each component in 
                composite glyphs (None for simple glyphs). 
 
        The &quot;hMetrics&quot; and vMetrics are used to compute the &quot;phantom points&quot; (see 
        the &quot;_getPhantomPoints&quot; method). 
 
        Return None if the requested glyphName is not present. 
        &quot;&quot;&quot;</span>
        <span class="s1">glyph </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">glyph </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">return None</span>
        <span class="s2">if </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">isComposite</span><span class="s3">():</span>
            <span class="s1">coords </span><span class="s3">= </span><span class="s1">GlyphCoordinates</span><span class="s3">(</span>
                <span class="s3">[(</span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s5">&quot;x&quot;</span><span class="s3">, </span><span class="s6">0</span><span class="s3">), </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s5">&quot;y&quot;</span><span class="s3">, </span><span class="s6">0</span><span class="s3">)) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">components</span><span class="s3">]</span>
            <span class="s3">)</span>
            <span class="s1">controls </span><span class="s3">= </span><span class="s1">_GlyphControls</span><span class="s3">(</span>
                <span class="s1">numberOfContours</span><span class="s3">=</span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">numberOfContours</span><span class="s3">,</span>
                <span class="s1">endPts</span><span class="s3">=</span><span class="s1">list</span><span class="s3">(</span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">components</span><span class="s3">))),</span>
                <span class="s1">flags</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
                <span class="s1">components</span><span class="s3">=[</span>
                    <span class="s3">(</span><span class="s1">c</span><span class="s3">.</span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">c</span><span class="s3">, </span><span class="s5">&quot;transform&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">))</span>
                    <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">components</span>
                <span class="s3">],</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">coords</span><span class="s3">, </span><span class="s1">endPts</span><span class="s3">, </span><span class="s1">flags </span><span class="s3">= </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">getCoordinates</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
            <span class="s1">coords </span><span class="s3">= </span><span class="s1">coords</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">controls </span><span class="s3">= </span><span class="s1">_GlyphControls</span><span class="s3">(</span>
                <span class="s1">numberOfContours</span><span class="s3">=</span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">numberOfContours</span><span class="s3">,</span>
                <span class="s1">endPts</span><span class="s3">=</span><span class="s1">endPts</span><span class="s3">,</span>
                <span class="s1">flags</span><span class="s3">=</span><span class="s1">flags</span><span class="s3">,</span>
                <span class="s1">components</span><span class="s3">=</span><span class="s2">None</span><span class="s3">,</span>
            <span class="s3">)</span>
        <span class="s4"># Add phantom points for (left, right, top, bottom) positions.</span>
        <span class="s1">phantomPoints </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_getPhantomPoints</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">hMetrics</span><span class="s3">, </span><span class="s1">vMetrics</span><span class="s3">)</span>
        <span class="s1">coords</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">phantomPoints</span><span class="s3">)</span>
        <span class="s1">coords</span><span class="s3">.</span><span class="s1">toInt</span><span class="s3">(</span><span class="s1">round</span><span class="s3">=</span><span class="s1">round</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">coords</span><span class="s3">, </span><span class="s1">controls</span>

    <span class="s2">def </span><span class="s1">_setCoordinates</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">coord</span><span class="s3">, </span><span class="s1">hMetrics</span><span class="s3">, </span><span class="s1">vMetrics</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Set coordinates and metrics for the given glyph. 
 
        &quot;coord&quot; is an array of GlyphCoordinates which must include the &quot;phantom 
        points&quot; as the last four coordinates. 
 
        Both the horizontal/vertical advances and left/top sidebearings in &quot;hmtx&quot; 
        and &quot;vmtx&quot; tables (if any) are updated from four phantom points and 
        the glyph's bounding boxes. 
 
        The &quot;hMetrics&quot; and vMetrics are used to propagate &quot;phantom points&quot; 
        into &quot;hmtx&quot; and &quot;vmtx&quot; tables if desired.  (see the &quot;_getPhantomPoints&quot; 
        method). 
        &quot;&quot;&quot;</span>
        <span class="s1">glyph </span><span class="s3">= </span><span class="s1">self</span><span class="s3">[</span><span class="s1">glyphName</span><span class="s3">]</span>

        <span class="s4"># Handle phantom points for (left, right, top, bottom) positions.</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">coord</span><span class="s3">) &gt;= </span><span class="s6">4</span>
        <span class="s1">leftSideX </span><span class="s3">= </span><span class="s1">coord</span><span class="s3">[-</span><span class="s6">4</span><span class="s3">][</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">rightSideX </span><span class="s3">= </span><span class="s1">coord</span><span class="s3">[-</span><span class="s6">3</span><span class="s3">][</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">topSideY </span><span class="s3">= </span><span class="s1">coord</span><span class="s3">[-</span><span class="s6">2</span><span class="s3">][</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">bottomSideY </span><span class="s3">= </span><span class="s1">coord</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">][</span><span class="s6">1</span><span class="s3">]</span>

        <span class="s1">coord </span><span class="s3">= </span><span class="s1">coord</span><span class="s3">[:-</span><span class="s6">4</span><span class="s3">]</span>

        <span class="s2">if </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">isComposite</span><span class="s3">():</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">coord</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">components</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">p</span><span class="s3">, </span><span class="s1">comp </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">coord</span><span class="s3">, </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">components</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">comp</span><span class="s3">, </span><span class="s5">&quot;x&quot;</span><span class="s3">):</span>
                    <span class="s1">comp</span><span class="s3">.</span><span class="s1">x</span><span class="s3">, </span><span class="s1">comp</span><span class="s3">.</span><span class="s1">y </span><span class="s3">= </span><span class="s1">p</span>
        <span class="s2">elif </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">coord</span><span class="s3">) == </span><span class="s6">0</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">coord</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">coordinates</span><span class="s3">)</span>
            <span class="s1">glyph</span><span class="s3">.</span><span class="s1">coordinates </span><span class="s3">= </span><span class="s1">GlyphCoordinates</span><span class="s3">(</span><span class="s1">coord</span><span class="s3">)</span>

        <span class="s1">glyph</span><span class="s3">.</span><span class="s1">recalcBounds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">boundsDone</span><span class="s3">=</span><span class="s1">set</span><span class="s3">())</span>

        <span class="s1">horizontalAdvanceWidth </span><span class="s3">= </span><span class="s1">otRound</span><span class="s3">(</span><span class="s1">rightSideX </span><span class="s3">- </span><span class="s1">leftSideX</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">horizontalAdvanceWidth </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s4"># unlikely, but it can happen, see:</span>
            <span class="s4"># https://github.com/fonttools/fonttools/pull/1198</span>
            <span class="s1">horizontalAdvanceWidth </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">leftSideBearing </span><span class="s3">= </span><span class="s1">otRound</span><span class="s3">(</span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">xMin </span><span class="s3">- </span><span class="s1">leftSideX</span><span class="s3">)</span>
        <span class="s1">hMetrics</span><span class="s3">[</span><span class="s1">glyphName</span><span class="s3">] = </span><span class="s1">horizontalAdvanceWidth</span><span class="s3">, </span><span class="s1">leftSideBearing</span>

        <span class="s2">if </span><span class="s1">vMetrics </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s1">verticalAdvanceWidth </span><span class="s3">= </span><span class="s1">otRound</span><span class="s3">(</span><span class="s1">topSideY </span><span class="s3">- </span><span class="s1">bottomSideY</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">verticalAdvanceWidth </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:  </span><span class="s4"># unlikely but do the same as horizontal</span>
                <span class="s1">verticalAdvanceWidth </span><span class="s3">= </span><span class="s6">0</span>
            <span class="s1">topSideBearing </span><span class="s3">= </span><span class="s1">otRound</span><span class="s3">(</span><span class="s1">topSideY </span><span class="s3">- </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">yMax</span><span class="s3">)</span>
            <span class="s1">vMetrics</span><span class="s3">[</span><span class="s1">glyphName</span><span class="s3">] = </span><span class="s1">verticalAdvanceWidth</span><span class="s3">, </span><span class="s1">topSideBearing</span>

    <span class="s4"># Deprecated</span>

    <span class="s2">def </span><span class="s1">_synthesizeVMetrics</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">, </span><span class="s1">defaultVerticalOrigin</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;This method is wrong and deprecated. 
        For rationale see: 
        https://github.com/fonttools/fonttools/pull/2266/files#r613569473 
        &quot;&quot;&quot;</span>
        <span class="s1">vMetrics </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">ttFont</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">&quot;vmtx&quot;</span><span class="s3">), </span><span class="s5">&quot;metrics&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">vMetrics </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">verticalAdvanceWidth </span><span class="s3">= </span><span class="s1">ttFont</span><span class="s3">[</span><span class="s5">&quot;head&quot;</span><span class="s3">].</span><span class="s1">unitsPerEm</span>
            <span class="s1">topSideY </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">ttFont</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">&quot;hhea&quot;</span><span class="s3">), </span><span class="s5">&quot;ascent&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">topSideY </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">defaultVerticalOrigin </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">topSideY </span><span class="s3">= </span><span class="s1">defaultVerticalOrigin</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">topSideY </span><span class="s3">= </span><span class="s1">verticalAdvanceWidth</span>
            <span class="s1">glyph </span><span class="s3">= </span><span class="s1">self</span><span class="s3">[</span><span class="s1">glyphName</span><span class="s3">]</span>
            <span class="s1">glyph</span><span class="s3">.</span><span class="s1">recalcBounds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)</span>
            <span class="s1">topSideBearing </span><span class="s3">= </span><span class="s1">otRound</span><span class="s3">(</span><span class="s1">topSideY </span><span class="s3">- </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">yMax</span><span class="s3">)</span>
            <span class="s1">vMetrics </span><span class="s3">= {</span><span class="s1">glyphName</span><span class="s3">: (</span><span class="s1">verticalAdvanceWidth</span><span class="s3">, </span><span class="s1">topSideBearing</span><span class="s3">)}</span>
        <span class="s2">return </span><span class="s1">vMetrics</span>

    <span class="s3">@</span><span class="s1">deprecateFunction</span><span class="s3">(</span><span class="s5">&quot;use '_getPhantomPoints' instead&quot;</span><span class="s3">, </span><span class="s1">category</span><span class="s3">=</span><span class="s1">DeprecationWarning</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">getPhantomPoints</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">, </span><span class="s1">defaultVerticalOrigin</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Old public name for self._getPhantomPoints(). 
        See: https://github.com/fonttools/fonttools/pull/2266&quot;&quot;&quot;</span>
        <span class="s1">hMetrics </span><span class="s3">= </span><span class="s1">ttFont</span><span class="s3">[</span><span class="s5">&quot;hmtx&quot;</span><span class="s3">].</span><span class="s1">metrics</span>
        <span class="s1">vMetrics </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_synthesizeVMetrics</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">, </span><span class="s1">defaultVerticalOrigin</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_getPhantomPoints</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">hMetrics</span><span class="s3">, </span><span class="s1">vMetrics</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">deprecateFunction</span><span class="s3">(</span>
        <span class="s5">&quot;use '_getCoordinatesAndControls' instead&quot;</span><span class="s3">, </span><span class="s1">category</span><span class="s3">=</span><span class="s1">DeprecationWarning</span>
    <span class="s3">)</span>
    <span class="s2">def </span><span class="s1">getCoordinatesAndControls</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">, </span><span class="s1">defaultVerticalOrigin</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Old public name for self._getCoordinatesAndControls(). 
        See: https://github.com/fonttools/fonttools/pull/2266&quot;&quot;&quot;</span>
        <span class="s1">hMetrics </span><span class="s3">= </span><span class="s1">ttFont</span><span class="s3">[</span><span class="s5">&quot;hmtx&quot;</span><span class="s3">].</span><span class="s1">metrics</span>
        <span class="s1">vMetrics </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_synthesizeVMetrics</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">, </span><span class="s1">defaultVerticalOrigin</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_getCoordinatesAndControls</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">hMetrics</span><span class="s3">, </span><span class="s1">vMetrics</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">deprecateFunction</span><span class="s3">(</span><span class="s5">&quot;use '_setCoordinates' instead&quot;</span><span class="s3">, </span><span class="s1">category</span><span class="s3">=</span><span class="s1">DeprecationWarning</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">setCoordinates</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Old public name for self._setCoordinates(). 
        See: https://github.com/fonttools/fonttools/pull/2266&quot;&quot;&quot;</span>
        <span class="s1">hMetrics </span><span class="s3">= </span><span class="s1">ttFont</span><span class="s3">[</span><span class="s5">&quot;hmtx&quot;</span><span class="s3">].</span><span class="s1">metrics</span>
        <span class="s1">vMetrics </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">ttFont</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s5">&quot;vmtx&quot;</span><span class="s3">), </span><span class="s5">&quot;metrics&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_setCoordinates</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">hMetrics</span><span class="s3">, </span><span class="s1">vMetrics</span><span class="s3">)</span>


<span class="s1">_GlyphControls </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span>
    <span class="s5">&quot;_GlyphControls&quot;</span><span class="s3">, </span><span class="s5">&quot;numberOfContours endPts flags components&quot;</span>
<span class="s3">)</span>


<span class="s1">glyphHeaderFormat </span><span class="s3">= </span><span class="s5">&quot;&quot;&quot; 
        &gt;   # big endian 
        numberOfContours:   h 
        xMin:               h 
        yMin:               h 
        xMax:               h 
        yMax:               h 
&quot;&quot;&quot;</span>

<span class="s4"># flags</span>
<span class="s1">flagOnCurve </span><span class="s3">= </span><span class="s6">0x01</span>
<span class="s1">flagXShort </span><span class="s3">= </span><span class="s6">0x02</span>
<span class="s1">flagYShort </span><span class="s3">= </span><span class="s6">0x04</span>
<span class="s1">flagRepeat </span><span class="s3">= </span><span class="s6">0x08</span>
<span class="s1">flagXsame </span><span class="s3">= </span><span class="s6">0x10</span>
<span class="s1">flagYsame </span><span class="s3">= </span><span class="s6">0x20</span>
<span class="s1">flagOverlapSimple </span><span class="s3">= </span><span class="s6">0x40</span>
<span class="s1">flagCubic </span><span class="s3">= </span><span class="s6">0x80</span>

<span class="s4"># These flags are kept for XML output after decompiling the coordinates</span>
<span class="s1">keepFlags </span><span class="s3">= </span><span class="s1">flagOnCurve </span><span class="s3">+ </span><span class="s1">flagOverlapSimple </span><span class="s3">+ </span><span class="s1">flagCubic</span>

<span class="s1">_flagSignBytes </span><span class="s3">= {</span>
    <span class="s6">0</span><span class="s3">: </span><span class="s6">2</span><span class="s3">,</span>
    <span class="s1">flagXsame</span><span class="s3">: </span><span class="s6">0</span><span class="s3">,</span>
    <span class="s1">flagXShort </span><span class="s3">| </span><span class="s1">flagXsame</span><span class="s3">: +</span><span class="s6">1</span><span class="s3">,</span>
    <span class="s1">flagXShort</span><span class="s3">: -</span><span class="s6">1</span><span class="s3">,</span>
    <span class="s1">flagYsame</span><span class="s3">: </span><span class="s6">0</span><span class="s3">,</span>
    <span class="s1">flagYShort </span><span class="s3">| </span><span class="s1">flagYsame</span><span class="s3">: +</span><span class="s6">1</span><span class="s3">,</span>
    <span class="s1">flagYShort</span><span class="s3">: -</span><span class="s6">1</span><span class="s3">,</span>
<span class="s3">}</span>


<span class="s2">def </span><span class="s1">flagBest</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">onCurve</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;For a given x,y delta pair, returns the flag that packs this pair 
    most efficiently, as well as the number of byte cost of such flag.&quot;&quot;&quot;</span>

    <span class="s1">flag </span><span class="s3">= </span><span class="s1">flagOnCurve </span><span class="s2">if </span><span class="s1">onCurve </span><span class="s2">else </span><span class="s6">0</span>
    <span class="s1">cost </span><span class="s3">= </span><span class="s6">0</span>
    <span class="s4"># do x</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s1">flag </span><span class="s3">= </span><span class="s1">flag </span><span class="s3">| </span><span class="s1">flagXsame</span>
    <span class="s2">elif </span><span class="s3">-</span><span class="s6">255 </span><span class="s3">&lt;= </span><span class="s1">x </span><span class="s3">&lt;= </span><span class="s6">255</span><span class="s3">:</span>
        <span class="s1">flag </span><span class="s3">= </span><span class="s1">flag </span><span class="s3">| </span><span class="s1">flagXShort</span>
        <span class="s2">if </span><span class="s1">x </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">flag </span><span class="s3">= </span><span class="s1">flag </span><span class="s3">| </span><span class="s1">flagXsame</span>
        <span class="s1">cost </span><span class="s3">+= </span><span class="s6">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">cost </span><span class="s3">+= </span><span class="s6">2</span>
    <span class="s4"># do y</span>
    <span class="s2">if </span><span class="s1">y </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
        <span class="s1">flag </span><span class="s3">= </span><span class="s1">flag </span><span class="s3">| </span><span class="s1">flagYsame</span>
    <span class="s2">elif </span><span class="s3">-</span><span class="s6">255 </span><span class="s3">&lt;= </span><span class="s1">y </span><span class="s3">&lt;= </span><span class="s6">255</span><span class="s3">:</span>
        <span class="s1">flag </span><span class="s3">= </span><span class="s1">flag </span><span class="s3">| </span><span class="s1">flagYShort</span>
        <span class="s2">if </span><span class="s1">y </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">flag </span><span class="s3">= </span><span class="s1">flag </span><span class="s3">| </span><span class="s1">flagYsame</span>
        <span class="s1">cost </span><span class="s3">+= </span><span class="s6">1</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">cost </span><span class="s3">+= </span><span class="s6">2</span>
    <span class="s2">return </span><span class="s1">flag</span><span class="s3">, </span><span class="s1">cost</span>


<span class="s2">def </span><span class="s1">flagFits</span><span class="s3">(</span><span class="s1">newFlag</span><span class="s3">, </span><span class="s1">oldFlag</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">):</span>
    <span class="s1">newBytes </span><span class="s3">= </span><span class="s1">_flagSignBytes</span><span class="s3">[</span><span class="s1">newFlag </span><span class="s3">&amp; </span><span class="s1">mask</span><span class="s3">]</span>
    <span class="s1">oldBytes </span><span class="s3">= </span><span class="s1">_flagSignBytes</span><span class="s3">[</span><span class="s1">oldFlag </span><span class="s3">&amp; </span><span class="s1">mask</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">newBytes </span><span class="s3">== </span><span class="s1">oldBytes </span><span class="s2">or </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">newBytes</span><span class="s3">) &gt; </span><span class="s1">abs</span><span class="s3">(</span><span class="s1">oldBytes</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">flagSupports</span><span class="s3">(</span><span class="s1">newFlag</span><span class="s3">, </span><span class="s1">oldFlag</span><span class="s3">):</span>
    <span class="s2">return </span><span class="s3">(</span>
        <span class="s3">(</span><span class="s1">oldFlag </span><span class="s3">&amp; </span><span class="s1">flagOnCurve</span><span class="s3">) == (</span><span class="s1">newFlag </span><span class="s3">&amp; </span><span class="s1">flagOnCurve</span><span class="s3">)</span>
        <span class="s2">and </span><span class="s1">flagFits</span><span class="s3">(</span><span class="s1">newFlag</span><span class="s3">, </span><span class="s1">oldFlag</span><span class="s3">, </span><span class="s1">flagXsame </span><span class="s3">| </span><span class="s1">flagXShort</span><span class="s3">)</span>
        <span class="s2">and </span><span class="s1">flagFits</span><span class="s3">(</span><span class="s1">newFlag</span><span class="s3">, </span><span class="s1">oldFlag</span><span class="s3">, </span><span class="s1">flagYsame </span><span class="s3">| </span><span class="s1">flagYShort</span><span class="s3">)</span>
    <span class="s3">)</span>


<span class="s2">def </span><span class="s1">flagEncodeCoord</span><span class="s3">(</span><span class="s1">flag</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">coord</span><span class="s3">, </span><span class="s1">coordBytes</span><span class="s3">):</span>
    <span class="s1">byteCount </span><span class="s3">= </span><span class="s1">_flagSignBytes</span><span class="s3">[</span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">mask</span><span class="s3">]</span>
    <span class="s2">if </span><span class="s1">byteCount </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s1">coordBytes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">coord</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">byteCount </span><span class="s3">== -</span><span class="s6">1</span><span class="s3">:</span>
        <span class="s1">coordBytes</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(-</span><span class="s1">coord</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">byteCount </span><span class="s3">== </span><span class="s6">2</span><span class="s3">:</span>
        <span class="s1">coordBytes</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s5">&quot;&gt;h&quot;</span><span class="s3">, </span><span class="s1">coord</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">flagEncodeCoords</span><span class="s3">(</span><span class="s1">flag</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">xBytes</span><span class="s3">, </span><span class="s1">yBytes</span><span class="s3">):</span>
    <span class="s1">flagEncodeCoord</span><span class="s3">(</span><span class="s1">flag</span><span class="s3">, </span><span class="s1">flagXsame </span><span class="s3">| </span><span class="s1">flagXShort</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">xBytes</span><span class="s3">)</span>
    <span class="s1">flagEncodeCoord</span><span class="s3">(</span><span class="s1">flag</span><span class="s3">, </span><span class="s1">flagYsame </span><span class="s3">| </span><span class="s1">flagYShort</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">yBytes</span><span class="s3">)</span>


<span class="s1">ARG_1_AND_2_ARE_WORDS </span><span class="s3">= </span><span class="s6">0x0001  </span><span class="s4"># if set args are words otherwise they are bytes</span>
<span class="s1">ARGS_ARE_XY_VALUES </span><span class="s3">= </span><span class="s6">0x0002  </span><span class="s4"># if set args are xy values, otherwise they are points</span>
<span class="s1">ROUND_XY_TO_GRID </span><span class="s3">= </span><span class="s6">0x0004  </span><span class="s4"># for the xy values if above is true</span>
<span class="s1">WE_HAVE_A_SCALE </span><span class="s3">= </span><span class="s6">0x0008  </span><span class="s4"># Sx = Sy, otherwise scale == 1.0</span>
<span class="s1">NON_OVERLAPPING </span><span class="s3">= </span><span class="s6">0x0010  </span><span class="s4"># set to same value for all components (obsolete!)</span>
<span class="s1">MORE_COMPONENTS </span><span class="s3">= </span><span class="s6">0x0020  </span><span class="s4"># indicates at least one more glyph after this one</span>
<span class="s1">WE_HAVE_AN_X_AND_Y_SCALE </span><span class="s3">= </span><span class="s6">0x0040  </span><span class="s4"># Sx, Sy</span>
<span class="s1">WE_HAVE_A_TWO_BY_TWO </span><span class="s3">= </span><span class="s6">0x0080  </span><span class="s4"># t00, t01, t10, t11</span>
<span class="s1">WE_HAVE_INSTRUCTIONS </span><span class="s3">= </span><span class="s6">0x0100  </span><span class="s4"># instructions follow</span>
<span class="s1">USE_MY_METRICS </span><span class="s3">= </span><span class="s6">0x0200  </span><span class="s4"># apply these metrics to parent glyph</span>
<span class="s1">OVERLAP_COMPOUND </span><span class="s3">= </span><span class="s6">0x0400  </span><span class="s4"># used by Apple in GX fonts</span>
<span class="s1">SCALED_COMPONENT_OFFSET </span><span class="s3">= </span><span class="s6">0x0800  </span><span class="s4"># composite designed to have the component offset scaled (designed for Apple)</span>
<span class="s1">UNSCALED_COMPONENT_OFFSET </span><span class="s3">= </span><span class="s6">0x1000  </span><span class="s4"># composite designed not to have the component offset scaled (designed for MS)</span>


<span class="s1">CompositeMaxpValues </span><span class="s3">= </span><span class="s1">namedtuple</span><span class="s3">(</span>
    <span class="s5">&quot;CompositeMaxpValues&quot;</span><span class="s3">, [</span><span class="s5">&quot;nPoints&quot;</span><span class="s3">, </span><span class="s5">&quot;nContours&quot;</span><span class="s3">, </span><span class="s5">&quot;maxComponentDepth&quot;</span><span class="s3">]</span>
<span class="s3">)</span>


<span class="s2">class </span><span class="s1">Glyph</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;This class represents an individual TrueType glyph. 
 
    TrueType glyph objects come in two flavours: simple and composite. Simple 
    glyph objects contain contours, represented via the ``.coordinates``, 
    ``.flags``, ``.numberOfContours``, and ``.endPtsOfContours`` attributes; 
    composite glyphs contain components, available through the ``.components`` 
    attributes. 
 
    Because the ``.coordinates`` attribute (and other simple glyph attributes mentioned 
    above) is only set on simple glyphs and the ``.components`` attribute is only 
    set on composite glyphs, it is necessary to use the :py:meth:`isComposite` 
    method to test whether a glyph is simple or composite before attempting to 
    access its data. 
 
    For a composite glyph, the components can also be accessed via array-like access:: 
 
            &gt;&gt; assert(font[&quot;glyf&quot;][&quot;Aacute&quot;].isComposite()) 
            &gt;&gt; font[&quot;glyf&quot;][&quot;Aacute&quot;][0] 
            &lt;fontTools.ttLib.tables._g_l_y_f.GlyphComponent at 0x1027b2ee0&gt; 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">=</span><span class="s7">b&quot;&quot;</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">data</span><span class="s3">:</span>
            <span class="s4"># empty char</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">= </span><span class="s6">0</span>
            <span class="s2">return</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">data </span><span class="s3">= </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">compact</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyfTable</span><span class="s3">, </span><span class="s1">recalcBBoxes</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s1">glyfTable</span><span class="s3">, </span><span class="s1">recalcBBoxes</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">.</span><span class="s1">clear</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">data </span><span class="s3">= </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">expand</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyfTable</span><span class="s3">):</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s3">):</span>
            <span class="s4"># already unpacked</span>
            <span class="s2">return</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">:</span>
            <span class="s4"># empty char</span>
            <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">= </span><span class="s6">0</span>
            <span class="s2">return</span>
        <span class="s1">dummy</span><span class="s3">, </span><span class="s1">data </span><span class="s3">= </span><span class="s1">sstruct</span><span class="s3">.</span><span class="s1">unpack2</span><span class="s3">(</span><span class="s1">glyphHeaderFormat</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">, </span><span class="s1">self</span><span class="s3">)</span>
        <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span>
        <span class="s4"># Some fonts (eg. Neirizi.ttf) have a 0 for numberOfContours in</span>
        <span class="s4"># some glyphs; decompileCoordinates assumes that there's at least</span>
        <span class="s4"># one, so short-circuit here.</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">isComposite</span><span class="s3">():</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">decompileComponents</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">glyfTable</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">decompileCoordinates</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">compile</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyfTable</span><span class="s3">, </span><span class="s1">recalcBBoxes</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, *, </span><span class="s1">boundsDone</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">recalcBBoxes</span><span class="s3">:</span>
                <span class="s4"># must unpack glyph in order to recalculate bounding box</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">expand</span><span class="s3">(</span><span class="s1">glyfTable</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s7">b&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">recalcBBoxes</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">recalcBounds</span><span class="s3">(</span><span class="s1">glyfTable</span><span class="s3">, </span><span class="s1">boundsDone</span><span class="s3">=</span><span class="s1">boundsDone</span><span class="s3">)</span>

        <span class="s1">data </span><span class="s3">= </span><span class="s1">sstruct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s1">glyphHeaderFormat</span><span class="s3">, </span><span class="s1">self</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">isComposite</span><span class="s3">():</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">data </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compileComponents</span><span class="s3">(</span><span class="s1">glyfTable</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">data </span><span class="s3">+ </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compileCoordinates</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">toXML</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">writer</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">isComposite</span><span class="s3">():</span>
            <span class="s2">for </span><span class="s1">compo </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">components</span><span class="s3">:</span>
                <span class="s1">compo</span><span class="s3">.</span><span class="s1">toXML</span><span class="s3">(</span><span class="s1">writer</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">)</span>
            <span class="s1">haveInstructions </span><span class="s3">= </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;program&quot;</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">last </span><span class="s3">= </span><span class="s6">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">numberOfContours</span><span class="s3">):</span>
                <span class="s1">writer</span><span class="s3">.</span><span class="s1">begintag</span><span class="s3">(</span><span class="s5">&quot;contour&quot;</span><span class="s3">)</span>
                <span class="s1">writer</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>
                <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">last</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">endPtsOfContours</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + </span><span class="s6">1</span><span class="s3">):</span>
                    <span class="s1">attrs </span><span class="s3">= [</span>
                        <span class="s3">(</span><span class="s5">&quot;x&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">coordinates</span><span class="s3">[</span><span class="s1">j</span><span class="s3">][</span><span class="s6">0</span><span class="s3">]),</span>
                        <span class="s3">(</span><span class="s5">&quot;y&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">coordinates</span><span class="s3">[</span><span class="s1">j</span><span class="s3">][</span><span class="s6">1</span><span class="s3">]),</span>
                        <span class="s3">(</span><span class="s5">&quot;on&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] &amp; </span><span class="s1">flagOnCurve</span><span class="s3">),</span>
                    <span class="s3">]</span>
                    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] &amp; </span><span class="s1">flagOverlapSimple</span><span class="s3">:</span>
                        <span class="s4"># Apple's rasterizer uses flagOverlapSimple in the first contour/first pt to flag glyphs that contain overlapping contours</span>
                        <span class="s1">attrs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s5">&quot;overlap&quot;</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>
                    <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] &amp; </span><span class="s1">flagCubic</span><span class="s3">:</span>
                        <span class="s1">attrs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s5">&quot;cubic&quot;</span><span class="s3">, </span><span class="s6">1</span><span class="s3">))</span>
                    <span class="s1">writer</span><span class="s3">.</span><span class="s1">simpletag</span><span class="s3">(</span><span class="s5">&quot;pt&quot;</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">)</span>
                    <span class="s1">writer</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>
                <span class="s1">last </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">endPtsOfContours</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + </span><span class="s6">1</span>
                <span class="s1">writer</span><span class="s3">.</span><span class="s1">endtag</span><span class="s3">(</span><span class="s5">&quot;contour&quot;</span><span class="s3">)</span>
                <span class="s1">writer</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>
            <span class="s1">haveInstructions </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">&gt; </span><span class="s6">0</span>
        <span class="s2">if </span><span class="s1">haveInstructions</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">program</span><span class="s3">:</span>
                <span class="s1">writer</span><span class="s3">.</span><span class="s1">begintag</span><span class="s3">(</span><span class="s5">&quot;instructions&quot;</span><span class="s3">)</span>
                <span class="s1">writer</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">program</span><span class="s3">.</span><span class="s1">toXML</span><span class="s3">(</span><span class="s1">writer</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">)</span>
                <span class="s1">writer</span><span class="s3">.</span><span class="s1">endtag</span><span class="s3">(</span><span class="s5">&quot;instructions&quot;</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">writer</span><span class="s3">.</span><span class="s1">simpletag</span><span class="s3">(</span><span class="s5">&quot;instructions&quot;</span><span class="s3">)</span>
            <span class="s1">writer</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">fromXML</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">content</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s3">== </span><span class="s5">&quot;contour&quot;</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">&lt; </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ttLib</span><span class="s3">.</span><span class="s1">TTLibError</span><span class="s3">(</span><span class="s5">&quot;can't mix composites and contours in glyph&quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">+ </span><span class="s6">1</span>
            <span class="s1">coordinates </span><span class="s3">= </span><span class="s1">GlyphCoordinates</span><span class="s3">()</span>
            <span class="s1">flags </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">()</span>
            <span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">content</span><span class="s3">:</span>
                <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">element</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
                    <span class="s2">continue</span>
                <span class="s1">name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">content </span><span class="s3">= </span><span class="s1">element</span>
                <span class="s2">if </span><span class="s1">name </span><span class="s3">!= </span><span class="s5">&quot;pt&quot;</span><span class="s3">:</span>
                    <span class="s2">continue  </span><span class="s4"># ignore anything but &quot;pt&quot;</span>
                <span class="s1">coordinates</span><span class="s3">.</span><span class="s1">append</span><span class="s3">((</span><span class="s1">safeEval</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;x&quot;</span><span class="s3">]), </span><span class="s1">safeEval</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;y&quot;</span><span class="s3">])))</span>
                <span class="s1">flag </span><span class="s3">= </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">safeEval</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;on&quot;</span><span class="s3">]))</span>
                <span class="s2">if </span><span class="s5">&quot;overlap&quot; </span><span class="s2">in </span><span class="s1">attrs </span><span class="s2">and </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">safeEval</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;overlap&quot;</span><span class="s3">])):</span>
                    <span class="s1">flag </span><span class="s3">|= </span><span class="s1">flagOverlapSimple</span>
                <span class="s2">if </span><span class="s5">&quot;cubic&quot; </span><span class="s2">in </span><span class="s1">attrs </span><span class="s2">and </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">safeEval</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;cubic&quot;</span><span class="s3">])):</span>
                    <span class="s1">flag </span><span class="s3">|= </span><span class="s1">flagCubic</span>
                <span class="s1">flags</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">flag</span><span class="s3">)</span>
            <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;coordinates&quot;</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">coordinates </span><span class="s3">= </span><span class="s1">coordinates</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">= </span><span class="s1">flags</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">endPtsOfContours </span><span class="s3">= [</span><span class="s1">len</span><span class="s3">(</span><span class="s1">coordinates</span><span class="s3">) - </span><span class="s6">1</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">coordinates</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">coordinates</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">flags</span><span class="s3">)</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">endPtsOfContours</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">coordinates</span><span class="s3">) - </span><span class="s6">1</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">name </span><span class="s3">== </span><span class="s5">&quot;component&quot;</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ttLib</span><span class="s3">.</span><span class="s1">TTLibError</span><span class="s3">(</span><span class="s5">&quot;can't mix composites and contours in glyph&quot;</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">= -</span><span class="s6">1</span>
            <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;components&quot;</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">components </span><span class="s3">= []</span>
            <span class="s1">component </span><span class="s3">= </span><span class="s1">GlyphComponent</span><span class="s3">()</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">components</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">component</span><span class="s3">)</span>
            <span class="s1">component</span><span class="s3">.</span><span class="s1">fromXML</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">content</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">name </span><span class="s3">== </span><span class="s5">&quot;instructions&quot;</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">program </span><span class="s3">= </span><span class="s1">ttProgram</span><span class="s3">.</span><span class="s1">Program</span><span class="s3">()</span>
            <span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">content</span><span class="s3">:</span>
                <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">element</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
                    <span class="s2">continue</span>
                <span class="s1">name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">content </span><span class="s3">= </span><span class="s1">element</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">program</span><span class="s3">.</span><span class="s1">fromXML</span><span class="s3">(</span><span class="s1">name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">content</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">getCompositeMaxpValues</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyfTable</span><span class="s3">, </span><span class="s1">maxComponentDepth</span><span class="s3">=</span><span class="s6">1</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">isComposite</span><span class="s3">()</span>
        <span class="s1">nContours </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">nPoints </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">initialMaxComponentDepth </span><span class="s3">= </span><span class="s1">maxComponentDepth</span>
        <span class="s2">for </span><span class="s1">compo </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">components</span><span class="s3">:</span>
            <span class="s1">baseGlyph </span><span class="s3">= </span><span class="s1">glyfTable</span><span class="s3">[</span><span class="s1">compo</span><span class="s3">.</span><span class="s1">glyphName</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">baseGlyph</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s2">continue</span>
            <span class="s2">elif </span><span class="s1">baseGlyph</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s1">nP</span><span class="s3">, </span><span class="s1">nC </span><span class="s3">= </span><span class="s1">baseGlyph</span><span class="s3">.</span><span class="s1">getMaxpValues</span><span class="s3">()</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">nP</span><span class="s3">, </span><span class="s1">nC</span><span class="s3">, </span><span class="s1">componentDepth </span><span class="s3">= </span><span class="s1">baseGlyph</span><span class="s3">.</span><span class="s1">getCompositeMaxpValues</span><span class="s3">(</span>
                    <span class="s1">glyfTable</span><span class="s3">, </span><span class="s1">initialMaxComponentDepth </span><span class="s3">+ </span><span class="s6">1</span>
                <span class="s3">)</span>
                <span class="s1">maxComponentDepth </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">maxComponentDepth</span><span class="s3">, </span><span class="s1">componentDepth</span><span class="s3">)</span>
            <span class="s1">nPoints </span><span class="s3">= </span><span class="s1">nPoints </span><span class="s3">+ </span><span class="s1">nP</span>
            <span class="s1">nContours </span><span class="s3">= </span><span class="s1">nContours </span><span class="s3">+ </span><span class="s1">nC</span>
        <span class="s2">return </span><span class="s1">CompositeMaxpValues</span><span class="s3">(</span><span class="s1">nPoints</span><span class="s3">, </span><span class="s1">nContours</span><span class="s3">, </span><span class="s1">maxComponentDepth</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">getMaxpValues</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">self</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">&gt; </span><span class="s6">0</span>
        <span class="s2">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">coordinates</span><span class="s3">), </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">endPtsOfContours</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">decompileComponents</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">glyfTable</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">components </span><span class="s3">= []</span>
        <span class="s1">more </span><span class="s3">= </span><span class="s6">1</span>
        <span class="s1">haveInstructions </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s2">while </span><span class="s1">more</span><span class="s3">:</span>
            <span class="s1">component </span><span class="s3">= </span><span class="s1">GlyphComponent</span><span class="s3">()</span>
            <span class="s1">more</span><span class="s3">, </span><span class="s1">haveInstr</span><span class="s3">, </span><span class="s1">data </span><span class="s3">= </span><span class="s1">component</span><span class="s3">.</span><span class="s1">decompile</span><span class="s3">(</span><span class="s1">data</span><span class="s3">, </span><span class="s1">glyfTable</span><span class="s3">)</span>
            <span class="s1">haveInstructions </span><span class="s3">= </span><span class="s1">haveInstructions </span><span class="s3">| </span><span class="s1">haveInstr</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">components</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">component</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">haveInstructions</span><span class="s3">:</span>
            <span class="s3">(</span><span class="s1">numInstructions</span><span class="s3">,) = </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack</span><span class="s3">(</span><span class="s5">&quot;&gt;h&quot;</span><span class="s3">, </span><span class="s1">data</span><span class="s3">[:</span><span class="s6">2</span><span class="s3">])</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s6">2</span><span class="s3">:]</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">program </span><span class="s3">= </span><span class="s1">ttProgram</span><span class="s3">.</span><span class="s1">Program</span><span class="s3">()</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">program</span><span class="s3">.</span><span class="s1">fromBytecode</span><span class="s3">(</span><span class="s1">data</span><span class="s3">[:</span><span class="s1">numInstructions</span><span class="s3">])</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s1">numInstructions</span><span class="s3">:]</span>
            <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">data</span><span class="s3">) &gt;= </span><span class="s6">4</span><span class="s3">:</span>
                <span class="s1">log</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span>
                    <span class="s5">&quot;too much glyph data at the end of composite glyph: %d excess bytes&quot;</span><span class="s3">,</span>
                    <span class="s1">len</span><span class="s3">(</span><span class="s1">data</span><span class="s3">),</span>
                <span class="s3">)</span>

    <span class="s2">def </span><span class="s1">decompileCoordinates</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
        <span class="s1">endPtsOfContours </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s5">&quot;H&quot;</span><span class="s3">)</span>
        <span class="s1">endPtsOfContours</span><span class="s3">.</span><span class="s1">frombytes</span><span class="s3">(</span><span class="s1">data</span><span class="s3">[: </span><span class="s6">2 </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">numberOfContours</span><span class="s3">])</span>
        <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">byteorder </span><span class="s3">!= </span><span class="s5">&quot;big&quot;</span><span class="s3">:</span>
            <span class="s1">endPtsOfContours</span><span class="s3">.</span><span class="s1">byteswap</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">endPtsOfContours </span><span class="s3">= </span><span class="s1">endPtsOfContours</span><span class="s3">.</span><span class="s1">tolist</span><span class="s3">()</span>

        <span class="s1">pos </span><span class="s3">= </span><span class="s6">2 </span><span class="s3">* </span><span class="s1">self</span><span class="s3">.</span><span class="s1">numberOfContours</span>
        <span class="s3">(</span><span class="s1">instructionLength</span><span class="s3">,) = </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack</span><span class="s3">(</span><span class="s5">&quot;&gt;h&quot;</span><span class="s3">, </span><span class="s1">data</span><span class="s3">[</span><span class="s1">pos </span><span class="s3">: </span><span class="s1">pos </span><span class="s3">+ </span><span class="s6">2</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">program </span><span class="s3">= </span><span class="s1">ttProgram</span><span class="s3">.</span><span class="s1">Program</span><span class="s3">()</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">program</span><span class="s3">.</span><span class="s1">fromBytecode</span><span class="s3">(</span><span class="s1">data</span><span class="s3">[</span><span class="s1">pos </span><span class="s3">+ </span><span class="s6">2 </span><span class="s3">: </span><span class="s1">pos </span><span class="s3">+ </span><span class="s6">2 </span><span class="s3">+ </span><span class="s1">instructionLength</span><span class="s3">])</span>
        <span class="s1">pos </span><span class="s3">+= </span><span class="s6">2 </span><span class="s3">+ </span><span class="s1">instructionLength</span>
        <span class="s1">nCoordinates </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">endPtsOfContours</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">] + </span><span class="s6">1</span>
        <span class="s1">flags</span><span class="s3">, </span><span class="s1">xCoordinates</span><span class="s3">, </span><span class="s1">yCoordinates </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">decompileCoordinatesRaw</span><span class="s3">(</span>
            <span class="s1">nCoordinates</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">pos</span>
        <span class="s3">)</span>

        <span class="s4"># fill in repetitions and apply signs</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">coordinates </span><span class="s3">= </span><span class="s1">coordinates </span><span class="s3">= </span><span class="s1">GlyphCoordinates</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">nCoordinates</span><span class="s3">)</span>
        <span class="s1">xIndex </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">yIndex </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">nCoordinates</span><span class="s3">):</span>
            <span class="s1">flag </span><span class="s3">= </span><span class="s1">flags</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s4"># x coordinate</span>
            <span class="s2">if </span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">flagXShort</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">flagXsame</span><span class="s3">:</span>
                    <span class="s1">x </span><span class="s3">= </span><span class="s1">xCoordinates</span><span class="s3">[</span><span class="s1">xIndex</span><span class="s3">]</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">x </span><span class="s3">= -</span><span class="s1">xCoordinates</span><span class="s3">[</span><span class="s1">xIndex</span><span class="s3">]</span>
                <span class="s1">xIndex </span><span class="s3">= </span><span class="s1">xIndex </span><span class="s3">+ </span><span class="s6">1</span>
            <span class="s2">elif </span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">flagXsame</span><span class="s3">:</span>
                <span class="s1">x </span><span class="s3">= </span><span class="s6">0</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">x </span><span class="s3">= </span><span class="s1">xCoordinates</span><span class="s3">[</span><span class="s1">xIndex</span><span class="s3">]</span>
                <span class="s1">xIndex </span><span class="s3">= </span><span class="s1">xIndex </span><span class="s3">+ </span><span class="s6">1</span>
            <span class="s4"># y coordinate</span>
            <span class="s2">if </span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">flagYShort</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">flagYsame</span><span class="s3">:</span>
                    <span class="s1">y </span><span class="s3">= </span><span class="s1">yCoordinates</span><span class="s3">[</span><span class="s1">yIndex</span><span class="s3">]</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">y </span><span class="s3">= -</span><span class="s1">yCoordinates</span><span class="s3">[</span><span class="s1">yIndex</span><span class="s3">]</span>
                <span class="s1">yIndex </span><span class="s3">= </span><span class="s1">yIndex </span><span class="s3">+ </span><span class="s6">1</span>
            <span class="s2">elif </span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">flagYsame</span><span class="s3">:</span>
                <span class="s1">y </span><span class="s3">= </span><span class="s6">0</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">y </span><span class="s3">= </span><span class="s1">yCoordinates</span><span class="s3">[</span><span class="s1">yIndex</span><span class="s3">]</span>
                <span class="s1">yIndex </span><span class="s3">= </span><span class="s1">yIndex </span><span class="s3">+ </span><span class="s6">1</span>
            <span class="s1">coordinates</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = (</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">xIndex </span><span class="s3">== </span><span class="s1">len</span><span class="s3">(</span><span class="s1">xCoordinates</span><span class="s3">)</span>
        <span class="s2">assert </span><span class="s1">yIndex </span><span class="s3">== </span><span class="s1">len</span><span class="s3">(</span><span class="s1">yCoordinates</span><span class="s3">)</span>
        <span class="s1">coordinates</span><span class="s3">.</span><span class="s1">relativeToAbsolute</span><span class="s3">()</span>
        <span class="s4"># discard all flags except &quot;keepFlags&quot;</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">flags</span><span class="s3">)):</span>
            <span class="s1">flags</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &amp;= </span><span class="s1">keepFlags</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">= </span><span class="s1">flags</span>

    <span class="s2">def </span><span class="s1">decompileCoordinatesRaw</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">nCoordinates</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">=</span><span class="s6">0</span><span class="s3">):</span>
        <span class="s4"># unpack flags and prepare unpacking of coordinates</span>
        <span class="s1">flags </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">(</span><span class="s1">nCoordinates</span><span class="s3">)</span>
        <span class="s4"># Warning: deep Python trickery going on. We use the struct module to unpack</span>
        <span class="s4"># the coordinates. We build a format string based on the flags, so we can</span>
        <span class="s4"># unpack the coordinates in one struct.unpack() call.</span>
        <span class="s1">xFormat </span><span class="s3">= </span><span class="s5">&quot;&gt;&quot;  </span><span class="s4"># big endian</span>
        <span class="s1">yFormat </span><span class="s3">= </span><span class="s5">&quot;&gt;&quot;  </span><span class="s4"># big endian</span>
        <span class="s1">j </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s2">while True</span><span class="s3">:</span>
            <span class="s1">flag </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s1">pos</span><span class="s3">]</span>
            <span class="s1">pos </span><span class="s3">+= </span><span class="s6">1</span>
            <span class="s1">repeat </span><span class="s3">= </span><span class="s6">1</span>
            <span class="s2">if </span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">flagRepeat</span><span class="s3">:</span>
                <span class="s1">repeat </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s1">pos</span><span class="s3">] + </span><span class="s6">1</span>
                <span class="s1">pos </span><span class="s3">+= </span><span class="s6">1</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">repeat</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">flagXShort</span><span class="s3">:</span>
                    <span class="s1">xFormat </span><span class="s3">= </span><span class="s1">xFormat </span><span class="s3">+ </span><span class="s5">&quot;B&quot;</span>
                <span class="s2">elif not </span><span class="s3">(</span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">flagXsame</span><span class="s3">):</span>
                    <span class="s1">xFormat </span><span class="s3">= </span><span class="s1">xFormat </span><span class="s3">+ </span><span class="s5">&quot;h&quot;</span>
                <span class="s2">if </span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">flagYShort</span><span class="s3">:</span>
                    <span class="s1">yFormat </span><span class="s3">= </span><span class="s1">yFormat </span><span class="s3">+ </span><span class="s5">&quot;B&quot;</span>
                <span class="s2">elif not </span><span class="s3">(</span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">flagYsame</span><span class="s3">):</span>
                    <span class="s1">yFormat </span><span class="s3">= </span><span class="s1">yFormat </span><span class="s3">+ </span><span class="s5">&quot;h&quot;</span>
                <span class="s1">flags</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] = </span><span class="s1">flag</span>
                <span class="s1">j </span><span class="s3">= </span><span class="s1">j </span><span class="s3">+ </span><span class="s6">1</span>
            <span class="s2">if </span><span class="s1">j </span><span class="s3">&gt;= </span><span class="s1">nCoordinates</span><span class="s3">:</span>
                <span class="s2">break</span>
        <span class="s2">assert </span><span class="s1">j </span><span class="s3">== </span><span class="s1">nCoordinates</span><span class="s3">, </span><span class="s5">&quot;bad glyph flags&quot;</span>
        <span class="s4"># unpack raw coordinates, krrrrrr-tching!</span>
        <span class="s1">xDataLen </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">calcsize</span><span class="s3">(</span><span class="s1">xFormat</span><span class="s3">)</span>
        <span class="s1">yDataLen </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">calcsize</span><span class="s3">(</span><span class="s1">yFormat</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">data</span><span class="s3">) - </span><span class="s1">pos </span><span class="s3">- (</span><span class="s1">xDataLen </span><span class="s3">+ </span><span class="s1">yDataLen</span><span class="s3">) &gt;= </span><span class="s6">4</span><span class="s3">:</span>
            <span class="s1">log</span><span class="s3">.</span><span class="s1">warning</span><span class="s3">(</span>
                <span class="s5">&quot;too much glyph data: %d excess bytes&quot;</span><span class="s3">,</span>
                <span class="s1">len</span><span class="s3">(</span><span class="s1">data</span><span class="s3">) - </span><span class="s1">pos </span><span class="s3">- (</span><span class="s1">xDataLen </span><span class="s3">+ </span><span class="s1">yDataLen</span><span class="s3">),</span>
            <span class="s3">)</span>
        <span class="s1">xCoordinates </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack</span><span class="s3">(</span><span class="s1">xFormat</span><span class="s3">, </span><span class="s1">data</span><span class="s3">[</span><span class="s1">pos </span><span class="s3">: </span><span class="s1">pos </span><span class="s3">+ </span><span class="s1">xDataLen</span><span class="s3">])</span>
        <span class="s1">yCoordinates </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack</span><span class="s3">(</span>
            <span class="s1">yFormat</span><span class="s3">, </span><span class="s1">data</span><span class="s3">[</span><span class="s1">pos </span><span class="s3">+ </span><span class="s1">xDataLen </span><span class="s3">: </span><span class="s1">pos </span><span class="s3">+ </span><span class="s1">xDataLen </span><span class="s3">+ </span><span class="s1">yDataLen</span><span class="s3">]</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">flags</span><span class="s3">, </span><span class="s1">xCoordinates</span><span class="s3">, </span><span class="s1">yCoordinates</span>

    <span class="s2">def </span><span class="s1">compileComponents</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyfTable</span><span class="s3">):</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s7">b&quot;&quot;</span>
        <span class="s1">lastcomponent </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">components</span><span class="s3">) - </span><span class="s6">1</span>
        <span class="s1">more </span><span class="s3">= </span><span class="s6">1</span>
        <span class="s1">haveInstructions </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">components</span><span class="s3">)):</span>
            <span class="s2">if </span><span class="s1">i </span><span class="s3">== </span><span class="s1">lastcomponent</span><span class="s3">:</span>
                <span class="s1">haveInstructions </span><span class="s3">= </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;program&quot;</span><span class="s3">)</span>
                <span class="s1">more </span><span class="s3">= </span><span class="s6">0</span>
            <span class="s1">compo </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">components</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">data </span><span class="s3">+ </span><span class="s1">compo</span><span class="s3">.</span><span class="s1">compile</span><span class="s3">(</span><span class="s1">more</span><span class="s3">, </span><span class="s1">haveInstructions</span><span class="s3">, </span><span class="s1">glyfTable</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">haveInstructions</span><span class="s3">:</span>
            <span class="s1">instructions </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">program</span><span class="s3">.</span><span class="s1">getBytecode</span><span class="s3">()</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">data </span><span class="s3">+ </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s5">&quot;&gt;h&quot;</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">instructions</span><span class="s3">)) + </span><span class="s1">instructions</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">compileCoordinates</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">coordinates</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">)</span>
        <span class="s1">data </span><span class="s3">= []</span>
        <span class="s1">endPtsOfContours </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s5">&quot;H&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">endPtsOfContours</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">sys</span><span class="s3">.</span><span class="s1">byteorder </span><span class="s3">!= </span><span class="s5">&quot;big&quot;</span><span class="s3">:</span>
            <span class="s1">endPtsOfContours</span><span class="s3">.</span><span class="s1">byteswap</span><span class="s3">()</span>
        <span class="s1">data</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">endPtsOfContours</span><span class="s3">.</span><span class="s1">tobytes</span><span class="s3">())</span>
        <span class="s1">instructions </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">program</span><span class="s3">.</span><span class="s1">getBytecode</span><span class="s3">()</span>
        <span class="s1">data</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s5">&quot;&gt;h&quot;</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">instructions</span><span class="s3">)))</span>
        <span class="s1">data</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">instructions</span><span class="s3">)</span>

        <span class="s1">deltas </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">coordinates</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">deltas</span><span class="s3">.</span><span class="s1">toInt</span><span class="s3">()</span>
        <span class="s1">deltas</span><span class="s3">.</span><span class="s1">absoluteToRelative</span><span class="s3">()</span>

        <span class="s4"># TODO(behdad): Add a configuration option for this?</span>
        <span class="s1">deltas </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">compileDeltasGreedy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">, </span><span class="s1">deltas</span><span class="s3">)</span>
        <span class="s4"># deltas = self.compileDeltasOptimal(self.flags, deltas)</span>

        <span class="s1">data</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">deltas</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s7">b&quot;&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">compileDeltasGreedy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">, </span><span class="s1">deltas</span><span class="s3">):</span>
        <span class="s4"># Implements greedy algorithm for packing coordinate deltas:</span>
        <span class="s4"># uses shortest representation one coordinate at a time.</span>
        <span class="s1">compressedFlags </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">()</span>
        <span class="s1">compressedXs </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">()</span>
        <span class="s1">compressedYs </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">()</span>
        <span class="s1">lastflag </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">repeat </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s2">for </span><span class="s1">flag</span><span class="s3">, (</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">flags</span><span class="s3">, </span><span class="s1">deltas</span><span class="s3">):</span>
            <span class="s4"># Oh, the horrors of TrueType</span>
            <span class="s4"># do x</span>
            <span class="s2">if </span><span class="s1">x </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s1">flag </span><span class="s3">= </span><span class="s1">flag </span><span class="s3">| </span><span class="s1">flagXsame</span>
            <span class="s2">elif </span><span class="s3">-</span><span class="s6">255 </span><span class="s3">&lt;= </span><span class="s1">x </span><span class="s3">&lt;= </span><span class="s6">255</span><span class="s3">:</span>
                <span class="s1">flag </span><span class="s3">= </span><span class="s1">flag </span><span class="s3">| </span><span class="s1">flagXShort</span>
                <span class="s2">if </span><span class="s1">x </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
                    <span class="s1">flag </span><span class="s3">= </span><span class="s1">flag </span><span class="s3">| </span><span class="s1">flagXsame</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">x </span><span class="s3">= -</span><span class="s1">x</span>
                <span class="s1">compressedXs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">compressedXs</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s5">&quot;&gt;h&quot;</span><span class="s3">, </span><span class="s1">x</span><span class="s3">))</span>
            <span class="s4"># do y</span>
            <span class="s2">if </span><span class="s1">y </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s1">flag </span><span class="s3">= </span><span class="s1">flag </span><span class="s3">| </span><span class="s1">flagYsame</span>
            <span class="s2">elif </span><span class="s3">-</span><span class="s6">255 </span><span class="s3">&lt;= </span><span class="s1">y </span><span class="s3">&lt;= </span><span class="s6">255</span><span class="s3">:</span>
                <span class="s1">flag </span><span class="s3">= </span><span class="s1">flag </span><span class="s3">| </span><span class="s1">flagYShort</span>
                <span class="s2">if </span><span class="s1">y </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
                    <span class="s1">flag </span><span class="s3">= </span><span class="s1">flag </span><span class="s3">| </span><span class="s1">flagYsame</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">y </span><span class="s3">= -</span><span class="s1">y</span>
                <span class="s1">compressedYs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">compressedYs</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s5">&quot;&gt;h&quot;</span><span class="s3">, </span><span class="s1">y</span><span class="s3">))</span>
            <span class="s4"># handle repeating flags</span>
            <span class="s2">if </span><span class="s1">flag </span><span class="s3">== </span><span class="s1">lastflag </span><span class="s2">and </span><span class="s1">repeat </span><span class="s3">!= </span><span class="s6">255</span><span class="s3">:</span>
                <span class="s1">repeat </span><span class="s3">= </span><span class="s1">repeat </span><span class="s3">+ </span><span class="s6">1</span>
                <span class="s2">if </span><span class="s1">repeat </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
                    <span class="s1">compressedFlags</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">flag</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">compressedFlags</span><span class="s3">[-</span><span class="s6">2</span><span class="s3">] = </span><span class="s1">flag </span><span class="s3">| </span><span class="s1">flagRepeat</span>
                    <span class="s1">compressedFlags</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">] = </span><span class="s1">repeat</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">repeat </span><span class="s3">= </span><span class="s6">0</span>
                <span class="s1">compressedFlags</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">flag</span><span class="s3">)</span>
            <span class="s1">lastflag </span><span class="s3">= </span><span class="s1">flag</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">compressedFlags</span><span class="s3">, </span><span class="s1">compressedXs</span><span class="s3">, </span><span class="s1">compressedYs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">compileDeltasOptimal</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">, </span><span class="s1">deltas</span><span class="s3">):</span>
        <span class="s4"># Implements optimal, dynaic-programming, algorithm for packing coordinate</span>
        <span class="s4"># deltas.  The savings are negligible :(.</span>
        <span class="s1">candidates </span><span class="s3">= []</span>
        <span class="s1">bestTuple </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s1">bestCost </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">repeat </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s2">for </span><span class="s1">flag</span><span class="s3">, (</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">) </span><span class="s2">in </span><span class="s1">zip</span><span class="s3">(</span><span class="s1">flags</span><span class="s3">, </span><span class="s1">deltas</span><span class="s3">):</span>
            <span class="s4"># Oh, the horrors of TrueType</span>
            <span class="s1">flag</span><span class="s3">, </span><span class="s1">coordBytes </span><span class="s3">= </span><span class="s1">flagBest</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">flag</span><span class="s3">)</span>
            <span class="s1">bestCost </span><span class="s3">+= </span><span class="s6">1 </span><span class="s3">+ </span><span class="s1">coordBytes</span>
            <span class="s1">newCandidates </span><span class="s3">= [</span>
                <span class="s3">(</span><span class="s1">bestCost</span><span class="s3">, </span><span class="s1">bestTuple</span><span class="s3">, </span><span class="s1">flag</span><span class="s3">, </span><span class="s1">coordBytes</span><span class="s3">),</span>
                <span class="s3">(</span><span class="s1">bestCost </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">, </span><span class="s1">bestTuple</span><span class="s3">, (</span><span class="s1">flag </span><span class="s3">| </span><span class="s1">flagRepeat</span><span class="s3">), </span><span class="s1">coordBytes</span><span class="s3">),</span>
            <span class="s3">]</span>
            <span class="s2">for </span><span class="s1">lastCost</span><span class="s3">, </span><span class="s1">lastTuple</span><span class="s3">, </span><span class="s1">lastFlag</span><span class="s3">, </span><span class="s1">coordBytes </span><span class="s2">in </span><span class="s1">candidates</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s3">(</span>
                    <span class="s1">lastCost </span><span class="s3">+ </span><span class="s1">coordBytes </span><span class="s3">&lt;= </span><span class="s1">bestCost </span><span class="s3">+ </span><span class="s6">1</span>
                    <span class="s2">and </span><span class="s3">(</span><span class="s1">lastFlag </span><span class="s3">&amp; </span><span class="s1">flagRepeat</span><span class="s3">)</span>
                    <span class="s2">and </span><span class="s3">(</span><span class="s1">lastFlag </span><span class="s3">&lt; </span><span class="s6">0xFF00</span><span class="s3">)</span>
                    <span class="s2">and </span><span class="s1">flagSupports</span><span class="s3">(</span><span class="s1">lastFlag</span><span class="s3">, </span><span class="s1">flag</span><span class="s3">)</span>
                <span class="s3">):</span>
                    <span class="s2">if </span><span class="s3">(</span><span class="s1">lastFlag </span><span class="s3">&amp; </span><span class="s6">0xFF</span><span class="s3">) == (</span>
                        <span class="s1">flag </span><span class="s3">| </span><span class="s1">flagRepeat</span>
                    <span class="s3">) </span><span class="s2">and </span><span class="s1">lastCost </span><span class="s3">== </span><span class="s1">bestCost </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">:</span>
                        <span class="s2">continue</span>
                    <span class="s1">newCandidates</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                        <span class="s3">(</span><span class="s1">lastCost </span><span class="s3">+ </span><span class="s1">coordBytes</span><span class="s3">, </span><span class="s1">lastTuple</span><span class="s3">, </span><span class="s1">lastFlag </span><span class="s3">+ </span><span class="s6">256</span><span class="s3">, </span><span class="s1">coordBytes</span><span class="s3">)</span>
                    <span class="s3">)</span>
            <span class="s1">candidates </span><span class="s3">= </span><span class="s1">newCandidates</span>
            <span class="s1">bestTuple </span><span class="s3">= </span><span class="s1">min</span><span class="s3">(</span><span class="s1">candidates</span><span class="s3">, </span><span class="s1">key</span><span class="s3">=</span><span class="s2">lambda </span><span class="s1">t</span><span class="s3">: </span><span class="s1">t</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>
            <span class="s1">bestCost </span><span class="s3">= </span><span class="s1">bestTuple</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>

        <span class="s1">flags </span><span class="s3">= []</span>
        <span class="s2">while </span><span class="s1">bestTuple</span><span class="s3">:</span>
            <span class="s1">cost</span><span class="s3">, </span><span class="s1">bestTuple</span><span class="s3">, </span><span class="s1">flag</span><span class="s3">, </span><span class="s1">coordBytes </span><span class="s3">= </span><span class="s1">bestTuple</span>
            <span class="s1">flags</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">flag</span><span class="s3">)</span>
        <span class="s1">flags</span><span class="s3">.</span><span class="s1">reverse</span><span class="s3">()</span>

        <span class="s1">compressedFlags </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">()</span>
        <span class="s1">compressedXs </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">()</span>
        <span class="s1">compressedYs </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">()</span>
        <span class="s1">coords </span><span class="s3">= </span><span class="s1">iter</span><span class="s3">(</span><span class="s1">deltas</span><span class="s3">)</span>
        <span class="s1">ff </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">flag </span><span class="s2">in </span><span class="s1">flags</span><span class="s3">:</span>
            <span class="s1">repeatCount</span><span class="s3">, </span><span class="s1">flag </span><span class="s3">= </span><span class="s1">flag </span><span class="s3">&gt;&gt; </span><span class="s6">8</span><span class="s3">, </span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s6">0xFF</span>
            <span class="s1">compressedFlags</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">flag</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">flagRepeat</span><span class="s3">:</span>
                <span class="s2">assert </span><span class="s1">repeatCount </span><span class="s3">&gt; </span><span class="s6">0</span>
                <span class="s1">compressedFlags</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">repeatCount</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">assert </span><span class="s1">repeatCount </span><span class="s3">== </span><span class="s6">0</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s6">1 </span><span class="s3">+ </span><span class="s1">repeatCount</span><span class="s3">):</span>
                <span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">next</span><span class="s3">(</span><span class="s1">coords</span><span class="s3">)</span>
                <span class="s1">flagEncodeCoords</span><span class="s3">(</span><span class="s1">flag</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">compressedXs</span><span class="s3">, </span><span class="s1">compressedYs</span><span class="s3">)</span>
                <span class="s1">ff</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">flag</span><span class="s3">)</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">next</span><span class="s3">(</span><span class="s1">coords</span><span class="s3">)</span>
            <span class="s2">raise </span><span class="s1">Exception</span><span class="s3">(</span><span class="s5">&quot;internal error&quot;</span><span class="s3">)</span>
        <span class="s2">except </span><span class="s1">StopIteration</span><span class="s3">:</span>
            <span class="s2">pass</span>

        <span class="s2">return </span><span class="s3">(</span><span class="s1">compressedFlags</span><span class="s3">, </span><span class="s1">compressedXs</span><span class="s3">, </span><span class="s1">compressedYs</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">recalcBounds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyfTable</span><span class="s3">, *, </span><span class="s1">boundsDone</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Recalculates the bounds of the glyph. 
 
        Each glyph object stores its bounding box in the 
        ``xMin``/``yMin``/``xMax``/``yMax`` attributes. These bounds must be 
        recomputed when the ``coordinates`` change. The ``table__g_l_y_f`` bounds 
        must be provided to resolve component bounds. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">isComposite</span><span class="s3">() </span><span class="s2">and </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tryRecalcBoundsComposite</span><span class="s3">(</span>
            <span class="s1">glyfTable</span><span class="s3">, </span><span class="s1">boundsDone</span><span class="s3">=</span><span class="s1">boundsDone</span>
        <span class="s3">):</span>
            <span class="s2">return</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s1">coords</span><span class="s3">, </span><span class="s1">endPts</span><span class="s3">, </span><span class="s1">flags </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getCoordinates</span><span class="s3">(</span><span class="s1">glyfTable</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">xMin</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">yMin</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">xMax</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">yMax </span><span class="s3">= </span><span class="s1">coords</span><span class="s3">.</span><span class="s1">calcIntBounds</span><span class="s3">()</span>
        <span class="s2">except </span><span class="s1">NotImplementedError</span><span class="s3">:</span>
            <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">tryRecalcBoundsComposite</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyfTable</span><span class="s3">, *, </span><span class="s1">boundsDone</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Try recalculating the bounds of a composite glyph that has 
        certain constrained properties. Namely, none of the components 
        have a transform other than an integer translate, and none 
        uses the anchor points. 
 
        Each glyph object stores its bounding box in the 
        ``xMin``/``yMin``/``xMax``/``yMax`` attributes. These bounds must be 
        recomputed when the ``coordinates`` change. The ``table__g_l_y_f`` bounds 
        must be provided to resolve component bounds. 
 
        Return True if bounds were calculated, False otherwise. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">compo </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">components</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">compo</span><span class="s3">, </span><span class="s5">&quot;firstPt&quot;</span><span class="s3">) </span><span class="s2">or </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">compo</span><span class="s3">, </span><span class="s5">&quot;transform&quot;</span><span class="s3">):</span>
                <span class="s2">return False</span>
            <span class="s2">if not </span><span class="s1">float</span><span class="s3">(</span><span class="s1">compo</span><span class="s3">.</span><span class="s1">x</span><span class="s3">).</span><span class="s1">is_integer</span><span class="s3">() </span><span class="s2">or not </span><span class="s1">float</span><span class="s3">(</span><span class="s1">compo</span><span class="s3">.</span><span class="s1">y</span><span class="s3">).</span><span class="s1">is_integer</span><span class="s3">():</span>
                <span class="s2">return False</span>

        <span class="s4"># All components are untransformed and have an integer x/y translate</span>
        <span class="s1">bounds </span><span class="s3">= </span><span class="s2">None</span>
        <span class="s2">for </span><span class="s1">compo </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">components</span><span class="s3">:</span>
            <span class="s1">glyphName </span><span class="s3">= </span><span class="s1">compo</span><span class="s3">.</span><span class="s1">glyphName</span>
            <span class="s1">g </span><span class="s3">= </span><span class="s1">glyfTable</span><span class="s3">[</span><span class="s1">glyphName</span><span class="s3">]</span>

            <span class="s2">if </span><span class="s1">boundsDone </span><span class="s2">is None or </span><span class="s1">glyphName </span><span class="s2">not in </span><span class="s1">boundsDone</span><span class="s3">:</span>
                <span class="s1">g</span><span class="s3">.</span><span class="s1">recalcBounds</span><span class="s3">(</span><span class="s1">glyfTable</span><span class="s3">, </span><span class="s1">boundsDone</span><span class="s3">=</span><span class="s1">boundsDone</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">boundsDone </span><span class="s2">is not None</span><span class="s3">:</span>
                    <span class="s1">boundsDone</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">)</span>
            <span class="s4"># empty components shouldn't update the bounds of the parent glyph</span>
            <span class="s2">if </span><span class="s1">g</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s2">continue</span>

            <span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">compo</span><span class="s3">.</span><span class="s1">x</span><span class="s3">, </span><span class="s1">compo</span><span class="s3">.</span><span class="s1">y</span>
            <span class="s1">bounds </span><span class="s3">= </span><span class="s1">updateBounds</span><span class="s3">(</span><span class="s1">bounds</span><span class="s3">, (</span><span class="s1">g</span><span class="s3">.</span><span class="s1">xMin </span><span class="s3">+ </span><span class="s1">x</span><span class="s3">, </span><span class="s1">g</span><span class="s3">.</span><span class="s1">yMin </span><span class="s3">+ </span><span class="s1">y</span><span class="s3">))</span>
            <span class="s1">bounds </span><span class="s3">= </span><span class="s1">updateBounds</span><span class="s3">(</span><span class="s1">bounds</span><span class="s3">, (</span><span class="s1">g</span><span class="s3">.</span><span class="s1">xMax </span><span class="s3">+ </span><span class="s1">x</span><span class="s3">, </span><span class="s1">g</span><span class="s3">.</span><span class="s1">yMax </span><span class="s3">+ </span><span class="s1">y</span><span class="s3">))</span>

        <span class="s2">if </span><span class="s1">bounds </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">bounds </span><span class="s3">= (</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">xMin</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">yMin</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">xMax</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">yMax </span><span class="s3">= </span><span class="s1">bounds</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">isComposite</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Test whether a glyph has components&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack</span><span class="s3">(</span><span class="s5">&quot;&gt;h&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[:</span><span class="s6">2</span><span class="s3">])[</span><span class="s6">0</span><span class="s3">] == -</span><span class="s6">1 </span><span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data </span><span class="s2">else False</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">== -</span><span class="s6">1</span>

    <span class="s2">def </span><span class="s1">getCoordinates</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyfTable</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Return the coordinates, end points and flags 
 
        This method returns three values: A :py:class:`GlyphCoordinates` object, 
        a list of the indexes of the final points of each contour (allowing you 
        to split up the coordinates list into contours) and a list of flags. 
 
        On simple glyphs, this method returns information from the glyph's own 
        contours; on composite glyphs, it &quot;flattens&quot; all components recursively 
        to return a list of coordinates representing all the components involved 
        in the glyph. 
 
        To interpret the flags for each point, see the &quot;Simple Glyph Flags&quot; 
        section of the `glyf table specification &lt;https://docs.microsoft.com/en-us/typography/opentype/spec/glyf#simple-glyph-description&gt;`. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">coordinates</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">endPtsOfContours</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags</span>
        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">isComposite</span><span class="s3">():</span>
            <span class="s4"># it's a composite</span>
            <span class="s1">allCoords </span><span class="s3">= </span><span class="s1">GlyphCoordinates</span><span class="s3">()</span>
            <span class="s1">allFlags </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">()</span>
            <span class="s1">allEndPts </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">compo </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">components</span><span class="s3">:</span>
                <span class="s1">g </span><span class="s3">= </span><span class="s1">glyfTable</span><span class="s3">[</span><span class="s1">compo</span><span class="s3">.</span><span class="s1">glyphName</span><span class="s3">]</span>
                <span class="s2">try</span><span class="s3">:</span>
                    <span class="s1">coordinates</span><span class="s3">, </span><span class="s1">endPts</span><span class="s3">, </span><span class="s1">flags </span><span class="s3">= </span><span class="s1">g</span><span class="s3">.</span><span class="s1">getCoordinates</span><span class="s3">(</span><span class="s1">glyfTable</span><span class="s3">)</span>
                <span class="s2">except </span><span class="s1">RecursionError</span><span class="s3">:</span>
                    <span class="s2">raise </span><span class="s1">ttLib</span><span class="s3">.</span><span class="s1">TTLibError</span><span class="s3">(</span>
                        <span class="s5">&quot;glyph '%s' contains a recursive component reference&quot;</span>
                        <span class="s3">% </span><span class="s1">compo</span><span class="s3">.</span><span class="s1">glyphName</span>
                    <span class="s3">)</span>
                <span class="s1">coordinates </span><span class="s3">= </span><span class="s1">GlyphCoordinates</span><span class="s3">(</span><span class="s1">coordinates</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">compo</span><span class="s3">, </span><span class="s5">&quot;firstPt&quot;</span><span class="s3">):</span>
                    <span class="s4"># component uses two reference points: we apply the transform _before_</span>
                    <span class="s4"># computing the offset between the points</span>
                    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">compo</span><span class="s3">, </span><span class="s5">&quot;transform&quot;</span><span class="s3">):</span>
                        <span class="s1">coordinates</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">compo</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">)</span>
                    <span class="s1">x1</span><span class="s3">, </span><span class="s1">y1 </span><span class="s3">= </span><span class="s1">allCoords</span><span class="s3">[</span><span class="s1">compo</span><span class="s3">.</span><span class="s1">firstPt</span><span class="s3">]</span>
                    <span class="s1">x2</span><span class="s3">, </span><span class="s1">y2 </span><span class="s3">= </span><span class="s1">coordinates</span><span class="s3">[</span><span class="s1">compo</span><span class="s3">.</span><span class="s1">secondPt</span><span class="s3">]</span>
                    <span class="s1">move </span><span class="s3">= </span><span class="s1">x1 </span><span class="s3">- </span><span class="s1">x2</span><span class="s3">, </span><span class="s1">y1 </span><span class="s3">- </span><span class="s1">y2</span>
                    <span class="s1">coordinates</span><span class="s3">.</span><span class="s1">translate</span><span class="s3">(</span><span class="s1">move</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s4"># component uses XY offsets</span>
                    <span class="s1">move </span><span class="s3">= </span><span class="s1">compo</span><span class="s3">.</span><span class="s1">x</span><span class="s3">, </span><span class="s1">compo</span><span class="s3">.</span><span class="s1">y</span>
                    <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">compo</span><span class="s3">, </span><span class="s5">&quot;transform&quot;</span><span class="s3">):</span>
                        <span class="s1">coordinates</span><span class="s3">.</span><span class="s1">translate</span><span class="s3">(</span><span class="s1">move</span><span class="s3">)</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">apple_way </span><span class="s3">= </span><span class="s1">compo</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">SCALED_COMPONENT_OFFSET</span>
                        <span class="s1">ms_way </span><span class="s3">= </span><span class="s1">compo</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">UNSCALED_COMPONENT_OFFSET</span>
                        <span class="s2">assert not </span><span class="s3">(</span><span class="s1">apple_way </span><span class="s2">and </span><span class="s1">ms_way</span><span class="s3">)</span>
                        <span class="s2">if not </span><span class="s3">(</span><span class="s1">apple_way </span><span class="s2">or </span><span class="s1">ms_way</span><span class="s3">):</span>
                            <span class="s1">scale_component_offset </span><span class="s3">= (</span>
                                <span class="s1">SCALE_COMPONENT_OFFSET_DEFAULT  </span><span class="s4"># see top of this file</span>
                            <span class="s3">)</span>
                        <span class="s2">else</span><span class="s3">:</span>
                            <span class="s1">scale_component_offset </span><span class="s3">= </span><span class="s1">apple_way</span>
                        <span class="s2">if </span><span class="s1">scale_component_offset</span><span class="s3">:</span>
                            <span class="s4"># the Apple way: first move, then scale (ie. scale the component offset)</span>
                            <span class="s1">coordinates</span><span class="s3">.</span><span class="s1">translate</span><span class="s3">(</span><span class="s1">move</span><span class="s3">)</span>
                            <span class="s1">coordinates</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">compo</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">)</span>
                        <span class="s2">else</span><span class="s3">:</span>
                            <span class="s4"># the MS way: first scale, then move</span>
                            <span class="s1">coordinates</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">(</span><span class="s1">compo</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">)</span>
                            <span class="s1">coordinates</span><span class="s3">.</span><span class="s1">translate</span><span class="s3">(</span><span class="s1">move</span><span class="s3">)</span>
                <span class="s1">offset </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">allCoords</span><span class="s3">)</span>
                <span class="s1">allEndPts</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">e </span><span class="s3">+ </span><span class="s1">offset </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">endPts</span><span class="s3">)</span>
                <span class="s1">allCoords</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">coordinates</span><span class="s3">)</span>
                <span class="s1">allFlags</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">flags</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">allCoords</span><span class="s3">, </span><span class="s1">allEndPts</span><span class="s3">, </span><span class="s1">allFlags</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">GlyphCoordinates</span><span class="s3">(), [], </span><span class="s1">bytearray</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">getComponentNames</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">glyfTable</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Returns a list of names of component glyphs used in this glyph 
 
        This method can be used on simple glyphs (in which case it returns an 
        empty list) or composite glyphs. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">isComposite</span><span class="s3">():</span>
                <span class="s2">return </span><span class="s3">[</span><span class="s1">c</span><span class="s3">.</span><span class="s1">glyphName </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">components</span><span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s3">[]</span>

        <span class="s4"># Extract components without expanding glyph</span>

        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data </span><span class="s2">or </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack</span><span class="s3">(</span><span class="s5">&quot;&gt;h&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[:</span><span class="s6">2</span><span class="s3">])[</span><span class="s6">0</span><span class="s3">] &gt;= </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s3">[]  </span><span class="s4"># Not composite</span>

        <span class="s1">data </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s6">10</span>
        <span class="s1">components </span><span class="s3">= []</span>
        <span class="s1">more </span><span class="s3">= </span><span class="s6">1</span>
        <span class="s2">while </span><span class="s1">more</span><span class="s3">:</span>
            <span class="s1">flags</span><span class="s3">, </span><span class="s1">glyphID </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack</span><span class="s3">(</span><span class="s5">&quot;&gt;HH&quot;</span><span class="s3">, </span><span class="s1">data</span><span class="s3">[</span><span class="s1">i </span><span class="s3">: </span><span class="s1">i </span><span class="s3">+ </span><span class="s6">4</span><span class="s3">])</span>
            <span class="s1">i </span><span class="s3">+= </span><span class="s6">4</span>
            <span class="s1">flags </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">flags</span><span class="s3">)</span>
            <span class="s1">components</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">glyfTable</span><span class="s3">.</span><span class="s1">getGlyphName</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">glyphID</span><span class="s3">)))</span>

            <span class="s2">if </span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">ARG_1_AND_2_ARE_WORDS</span><span class="s3">:</span>
                <span class="s1">i </span><span class="s3">+= </span><span class="s6">4</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">i </span><span class="s3">+= </span><span class="s6">2</span>
            <span class="s2">if </span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">WE_HAVE_A_SCALE</span><span class="s3">:</span>
                <span class="s1">i </span><span class="s3">+= </span><span class="s6">2</span>
            <span class="s2">elif </span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">WE_HAVE_AN_X_AND_Y_SCALE</span><span class="s3">:</span>
                <span class="s1">i </span><span class="s3">+= </span><span class="s6">4</span>
            <span class="s2">elif </span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">WE_HAVE_A_TWO_BY_TWO</span><span class="s3">:</span>
                <span class="s1">i </span><span class="s3">+= </span><span class="s6">8</span>
            <span class="s1">more </span><span class="s3">= </span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">MORE_COMPONENTS</span>

        <span class="s2">return </span><span class="s1">components</span>

    <span class="s2">def </span><span class="s1">trim</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">remove_hinting</span><span class="s3">=</span><span class="s2">False</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Remove padding and, if requested, hinting, from a glyph. 
        This works on both expanded and compacted glyphs, without 
        expanding it.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;data&quot;</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">remove_hinting</span><span class="s3">:</span>
                <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">isComposite</span><span class="s3">():</span>
                    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;program&quot;</span><span class="s3">):</span>
                        <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">program</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">program </span><span class="s3">= </span><span class="s1">ttProgram</span><span class="s3">.</span><span class="s1">Program</span><span class="s3">()</span>
                    <span class="s1">self</span><span class="s3">.</span><span class="s1">program</span><span class="s3">.</span><span class="s1">fromBytecode</span><span class="s3">([])</span>
            <span class="s4"># No padding to trim.</span>
            <span class="s2">return</span>
        <span class="s2">if not </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s1">numContours </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack</span><span class="s3">(</span><span class="s5">&quot;&gt;h&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">[:</span><span class="s6">2</span><span class="s3">])[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">bytearray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">data</span><span class="s3">)</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s6">10</span>
        <span class="s2">if </span><span class="s1">numContours </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">i </span><span class="s3">+= </span><span class="s6">2 </span><span class="s3">* </span><span class="s1">numContours  </span><span class="s4"># endPtsOfContours</span>
            <span class="s1">nCoordinates </span><span class="s3">= ((</span><span class="s1">data</span><span class="s3">[</span><span class="s1">i </span><span class="s3">- </span><span class="s6">2</span><span class="s3">] &lt;&lt; </span><span class="s6">8</span><span class="s3">) | </span><span class="s1">data</span><span class="s3">[</span><span class="s1">i </span><span class="s3">- </span><span class="s6">1</span><span class="s3">]) + </span><span class="s6">1</span>
            <span class="s1">instructionLen </span><span class="s3">= (</span><span class="s1">data</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &lt;&lt; </span><span class="s6">8</span><span class="s3">) | </span><span class="s1">data</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">remove_hinting</span><span class="s3">:</span>
                <span class="s4"># Zero instruction length</span>
                <span class="s1">data</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">data</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">] = </span><span class="s6">0</span>
                <span class="s1">i </span><span class="s3">+= </span><span class="s6">2</span>
                <span class="s2">if </span><span class="s1">instructionLen</span><span class="s3">:</span>
                    <span class="s4"># Splice it out</span>
                    <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[:</span><span class="s1">i</span><span class="s3">] + </span><span class="s1">data</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s1">instructionLen </span><span class="s3">:]</span>
                <span class="s1">instructionLen </span><span class="s3">= </span><span class="s6">0</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">i </span><span class="s3">+= </span><span class="s6">2 </span><span class="s3">+ </span><span class="s1">instructionLen</span>

            <span class="s1">coordBytes </span><span class="s3">= </span><span class="s6">0</span>
            <span class="s1">j </span><span class="s3">= </span><span class="s6">0</span>
            <span class="s2">while True</span><span class="s3">:</span>
                <span class="s1">flag </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                <span class="s1">i </span><span class="s3">= </span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span>
                <span class="s1">repeat </span><span class="s3">= </span><span class="s6">1</span>
                <span class="s2">if </span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">flagRepeat</span><span class="s3">:</span>
                    <span class="s1">repeat </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + </span><span class="s6">1</span>
                    <span class="s1">i </span><span class="s3">= </span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span>
                <span class="s1">xBytes </span><span class="s3">= </span><span class="s1">yBytes </span><span class="s3">= </span><span class="s6">0</span>
                <span class="s2">if </span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">flagXShort</span><span class="s3">:</span>
                    <span class="s1">xBytes </span><span class="s3">= </span><span class="s6">1</span>
                <span class="s2">elif not </span><span class="s3">(</span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">flagXsame</span><span class="s3">):</span>
                    <span class="s1">xBytes </span><span class="s3">= </span><span class="s6">2</span>
                <span class="s2">if </span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">flagYShort</span><span class="s3">:</span>
                    <span class="s1">yBytes </span><span class="s3">= </span><span class="s6">1</span>
                <span class="s2">elif not </span><span class="s3">(</span><span class="s1">flag </span><span class="s3">&amp; </span><span class="s1">flagYsame</span><span class="s3">):</span>
                    <span class="s1">yBytes </span><span class="s3">= </span><span class="s6">2</span>
                <span class="s1">coordBytes </span><span class="s3">+= (</span><span class="s1">xBytes </span><span class="s3">+ </span><span class="s1">yBytes</span><span class="s3">) * </span><span class="s1">repeat</span>
                <span class="s1">j </span><span class="s3">+= </span><span class="s1">repeat</span>
                <span class="s2">if </span><span class="s1">j </span><span class="s3">&gt;= </span><span class="s1">nCoordinates</span><span class="s3">:</span>
                    <span class="s2">break</span>
            <span class="s2">assert </span><span class="s1">j </span><span class="s3">== </span><span class="s1">nCoordinates</span><span class="s3">, </span><span class="s5">&quot;bad glyph flags&quot;</span>
            <span class="s1">i </span><span class="s3">+= </span><span class="s1">coordBytes</span>
            <span class="s4"># Remove padding</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[:</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">isComposite</span><span class="s3">():</span>
            <span class="s1">more </span><span class="s3">= </span><span class="s6">1</span>
            <span class="s1">we_have_instructions </span><span class="s3">= </span><span class="s2">False</span>
            <span class="s2">while </span><span class="s1">more</span><span class="s3">:</span>
                <span class="s1">flags </span><span class="s3">= (</span><span class="s1">data</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &lt;&lt; </span><span class="s6">8</span><span class="s3">) | </span><span class="s1">data</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">]</span>
                <span class="s2">if </span><span class="s1">remove_hinting</span><span class="s3">:</span>
                    <span class="s1">flags </span><span class="s3">&amp;= ~</span><span class="s1">WE_HAVE_INSTRUCTIONS</span>
                <span class="s2">if </span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">WE_HAVE_INSTRUCTIONS</span><span class="s3">:</span>
                    <span class="s1">we_have_instructions </span><span class="s3">= </span><span class="s2">True</span>
                <span class="s1">data</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">0</span><span class="s3">] = </span><span class="s1">flags </span><span class="s3">&gt;&gt; </span><span class="s6">8</span>
                <span class="s1">data</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">] = </span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s6">0xFF</span>
                <span class="s1">i </span><span class="s3">+= </span><span class="s6">4</span>
                <span class="s1">flags </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">flags</span><span class="s3">)</span>

                <span class="s2">if </span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">ARG_1_AND_2_ARE_WORDS</span><span class="s3">:</span>
                    <span class="s1">i </span><span class="s3">+= </span><span class="s6">4</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">i </span><span class="s3">+= </span><span class="s6">2</span>
                <span class="s2">if </span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">WE_HAVE_A_SCALE</span><span class="s3">:</span>
                    <span class="s1">i </span><span class="s3">+= </span><span class="s6">2</span>
                <span class="s2">elif </span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">WE_HAVE_AN_X_AND_Y_SCALE</span><span class="s3">:</span>
                    <span class="s1">i </span><span class="s3">+= </span><span class="s6">4</span>
                <span class="s2">elif </span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">WE_HAVE_A_TWO_BY_TWO</span><span class="s3">:</span>
                    <span class="s1">i </span><span class="s3">+= </span><span class="s6">8</span>
                <span class="s1">more </span><span class="s3">= </span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">MORE_COMPONENTS</span>
            <span class="s2">if </span><span class="s1">we_have_instructions</span><span class="s3">:</span>
                <span class="s1">instructionLen </span><span class="s3">= (</span><span class="s1">data</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &lt;&lt; </span><span class="s6">8</span><span class="s3">) | </span><span class="s1">data</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">]</span>
                <span class="s1">i </span><span class="s3">+= </span><span class="s6">2 </span><span class="s3">+ </span><span class="s1">instructionLen</span>
            <span class="s4"># Remove padding</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[:</span><span class="s1">i</span><span class="s3">]</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">data </span><span class="s3">= </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">removeHinting</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Removes TrueType hinting instructions from the glyph.&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">trim</span><span class="s3">(</span><span class="s1">remove_hinting</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">draw</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pen</span><span class="s3">, </span><span class="s1">glyfTable</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">=</span><span class="s6">0</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Draws the glyph using the supplied pen object. 
 
        Arguments: 
                pen: An object conforming to the pen protocol. 
                glyfTable: A :py:class:`table__g_l_y_f` object, to resolve components. 
                offset (int): A horizontal offset. If provided, all coordinates are 
                        translated by this offset. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">isComposite</span><span class="s3">():</span>
            <span class="s2">for </span><span class="s1">component </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">components</span><span class="s3">:</span>
                <span class="s1">glyphName</span><span class="s3">, </span><span class="s1">transform </span><span class="s3">= </span><span class="s1">component</span><span class="s3">.</span><span class="s1">getComponentInfo</span><span class="s3">()</span>
                <span class="s1">pen</span><span class="s3">.</span><span class="s1">addComponent</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">transform</span><span class="s3">)</span>
            <span class="s2">return</span>

        <span class="s1">coordinates</span><span class="s3">, </span><span class="s1">endPts</span><span class="s3">, </span><span class="s1">flags </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getCoordinates</span><span class="s3">(</span><span class="s1">glyfTable</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">offset</span><span class="s3">:</span>
            <span class="s1">coordinates </span><span class="s3">= </span><span class="s1">coordinates</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">coordinates</span><span class="s3">.</span><span class="s1">translate</span><span class="s3">((</span><span class="s1">offset</span><span class="s3">, </span><span class="s6">0</span><span class="s3">))</span>
        <span class="s1">start </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">maybeInt </span><span class="s3">= </span><span class="s2">lambda </span><span class="s1">v</span><span class="s3">: </span><span class="s1">int</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) </span><span class="s2">if </span><span class="s1">v </span><span class="s3">== </span><span class="s1">int</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) </span><span class="s2">else </span><span class="s1">v</span>
        <span class="s2">for </span><span class="s1">end </span><span class="s2">in </span><span class="s1">endPts</span><span class="s3">:</span>
            <span class="s1">end </span><span class="s3">= </span><span class="s1">end </span><span class="s3">+ </span><span class="s6">1</span>
            <span class="s1">contour </span><span class="s3">= </span><span class="s1">coordinates</span><span class="s3">[</span><span class="s1">start</span><span class="s3">:</span><span class="s1">end</span><span class="s3">]</span>
            <span class="s1">cFlags </span><span class="s3">= [</span><span class="s1">flagOnCurve </span><span class="s3">&amp; </span><span class="s1">f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">flags</span><span class="s3">[</span><span class="s1">start</span><span class="s3">:</span><span class="s1">end</span><span class="s3">]]</span>
            <span class="s1">cuFlags </span><span class="s3">= [</span><span class="s1">flagCubic </span><span class="s3">&amp; </span><span class="s1">f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">flags</span><span class="s3">[</span><span class="s1">start</span><span class="s3">:</span><span class="s1">end</span><span class="s3">]]</span>
            <span class="s1">start </span><span class="s3">= </span><span class="s1">end</span>
            <span class="s2">if </span><span class="s6">1 </span><span class="s2">not in </span><span class="s1">cFlags</span><span class="s3">:</span>
                <span class="s2">assert </span><span class="s1">all</span><span class="s3">(</span><span class="s1">cuFlags</span><span class="s3">) </span><span class="s2">or not </span><span class="s1">any</span><span class="s3">(</span><span class="s1">cuFlags</span><span class="s3">)</span>
                <span class="s1">cubic </span><span class="s3">= </span><span class="s1">all</span><span class="s3">(</span><span class="s1">cuFlags</span><span class="s3">)</span>
                <span class="s2">if </span><span class="s1">cubic</span><span class="s3">:</span>
                    <span class="s1">count </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">contour</span><span class="s3">)</span>
                    <span class="s2">assert </span><span class="s1">count </span><span class="s3">% </span><span class="s6">2 </span><span class="s3">== </span><span class="s6">0</span><span class="s3">, </span><span class="s5">&quot;Odd number of cubic off-curves undefined&quot;</span>
                    <span class="s1">l </span><span class="s3">= </span><span class="s1">contour</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]</span>
                    <span class="s1">f </span><span class="s3">= </span><span class="s1">contour</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
                    <span class="s1">p0 </span><span class="s3">= (</span><span class="s1">maybeInt</span><span class="s3">((</span><span class="s1">l</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] + </span><span class="s1">f</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]) * </span><span class="s6">0.5</span><span class="s3">), </span><span class="s1">maybeInt</span><span class="s3">((</span><span class="s1">l</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] + </span><span class="s1">f</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]) * </span><span class="s6">0.5</span><span class="s3">))</span>
                    <span class="s1">pen</span><span class="s3">.</span><span class="s1">moveTo</span><span class="s3">(</span><span class="s1">p0</span><span class="s3">)</span>
                    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">count</span><span class="s3">, </span><span class="s6">2</span><span class="s3">):</span>
                        <span class="s1">p1 </span><span class="s3">= </span><span class="s1">contour</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                        <span class="s1">p2 </span><span class="s3">= </span><span class="s1">contour</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">]</span>
                        <span class="s1">p4 </span><span class="s3">= </span><span class="s1">contour</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">2 </span><span class="s2">if </span><span class="s1">i </span><span class="s3">+ </span><span class="s6">2 </span><span class="s3">&lt; </span><span class="s1">count </span><span class="s2">else </span><span class="s6">0</span><span class="s3">]</span>
                        <span class="s1">p3 </span><span class="s3">= (</span>
                            <span class="s1">maybeInt</span><span class="s3">((</span><span class="s1">p2</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] + </span><span class="s1">p4</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]) * </span><span class="s6">0.5</span><span class="s3">),</span>
                            <span class="s1">maybeInt</span><span class="s3">((</span><span class="s1">p2</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] + </span><span class="s1">p4</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]) * </span><span class="s6">0.5</span><span class="s3">),</span>
                        <span class="s3">)</span>
                        <span class="s1">pen</span><span class="s3">.</span><span class="s1">curveTo</span><span class="s3">(</span><span class="s1">p1</span><span class="s3">, </span><span class="s1">p2</span><span class="s3">, </span><span class="s1">p3</span><span class="s3">)</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s4"># There is not a single on-curve point on the curve,</span>
                    <span class="s4"># use pen.qCurveTo's special case by specifying None</span>
                    <span class="s4"># as the on-curve point.</span>
                    <span class="s1">contour</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s2">None</span><span class="s3">)</span>
                    <span class="s1">pen</span><span class="s3">.</span><span class="s1">qCurveTo</span><span class="s3">(*</span><span class="s1">contour</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s4"># Shuffle the points so that the contour is guaranteed</span>
                <span class="s4"># to *end* in an on-curve point, which we'll use for</span>
                <span class="s4"># the moveTo.</span>
                <span class="s1">firstOnCurve </span><span class="s3">= </span><span class="s1">cFlags</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s6">1</span><span class="s3">) + </span><span class="s6">1</span>
                <span class="s1">contour </span><span class="s3">= </span><span class="s1">contour</span><span class="s3">[</span><span class="s1">firstOnCurve</span><span class="s3">:] + </span><span class="s1">contour</span><span class="s3">[:</span><span class="s1">firstOnCurve</span><span class="s3">]</span>
                <span class="s1">cFlags </span><span class="s3">= </span><span class="s1">cFlags</span><span class="s3">[</span><span class="s1">firstOnCurve</span><span class="s3">:] + </span><span class="s1">cFlags</span><span class="s3">[:</span><span class="s1">firstOnCurve</span><span class="s3">]</span>
                <span class="s1">cuFlags </span><span class="s3">= </span><span class="s1">cuFlags</span><span class="s3">[</span><span class="s1">firstOnCurve</span><span class="s3">:] + </span><span class="s1">cuFlags</span><span class="s3">[:</span><span class="s1">firstOnCurve</span><span class="s3">]</span>
                <span class="s1">pen</span><span class="s3">.</span><span class="s1">moveTo</span><span class="s3">(</span><span class="s1">contour</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">])</span>
                <span class="s2">while </span><span class="s1">contour</span><span class="s3">:</span>
                    <span class="s1">nextOnCurve </span><span class="s3">= </span><span class="s1">cFlags</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s6">1</span><span class="s3">) + </span><span class="s6">1</span>
                    <span class="s2">if </span><span class="s1">nextOnCurve </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
                        <span class="s4"># Skip a final lineTo(), as it is implied by</span>
                        <span class="s4"># pen.closePath()</span>
                        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">contour</span><span class="s3">) &gt; </span><span class="s6">1</span><span class="s3">:</span>
                            <span class="s1">pen</span><span class="s3">.</span><span class="s1">lineTo</span><span class="s3">(</span><span class="s1">contour</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>
                    <span class="s2">else</span><span class="s3">:</span>
                        <span class="s1">cubicFlags </span><span class="s3">= [</span><span class="s1">f </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">cuFlags</span><span class="s3">[: </span><span class="s1">nextOnCurve </span><span class="s3">- </span><span class="s6">1</span><span class="s3">]]</span>
                        <span class="s2">assert </span><span class="s1">all</span><span class="s3">(</span><span class="s1">cubicFlags</span><span class="s3">) </span><span class="s2">or not </span><span class="s1">any</span><span class="s3">(</span><span class="s1">cubicFlags</span><span class="s3">)</span>
                        <span class="s1">cubic </span><span class="s3">= </span><span class="s1">any</span><span class="s3">(</span><span class="s1">cubicFlags</span><span class="s3">)</span>
                        <span class="s2">if </span><span class="s1">cubic</span><span class="s3">:</span>
                            <span class="s2">assert </span><span class="s1">all</span><span class="s3">(</span>
                                <span class="s1">cubicFlags</span>
                            <span class="s3">), </span><span class="s5">&quot;Mixed cubic and quadratic segment undefined&quot;</span>

                            <span class="s1">count </span><span class="s3">= </span><span class="s1">nextOnCurve</span>
                            <span class="s2">assert </span><span class="s3">(</span>
                                <span class="s1">count </span><span class="s3">&gt;= </span><span class="s6">3</span>
                            <span class="s3">), </span><span class="s5">&quot;At least two cubic off-curve points required&quot;</span>
                            <span class="s2">assert </span><span class="s3">(</span>
                                <span class="s1">count </span><span class="s3">- </span><span class="s6">1</span>
                            <span class="s3">) % </span><span class="s6">2 </span><span class="s3">== </span><span class="s6">0</span><span class="s3">, </span><span class="s5">&quot;Odd number of cubic off-curves undefined&quot;</span>
                            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">count </span><span class="s3">- </span><span class="s6">3</span><span class="s3">, </span><span class="s6">2</span><span class="s3">):</span>
                                <span class="s1">p1 </span><span class="s3">= </span><span class="s1">contour</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
                                <span class="s1">p2 </span><span class="s3">= </span><span class="s1">contour</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">]</span>
                                <span class="s1">p4 </span><span class="s3">= </span><span class="s1">contour</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">2</span><span class="s3">]</span>
                                <span class="s1">p3 </span><span class="s3">= (</span>
                                    <span class="s1">maybeInt</span><span class="s3">((</span><span class="s1">p2</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] + </span><span class="s1">p4</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]) * </span><span class="s6">0.5</span><span class="s3">),</span>
                                    <span class="s1">maybeInt</span><span class="s3">((</span><span class="s1">p2</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] + </span><span class="s1">p4</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]) * </span><span class="s6">0.5</span><span class="s3">),</span>
                                <span class="s3">)</span>
                                <span class="s1">lastOnCurve </span><span class="s3">= </span><span class="s1">p3</span>
                                <span class="s1">pen</span><span class="s3">.</span><span class="s1">curveTo</span><span class="s3">(</span><span class="s1">p1</span><span class="s3">, </span><span class="s1">p2</span><span class="s3">, </span><span class="s1">p3</span><span class="s3">)</span>
                            <span class="s1">pen</span><span class="s3">.</span><span class="s1">curveTo</span><span class="s3">(*</span><span class="s1">contour</span><span class="s3">[</span><span class="s1">count </span><span class="s3">- </span><span class="s6">3 </span><span class="s3">: </span><span class="s1">count</span><span class="s3">])</span>
                        <span class="s2">else</span><span class="s3">:</span>
                            <span class="s1">pen</span><span class="s3">.</span><span class="s1">qCurveTo</span><span class="s3">(*</span><span class="s1">contour</span><span class="s3">[:</span><span class="s1">nextOnCurve</span><span class="s3">])</span>
                    <span class="s1">contour </span><span class="s3">= </span><span class="s1">contour</span><span class="s3">[</span><span class="s1">nextOnCurve</span><span class="s3">:]</span>
                    <span class="s1">cFlags </span><span class="s3">= </span><span class="s1">cFlags</span><span class="s3">[</span><span class="s1">nextOnCurve</span><span class="s3">:]</span>
                    <span class="s1">cuFlags </span><span class="s3">= </span><span class="s1">cuFlags</span><span class="s3">[</span><span class="s1">nextOnCurve</span><span class="s3">:]</span>
            <span class="s1">pen</span><span class="s3">.</span><span class="s1">closePath</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">drawPoints</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">pen</span><span class="s3">, </span><span class="s1">glyfTable</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">=</span><span class="s6">0</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Draw the glyph using the supplied pointPen. As opposed to Glyph.draw(), 
        this will not change the point indices. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">isComposite</span><span class="s3">():</span>
            <span class="s2">for </span><span class="s1">component </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">components</span><span class="s3">:</span>
                <span class="s1">glyphName</span><span class="s3">, </span><span class="s1">transform </span><span class="s3">= </span><span class="s1">component</span><span class="s3">.</span><span class="s1">getComponentInfo</span><span class="s3">()</span>
                <span class="s1">pen</span><span class="s3">.</span><span class="s1">addComponent</span><span class="s3">(</span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">transform</span><span class="s3">)</span>
            <span class="s2">return</span>

        <span class="s1">coordinates</span><span class="s3">, </span><span class="s1">endPts</span><span class="s3">, </span><span class="s1">flags </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">getCoordinates</span><span class="s3">(</span><span class="s1">glyfTable</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">offset</span><span class="s3">:</span>
            <span class="s1">coordinates </span><span class="s3">= </span><span class="s1">coordinates</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
            <span class="s1">coordinates</span><span class="s3">.</span><span class="s1">translate</span><span class="s3">((</span><span class="s1">offset</span><span class="s3">, </span><span class="s6">0</span><span class="s3">))</span>
        <span class="s1">start </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s2">for </span><span class="s1">end </span><span class="s2">in </span><span class="s1">endPts</span><span class="s3">:</span>
            <span class="s1">end </span><span class="s3">= </span><span class="s1">end </span><span class="s3">+ </span><span class="s6">1</span>
            <span class="s1">contour </span><span class="s3">= </span><span class="s1">coordinates</span><span class="s3">[</span><span class="s1">start</span><span class="s3">:</span><span class="s1">end</span><span class="s3">]</span>
            <span class="s1">cFlags </span><span class="s3">= </span><span class="s1">flags</span><span class="s3">[</span><span class="s1">start</span><span class="s3">:</span><span class="s1">end</span><span class="s3">]</span>
            <span class="s1">start </span><span class="s3">= </span><span class="s1">end</span>
            <span class="s1">pen</span><span class="s3">.</span><span class="s1">beginPath</span><span class="s3">()</span>
            <span class="s4"># Start with the appropriate segment type based on the final segment</span>

            <span class="s2">if </span><span class="s1">cFlags</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">] &amp; </span><span class="s1">flagOnCurve</span><span class="s3">:</span>
                <span class="s1">segmentType </span><span class="s3">= </span><span class="s5">&quot;line&quot;</span>
            <span class="s2">elif </span><span class="s1">cFlags</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">] &amp; </span><span class="s1">flagCubic</span><span class="s3">:</span>
                <span class="s1">segmentType </span><span class="s3">= </span><span class="s5">&quot;curve&quot;</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">segmentType </span><span class="s3">= </span><span class="s5">&quot;qcurve&quot;</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">pt </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">contour</span><span class="s3">):</span>
                <span class="s2">if </span><span class="s1">cFlags</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &amp; </span><span class="s1">flagOnCurve</span><span class="s3">:</span>
                    <span class="s1">pen</span><span class="s3">.</span><span class="s1">addPoint</span><span class="s3">(</span><span class="s1">pt</span><span class="s3">, </span><span class="s1">segmentType</span><span class="s3">=</span><span class="s1">segmentType</span><span class="s3">)</span>
                    <span class="s1">segmentType </span><span class="s3">= </span><span class="s5">&quot;line&quot;</span>
                <span class="s2">else</span><span class="s3">:</span>
                    <span class="s1">pen</span><span class="s3">.</span><span class="s1">addPoint</span><span class="s3">(</span><span class="s1">pt</span><span class="s3">)</span>
                    <span class="s1">segmentType </span><span class="s3">= </span><span class="s5">&quot;curve&quot; </span><span class="s2">if </span><span class="s1">cFlags</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &amp; </span><span class="s1">flagCubic </span><span class="s2">else </span><span class="s5">&quot;qcurve&quot;</span>
            <span class="s1">pen</span><span class="s3">.</span><span class="s1">endPath</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">__eq__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) != </span><span class="s1">type</span><span class="s3">(</span><span class="s1">other</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__dict__ </span><span class="s3">== </span><span class="s1">other</span><span class="s3">.</span><span class="s1">__dict__</span>

    <span class="s2">def </span><span class="s1">__ne__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__eq__</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">result </span><span class="s2">if </span><span class="s1">result </span><span class="s2">is </span><span class="s1">NotImplemented </span><span class="s2">else not </span><span class="s1">result</span>


<span class="s4"># Vector.__round__ uses the built-in (Banker's) `round` but we want</span>
<span class="s4"># to use otRound below</span>
<span class="s1">_roundv </span><span class="s3">= </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">Vector</span><span class="s3">.</span><span class="s1">__round__</span><span class="s3">, </span><span class="s1">round</span><span class="s3">=</span><span class="s1">otRound</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_is_mid_point</span><span class="s3">(</span><span class="s1">p0</span><span class="s3">: </span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">p1</span><span class="s3">: </span><span class="s1">tuple</span><span class="s3">, </span><span class="s1">p2</span><span class="s3">: </span><span class="s1">tuple</span><span class="s3">) </span><span class="s1">-&gt; bool</span><span class="s3">:</span>
    <span class="s4"># True if p1 is in the middle of p0 and p2, either before or after rounding</span>
    <span class="s1">p0 </span><span class="s3">= </span><span class="s1">Vector</span><span class="s3">(</span><span class="s1">p0</span><span class="s3">)</span>
    <span class="s1">p1 </span><span class="s3">= </span><span class="s1">Vector</span><span class="s3">(</span><span class="s1">p1</span><span class="s3">)</span>
    <span class="s1">p2 </span><span class="s3">= </span><span class="s1">Vector</span><span class="s3">(</span><span class="s1">p2</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s3">((</span><span class="s1">p0 </span><span class="s3">+ </span><span class="s1">p2</span><span class="s3">) * </span><span class="s6">0.5</span><span class="s3">).</span><span class="s1">isclose</span><span class="s3">(</span><span class="s1">p1</span><span class="s3">) </span><span class="s2">or </span><span class="s1">_roundv</span><span class="s3">(</span><span class="s1">p0</span><span class="s3">) + </span><span class="s1">_roundv</span><span class="s3">(</span><span class="s1">p2</span><span class="s3">) == </span><span class="s1">_roundv</span><span class="s3">(</span><span class="s1">p1</span><span class="s3">) * </span><span class="s6">2</span>


<span class="s2">def </span><span class="s1">dropImpliedOnCurvePoints</span><span class="s3">(*</span><span class="s1">interpolatable_glyphs</span><span class="s3">: </span><span class="s1">Glyph</span><span class="s3">) </span><span class="s1">-&gt; Set</span><span class="s3">[</span><span class="s1">int</span><span class="s3">]:</span>
    <span class="s0">&quot;&quot;&quot;Drop impliable on-curve points from the (simple) glyph or glyphs. 
 
    In TrueType glyf outlines, on-curve points can be implied when they are located at 
    the midpoint of the line connecting two consecutive off-curve points. 
 
    If more than one glyphs are passed, these are assumed to be interpolatable masters 
    of the same glyph impliable, and thus only the on-curve points that are impliable 
    for all of them will actually be implied. 
    Composite glyphs or empty glyphs are skipped, only simple glyphs with 1 or more 
    contours are considered. 
    The input glyph(s) is/are modified in-place. 
 
    Args: 
        interpolatable_glyphs: The glyph or glyphs to modify in-place. 
 
    Returns: 
        The set of point indices that were dropped if any. 
 
    Raises: 
        ValueError if simple glyphs are not in fact interpolatable because they have 
        different point flags or number of contours. 
 
    Reference: 
    https://developer.apple.com/fonts/TrueType-Reference-Manual/RM01/Chap1.html 
    &quot;&quot;&quot;</span>
    <span class="s1">staticAttributes </span><span class="s3">= </span><span class="s1">SimpleNamespace</span><span class="s3">(</span>
        <span class="s1">numberOfContours</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">endPtsOfContours</span><span class="s3">=</span><span class="s2">None</span>
    <span class="s3">)</span>
    <span class="s1">drop </span><span class="s3">= </span><span class="s2">None</span>
    <span class="s1">simple_glyphs </span><span class="s3">= []</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">glyph </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">interpolatable_glyphs</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">numberOfContours </span><span class="s3">&lt; </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s4"># ignore composite or empty glyphs</span>
            <span class="s2">continue</span>

        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">staticAttributes</span><span class="s3">.</span><span class="s1">__dict__</span><span class="s3">:</span>
            <span class="s1">expected </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">staticAttributes</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">)</span>
            <span class="s1">found </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">glyph</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">expected </span><span class="s2">is None</span><span class="s3">:</span>
                <span class="s1">setattr</span><span class="s3">(</span><span class="s1">staticAttributes</span><span class="s3">, </span><span class="s1">attr</span><span class="s3">, </span><span class="s1">found</span><span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">expected </span><span class="s3">!= </span><span class="s1">found</span><span class="s3">:</span>
                <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                    <span class="s5">f&quot;Incompatible </span><span class="s2">{</span><span class="s1">attr</span><span class="s2">} </span><span class="s5">for glyph at master index </span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s5">: &quot;</span>
                    <span class="s5">f&quot;expected </span><span class="s2">{</span><span class="s1">expected</span><span class="s2">}</span><span class="s5">, found </span><span class="s2">{</span><span class="s1">found</span><span class="s2">}</span><span class="s5">&quot;</span>
                <span class="s3">)</span>

        <span class="s1">may_drop </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
        <span class="s1">start </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">coords </span><span class="s3">= </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">coordinates</span>
        <span class="s1">flags </span><span class="s3">= </span><span class="s1">staticAttributes</span><span class="s3">.</span><span class="s1">flags</span>
        <span class="s1">endPtsOfContours </span><span class="s3">= </span><span class="s1">staticAttributes</span><span class="s3">.</span><span class="s1">endPtsOfContours</span>
        <span class="s2">for </span><span class="s1">last </span><span class="s2">in </span><span class="s1">endPtsOfContours</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">last </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">):</span>
                <span class="s2">if not </span><span class="s3">(</span><span class="s1">flags</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] &amp; </span><span class="s1">flagOnCurve</span><span class="s3">):</span>
                    <span class="s2">continue</span>
                <span class="s1">prv </span><span class="s3">= </span><span class="s1">i </span><span class="s3">- </span><span class="s6">1 </span><span class="s2">if </span><span class="s1">i </span><span class="s3">&gt; </span><span class="s1">start </span><span class="s2">else </span><span class="s1">last</span>
                <span class="s1">nxt </span><span class="s3">= </span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1 </span><span class="s2">if </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">last </span><span class="s2">else </span><span class="s1">start</span>
                <span class="s2">if </span><span class="s3">(</span><span class="s1">flags</span><span class="s3">[</span><span class="s1">prv</span><span class="s3">] &amp; </span><span class="s1">flagOnCurve</span><span class="s3">) </span><span class="s2">or </span><span class="s1">flags</span><span class="s3">[</span><span class="s1">prv</span><span class="s3">] != </span><span class="s1">flags</span><span class="s3">[</span><span class="s1">nxt</span><span class="s3">]:</span>
                    <span class="s2">continue</span>
                <span class="s4"># we may drop the ith on-curve if halfway between previous/next off-curves</span>
                <span class="s2">if not </span><span class="s1">_is_mid_point</span><span class="s3">(</span><span class="s1">coords</span><span class="s3">[</span><span class="s1">prv</span><span class="s3">], </span><span class="s1">coords</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">coords</span><span class="s3">[</span><span class="s1">nxt</span><span class="s3">]):</span>
                    <span class="s2">continue</span>

                <span class="s1">may_drop</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">i</span><span class="s3">)</span>
            <span class="s1">start </span><span class="s3">= </span><span class="s1">last </span><span class="s3">+ </span><span class="s6">1</span>
        <span class="s4"># we only want to drop if ALL interpolatable glyphs have the same implied oncurves</span>
        <span class="s2">if </span><span class="s1">drop </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s1">drop </span><span class="s3">= </span><span class="s1">may_drop</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">drop</span><span class="s3">.</span><span class="s1">intersection_update</span><span class="s3">(</span><span class="s1">may_drop</span><span class="s3">)</span>

        <span class="s1">simple_glyphs</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">glyph</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">drop</span><span class="s3">:</span>
        <span class="s4"># Do the actual dropping</span>
        <span class="s1">flags </span><span class="s3">= </span><span class="s1">staticAttributes</span><span class="s3">.</span><span class="s1">flags</span>
        <span class="s2">assert </span><span class="s1">flags </span><span class="s2">is not None</span>
        <span class="s1">newFlags </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span>
            <span class="s5">&quot;B&quot;</span><span class="s3">, (</span><span class="s1">flags</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">flags</span><span class="s3">)) </span><span class="s2">if </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">drop</span><span class="s3">)</span>
        <span class="s3">)</span>

        <span class="s1">endPts </span><span class="s3">= </span><span class="s1">staticAttributes</span><span class="s3">.</span><span class="s1">endPtsOfContours</span>
        <span class="s2">assert </span><span class="s1">endPts </span><span class="s2">is not None</span>
        <span class="s1">newEndPts </span><span class="s3">= []</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s1">delta </span><span class="s3">= </span><span class="s6">0</span>
        <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">sorted</span><span class="s3">(</span><span class="s1">drop</span><span class="s3">):</span>
            <span class="s2">while </span><span class="s1">d </span><span class="s3">&gt; </span><span class="s1">endPts</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]:</span>
                <span class="s1">newEndPts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">endPts</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">delta</span><span class="s3">)</span>
                <span class="s1">i </span><span class="s3">+= </span><span class="s6">1</span>
            <span class="s1">delta </span><span class="s3">+= </span><span class="s6">1</span>
        <span class="s2">while </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">(</span><span class="s1">endPts</span><span class="s3">):</span>
            <span class="s1">newEndPts</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">endPts</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] - </span><span class="s1">delta</span><span class="s3">)</span>
            <span class="s1">i </span><span class="s3">+= </span><span class="s6">1</span>

        <span class="s2">for </span><span class="s1">glyph </span><span class="s2">in </span><span class="s1">simple_glyphs</span><span class="s3">:</span>
            <span class="s1">coords </span><span class="s3">= </span><span class="s1">glyph</span><span class="s3">.</span><span class="s1">coordinates</span>
            <span class="s1">glyph</span><span class="s3">.</span><span class="s1">coordinates </span><span class="s3">= </span><span class="s1">GlyphCoordinates</span><span class="s3">(</span>
                <span class="s1">coords</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">coords</span><span class="s3">)) </span><span class="s2">if </span><span class="s1">i </span><span class="s2">not in </span><span class="s1">drop</span>
            <span class="s3">)</span>
            <span class="s1">glyph</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">= </span><span class="s1">newFlags</span>
            <span class="s1">glyph</span><span class="s3">.</span><span class="s1">endPtsOfContours </span><span class="s3">= </span><span class="s1">newEndPts</span>

    <span class="s2">return </span><span class="s1">drop </span><span class="s2">if </span><span class="s1">drop </span><span class="s2">is not None else </span><span class="s1">set</span><span class="s3">()</span>


<span class="s2">class </span><span class="s1">GlyphComponent</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Represents a component within a composite glyph. 
 
    The component is represented internally with four attributes: ``glyphName``, 
    ``x``, ``y`` and ``transform``. If there is no &quot;two-by-two&quot; matrix (i.e 
    no scaling, reflection, or rotation; only translation), the ``transform`` 
    attribute is not present. 
    &quot;&quot;&quot;</span>

    <span class="s4"># The above documentation is not *completely* true, but is *true enough* because</span>
    <span class="s4"># the rare firstPt/lastPt attributes are not totally supported and nobody seems to</span>
    <span class="s4"># mind - see below.</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">getComponentInfo</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Return information about the component 
 
        This method returns a tuple of two values: the glyph name of the component's 
        base glyph, and a transformation matrix. As opposed to accessing the attributes 
        directly, ``getComponentInfo`` always returns a six-element tuple of the 
        component's transformation matrix, even when the two-by-two ``.transform`` 
        matrix is not present. 
        &quot;&quot;&quot;</span>
        <span class="s4"># XXX Ignoring self.firstPt &amp; self.lastpt for now: I need to implement</span>
        <span class="s4"># something equivalent in fontTools.objects.glyph (I'd rather not</span>
        <span class="s4"># convert it to an absolute offset, since it is valuable information).</span>
        <span class="s4"># This method will now raise &quot;AttributeError: x&quot; on glyphs that use</span>
        <span class="s4"># this TT feature.</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;transform&quot;</span><span class="s3">):</span>
            <span class="s3">[[</span><span class="s1">xx</span><span class="s3">, </span><span class="s1">xy</span><span class="s3">], [</span><span class="s1">yx</span><span class="s3">, </span><span class="s1">yy</span><span class="s3">]] = </span><span class="s1">self</span><span class="s3">.</span><span class="s1">transform</span>
            <span class="s1">trans </span><span class="s3">= (</span><span class="s1">xx</span><span class="s3">, </span><span class="s1">xy</span><span class="s3">, </span><span class="s1">yx</span><span class="s3">, </span><span class="s1">yy</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">x</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">trans </span><span class="s3">= (</span><span class="s6">1</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">1</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">x</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphName</span><span class="s3">, </span><span class="s1">trans</span>

    <span class="s2">def </span><span class="s1">decompile</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">glyfTable</span><span class="s3">):</span>
        <span class="s1">flags</span><span class="s3">, </span><span class="s1">glyphID </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack</span><span class="s3">(</span><span class="s5">&quot;&gt;HH&quot;</span><span class="s3">, </span><span class="s1">data</span><span class="s3">[:</span><span class="s6">4</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">flags</span><span class="s3">)</span>
        <span class="s1">glyphID </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">glyphID</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">glyphName </span><span class="s3">= </span><span class="s1">glyfTable</span><span class="s3">.</span><span class="s1">getGlyphName</span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">glyphID</span><span class="s3">))</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s6">4</span><span class="s3">:]</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">ARG_1_AND_2_ARE_WORDS</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">ARGS_ARE_XY_VALUES</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">x</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">y </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack</span><span class="s3">(</span><span class="s5">&quot;&gt;hh&quot;</span><span class="s3">, </span><span class="s1">data</span><span class="s3">[:</span><span class="s6">4</span><span class="s3">])</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack</span><span class="s3">(</span><span class="s5">&quot;&gt;HH&quot;</span><span class="s3">, </span><span class="s1">data</span><span class="s3">[:</span><span class="s6">4</span><span class="s3">])</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">firstPt</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">secondPt </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">int</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s6">4</span><span class="s3">:]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">ARGS_ARE_XY_VALUES</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">x</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">y </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack</span><span class="s3">(</span><span class="s5">&quot;&gt;bb&quot;</span><span class="s3">, </span><span class="s1">data</span><span class="s3">[:</span><span class="s6">2</span><span class="s3">])</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack</span><span class="s3">(</span><span class="s5">&quot;&gt;BB&quot;</span><span class="s3">, </span><span class="s1">data</span><span class="s3">[:</span><span class="s6">2</span><span class="s3">])</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">firstPt</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">secondPt </span><span class="s3">= </span><span class="s1">int</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">int</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s6">2</span><span class="s3">:]</span>

        <span class="s2">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">WE_HAVE_A_SCALE</span><span class="s3">:</span>
            <span class="s3">(</span><span class="s1">scale</span><span class="s3">,) = </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack</span><span class="s3">(</span><span class="s5">&quot;&gt;h&quot;</span><span class="s3">, </span><span class="s1">data</span><span class="s3">[:</span><span class="s6">2</span><span class="s3">])</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">transform </span><span class="s3">= [</span>
                <span class="s3">[</span><span class="s1">fi2fl</span><span class="s3">(</span><span class="s1">scale</span><span class="s3">, </span><span class="s6">14</span><span class="s3">), </span><span class="s6">0</span><span class="s3">],</span>
                <span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s1">fi2fl</span><span class="s3">(</span><span class="s1">scale</span><span class="s3">, </span><span class="s6">14</span><span class="s3">)],</span>
            <span class="s3">]  </span><span class="s4"># fixed 2.14</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s6">2</span><span class="s3">:]</span>
        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">WE_HAVE_AN_X_AND_Y_SCALE</span><span class="s3">:</span>
            <span class="s1">xscale</span><span class="s3">, </span><span class="s1">yscale </span><span class="s3">= </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack</span><span class="s3">(</span><span class="s5">&quot;&gt;hh&quot;</span><span class="s3">, </span><span class="s1">data</span><span class="s3">[:</span><span class="s6">4</span><span class="s3">])</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">transform </span><span class="s3">= [</span>
                <span class="s3">[</span><span class="s1">fi2fl</span><span class="s3">(</span><span class="s1">xscale</span><span class="s3">, </span><span class="s6">14</span><span class="s3">), </span><span class="s6">0</span><span class="s3">],</span>
                <span class="s3">[</span><span class="s6">0</span><span class="s3">, </span><span class="s1">fi2fl</span><span class="s3">(</span><span class="s1">yscale</span><span class="s3">, </span><span class="s6">14</span><span class="s3">)],</span>
            <span class="s3">]  </span><span class="s4"># fixed 2.14</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s6">4</span><span class="s3">:]</span>
        <span class="s2">elif </span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">WE_HAVE_A_TWO_BY_TWO</span><span class="s3">:</span>
            <span class="s3">(</span><span class="s1">xscale</span><span class="s3">, </span><span class="s1">scale01</span><span class="s3">, </span><span class="s1">scale10</span><span class="s3">, </span><span class="s1">yscale</span><span class="s3">) = </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">unpack</span><span class="s3">(</span><span class="s5">&quot;&gt;hhhh&quot;</span><span class="s3">, </span><span class="s1">data</span><span class="s3">[:</span><span class="s6">8</span><span class="s3">])</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">transform </span><span class="s3">= [</span>
                <span class="s3">[</span><span class="s1">fi2fl</span><span class="s3">(</span><span class="s1">xscale</span><span class="s3">, </span><span class="s6">14</span><span class="s3">), </span><span class="s1">fi2fl</span><span class="s3">(</span><span class="s1">scale01</span><span class="s3">, </span><span class="s6">14</span><span class="s3">)],</span>
                <span class="s3">[</span><span class="s1">fi2fl</span><span class="s3">(</span><span class="s1">scale10</span><span class="s3">, </span><span class="s6">14</span><span class="s3">), </span><span class="s1">fi2fl</span><span class="s3">(</span><span class="s1">yscale</span><span class="s3">, </span><span class="s6">14</span><span class="s3">)],</span>
            <span class="s3">]  </span><span class="s4"># fixed 2.14</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s6">8</span><span class="s3">:]</span>
        <span class="s1">more </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">MORE_COMPONENTS</span>
        <span class="s1">haveInstructions </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">&amp; </span><span class="s1">WE_HAVE_INSTRUCTIONS</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">&amp; (</span>
            <span class="s1">ROUND_XY_TO_GRID</span>
            <span class="s3">| </span><span class="s1">USE_MY_METRICS</span>
            <span class="s3">| </span><span class="s1">SCALED_COMPONENT_OFFSET</span>
            <span class="s3">| </span><span class="s1">UNSCALED_COMPONENT_OFFSET</span>
            <span class="s3">| </span><span class="s1">NON_OVERLAPPING</span>
            <span class="s3">| </span><span class="s1">OVERLAP_COMPOUND</span>
        <span class="s3">)</span>
        <span class="s2">return </span><span class="s1">more</span><span class="s3">, </span><span class="s1">haveInstructions</span><span class="s3">, </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">compile</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">more</span><span class="s3">, </span><span class="s1">haveInstructions</span><span class="s3">, </span><span class="s1">glyfTable</span><span class="s3">):</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s7">b&quot;&quot;</span>

        <span class="s4"># reset all flags we will calculate ourselves</span>
        <span class="s1">flags </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">&amp; (</span>
            <span class="s1">ROUND_XY_TO_GRID</span>
            <span class="s3">| </span><span class="s1">USE_MY_METRICS</span>
            <span class="s3">| </span><span class="s1">SCALED_COMPONENT_OFFSET</span>
            <span class="s3">| </span><span class="s1">UNSCALED_COMPONENT_OFFSET</span>
            <span class="s3">| </span><span class="s1">NON_OVERLAPPING</span>
            <span class="s3">| </span><span class="s1">OVERLAP_COMPOUND</span>
        <span class="s3">)</span>
        <span class="s2">if </span><span class="s1">more</span><span class="s3">:</span>
            <span class="s1">flags </span><span class="s3">= </span><span class="s1">flags </span><span class="s3">| </span><span class="s1">MORE_COMPONENTS</span>
        <span class="s2">if </span><span class="s1">haveInstructions</span><span class="s3">:</span>
            <span class="s1">flags </span><span class="s3">= </span><span class="s1">flags </span><span class="s3">| </span><span class="s1">WE_HAVE_INSTRUCTIONS</span>

        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;firstPt&quot;</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s3">(</span><span class="s6">0 </span><span class="s3">&lt;= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">firstPt </span><span class="s3">&lt;= </span><span class="s6">255</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(</span><span class="s6">0 </span><span class="s3">&lt;= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">secondPt </span><span class="s3">&lt;= </span><span class="s6">255</span><span class="s3">):</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data </span><span class="s3">+ </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s5">&quot;&gt;BB&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">firstPt</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">secondPt</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data </span><span class="s3">+ </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s5">&quot;&gt;HH&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">firstPt</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">secondPt</span><span class="s3">)</span>
                <span class="s1">flags </span><span class="s3">= </span><span class="s1">flags </span><span class="s3">| </span><span class="s1">ARG_1_AND_2_ARE_WORDS</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">otRound</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">x</span><span class="s3">)</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s1">otRound</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">)</span>
            <span class="s1">flags </span><span class="s3">= </span><span class="s1">flags </span><span class="s3">| </span><span class="s1">ARGS_ARE_XY_VALUES</span>
            <span class="s2">if </span><span class="s3">(-</span><span class="s6">128 </span><span class="s3">&lt;= </span><span class="s1">x </span><span class="s3">&lt;= </span><span class="s6">127</span><span class="s3">) </span><span class="s2">and </span><span class="s3">(-</span><span class="s6">128 </span><span class="s3">&lt;= </span><span class="s1">y </span><span class="s3">&lt;= </span><span class="s6">127</span><span class="s3">):</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data </span><span class="s3">+ </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s5">&quot;&gt;bb&quot;</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data </span><span class="s3">+ </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s5">&quot;&gt;hh&quot;</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
                <span class="s1">flags </span><span class="s3">= </span><span class="s1">flags </span><span class="s3">| </span><span class="s1">ARG_1_AND_2_ARE_WORDS</span>

        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;transform&quot;</span><span class="s3">):</span>
            <span class="s1">transform </span><span class="s3">= [[</span><span class="s1">fl2fi</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s6">14</span><span class="s3">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">row</span><span class="s3">] </span><span class="s2">for </span><span class="s1">row </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">transform</span><span class="s3">]</span>
            <span class="s2">if </span><span class="s1">transform</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s6">1</span><span class="s3">] </span><span class="s2">or </span><span class="s1">transform</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][</span><span class="s6">0</span><span class="s3">]:</span>
                <span class="s1">flags </span><span class="s3">= </span><span class="s1">flags </span><span class="s3">| </span><span class="s1">WE_HAVE_A_TWO_BY_TWO</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data </span><span class="s3">+ </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span>
                    <span class="s5">&quot;&gt;hhhh&quot;</span><span class="s3">,</span>
                    <span class="s1">transform</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s6">0</span><span class="s3">],</span>
                    <span class="s1">transform</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s6">1</span><span class="s3">],</span>
                    <span class="s1">transform</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][</span><span class="s6">0</span><span class="s3">],</span>
                    <span class="s1">transform</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][</span><span class="s6">1</span><span class="s3">],</span>
                <span class="s3">)</span>
            <span class="s2">elif </span><span class="s1">transform</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s6">0</span><span class="s3">] != </span><span class="s1">transform</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][</span><span class="s6">1</span><span class="s3">]:</span>
                <span class="s1">flags </span><span class="s3">= </span><span class="s1">flags </span><span class="s3">| </span><span class="s1">WE_HAVE_AN_X_AND_Y_SCALE</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data </span><span class="s3">+ </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s5">&quot;&gt;hh&quot;</span><span class="s3">, </span><span class="s1">transform</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s6">0</span><span class="s3">], </span><span class="s1">transform</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][</span><span class="s6">1</span><span class="s3">])</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">flags </span><span class="s3">= </span><span class="s1">flags </span><span class="s3">| </span><span class="s1">WE_HAVE_A_SCALE</span>
                <span class="s1">data </span><span class="s3">= </span><span class="s1">data </span><span class="s3">+ </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s5">&quot;&gt;h&quot;</span><span class="s3">, </span><span class="s1">transform</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s6">0</span><span class="s3">])</span>

        <span class="s1">glyphID </span><span class="s3">= </span><span class="s1">glyfTable</span><span class="s3">.</span><span class="s1">getGlyphID</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphName</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">struct</span><span class="s3">.</span><span class="s1">pack</span><span class="s3">(</span><span class="s5">&quot;&gt;HH&quot;</span><span class="s3">, </span><span class="s1">flags</span><span class="s3">, </span><span class="s1">glyphID</span><span class="s3">) + </span><span class="s1">data</span>

    <span class="s2">def </span><span class="s1">toXML</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">writer</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">):</span>
        <span class="s1">attrs </span><span class="s3">= [(</span><span class="s5">&quot;glyphName&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">glyphName</span><span class="s3">)]</span>
        <span class="s2">if not </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;firstPt&quot;</span><span class="s3">):</span>
            <span class="s1">attrs </span><span class="s3">= </span><span class="s1">attrs </span><span class="s3">+ [(</span><span class="s5">&quot;x&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">x</span><span class="s3">), (</span><span class="s5">&quot;y&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">y</span><span class="s3">)]</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">attrs </span><span class="s3">= </span><span class="s1">attrs </span><span class="s3">+ [(</span><span class="s5">&quot;firstPt&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">firstPt</span><span class="s3">), (</span><span class="s5">&quot;secondPt&quot;</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">secondPt</span><span class="s3">)]</span>

        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s5">&quot;transform&quot;</span><span class="s3">):</span>
            <span class="s1">transform </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">transform</span>
            <span class="s2">if </span><span class="s1">transform</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s6">1</span><span class="s3">] </span><span class="s2">or </span><span class="s1">transform</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][</span><span class="s6">0</span><span class="s3">]:</span>
                <span class="s1">attrs </span><span class="s3">= </span><span class="s1">attrs </span><span class="s3">+ [</span>
                    <span class="s3">(</span><span class="s5">&quot;scalex&quot;</span><span class="s3">, </span><span class="s1">fl2str</span><span class="s3">(</span><span class="s1">transform</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s6">0</span><span class="s3">], </span><span class="s6">14</span><span class="s3">)),</span>
                    <span class="s3">(</span><span class="s5">&quot;scale01&quot;</span><span class="s3">, </span><span class="s1">fl2str</span><span class="s3">(</span><span class="s1">transform</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s6">1</span><span class="s3">], </span><span class="s6">14</span><span class="s3">)),</span>
                    <span class="s3">(</span><span class="s5">&quot;scale10&quot;</span><span class="s3">, </span><span class="s1">fl2str</span><span class="s3">(</span><span class="s1">transform</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][</span><span class="s6">0</span><span class="s3">], </span><span class="s6">14</span><span class="s3">)),</span>
                    <span class="s3">(</span><span class="s5">&quot;scaley&quot;</span><span class="s3">, </span><span class="s1">fl2str</span><span class="s3">(</span><span class="s1">transform</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][</span><span class="s6">1</span><span class="s3">], </span><span class="s6">14</span><span class="s3">)),</span>
                <span class="s3">]</span>
            <span class="s2">elif </span><span class="s1">transform</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s6">0</span><span class="s3">] != </span><span class="s1">transform</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][</span><span class="s6">1</span><span class="s3">]:</span>
                <span class="s1">attrs </span><span class="s3">= </span><span class="s1">attrs </span><span class="s3">+ [</span>
                    <span class="s3">(</span><span class="s5">&quot;scalex&quot;</span><span class="s3">, </span><span class="s1">fl2str</span><span class="s3">(</span><span class="s1">transform</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s6">0</span><span class="s3">], </span><span class="s6">14</span><span class="s3">)),</span>
                    <span class="s3">(</span><span class="s5">&quot;scaley&quot;</span><span class="s3">, </span><span class="s1">fl2str</span><span class="s3">(</span><span class="s1">transform</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][</span><span class="s6">1</span><span class="s3">], </span><span class="s6">14</span><span class="s3">)),</span>
                <span class="s3">]</span>
            <span class="s2">else</span><span class="s3">:</span>
                <span class="s1">attrs </span><span class="s3">= </span><span class="s1">attrs </span><span class="s3">+ [(</span><span class="s5">&quot;scale&quot;</span><span class="s3">, </span><span class="s1">fl2str</span><span class="s3">(</span><span class="s1">transform</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s6">0</span><span class="s3">], </span><span class="s6">14</span><span class="s3">))]</span>
        <span class="s1">attrs </span><span class="s3">= </span><span class="s1">attrs </span><span class="s3">+ [(</span><span class="s5">&quot;flags&quot;</span><span class="s3">, </span><span class="s1">hex</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">flags</span><span class="s3">))]</span>
        <span class="s1">writer</span><span class="s3">.</span><span class="s1">simpletag</span><span class="s3">(</span><span class="s5">&quot;component&quot;</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">)</span>
        <span class="s1">writer</span><span class="s3">.</span><span class="s1">newline</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">fromXML</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">, </span><span class="s1">content</span><span class="s3">, </span><span class="s1">ttFont</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">glyphName </span><span class="s3">= </span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;glyphName&quot;</span><span class="s3">]</span>
        <span class="s2">if </span><span class="s5">&quot;firstPt&quot; </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">firstPt </span><span class="s3">= </span><span class="s1">safeEval</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;firstPt&quot;</span><span class="s3">])</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">secondPt </span><span class="s3">= </span><span class="s1">safeEval</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;secondPt&quot;</span><span class="s3">])</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">x </span><span class="s3">= </span><span class="s1">safeEval</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;x&quot;</span><span class="s3">])</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">y </span><span class="s3">= </span><span class="s1">safeEval</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;y&quot;</span><span class="s3">])</span>
        <span class="s2">if </span><span class="s5">&quot;scale01&quot; </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
            <span class="s1">scalex </span><span class="s3">= </span><span class="s1">str2fl</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;scalex&quot;</span><span class="s3">], </span><span class="s6">14</span><span class="s3">)</span>
            <span class="s1">scale01 </span><span class="s3">= </span><span class="s1">str2fl</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;scale01&quot;</span><span class="s3">], </span><span class="s6">14</span><span class="s3">)</span>
            <span class="s1">scale10 </span><span class="s3">= </span><span class="s1">str2fl</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;scale10&quot;</span><span class="s3">], </span><span class="s6">14</span><span class="s3">)</span>
            <span class="s1">scaley </span><span class="s3">= </span><span class="s1">str2fl</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;scaley&quot;</span><span class="s3">], </span><span class="s6">14</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">transform </span><span class="s3">= [[</span><span class="s1">scalex</span><span class="s3">, </span><span class="s1">scale01</span><span class="s3">], [</span><span class="s1">scale10</span><span class="s3">, </span><span class="s1">scaley</span><span class="s3">]]</span>
        <span class="s2">elif </span><span class="s5">&quot;scalex&quot; </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
            <span class="s1">scalex </span><span class="s3">= </span><span class="s1">str2fl</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;scalex&quot;</span><span class="s3">], </span><span class="s6">14</span><span class="s3">)</span>
            <span class="s1">scaley </span><span class="s3">= </span><span class="s1">str2fl</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;scaley&quot;</span><span class="s3">], </span><span class="s6">14</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">transform </span><span class="s3">= [[</span><span class="s1">scalex</span><span class="s3">, </span><span class="s6">0</span><span class="s3">], [</span><span class="s6">0</span><span class="s3">, </span><span class="s1">scaley</span><span class="s3">]]</span>
        <span class="s2">elif </span><span class="s5">&quot;scale&quot; </span><span class="s2">in </span><span class="s1">attrs</span><span class="s3">:</span>
            <span class="s1">scale </span><span class="s3">= </span><span class="s1">str2fl</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;scale&quot;</span><span class="s3">], </span><span class="s6">14</span><span class="s3">)</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">transform </span><span class="s3">= [[</span><span class="s1">scale</span><span class="s3">, </span><span class="s6">0</span><span class="s3">], [</span><span class="s6">0</span><span class="s3">, </span><span class="s1">scale</span><span class="s3">]]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">flags </span><span class="s3">= </span><span class="s1">safeEval</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s5">&quot;flags&quot;</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">__eq__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) != </span><span class="s1">type</span><span class="s3">(</span><span class="s1">other</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__dict__ </span><span class="s3">== </span><span class="s1">other</span><span class="s3">.</span><span class="s1">__dict__</span>

    <span class="s2">def </span><span class="s1">__ne__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__eq__</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">result </span><span class="s2">if </span><span class="s1">result </span><span class="s2">is </span><span class="s1">NotImplemented </span><span class="s2">else not </span><span class="s1">result</span>


<span class="s2">class </span><span class="s1">GlyphCoordinates</span><span class="s3">(</span><span class="s1">object</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;A list of glyph coordinates. 
 
    Unlike an ordinary list, this is a numpy-like matrix object which supports 
    matrix addition, scalar multiplication and other operations described below. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">iterable</span><span class="s3">=[]):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_a </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s5">&quot;d&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">iterable</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">array</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Returns the underlying array of coordinates&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span>

    <span class="s3">@</span><span class="s1">staticmethod</span>
    <span class="s2">def </span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">count</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Creates a new ``GlyphCoordinates`` object with all coordinates set to (0,0)&quot;&quot;&quot;</span>
        <span class="s1">g </span><span class="s3">= </span><span class="s1">GlyphCoordinates</span><span class="s3">()</span>
        <span class="s1">g</span><span class="s3">.</span><span class="s1">_a</span><span class="s3">.</span><span class="s1">frombytes</span><span class="s3">(</span><span class="s1">bytes</span><span class="s3">(</span><span class="s1">count </span><span class="s3">* </span><span class="s6">2 </span><span class="s3">* </span><span class="s1">g</span><span class="s3">.</span><span class="s1">_a</span><span class="s3">.</span><span class="s1">itemsize</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">g</span>

    <span class="s2">def </span><span class="s1">copy</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Creates a new ``GlyphCoordinates`` object which is a copy of the current one.&quot;&quot;&quot;</span>
        <span class="s1">c </span><span class="s3">= </span><span class="s1">GlyphCoordinates</span><span class="s3">()</span>
        <span class="s1">c</span><span class="s3">.</span><span class="s1">_a</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">c</span>

    <span class="s2">def </span><span class="s1">__len__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Returns the number of coordinates in the array.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span><span class="s3">) // </span><span class="s6">2</span>

    <span class="s2">def </span><span class="s1">__getitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Returns a two element tuple (x,y)&quot;&quot;&quot;</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">):</span>
            <span class="s1">indices </span><span class="s3">= </span><span class="s1">range</span><span class="s3">(*</span><span class="s1">k</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)))</span>
            <span class="s4"># Instead of calling ourselves recursively, duplicate code; faster</span>
            <span class="s1">ret </span><span class="s3">= []</span>
            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">indices</span><span class="s3">:</span>
                <span class="s1">x </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s6">2 </span><span class="s3">* </span><span class="s1">k</span><span class="s3">]</span>
                <span class="s1">y </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s6">2 </span><span class="s3">* </span><span class="s1">k </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">]</span>
                <span class="s1">ret</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span>
                    <span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">is_integer</span><span class="s3">() </span><span class="s2">else </span><span class="s1">x</span><span class="s3">, </span><span class="s1">int</span><span class="s3">(</span><span class="s1">y</span><span class="s3">) </span><span class="s2">if </span><span class="s1">y</span><span class="s3">.</span><span class="s1">is_integer</span><span class="s3">() </span><span class="s2">else </span><span class="s1">y</span><span class="s3">)</span>
                <span class="s3">)</span>
            <span class="s2">return </span><span class="s1">ret</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s6">2 </span><span class="s3">* </span><span class="s1">k</span><span class="s3">]</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s6">2 </span><span class="s3">* </span><span class="s1">k </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">int</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) </span><span class="s2">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">is_integer</span><span class="s3">() </span><span class="s2">else </span><span class="s1">x</span><span class="s3">, </span><span class="s1">int</span><span class="s3">(</span><span class="s1">y</span><span class="s3">) </span><span class="s2">if </span><span class="s1">y</span><span class="s3">.</span><span class="s1">is_integer</span><span class="s3">() </span><span class="s2">else </span><span class="s1">y</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__setitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">v</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Sets a point's coordinates to a two element tuple (x,y)&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">slice</span><span class="s3">):</span>
            <span class="s1">indices </span><span class="s3">= </span><span class="s1">range</span><span class="s3">(*</span><span class="s1">k</span><span class="s3">.</span><span class="s1">indices</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">)))</span>
            <span class="s4"># XXX This only works if len(v) == len(indices)</span>
            <span class="s2">for </span><span class="s1">j</span><span class="s3">, </span><span class="s1">i </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">indices</span><span class="s3">):</span>
                <span class="s1">self</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">v</span><span class="s3">[</span><span class="s1">j</span><span class="s3">]</span>
            <span class="s2">return</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span><span class="s3">[</span><span class="s6">2 </span><span class="s3">* </span><span class="s1">k</span><span class="s3">], </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span><span class="s3">[</span><span class="s6">2 </span><span class="s3">* </span><span class="s1">k </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">] = </span><span class="s1">v</span>

    <span class="s2">def </span><span class="s1">__delitem__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">i</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Removes a point from the list&quot;&quot;&quot;</span>
        <span class="s1">i </span><span class="s3">= (</span><span class="s6">2 </span><span class="s3">* </span><span class="s1">i</span><span class="s3">) % </span><span class="s1">len</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span><span class="s3">)</span>
        <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s2">del </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>

    <span class="s2">def </span><span class="s1">__repr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s5">&quot;GlyphCoordinates([&quot; </span><span class="s3">+ </span><span class="s5">&quot;,&quot;</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">str</span><span class="s3">(</span><span class="s1">c</span><span class="s3">) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self</span><span class="s3">) + </span><span class="s5">&quot;])&quot;</span>

    <span class="s2">def </span><span class="s1">append</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">p</span><span class="s3">))</span>

    <span class="s2">def </span><span class="s1">extend</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">iterable</span><span class="s3">):</span>
        <span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">iterable</span><span class="s3">:</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span><span class="s3">.</span><span class="s1">extend</span><span class="s3">(</span><span class="s1">p</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">toInt</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *, </span><span class="s1">round</span><span class="s3">=</span><span class="s1">otRound</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">round </span><span class="s2">is </span><span class="s1">noRound</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)):</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">round</span><span class="s3">(</span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">])</span>

    <span class="s2">def </span><span class="s1">calcBounds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span>
        <span class="s2">if not </span><span class="s1">a</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span>
        <span class="s1">xs </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s6">0</span><span class="s3">::</span><span class="s6">2</span><span class="s3">]</span>
        <span class="s1">ys </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s6">1</span><span class="s3">::</span><span class="s6">2</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">min</span><span class="s3">(</span><span class="s1">xs</span><span class="s3">), </span><span class="s1">min</span><span class="s3">(</span><span class="s1">ys</span><span class="s3">), </span><span class="s1">max</span><span class="s3">(</span><span class="s1">xs</span><span class="s3">), </span><span class="s1">max</span><span class="s3">(</span><span class="s1">ys</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">calcIntBounds</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">round</span><span class="s3">=</span><span class="s1">otRound</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">round</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) </span><span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">calcBounds</span><span class="s3">())</span>

    <span class="s2">def </span><span class="s1">relativeToAbsolute</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s6">2</span><span class="s3">):</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">x </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] + </span><span class="s1">x</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">] = </span><span class="s1">y </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">] + </span><span class="s1">y</span>

    <span class="s2">def </span><span class="s1">absoluteToRelative</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s6">2</span><span class="s3">):</span>
            <span class="s1">nx </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s1">ny </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">]</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">nx </span><span class="s3">- </span><span class="s1">x</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">] = </span><span class="s1">ny </span><span class="s3">- </span><span class="s1">y</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">nx</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s1">ny</span>

    <span class="s2">def </span><span class="s1">translate</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        &gt;&gt;&gt; GlyphCoordinates([(1,2)]).translate((.5,0)) 
        &quot;&quot;&quot;</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">p</span>
        <span class="s2">if </span><span class="s1">x </span><span class="s3">== </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">y </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s6">2</span><span class="s3">):</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] += </span><span class="s1">x</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">] += </span><span class="s1">y</span>

    <span class="s2">def </span><span class="s1">scale</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">p</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        &gt;&gt;&gt; GlyphCoordinates([(1,2)]).scale((.5,0)) 
        &quot;&quot;&quot;</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">p</span>
        <span class="s2">if </span><span class="s1">x </span><span class="s3">== </span><span class="s6">1 </span><span class="s2">and </span><span class="s1">y </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s2">return</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s6">2</span><span class="s3">):</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] *= </span><span class="s1">x</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">] *= </span><span class="s1">y</span>

    <span class="s2">def </span><span class="s1">transform</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">t</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        &gt;&gt;&gt; GlyphCoordinates([(1,2)]).transform(((.5,0),(.2,.5))) 
        &quot;&quot;&quot;</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s6">2</span><span class="s3">):</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s1">a</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">]</span>
            <span class="s1">px </span><span class="s3">= </span><span class="s1">x </span><span class="s3">* </span><span class="s1">t</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s6">0</span><span class="s3">] + </span><span class="s1">y </span><span class="s3">* </span><span class="s1">t</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][</span><span class="s6">0</span><span class="s3">]</span>
            <span class="s1">py </span><span class="s3">= </span><span class="s1">x </span><span class="s3">* </span><span class="s1">t</span><span class="s3">[</span><span class="s6">0</span><span class="s3">][</span><span class="s6">1</span><span class="s3">] + </span><span class="s1">y </span><span class="s3">* </span><span class="s1">t</span><span class="s3">[</span><span class="s6">1</span><span class="s3">][</span><span class="s6">1</span><span class="s3">]</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">px</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">i </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">] = </span><span class="s1">py</span>

    <span class="s2">def </span><span class="s1">__eq__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        &gt;&gt;&gt; g = GlyphCoordinates([(1,2)]) 
        &gt;&gt;&gt; g2 = GlyphCoordinates([(1.0,2)]) 
        &gt;&gt;&gt; g3 = GlyphCoordinates([(1.5,2)]) 
        &gt;&gt;&gt; g == g2 
        True 
        &gt;&gt;&gt; g == g3 
        False 
        &gt;&gt;&gt; g2 == g3 
        False 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">type</span><span class="s3">(</span><span class="s1">self</span><span class="s3">) != </span><span class="s1">type</span><span class="s3">(</span><span class="s1">other</span><span class="s3">):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a </span><span class="s3">== </span><span class="s1">other</span><span class="s3">.</span><span class="s1">_a</span>

    <span class="s2">def </span><span class="s1">__ne__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        &gt;&gt;&gt; g = GlyphCoordinates([(1,2)]) 
        &gt;&gt;&gt; g2 = GlyphCoordinates([(1.0,2)]) 
        &gt;&gt;&gt; g3 = GlyphCoordinates([(1.5,2)]) 
        &gt;&gt;&gt; g != g2 
        False 
        &gt;&gt;&gt; g != g3 
        True 
        &gt;&gt;&gt; g2 != g3 
        True 
        &quot;&quot;&quot;</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__eq__</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">result </span><span class="s2">if </span><span class="s1">result </span><span class="s2">is </span><span class="s1">NotImplemented </span><span class="s2">else not </span><span class="s1">result</span>

    <span class="s4"># Math operations</span>

    <span class="s2">def </span><span class="s1">__pos__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        &gt;&gt;&gt; g = GlyphCoordinates([(1,2)]) 
        &gt;&gt;&gt; g 
        GlyphCoordinates([(1, 2)]) 
        &gt;&gt;&gt; g2 = +g 
        &gt;&gt;&gt; g2 
        GlyphCoordinates([(1, 2)]) 
        &gt;&gt;&gt; g2.translate((1,0)) 
        &gt;&gt;&gt; g2 
        GlyphCoordinates([(2, 2)]) 
        &gt;&gt;&gt; g 
        GlyphCoordinates([(1, 2)]) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>

    <span class="s2">def </span><span class="s1">__neg__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        &gt;&gt;&gt; g = GlyphCoordinates([(1,2)]) 
        &gt;&gt;&gt; g 
        GlyphCoordinates([(1, 2)]) 
        &gt;&gt;&gt; g2 = -g 
        &gt;&gt;&gt; g2 
        GlyphCoordinates([(-1, -2)]) 
        &gt;&gt;&gt; g 
        GlyphCoordinates([(1, 2)]) 
        &quot;&quot;&quot;</span>
        <span class="s1">r </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">a </span><span class="s3">= </span><span class="s1">r</span><span class="s3">.</span><span class="s1">_a</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)):</span>
            <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = -</span><span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
        <span class="s2">return </span><span class="s1">r</span>

    <span class="s2">def </span><span class="s1">__round__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, *, </span><span class="s1">round</span><span class="s3">=</span><span class="s1">otRound</span><span class="s3">):</span>
        <span class="s1">r </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s1">r</span><span class="s3">.</span><span class="s1">toInt</span><span class="s3">(</span><span class="s1">round</span><span class="s3">=</span><span class="s1">round</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">r</span>

    <span class="s2">def </span><span class="s1">__add__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">().</span><span class="s1">__iadd__</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__sub__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">().</span><span class="s1">__isub__</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__mul__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">().</span><span class="s1">__imul__</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__truediv__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">().</span><span class="s1">__itruediv__</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>

    <span class="s1">__radd__ </span><span class="s3">= </span><span class="s1">__add__</span>
    <span class="s1">__rmul__ </span><span class="s3">= </span><span class="s1">__mul__</span>

    <span class="s2">def </span><span class="s1">__rsub__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">other </span><span class="s3">+ (-</span><span class="s1">self</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__iadd__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        &gt;&gt;&gt; g = GlyphCoordinates([(1,2)]) 
        &gt;&gt;&gt; g += (.5,0) 
        &gt;&gt;&gt; g 
        GlyphCoordinates([(1.5, 2)]) 
        &gt;&gt;&gt; g2 = GlyphCoordinates([(3,4)]) 
        &gt;&gt;&gt; g += g2 
        &gt;&gt;&gt; g 
        GlyphCoordinates([(4.5, 6)]) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">other</span><span class="s3">) == </span><span class="s6">2</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">translate</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">GlyphCoordinates</span><span class="s3">):</span>
            <span class="s1">other </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">_a</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)):</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] += </span><span class="s1">other</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">def </span><span class="s1">__isub__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        &gt;&gt;&gt; g = GlyphCoordinates([(1,2)]) 
        &gt;&gt;&gt; g -= (.5,0) 
        &gt;&gt;&gt; g 
        GlyphCoordinates([(0.5, 2)]) 
        &gt;&gt;&gt; g2 = GlyphCoordinates([(3,4)]) 
        &gt;&gt;&gt; g -= g2 
        &gt;&gt;&gt; g 
        GlyphCoordinates([(-2.5, -2)]) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">other</span><span class="s3">) == </span><span class="s6">2</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">translate</span><span class="s3">((-</span><span class="s1">other</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], -</span><span class="s1">other</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]))</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">GlyphCoordinates</span><span class="s3">):</span>
            <span class="s1">other </span><span class="s3">= </span><span class="s1">other</span><span class="s3">.</span><span class="s1">_a</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) == </span><span class="s1">len</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)):</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] -= </span><span class="s1">other</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">def </span><span class="s1">__imul__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        &gt;&gt;&gt; g = GlyphCoordinates([(1,2)]) 
        &gt;&gt;&gt; g *= (2,.5) 
        &gt;&gt;&gt; g *= 2 
        &gt;&gt;&gt; g 
        GlyphCoordinates([(4, 2)]) 
        &gt;&gt;&gt; g = GlyphCoordinates([(1,2)]) 
        &gt;&gt;&gt; g *= 2 
        &gt;&gt;&gt; g 
        GlyphCoordinates([(2, 4)]) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">other</span><span class="s3">) == </span><span class="s6">2</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">scale</span><span class="s3">(</span><span class="s1">other</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">Number</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">other </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
                <span class="s2">return </span><span class="s1">self</span>
            <span class="s1">a </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)):</span>
                <span class="s1">a</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] *= </span><span class="s1">other</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">def </span><span class="s1">__itruediv__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        &gt;&gt;&gt; g = GlyphCoordinates([(1,3)]) 
        &gt;&gt;&gt; g /= (.5,1.5) 
        &gt;&gt;&gt; g /= 2 
        &gt;&gt;&gt; g 
        GlyphCoordinates([(1, 1)]) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">Number</span><span class="s3">):</span>
            <span class="s1">other </span><span class="s3">= (</span><span class="s1">other</span><span class="s3">, </span><span class="s1">other</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">other</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s2">if </span><span class="s1">other </span><span class="s3">== (</span><span class="s6">1</span><span class="s3">, </span><span class="s6">1</span><span class="s3">):</span>
                <span class="s2">return </span><span class="s1">self</span>
            <span class="s2">assert </span><span class="s1">len</span><span class="s3">(</span><span class="s1">other</span><span class="s3">) == </span><span class="s6">2</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">scale</span><span class="s3">((</span><span class="s6">1.0 </span><span class="s3">/ </span><span class="s1">other</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s6">1.0 </span><span class="s3">/ </span><span class="s1">other</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]))</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s2">return </span><span class="s1">NotImplemented</span>

    <span class="s2">def </span><span class="s1">__bool__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        &gt;&gt;&gt; g = GlyphCoordinates([]) 
        &gt;&gt;&gt; bool(g) 
        False 
        &gt;&gt;&gt; g = GlyphCoordinates([(0,0), (0.,0)]) 
        &gt;&gt;&gt; bool(g) 
        True 
        &gt;&gt;&gt; g = GlyphCoordinates([(0,0), (1,0)]) 
        &gt;&gt;&gt; bool(g) 
        True 
        &gt;&gt;&gt; g = GlyphCoordinates([(0,.5), (0,0)]) 
        &gt;&gt;&gt; bool(g) 
        True 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_a</span><span class="s3">)</span>

    <span class="s1">__nonzero__ </span><span class="s3">= </span><span class="s1">__bool__</span>


<span class="s2">if </span><span class="s1">__name__ </span><span class="s3">== </span><span class="s5">&quot;__main__&quot;</span><span class="s3">:</span>
    <span class="s2">import </span><span class="s1">doctest</span><span class="s3">, </span><span class="s1">sys</span>

    <span class="s1">sys</span><span class="s3">.</span><span class="s1">exit</span><span class="s3">(</span><span class="s1">doctest</span><span class="s3">.</span><span class="s1">testmod</span><span class="s3">().</span><span class="s1">failed</span><span class="s3">)</span>
</pre>
</body>
</html>