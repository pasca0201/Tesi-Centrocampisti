<html>
<head>
<title>_mgc.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_mgc.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">_lib</span><span class="s2">.</span><span class="s1">_util </span><span class="s0">import </span><span class="s1">check_random_state</span><span class="s2">, </span><span class="s1">MapWrapper</span><span class="s2">, </span><span class="s1">rng_integers</span><span class="s2">, </span><span class="s1">_contains_nan</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">_lib</span><span class="s2">.</span><span class="s1">_bunch </span><span class="s0">import </span><span class="s1">_make_tuple_bunch</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">spatial</span><span class="s2">.</span><span class="s1">distance </span><span class="s0">import </span><span class="s1">cdist</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">ndimage </span><span class="s0">import </span><span class="s1">_measurements</span>

<span class="s0">from </span><span class="s2">.</span><span class="s1">_stats </span><span class="s0">import </span><span class="s1">_local_correlations  </span><span class="s3"># type: ignore[import-not-found]</span>
<span class="s0">from </span><span class="s2">. </span><span class="s0">import </span><span class="s1">distributions</span>

<span class="s1">__all__ </span><span class="s2">= [</span><span class="s4">'multiscale_graphcorr'</span><span class="s2">]</span>

<span class="s3"># FROM MGCPY: https://github.com/neurodata/mgcpy</span>


<span class="s0">class </span><span class="s1">_ParallelP</span><span class="s2">:</span>
    <span class="s5">&quot;&quot;&quot;Helper function to calculate parallel p-value.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">random_states</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">x </span><span class="s2">= </span><span class="s1">x</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">y </span><span class="s2">= </span><span class="s1">y</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">random_states </span><span class="s2">= </span><span class="s1">random_states</span>

    <span class="s0">def </span><span class="s1">__call__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">index</span><span class="s2">):</span>
        <span class="s1">order </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">random_states</span><span class="s2">[</span><span class="s1">index</span><span class="s2">].</span><span class="s1">permutation</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">])</span>
        <span class="s1">permy </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">y</span><span class="s2">[</span><span class="s1">order</span><span class="s2">][:, </span><span class="s1">order</span><span class="s2">]</span>

        <span class="s3"># calculate permuted stats, store in null distribution</span>
        <span class="s1">perm_stat </span><span class="s2">= </span><span class="s1">_mgc_stat</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">x</span><span class="s2">, </span><span class="s1">permy</span><span class="s2">)[</span><span class="s6">0</span><span class="s2">]</span>

        <span class="s0">return </span><span class="s1">perm_stat</span>


<span class="s0">def </span><span class="s1">_perm_test</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">stat</span><span class="s2">, </span><span class="s1">reps</span><span class="s2">=</span><span class="s6">1000</span><span class="s2">, </span><span class="s1">workers</span><span class="s2">=-</span><span class="s6">1</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s5">r&quot;&quot;&quot;Helper function that calculates the p-value. See below for uses. 
 
    Parameters 
    ---------- 
    x, y : ndarray 
        `x` and `y` have shapes `(n, p)` and `(n, q)`. 
    stat : float 
        The sample test statistic. 
    reps : int, optional 
        The number of replications used to estimate the null when using the 
        permutation test. The default is 1000 replications. 
    workers : int or map-like callable, optional 
        If `workers` is an int the population is subdivided into `workers` 
        sections and evaluated in parallel (uses 
        `multiprocessing.Pool &lt;multiprocessing&gt;`). Supply `-1` to use all cores 
        available to the Process. Alternatively supply a map-like callable, 
        such as `multiprocessing.Pool.map` for evaluating the population in 
        parallel. This evaluation is carried out as `workers(func, iterable)`. 
        Requires that `func` be pickleable. 
    random_state : {None, int, `numpy.random.Generator`, 
                    `numpy.random.RandomState`}, optional 
 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``RandomState`` instance is used, 
        seeded with `seed`. 
        If `seed` is already a ``Generator`` or ``RandomState`` instance then 
        that instance is used. 
 
    Returns 
    ------- 
    pvalue : float 
        The sample test p-value. 
    null_dist : list 
        The approximated null distribution. 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># generate seeds for each rep (change to new parallel random number</span>
    <span class="s3"># capabilities in numpy &gt;= 1.17+)</span>
    <span class="s1">random_state </span><span class="s2">= </span><span class="s1">check_random_state</span><span class="s2">(</span><span class="s1">random_state</span><span class="s2">)</span>
    <span class="s1">random_states </span><span class="s2">= [</span><span class="s1">np</span><span class="s2">.</span><span class="s1">random</span><span class="s2">.</span><span class="s1">RandomState</span><span class="s2">(</span><span class="s1">rng_integers</span><span class="s2">(</span><span class="s1">random_state</span><span class="s2">, </span><span class="s6">1 </span><span class="s2">&lt;&lt; </span><span class="s6">32</span><span class="s2">,</span>
                     <span class="s1">size</span><span class="s2">=</span><span class="s6">4</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">uint32</span><span class="s2">)) </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">reps</span><span class="s2">)]</span>

    <span class="s3"># parallelizes with specified workers over number of reps and set seeds</span>
    <span class="s1">parallelp </span><span class="s2">= </span><span class="s1">_ParallelP</span><span class="s2">(</span><span class="s1">x</span><span class="s2">=</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">=</span><span class="s1">y</span><span class="s2">, </span><span class="s1">random_states</span><span class="s2">=</span><span class="s1">random_states</span><span class="s2">)</span>
    <span class="s0">with </span><span class="s1">MapWrapper</span><span class="s2">(</span><span class="s1">workers</span><span class="s2">) </span><span class="s0">as </span><span class="s1">mapwrapper</span><span class="s2">:</span>
        <span class="s1">null_dist </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">list</span><span class="s2">(</span><span class="s1">mapwrapper</span><span class="s2">(</span><span class="s1">parallelp</span><span class="s2">, </span><span class="s1">range</span><span class="s2">(</span><span class="s1">reps</span><span class="s2">))))</span>

    <span class="s3"># calculate p-value and significant permutation map through list</span>
    <span class="s1">pvalue </span><span class="s2">= (</span><span class="s6">1 </span><span class="s2">+ (</span><span class="s1">null_dist </span><span class="s2">&gt;= </span><span class="s1">stat</span><span class="s2">).</span><span class="s1">sum</span><span class="s2">()) / (</span><span class="s6">1 </span><span class="s2">+ </span><span class="s1">reps</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">pvalue</span><span class="s2">, </span><span class="s1">null_dist</span>


<span class="s0">def </span><span class="s1">_euclidean_dist</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">cdist</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">x</span><span class="s2">)</span>


<span class="s1">MGCResult </span><span class="s2">= </span><span class="s1">_make_tuple_bunch</span><span class="s2">(</span><span class="s4">'MGCResult'</span><span class="s2">,</span>
                              <span class="s2">[</span><span class="s4">'statistic'</span><span class="s2">, </span><span class="s4">'pvalue'</span><span class="s2">, </span><span class="s4">'mgc_dict'</span><span class="s2">], [])</span>


<span class="s0">def </span><span class="s1">multiscale_graphcorr</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">compute_distance</span><span class="s2">=</span><span class="s1">_euclidean_dist</span><span class="s2">, </span><span class="s1">reps</span><span class="s2">=</span><span class="s6">1000</span><span class="s2">,</span>
                         <span class="s1">workers</span><span class="s2">=</span><span class="s6">1</span><span class="s2">, </span><span class="s1">is_twosamp</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
    <span class="s5">r&quot;&quot;&quot;Computes the Multiscale Graph Correlation (MGC) test statistic. 
 
    Specifically, for each point, MGC finds the :math:`k`-nearest neighbors for 
    one property (e.g. cloud density), and the :math:`l`-nearest neighbors for 
    the other property (e.g. grass wetness) [1]_. This pair :math:`(k, l)` is 
    called the &quot;scale&quot;. A priori, however, it is not know which scales will be 
    most informative. So, MGC computes all distance pairs, and then efficiently 
    computes the distance correlations for all scales. The local correlations 
    illustrate which scales are relatively informative about the relationship. 
    The key, therefore, to successfully discover and decipher relationships 
    between disparate data modalities is to adaptively determine which scales 
    are the most informative, and the geometric implication for the most 
    informative scales. Doing so not only provides an estimate of whether the 
    modalities are related, but also provides insight into how the 
    determination was made. This is especially important in high-dimensional 
    data, where simple visualizations do not reveal relationships to the 
    unaided human eye. Characterizations of this implementation in particular 
    have been derived from and benchmarked within in [2]_. 
 
    Parameters 
    ---------- 
    x, y : ndarray 
        If ``x`` and ``y`` have shapes ``(n, p)`` and ``(n, q)`` where `n` is 
        the number of samples and `p` and `q` are the number of dimensions, 
        then the MGC independence test will be run.  Alternatively, ``x`` and 
        ``y`` can have shapes ``(n, n)`` if they are distance or similarity 
        matrices, and ``compute_distance`` must be sent to ``None``. If ``x`` 
        and ``y`` have shapes ``(n, p)`` and ``(m, p)``, an unpaired 
        two-sample MGC test will be run. 
    compute_distance : callable, optional 
        A function that computes the distance or similarity among the samples 
        within each data matrix. Set to ``None`` if ``x`` and ``y`` are 
        already distance matrices. The default uses the euclidean norm metric. 
        If you are calling a custom function, either create the distance 
        matrix before-hand or create a function of the form 
        ``compute_distance(x)`` where `x` is the data matrix for which 
        pairwise distances are calculated. 
    reps : int, optional 
        The number of replications used to estimate the null when using the 
        permutation test. The default is ``1000``. 
    workers : int or map-like callable, optional 
        If ``workers`` is an int the population is subdivided into ``workers`` 
        sections and evaluated in parallel (uses ``multiprocessing.Pool 
        &lt;multiprocessing&gt;``). Supply ``-1`` to use all cores available to the 
        Process. Alternatively supply a map-like callable, such as 
        ``multiprocessing.Pool.map`` for evaluating the p-value in parallel. 
        This evaluation is carried out as ``workers(func, iterable)``. 
        Requires that `func` be pickleable. The default is ``1``. 
    is_twosamp : bool, optional 
        If `True`, a two sample test will be run. If ``x`` and ``y`` have 
        shapes ``(n, p)`` and ``(m, p)``, this optional will be overridden and 
        set to ``True``. Set to ``True`` if ``x`` and ``y`` both have shapes 
        ``(n, p)`` and a two sample test is desired. The default is ``False``. 
        Note that this will not run if inputs are distance matrices. 
    random_state : {None, int, `numpy.random.Generator`, 
                    `numpy.random.RandomState`}, optional 
 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``RandomState`` instance is used, 
        seeded with `seed`. 
        If `seed` is already a ``Generator`` or ``RandomState`` instance then 
        that instance is used. 
 
    Returns 
    ------- 
    res : MGCResult 
        An object containing attributes: 
 
        statistic : float 
            The sample MGC test statistic within `[-1, 1]`. 
        pvalue : float 
            The p-value obtained via permutation. 
        mgc_dict : dict 
            Contains additional useful results: 
 
                - mgc_map : ndarray 
                    A 2D representation of the latent geometry of the 
                    relationship. 
                - opt_scale : (int, int) 
                    The estimated optimal scale as a `(x, y)` pair. 
                - null_dist : list 
                    The null distribution derived from the permuted matrices. 
 
    See Also 
    -------- 
    pearsonr : Pearson correlation coefficient and p-value for testing 
               non-correlation. 
    kendalltau : Calculates Kendall's tau. 
    spearmanr : Calculates a Spearman rank-order correlation coefficient. 
 
    Notes 
    ----- 
    A description of the process of MGC and applications on neuroscience data 
    can be found in [1]_. It is performed using the following steps: 
 
    #. Two distance matrices :math:`D^X` and :math:`D^Y` are computed and 
       modified to be mean zero columnwise. This results in two 
       :math:`n \times n` distance matrices :math:`A` and :math:`B` (the 
       centering and unbiased modification) [3]_. 
 
    #. For all values :math:`k` and :math:`l` from :math:`1, ..., n`, 
 
       * The :math:`k`-nearest neighbor and :math:`l`-nearest neighbor graphs 
         are calculated for each property. Here, :math:`G_k (i, j)` indicates 
         the :math:`k`-smallest values of the :math:`i`-th row of :math:`A` 
         and :math:`H_l (i, j)` indicates the :math:`l` smallested values of 
         the :math:`i`-th row of :math:`B` 
 
       * Let :math:`\circ` denotes the entry-wise matrix product, then local 
         correlations are summed and normalized using the following statistic: 
 
    .. math:: 
 
        c^{kl} = \frac{\sum_{ij} A G_k B H_l} 
                      {\sqrt{\sum_{ij} A^2 G_k \times \sum_{ij} B^2 H_l}} 
 
    #. The MGC test statistic is the smoothed optimal local correlation of 
       :math:`\{ c^{kl} \}`. Denote the smoothing operation as :math:`R(\cdot)` 
       (which essentially set all isolated large correlations) as 0 and 
       connected large correlations the same as before, see [3]_.) MGC is, 
 
    .. math:: 
 
        MGC_n (x, y) = \max_{(k, l)} R \left(c^{kl} \left( x_n, y_n \right) 
                                                    \right) 
 
    The test statistic returns a value between :math:`(-1, 1)` since it is 
    normalized. 
 
    The p-value returned is calculated using a permutation test. This process 
    is completed by first randomly permuting :math:`y` to estimate the null 
    distribution and then calculating the probability of observing a test 
    statistic, under the null, at least as extreme as the observed test 
    statistic. 
 
    MGC requires at least 5 samples to run with reliable results. It can also 
    handle high-dimensional data sets. 
    In addition, by manipulating the input data matrices, the two-sample 
    testing problem can be reduced to the independence testing problem [4]_. 
    Given sample data :math:`U` and :math:`V` of sizes :math:`p \times n` 
    :math:`p \times m`, data matrix :math:`X` and :math:`Y` can be created as 
    follows: 
 
    .. math:: 
 
        X = [U | V] \in \mathcal{R}^{p \times (n + m)} 
        Y = [0_{1 \times n} | 1_{1 \times m}] \in \mathcal{R}^{(n + m)} 
 
    Then, the MGC statistic can be calculated as normal. This methodology can 
    be extended to similar tests such as distance correlation [4]_. 
 
    .. versionadded:: 1.4.0 
 
    References 
    ---------- 
    .. [1] Vogelstein, J. T., Bridgeford, E. W., Wang, Q., Priebe, C. E., 
           Maggioni, M., &amp; Shen, C. (2019). Discovering and deciphering 
           relationships across disparate data modalities. ELife. 
    .. [2] Panda, S., Palaniappan, S., Xiong, J., Swaminathan, A., 
           Ramachandran, S., Bridgeford, E. W., ... Vogelstein, J. T. (2019). 
           mgcpy: A Comprehensive High Dimensional Independence Testing Python 
           Package. :arXiv:`1907.02088` 
    .. [3] Shen, C., Priebe, C.E., &amp; Vogelstein, J. T. (2019). From distance 
           correlation to multiscale graph correlation. Journal of the American 
           Statistical Association. 
    .. [4] Shen, C. &amp; Vogelstein, J. T. (2018). The Exact Equivalence of 
           Distance and Kernel Methods for Hypothesis Testing. 
           :arXiv:`1806.05514` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.stats import multiscale_graphcorr 
    &gt;&gt;&gt; x = np.arange(100) 
    &gt;&gt;&gt; y = x 
    &gt;&gt;&gt; res = multiscale_graphcorr(x, y) 
    &gt;&gt;&gt; res.statistic, res.pvalue 
    (1.0, 0.001) 
 
    To run an unpaired two-sample test, 
 
    &gt;&gt;&gt; x = np.arange(100) 
    &gt;&gt;&gt; y = np.arange(79) 
    &gt;&gt;&gt; res = multiscale_graphcorr(x, y) 
    &gt;&gt;&gt; res.statistic, res.pvalue  # doctest: +SKIP 
    (0.033258146255703246, 0.023) 
 
    or, if shape of the inputs are the same, 
 
    &gt;&gt;&gt; x = np.arange(100) 
    &gt;&gt;&gt; y = x 
    &gt;&gt;&gt; res = multiscale_graphcorr(x, y, is_twosamp=True) 
    &gt;&gt;&gt; res.statistic, res.pvalue  # doctest: +SKIP 
    (-0.008021809890200488, 1.0) 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">) </span><span class="s0">or not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;x and y must be ndarrays&quot;</span><span class="s2">)</span>

    <span class="s3"># convert arrays of type (n,) to (n, 1)</span>
    <span class="s0">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">x</span><span class="s2">[:, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">]</span>
    <span class="s0">elif </span><span class="s1">x</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s6">2</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">f&quot;Expected a 2-D array `x`, found shape </span><span class="s0">{</span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s2">)</span>
    <span class="s0">if </span><span class="s1">y</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">y</span><span class="s2">[:, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">newaxis</span><span class="s2">]</span>
    <span class="s0">elif </span><span class="s1">y</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">!= </span><span class="s6">2</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">f&quot;Expected a 2-D array `y`, found shape </span><span class="s0">{</span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s2">)</span>

    <span class="s1">nx</span><span class="s2">, </span><span class="s1">px </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span>
    <span class="s1">ny</span><span class="s2">, </span><span class="s1">py </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">shape</span>

    <span class="s3"># check for NaNs</span>
    <span class="s1">_contains_nan</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">nan_policy</span><span class="s2">=</span><span class="s4">'raise'</span><span class="s2">)</span>
    <span class="s1">_contains_nan</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">nan_policy</span><span class="s2">=</span><span class="s4">'raise'</span><span class="s2">)</span>

    <span class="s3"># check for positive or negative infinity and raise error</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)) &gt; </span><span class="s6">0 </span><span class="s0">or </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isinf</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)) &gt; </span><span class="s6">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Inputs contain infinities&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">nx </span><span class="s2">!= </span><span class="s1">ny</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">px </span><span class="s2">== </span><span class="s1">py</span><span class="s2">:</span>
            <span class="s3"># reshape x and y for two sample testing</span>
            <span class="s1">is_twosamp </span><span class="s2">= </span><span class="s0">True</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Shape mismatch, x and y must have shape [n, p] &quot;</span>
                             <span class="s4">&quot;and [n, q] or have shape [n, p] and [m, p].&quot;</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">nx </span><span class="s2">&lt; </span><span class="s6">5 </span><span class="s0">or </span><span class="s1">ny </span><span class="s2">&lt; </span><span class="s6">5</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;MGC requires at least 5 samples to give reasonable &quot;</span>
                         <span class="s4">&quot;results.&quot;</span><span class="s2">)</span>

    <span class="s3"># convert x and y to float</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>

    <span class="s3"># check if compute_distance_matrix if a callable()</span>
    <span class="s0">if not </span><span class="s1">callable</span><span class="s2">(</span><span class="s1">compute_distance</span><span class="s2">) </span><span class="s0">and </span><span class="s1">compute_distance </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Compute_distance must be a function.&quot;</span><span class="s2">)</span>

    <span class="s3"># check if number of reps exists, integer, or &gt; 0 (if under 1000 raises</span>
    <span class="s3"># warning)</span>
    <span class="s0">if not </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">reps</span><span class="s2">, </span><span class="s1">int</span><span class="s2">) </span><span class="s0">or </span><span class="s1">reps </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Number of reps must be an integer greater than 0.&quot;</span><span class="s2">)</span>
    <span class="s0">elif </span><span class="s1">reps </span><span class="s2">&lt; </span><span class="s6">1000</span><span class="s2">:</span>
        <span class="s1">msg </span><span class="s2">= (</span><span class="s4">&quot;The number of replications is low (under 1000), and p-value &quot;</span>
               <span class="s4">&quot;calculations may be unreliable. Use the p-value result, with &quot;</span>
               <span class="s4">&quot;caution!&quot;</span><span class="s2">)</span>
        <span class="s1">warnings</span><span class="s2">.</span><span class="s1">warn</span><span class="s2">(</span><span class="s1">msg</span><span class="s2">, </span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s6">2</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">is_twosamp</span><span class="s2">:</span>
        <span class="s0">if </span><span class="s1">compute_distance </span><span class="s0">is None</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;Cannot run if inputs are distance matrices&quot;</span><span class="s2">)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">= </span><span class="s1">_two_sample_transform</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">compute_distance </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s3"># compute distance matrices for x and y</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">compute_distance</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">compute_distance</span><span class="s2">(</span><span class="s1">y</span><span class="s2">)</span>

    <span class="s3"># calculate MGC stat</span>
    <span class="s1">stat</span><span class="s2">, </span><span class="s1">stat_dict </span><span class="s2">= </span><span class="s1">_mgc_stat</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>
    <span class="s1">stat_mgc_map </span><span class="s2">= </span><span class="s1">stat_dict</span><span class="s2">[</span><span class="s4">&quot;stat_mgc_map&quot;</span><span class="s2">]</span>
    <span class="s1">opt_scale </span><span class="s2">= </span><span class="s1">stat_dict</span><span class="s2">[</span><span class="s4">&quot;opt_scale&quot;</span><span class="s2">]</span>

    <span class="s3"># calculate permutation MGC p-value</span>
    <span class="s1">pvalue</span><span class="s2">, </span><span class="s1">null_dist </span><span class="s2">= </span><span class="s1">_perm_test</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">stat</span><span class="s2">, </span><span class="s1">reps</span><span class="s2">=</span><span class="s1">reps</span><span class="s2">, </span><span class="s1">workers</span><span class="s2">=</span><span class="s1">workers</span><span class="s2">,</span>
                                   <span class="s1">random_state</span><span class="s2">=</span><span class="s1">random_state</span><span class="s2">)</span>

    <span class="s3"># save all stats (other than stat/p-value) in dictionary</span>
    <span class="s1">mgc_dict </span><span class="s2">= {</span><span class="s4">&quot;mgc_map&quot;</span><span class="s2">: </span><span class="s1">stat_mgc_map</span><span class="s2">,</span>
                <span class="s4">&quot;opt_scale&quot;</span><span class="s2">: </span><span class="s1">opt_scale</span><span class="s2">,</span>
                <span class="s4">&quot;null_dist&quot;</span><span class="s2">: </span><span class="s1">null_dist</span><span class="s2">}</span>

    <span class="s3"># create result object with alias for backward compatibility</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">MGCResult</span><span class="s2">(</span><span class="s1">stat</span><span class="s2">, </span><span class="s1">pvalue</span><span class="s2">, </span><span class="s1">mgc_dict</span><span class="s2">)</span>
    <span class="s1">res</span><span class="s2">.</span><span class="s1">stat </span><span class="s2">= </span><span class="s1">stat</span>
    <span class="s0">return </span><span class="s1">res</span>


<span class="s0">def </span><span class="s1">_mgc_stat</span><span class="s2">(</span><span class="s1">distx</span><span class="s2">, </span><span class="s1">disty</span><span class="s2">):</span>
    <span class="s5">r&quot;&quot;&quot;Helper function that calculates the MGC stat. See above for use. 
 
    Parameters 
    ---------- 
    distx, disty : ndarray 
        `distx` and `disty` have shapes `(n, p)` and `(n, q)` or 
        `(n, n)` and `(n, n)` 
        if distance matrices. 
 
    Returns 
    ------- 
    stat : float 
        The sample MGC test statistic within `[-1, 1]`. 
    stat_dict : dict 
        Contains additional useful additional returns containing the following 
        keys: 
 
            - stat_mgc_map : ndarray 
                MGC-map of the statistics. 
            - opt_scale : (float, float) 
                The estimated optimal scale as a `(x, y)` pair. 
 
    &quot;&quot;&quot;</span>
    <span class="s3"># calculate MGC map and optimal scale</span>
    <span class="s1">stat_mgc_map </span><span class="s2">= </span><span class="s1">_local_correlations</span><span class="s2">(</span><span class="s1">distx</span><span class="s2">, </span><span class="s1">disty</span><span class="s2">, </span><span class="s1">global_corr</span><span class="s2">=</span><span class="s4">'mgc'</span><span class="s2">)</span>

    <span class="s1">n</span><span class="s2">, </span><span class="s1">m </span><span class="s2">= </span><span class="s1">stat_mgc_map</span><span class="s2">.</span><span class="s1">shape</span>
    <span class="s0">if </span><span class="s1">m </span><span class="s2">== </span><span class="s6">1 </span><span class="s0">or </span><span class="s1">n </span><span class="s2">== </span><span class="s6">1</span><span class="s2">:</span>
        <span class="s3"># the global scale at is the statistic calculated at maximial nearest</span>
        <span class="s3"># neighbors. There is not enough local scale to search over, so</span>
        <span class="s3"># default to global scale</span>
        <span class="s1">stat </span><span class="s2">= </span><span class="s1">stat_mgc_map</span><span class="s2">[</span><span class="s1">m </span><span class="s2">- </span><span class="s6">1</span><span class="s2">][</span><span class="s1">n </span><span class="s2">- </span><span class="s6">1</span><span class="s2">]</span>
        <span class="s1">opt_scale </span><span class="s2">= </span><span class="s1">m </span><span class="s2">* </span><span class="s1">n</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">samp_size </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">distx</span><span class="s2">) - </span><span class="s6">1</span>

        <span class="s3"># threshold to find connected region of significant local correlations</span>
        <span class="s1">sig_connect </span><span class="s2">= </span><span class="s1">_threshold_mgc_map</span><span class="s2">(</span><span class="s1">stat_mgc_map</span><span class="s2">, </span><span class="s1">samp_size</span><span class="s2">)</span>

        <span class="s3"># maximum within the significant region</span>
        <span class="s1">stat</span><span class="s2">, </span><span class="s1">opt_scale </span><span class="s2">= </span><span class="s1">_smooth_mgc_map</span><span class="s2">(</span><span class="s1">sig_connect</span><span class="s2">, </span><span class="s1">stat_mgc_map</span><span class="s2">)</span>

    <span class="s1">stat_dict </span><span class="s2">= {</span><span class="s4">&quot;stat_mgc_map&quot;</span><span class="s2">: </span><span class="s1">stat_mgc_map</span><span class="s2">,</span>
                 <span class="s4">&quot;opt_scale&quot;</span><span class="s2">: </span><span class="s1">opt_scale</span><span class="s2">}</span>

    <span class="s0">return </span><span class="s1">stat</span><span class="s2">, </span><span class="s1">stat_dict</span>


<span class="s0">def </span><span class="s1">_threshold_mgc_map</span><span class="s2">(</span><span class="s1">stat_mgc_map</span><span class="s2">, </span><span class="s1">samp_size</span><span class="s2">):</span>
    <span class="s5">r&quot;&quot;&quot; 
    Finds a connected region of significance in the MGC-map by thresholding. 
 
    Parameters 
    ---------- 
    stat_mgc_map : ndarray 
        All local correlations within `[-1,1]`. 
    samp_size : int 
        The sample size of original data. 
 
    Returns 
    ------- 
    sig_connect : ndarray 
        A binary matrix with 1's indicating the significant region. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">stat_mgc_map</span><span class="s2">.</span><span class="s1">shape</span>

    <span class="s3"># 0.02 is simply an empirical threshold, this can be set to 0.01 or 0.05</span>
    <span class="s3"># with varying levels of performance. Threshold is based on a beta</span>
    <span class="s3"># approximation.</span>
    <span class="s1">per_sig </span><span class="s2">= </span><span class="s6">1 </span><span class="s2">- (</span><span class="s6">0.02 </span><span class="s2">/ </span><span class="s1">samp_size</span><span class="s2">)  </span><span class="s3"># Percentile to consider as significant</span>
    <span class="s1">threshold </span><span class="s2">= </span><span class="s1">samp_size </span><span class="s2">* (</span><span class="s1">samp_size </span><span class="s2">- </span><span class="s6">3</span><span class="s2">)/</span><span class="s6">4 </span><span class="s2">- </span><span class="s6">1</span><span class="s2">/</span><span class="s6">2  </span><span class="s3"># Beta approximation</span>
    <span class="s1">threshold </span><span class="s2">= </span><span class="s1">distributions</span><span class="s2">.</span><span class="s1">beta</span><span class="s2">.</span><span class="s1">ppf</span><span class="s2">(</span><span class="s1">per_sig</span><span class="s2">, </span><span class="s1">threshold</span><span class="s2">, </span><span class="s1">threshold</span><span class="s2">) * </span><span class="s6">2 </span><span class="s2">- </span><span class="s6">1</span>

    <span class="s3"># the global scale at is the statistic calculated at maximial nearest</span>
    <span class="s3"># neighbors. Threshold is the maximum on the global and local scales</span>
    <span class="s1">threshold </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">threshold</span><span class="s2">, </span><span class="s1">stat_mgc_map</span><span class="s2">[</span><span class="s1">m </span><span class="s2">- </span><span class="s6">1</span><span class="s2">][</span><span class="s1">n </span><span class="s2">- </span><span class="s6">1</span><span class="s2">])</span>

    <span class="s3"># find the largest connected component of significant correlations</span>
    <span class="s1">sig_connect </span><span class="s2">= </span><span class="s1">stat_mgc_map </span><span class="s2">&gt; </span><span class="s1">threshold</span>
    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">sig_connect</span><span class="s2">) &gt; </span><span class="s6">0</span><span class="s2">:</span>
        <span class="s1">sig_connect</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_measurements</span><span class="s2">.</span><span class="s1">label</span><span class="s2">(</span><span class="s1">sig_connect</span><span class="s2">)</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">label_counts </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">unique</span><span class="s2">(</span><span class="s1">sig_connect</span><span class="s2">, </span><span class="s1">return_counts</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s3"># skip the first element in label_counts, as it is count(zeros)</span>
        <span class="s1">max_label </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argmax</span><span class="s2">(</span><span class="s1">label_counts</span><span class="s2">[</span><span class="s6">1</span><span class="s2">:]) + </span><span class="s6">1</span>
        <span class="s1">sig_connect </span><span class="s2">= </span><span class="s1">sig_connect </span><span class="s2">== </span><span class="s1">max_label</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">sig_connect </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([[</span><span class="s0">False</span><span class="s2">]])</span>

    <span class="s0">return </span><span class="s1">sig_connect</span>


<span class="s0">def </span><span class="s1">_smooth_mgc_map</span><span class="s2">(</span><span class="s1">sig_connect</span><span class="s2">, </span><span class="s1">stat_mgc_map</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Finds the smoothed maximal within the significant region R. 
 
    If area of R is too small it returns the last local correlation. Otherwise, 
    returns the maximum within significant_connected_region. 
 
    Parameters 
    ---------- 
    sig_connect : ndarray 
        A binary matrix with 1's indicating the significant region. 
    stat_mgc_map : ndarray 
        All local correlations within `[-1, 1]`. 
 
    Returns 
    ------- 
    stat : float 
        The sample MGC statistic within `[-1, 1]`. 
    opt_scale: (float, float) 
        The estimated optimal scale as an `(x, y)` pair. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m</span><span class="s2">, </span><span class="s1">n </span><span class="s2">= </span><span class="s1">stat_mgc_map</span><span class="s2">.</span><span class="s1">shape</span>

    <span class="s3"># the global scale at is the statistic calculated at maximial nearest</span>
    <span class="s3"># neighbors. By default, statistic and optimal scale are global.</span>
    <span class="s1">stat </span><span class="s2">= </span><span class="s1">stat_mgc_map</span><span class="s2">[</span><span class="s1">m </span><span class="s2">- </span><span class="s6">1</span><span class="s2">][</span><span class="s1">n </span><span class="s2">- </span><span class="s6">1</span><span class="s2">]</span>
    <span class="s1">opt_scale </span><span class="s2">= [</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">]</span>

    <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linalg</span><span class="s2">.</span><span class="s1">norm</span><span class="s2">(</span><span class="s1">sig_connect</span><span class="s2">) != </span><span class="s6">0</span><span class="s2">:</span>
        <span class="s3"># proceed only when the connected region's area is sufficiently large</span>
        <span class="s3"># 0.02 is simply an empirical threshold, this can be set to 0.01 or 0.05</span>
        <span class="s3"># with varying levels of performance</span>
        <span class="s0">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">sig_connect</span><span class="s2">) &gt;= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ceil</span><span class="s2">(</span><span class="s6">0.02 </span><span class="s2">* </span><span class="s1">max</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">)) * </span><span class="s1">min</span><span class="s2">(</span><span class="s1">m</span><span class="s2">, </span><span class="s1">n</span><span class="s2">):</span>
            <span class="s1">max_corr </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">stat_mgc_map</span><span class="s2">[</span><span class="s1">sig_connect</span><span class="s2">])</span>

            <span class="s3"># find all scales within significant_connected_region that maximize</span>
            <span class="s3"># the local correlation</span>
            <span class="s1">max_corr_index </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">where</span><span class="s2">((</span><span class="s1">stat_mgc_map </span><span class="s2">&gt;= </span><span class="s1">max_corr</span><span class="s2">) &amp; </span><span class="s1">sig_connect</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">max_corr </span><span class="s2">&gt;= </span><span class="s1">stat</span><span class="s2">:</span>
                <span class="s1">stat </span><span class="s2">= </span><span class="s1">max_corr</span>

                <span class="s1">k</span><span class="s2">, </span><span class="s1">l </span><span class="s2">= </span><span class="s1">max_corr_index</span>
                <span class="s1">one_d_indices </span><span class="s2">= </span><span class="s1">k </span><span class="s2">* </span><span class="s1">n </span><span class="s2">+ </span><span class="s1">l  </span><span class="s3"># 2D to 1D indexing</span>
                <span class="s1">k </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">one_d_indices</span><span class="s2">) // </span><span class="s1">n</span>
                <span class="s1">l </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">one_d_indices</span><span class="s2">) % </span><span class="s1">n</span>
                <span class="s1">opt_scale </span><span class="s2">= [</span><span class="s1">k</span><span class="s2">+</span><span class="s6">1</span><span class="s2">, </span><span class="s1">l</span><span class="s2">+</span><span class="s6">1</span><span class="s2">]  </span><span class="s3"># adding 1s to match R indexing</span>

    <span class="s0">return </span><span class="s1">stat</span><span class="s2">, </span><span class="s1">opt_scale</span>


<span class="s0">def </span><span class="s1">_two_sample_transform</span><span class="s2">(</span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Helper function that concatenates x and y for two sample MGC stat. 
 
    See above for use. 
 
    Parameters 
    ---------- 
    u, v : ndarray 
        `u` and `v` have shapes `(n, p)` and `(m, p)`. 
 
    Returns 
    ------- 
    x : ndarray 
        Concatenate `u` and `v` along the `axis = 0`. `x` thus has shape 
        `(2n, p)`. 
    y : ndarray 
        Label matrix for `x` where 0 refers to samples that comes from `u` and 
        1 refers to samples that come from `v`. `y` thus has shape `(2n, 1)`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">nx </span><span class="s2">= </span><span class="s1">u</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
    <span class="s1">ny </span><span class="s2">= </span><span class="s1">v</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]</span>
    <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">([</span><span class="s1">u</span><span class="s2">, </span><span class="s1">v</span><span class="s2">], </span><span class="s1">axis</span><span class="s2">=</span><span class="s6">0</span><span class="s2">)</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">([</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">nx</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">ny</span><span class="s2">)], </span><span class="s1">axis</span><span class="s2">=</span><span class="s6">0</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(-</span><span class="s6">1</span><span class="s2">, </span><span class="s6">1</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span>
</pre>
</body>
</html>