<html>
<head>
<title>_gpc.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_gpc.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Gaussian processes classification.&quot;&quot;&quot;</span>

<span class="s2"># Authors: Jan Hendrik Metzen &lt;jhm@informatik.uni-bremen.de&gt;</span>
<span class="s2">#</span>
<span class="s2"># License: BSD 3 clause</span>

<span class="s3">from </span><span class="s1">numbers </span><span class="s3">import </span><span class="s1">Integral</span>
<span class="s3">from </span><span class="s1">operator </span><span class="s3">import </span><span class="s1">itemgetter</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">optimize</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">linalg </span><span class="s3">import </span><span class="s1">cho_solve</span><span class="s4">, </span><span class="s1">cholesky</span><span class="s4">, </span><span class="s1">solve</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">special </span><span class="s3">import </span><span class="s1">erf</span><span class="s4">, </span><span class="s1">expit</span>

<span class="s3">from </span><span class="s4">..</span><span class="s1">base </span><span class="s3">import </span><span class="s1">BaseEstimator</span><span class="s4">, </span><span class="s1">ClassifierMixin</span><span class="s4">, </span><span class="s1">_fit_context</span><span class="s4">, </span><span class="s1">clone</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">multiclass </span><span class="s3">import </span><span class="s1">OneVsOneClassifier</span><span class="s4">, </span><span class="s1">OneVsRestClassifier</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">preprocessing </span><span class="s3">import </span><span class="s1">LabelEncoder</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils </span><span class="s3">import </span><span class="s1">check_random_state</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_param_validation </span><span class="s3">import </span><span class="s1">Interval</span><span class="s4">, </span><span class="s1">StrOptions</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">optimize </span><span class="s3">import </span><span class="s1">_check_optimize_result</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">validation </span><span class="s3">import </span><span class="s1">check_is_fitted</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">kernels </span><span class="s3">import </span><span class="s1">RBF</span><span class="s4">, </span><span class="s1">CompoundKernel</span><span class="s4">, </span><span class="s1">Kernel</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">kernels </span><span class="s3">import </span><span class="s1">ConstantKernel </span><span class="s3">as </span><span class="s1">C</span>

<span class="s2"># Values required for approximating the logistic sigmoid by</span>
<span class="s2"># error functions. coefs are obtained via:</span>
<span class="s2"># x = np.array([0, 0.6, 2, 3.5, 4.5, np.inf])</span>
<span class="s2"># b = logistic(x)</span>
<span class="s2"># A = (erf(np.dot(x, self.lambdas)) + 1) / 2</span>
<span class="s2"># coefs = lstsq(A, b)[0]</span>
<span class="s1">LAMBDAS </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">([</span><span class="s5">0.41</span><span class="s4">, </span><span class="s5">0.4</span><span class="s4">, </span><span class="s5">0.37</span><span class="s4">, </span><span class="s5">0.44</span><span class="s4">, </span><span class="s5">0.39</span><span class="s4">])[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>
<span class="s1">COEFS </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">(</span>
    <span class="s4">[-</span><span class="s5">1854.8214151</span><span class="s4">, </span><span class="s5">3516.89893646</span><span class="s4">, </span><span class="s5">221.29346712</span><span class="s4">, </span><span class="s5">128.12323805</span><span class="s4">, -</span><span class="s5">2010.49422654</span><span class="s4">]</span>
<span class="s4">)[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>


<span class="s3">class </span><span class="s1">_BinaryGaussianProcessClassifierLaplace</span><span class="s4">(</span><span class="s1">BaseEstimator</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Binary Gaussian process classification based on Laplace approximation. 
 
    The implementation is based on Algorithm 3.1, 3.2, and 5.1 from [RW2006]_. 
 
    Internally, the Laplace approximation is used for approximating the 
    non-Gaussian posterior by a Gaussian. 
 
    Currently, the implementation is restricted to using the logistic link 
    function. 
 
    .. versionadded:: 0.18 
 
    Parameters 
    ---------- 
    kernel : kernel instance, default=None 
        The kernel specifying the covariance function of the GP. If None is 
        passed, the kernel &quot;1.0 * RBF(1.0)&quot; is used as default. Note that 
        the kernel's hyperparameters are optimized during fitting. 
 
    optimizer : 'fmin_l_bfgs_b' or callable, default='fmin_l_bfgs_b' 
        Can either be one of the internally supported optimizers for optimizing 
        the kernel's parameters, specified by a string, or an externally 
        defined optimizer passed as a callable. If a callable is passed, it 
        must have the  signature:: 
 
            def optimizer(obj_func, initial_theta, bounds): 
                # * 'obj_func' is the objective function to be maximized, which 
                #   takes the hyperparameters theta as parameter and an 
                #   optional flag eval_gradient, which determines if the 
                #   gradient is returned additionally to the function value 
                # * 'initial_theta': the initial value for theta, which can be 
                #   used by local optimizers 
                # * 'bounds': the bounds on the values of theta 
                .... 
                # Returned are the best found hyperparameters theta and 
                # the corresponding value of the target function. 
                return theta_opt, func_min 
 
        Per default, the 'L-BFGS-B' algorithm from scipy.optimize.minimize 
        is used. If None is passed, the kernel's parameters are kept fixed. 
        Available internal optimizers are:: 
 
            'fmin_l_bfgs_b' 
 
    n_restarts_optimizer : int, default=0 
        The number of restarts of the optimizer for finding the kernel's 
        parameters which maximize the log-marginal likelihood. The first run 
        of the optimizer is performed from the kernel's initial parameters, 
        the remaining ones (if any) from thetas sampled log-uniform randomly 
        from the space of allowed theta-values. If greater than 0, all bounds 
        must be finite. Note that n_restarts_optimizer=0 implies that one 
        run is performed. 
 
    max_iter_predict : int, default=100 
        The maximum number of iterations in Newton's method for approximating 
        the posterior during predict. Smaller values will reduce computation 
        time at the cost of worse results. 
 
    warm_start : bool, default=False 
        If warm-starts are enabled, the solution of the last Newton iteration 
        on the Laplace approximation of the posterior mode is used as 
        initialization for the next call of _posterior_mode(). This can speed 
        up convergence when _posterior_mode is called several times on similar 
        problems as in hyperparameter optimization. See :term:`the Glossary 
        &lt;warm_start&gt;`. 
 
    copy_X_train : bool, default=True 
        If True, a persistent copy of the training data is stored in the 
        object. Otherwise, just a reference to the training data is stored, 
        which might cause predictions to change if the data is modified 
        externally. 
 
    random_state : int, RandomState instance or None, default=None 
        Determines random number generation used to initialize the centers. 
        Pass an int for reproducible results across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    Attributes 
    ---------- 
    X_train_ : array-like of shape (n_samples, n_features) or list of object 
        Feature vectors or other representations of training data (also 
        required for prediction). 
 
    y_train_ : array-like of shape (n_samples,) 
        Target values in training data (also required for prediction) 
 
    classes_ : array-like of shape (n_classes,) 
        Unique class labels. 
 
    kernel_ : kernl instance 
        The kernel used for prediction. The structure of the kernel is the 
        same as the one passed as parameter but with optimized hyperparameters 
 
    L_ : array-like of shape (n_samples, n_samples) 
        Lower-triangular Cholesky decomposition of the kernel in X_train_ 
 
    pi_ : array-like of shape (n_samples,) 
        The probabilities of the positive class for the training points 
        X_train_ 
 
    W_sr_ : array-like of shape (n_samples,) 
        Square root of W, the Hessian of log-likelihood of the latent function 
        values for the observed labels. Since W is diagonal, only the diagonal 
        of sqrt(W) is stored. 
 
    log_marginal_likelihood_value_ : float 
        The log-marginal-likelihood of ``self.kernel_.theta`` 
 
    References 
    ---------- 
    .. [RW2006] `Carl E. Rasmussen and Christopher K.I. Williams, 
       &quot;Gaussian Processes for Machine Learning&quot;, 
       MIT Press 2006 &lt;https://www.gaussianprocess.org/gpml/chapters/RW.pdf&gt;`_ 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">kernel</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">optimizer</span><span class="s4">=</span><span class="s6">&quot;fmin_l_bfgs_b&quot;</span><span class="s4">,</span>
        <span class="s1">n_restarts_optimizer</span><span class="s4">=</span><span class="s5">0</span><span class="s4">,</span>
        <span class="s1">max_iter_predict</span><span class="s4">=</span><span class="s5">100</span><span class="s4">,</span>
        <span class="s1">warm_start</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">copy_X_train</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">kernel </span><span class="s4">= </span><span class="s1">kernel</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">optimizer </span><span class="s4">= </span><span class="s1">optimizer</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_restarts_optimizer </span><span class="s4">= </span><span class="s1">n_restarts_optimizer</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">max_iter_predict </span><span class="s4">= </span><span class="s1">max_iter_predict</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">warm_start </span><span class="s4">= </span><span class="s1">warm_start</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">copy_X_train </span><span class="s4">= </span><span class="s1">copy_X_train</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">random_state </span><span class="s4">= </span><span class="s1">random_state</span>

    <span class="s3">def </span><span class="s1">fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Fit Gaussian process classification model. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) or list of object 
            Feature vectors or other representations of training data. 
 
        y : array-like of shape (n_samples,) 
            Target values, must be binary. 
 
        Returns 
        ------- 
        self : returns an instance of self. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel </span><span class="s3">is None</span><span class="s4">:  </span><span class="s2"># Use an RBF kernel as default</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_ </span><span class="s4">= </span><span class="s1">C</span><span class="s4">(</span><span class="s5">1.0</span><span class="s4">, </span><span class="s1">constant_value_bounds</span><span class="s4">=</span><span class="s6">&quot;fixed&quot;</span><span class="s4">) * </span><span class="s1">RBF</span><span class="s4">(</span>
                <span class="s5">1.0</span><span class="s4">, </span><span class="s1">length_scale_bounds</span><span class="s4">=</span><span class="s6">&quot;fixed&quot;</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_ </span><span class="s4">= </span><span class="s1">clone</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">rng </span><span class="s4">= </span><span class="s1">check_random_state</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">random_state</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">X_train_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">copy_X_train </span><span class="s3">else </span><span class="s1">X</span>

        <span class="s2"># Encode class labels and check that it is a binary classification</span>
        <span class="s2"># problem</span>
        <span class="s1">label_encoder </span><span class="s4">= </span><span class="s1">LabelEncoder</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">y_train_ </span><span class="s4">= </span><span class="s1">label_encoder</span><span class="s4">.</span><span class="s1">fit_transform</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">classes_ </span><span class="s4">= </span><span class="s1">label_encoder</span><span class="s4">.</span><span class="s1">classes_</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">.</span><span class="s1">size </span><span class="s4">&gt; </span><span class="s5">2</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s6">&quot;%s supports only binary classification. y contains classes %s&quot;</span>
                <span class="s4">% (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">)</span>
            <span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">.</span><span class="s1">size </span><span class="s4">== </span><span class="s5">1</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s6">&quot;{0:s} requires 2 classes; got {1:d} class&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">.</span><span class="s1">size</span>
                <span class="s4">)</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">optimizer </span><span class="s3">is not None and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_</span><span class="s4">.</span><span class="s1">n_dims </span><span class="s4">&gt; </span><span class="s5">0</span><span class="s4">:</span>
            <span class="s2"># Choose hyperparameters based on maximizing the log-marginal</span>
            <span class="s2"># likelihood (potentially starting from several initial values)</span>
            <span class="s3">def </span><span class="s1">obj_func</span><span class="s4">(</span><span class="s1">theta</span><span class="s4">, </span><span class="s1">eval_gradient</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
                <span class="s3">if </span><span class="s1">eval_gradient</span><span class="s4">:</span>
                    <span class="s1">lml</span><span class="s4">, </span><span class="s1">grad </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">log_marginal_likelihood</span><span class="s4">(</span>
                        <span class="s1">theta</span><span class="s4">, </span><span class="s1">eval_gradient</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">clone_kernel</span><span class="s4">=</span><span class="s3">False</span>
                    <span class="s4">)</span>
                    <span class="s3">return </span><span class="s4">-</span><span class="s1">lml</span><span class="s4">, -</span><span class="s1">grad</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s3">return </span><span class="s4">-</span><span class="s1">self</span><span class="s4">.</span><span class="s1">log_marginal_likelihood</span><span class="s4">(</span><span class="s1">theta</span><span class="s4">, </span><span class="s1">clone_kernel</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

            <span class="s2"># First optimize starting from theta specified in kernel</span>
            <span class="s1">optima </span><span class="s4">= [</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_constrained_optimization</span><span class="s4">(</span>
                    <span class="s1">obj_func</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_</span><span class="s4">.</span><span class="s1">theta</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_</span><span class="s4">.</span><span class="s1">bounds</span>
                <span class="s4">)</span>
            <span class="s4">]</span>

            <span class="s2"># Additional runs are performed from log-uniform chosen initial</span>
            <span class="s2"># theta</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_restarts_optimizer </span><span class="s4">&gt; </span><span class="s5">0</span><span class="s4">:</span>
                <span class="s3">if not </span><span class="s1">np</span><span class="s4">.</span><span class="s1">isfinite</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_</span><span class="s4">.</span><span class="s1">bounds</span><span class="s4">).</span><span class="s1">all</span><span class="s4">():</span>
                    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                        <span class="s6">&quot;Multiple optimizer restarts (n_restarts_optimizer&gt;0) &quot;</span>
                        <span class="s6">&quot;requires that all bounds are finite.&quot;</span>
                    <span class="s4">)</span>
                <span class="s1">bounds </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_</span><span class="s4">.</span><span class="s1">bounds</span>
                <span class="s3">for </span><span class="s1">iteration </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_restarts_optimizer</span><span class="s4">):</span>
                    <span class="s1">theta_initial </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">rng</span><span class="s4">.</span><span class="s1">uniform</span><span class="s4">(</span><span class="s1">bounds</span><span class="s4">[:, </span><span class="s5">0</span><span class="s4">], </span><span class="s1">bounds</span><span class="s4">[:, </span><span class="s5">1</span><span class="s4">]))</span>
                    <span class="s1">optima</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span>
                        <span class="s1">self</span><span class="s4">.</span><span class="s1">_constrained_optimization</span><span class="s4">(</span><span class="s1">obj_func</span><span class="s4">, </span><span class="s1">theta_initial</span><span class="s4">, </span><span class="s1">bounds</span><span class="s4">)</span>
                    <span class="s4">)</span>
            <span class="s2"># Select result from run with minimal (negative) log-marginal</span>
            <span class="s2"># likelihood</span>
            <span class="s1">lml_values </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">map</span><span class="s4">(</span><span class="s1">itemgetter</span><span class="s4">(</span><span class="s5">1</span><span class="s4">), </span><span class="s1">optima</span><span class="s4">))</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_</span><span class="s4">.</span><span class="s1">theta </span><span class="s4">= </span><span class="s1">optima</span><span class="s4">[</span><span class="s1">np</span><span class="s4">.</span><span class="s1">argmin</span><span class="s4">(</span><span class="s1">lml_values</span><span class="s4">)][</span><span class="s5">0</span><span class="s4">]</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_</span><span class="s4">.</span><span class="s1">_check_bounds_params</span><span class="s4">()</span>

            <span class="s1">self</span><span class="s4">.</span><span class="s1">log_marginal_likelihood_value_ </span><span class="s4">= -</span><span class="s1">np</span><span class="s4">.</span><span class="s1">min</span><span class="s4">(</span><span class="s1">lml_values</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">log_marginal_likelihood_value_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">log_marginal_likelihood</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_</span><span class="s4">.</span><span class="s1">theta</span>
            <span class="s4">)</span>

        <span class="s2"># Precompute quantities required for predictions which are independent</span>
        <span class="s2"># of actual query points</span>
        <span class="s1">K </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">X_train_</span><span class="s4">)</span>

        <span class="s1">_</span><span class="s4">, (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">pi_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">W_sr_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">L_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">) = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_posterior_mode</span><span class="s4">(</span>
            <span class="s1">K</span><span class="s4">, </span><span class="s1">return_temporaries</span><span class="s4">=</span><span class="s3">True</span>
        <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">predict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Perform classification on an array of test vectors X. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) or list of object 
            Query points where the GP is evaluated for classification. 
 
        Returns 
        ------- 
        C : ndarray of shape (n_samples,) 
            Predicted target values for X, values are from ``classes_`` 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

        <span class="s2"># As discussed on Section 3.4.2 of GPML, for making hard binary</span>
        <span class="s2"># decisions, it is enough to compute the MAP of the posterior and</span>
        <span class="s2"># pass it through the link function</span>
        <span class="s1">K_star </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">X_train_</span><span class="s4">, </span><span class="s1">X</span><span class="s4">)  </span><span class="s2"># K_star =k(x_star)</span>
        <span class="s1">f_star </span><span class="s4">= </span><span class="s1">K_star</span><span class="s4">.</span><span class="s1">T</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">y_train_ </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">pi_</span><span class="s4">)  </span><span class="s2"># Algorithm 3.2,Line 4</span>

        <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">where</span><span class="s4">(</span><span class="s1">f_star </span><span class="s4">&gt; </span><span class="s5">0</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">[</span><span class="s5">1</span><span class="s4">], </span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>

    <span class="s3">def </span><span class="s1">predict_proba</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return probability estimates for the test vector X. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) or list of object 
            Query points where the GP is evaluated for classification. 
 
        Returns 
        ------- 
        C : array-like of shape (n_samples, n_classes) 
            Returns the probability of the samples for each class in 
            the model. The columns correspond to the classes in sorted 
            order, as they appear in the attribute ``classes_``. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

        <span class="s2"># Based on Algorithm 3.2 of GPML</span>
        <span class="s1">K_star </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">X_train_</span><span class="s4">, </span><span class="s1">X</span><span class="s4">)  </span><span class="s2"># K_star =k(x_star)</span>
        <span class="s1">f_star </span><span class="s4">= </span><span class="s1">K_star</span><span class="s4">.</span><span class="s1">T</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">y_train_ </span><span class="s4">- </span><span class="s1">self</span><span class="s4">.</span><span class="s1">pi_</span><span class="s4">)  </span><span class="s2"># Line 4</span>
        <span class="s1">v </span><span class="s4">= </span><span class="s1">solve</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">L_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">W_sr_</span><span class="s4">[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">] * </span><span class="s1">K_star</span><span class="s4">)  </span><span class="s2"># Line 5</span>
        <span class="s2"># Line 6 (compute np.diag(v.T.dot(v)) via einsum)</span>
        <span class="s1">var_f_star </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_</span><span class="s4">.</span><span class="s1">diag</span><span class="s4">(</span><span class="s1">X</span><span class="s4">) - </span><span class="s1">np</span><span class="s4">.</span><span class="s1">einsum</span><span class="s4">(</span><span class="s6">&quot;ij,ij-&gt;j&quot;</span><span class="s4">, </span><span class="s1">v</span><span class="s4">, </span><span class="s1">v</span><span class="s4">)</span>

        <span class="s2"># Line 7:</span>
        <span class="s2"># Approximate \int log(z) * N(z | f_star, var_f_star)</span>
        <span class="s2"># Approximation is due to Williams &amp; Barber, &quot;Bayesian Classification</span>
        <span class="s2"># with Gaussian Processes&quot;, Appendix A: Approximate the logistic</span>
        <span class="s2"># sigmoid by a linear combination of 5 error functions.</span>
        <span class="s2"># For information on how this integral can be computed see</span>
        <span class="s2"># blitiri.blogspot.de/2012/11/gaussian-integral-of-error-function.html</span>
        <span class="s1">alpha </span><span class="s4">= </span><span class="s5">1 </span><span class="s4">/ (</span><span class="s5">2 </span><span class="s4">* </span><span class="s1">var_f_star</span><span class="s4">)</span>
        <span class="s1">gamma </span><span class="s4">= </span><span class="s1">LAMBDAS </span><span class="s4">* </span><span class="s1">f_star</span>
        <span class="s1">integrals </span><span class="s4">= (</span>
            <span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">pi </span><span class="s4">/ </span><span class="s1">alpha</span><span class="s4">)</span>
            <span class="s4">* </span><span class="s1">erf</span><span class="s4">(</span><span class="s1">gamma </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">alpha </span><span class="s4">/ (</span><span class="s1">alpha </span><span class="s4">+ </span><span class="s1">LAMBDAS</span><span class="s4">**</span><span class="s5">2</span><span class="s4">)))</span>
            <span class="s4">/ (</span><span class="s5">2 </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">var_f_star </span><span class="s4">* </span><span class="s5">2 </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">pi</span><span class="s4">))</span>
        <span class="s4">)</span>
        <span class="s1">pi_star </span><span class="s4">= (</span><span class="s1">COEFS </span><span class="s4">* </span><span class="s1">integrals</span><span class="s4">).</span><span class="s1">sum</span><span class="s4">(</span><span class="s1">axis</span><span class="s4">=</span><span class="s5">0</span><span class="s4">) + </span><span class="s5">0.5 </span><span class="s4">* </span><span class="s1">COEFS</span><span class="s4">.</span><span class="s1">sum</span><span class="s4">()</span>

        <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">vstack</span><span class="s4">((</span><span class="s5">1 </span><span class="s4">- </span><span class="s1">pi_star</span><span class="s4">, </span><span class="s1">pi_star</span><span class="s4">)).</span><span class="s1">T</span>

    <span class="s3">def </span><span class="s1">log_marginal_likelihood</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">theta</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">eval_gradient</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">clone_kernel</span><span class="s4">=</span><span class="s3">True</span>
    <span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Returns log-marginal likelihood of theta for training data. 
 
        Parameters 
        ---------- 
        theta : array-like of shape (n_kernel_params,), default=None 
            Kernel hyperparameters for which the log-marginal likelihood is 
            evaluated. If None, the precomputed log_marginal_likelihood 
            of ``self.kernel_.theta`` is returned. 
 
        eval_gradient : bool, default=False 
            If True, the gradient of the log-marginal likelihood with respect 
            to the kernel hyperparameters at position theta is returned 
            additionally. If True, theta must not be None. 
 
        clone_kernel : bool, default=True 
            If True, the kernel attribute is copied. If False, the kernel 
            attribute is modified, but may result in a performance improvement. 
 
        Returns 
        ------- 
        log_likelihood : float 
            Log-marginal likelihood of theta for training data. 
 
        log_likelihood_gradient : ndarray of shape (n_kernel_params,), \ 
                optional 
            Gradient of the log-marginal likelihood with respect to the kernel 
            hyperparameters at position theta. 
            Only returned when `eval_gradient` is True. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">theta </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">eval_gradient</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s6">&quot;Gradient can only be evaluated for theta!=None&quot;</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">log_marginal_likelihood_value_</span>

        <span class="s3">if </span><span class="s1">clone_kernel</span><span class="s4">:</span>
            <span class="s1">kernel </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_</span><span class="s4">.</span><span class="s1">clone_with_theta</span><span class="s4">(</span><span class="s1">theta</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">kernel </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel_</span>
            <span class="s1">kernel</span><span class="s4">.</span><span class="s1">theta </span><span class="s4">= </span><span class="s1">theta</span>

        <span class="s3">if </span><span class="s1">eval_gradient</span><span class="s4">:</span>
            <span class="s1">K</span><span class="s4">, </span><span class="s1">K_gradient </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">X_train_</span><span class="s4">, </span><span class="s1">eval_gradient</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">K </span><span class="s4">= </span><span class="s1">kernel</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">X_train_</span><span class="s4">)</span>

        <span class="s2"># Compute log-marginal-likelihood Z and also store some temporaries</span>
        <span class="s2"># which can be reused for computing Z's gradient</span>
        <span class="s1">Z</span><span class="s4">, (</span><span class="s1">pi</span><span class="s4">, </span><span class="s1">W_sr</span><span class="s4">, </span><span class="s1">L</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">a</span><span class="s4">) = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_posterior_mode</span><span class="s4">(</span><span class="s1">K</span><span class="s4">, </span><span class="s1">return_temporaries</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">eval_gradient</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">Z</span>

        <span class="s2"># Compute gradient based on Algorithm 5.1 of GPML</span>
        <span class="s1">d_Z </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">empty</span><span class="s4">(</span><span class="s1">theta</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>
        <span class="s2"># XXX: Get rid of the np.diag() in the next line</span>
        <span class="s1">R </span><span class="s4">= </span><span class="s1">W_sr</span><span class="s4">[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">] * </span><span class="s1">cho_solve</span><span class="s4">((</span><span class="s1">L</span><span class="s4">, </span><span class="s3">True</span><span class="s4">), </span><span class="s1">np</span><span class="s4">.</span><span class="s1">diag</span><span class="s4">(</span><span class="s1">W_sr</span><span class="s4">))  </span><span class="s2"># Line 7</span>
        <span class="s1">C </span><span class="s4">= </span><span class="s1">solve</span><span class="s4">(</span><span class="s1">L</span><span class="s4">, </span><span class="s1">W_sr</span><span class="s4">[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">] * </span><span class="s1">K</span><span class="s4">)  </span><span class="s2"># Line 8</span>
        <span class="s2"># Line 9: (use einsum to compute np.diag(C.T.dot(C))))</span>
        <span class="s1">s_2 </span><span class="s4">= (</span>
            <span class="s4">-</span><span class="s5">0.5</span>
            <span class="s4">* (</span><span class="s1">np</span><span class="s4">.</span><span class="s1">diag</span><span class="s4">(</span><span class="s1">K</span><span class="s4">) - </span><span class="s1">np</span><span class="s4">.</span><span class="s1">einsum</span><span class="s4">(</span><span class="s6">&quot;ij, ij -&gt; j&quot;</span><span class="s4">, </span><span class="s1">C</span><span class="s4">, </span><span class="s1">C</span><span class="s4">))</span>
            <span class="s4">* (</span><span class="s1">pi </span><span class="s4">* (</span><span class="s5">1 </span><span class="s4">- </span><span class="s1">pi</span><span class="s4">) * (</span><span class="s5">1 </span><span class="s4">- </span><span class="s5">2 </span><span class="s4">* </span><span class="s1">pi</span><span class="s4">))</span>
        <span class="s4">)  </span><span class="s2"># third derivative</span>

        <span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">d_Z</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]):</span>
            <span class="s1">C </span><span class="s4">= </span><span class="s1">K_gradient</span><span class="s4">[:, :, </span><span class="s1">j</span><span class="s4">]  </span><span class="s2"># Line 11</span>
            <span class="s2"># Line 12: (R.T.ravel().dot(C.ravel()) = np.trace(R.dot(C)))</span>
            <span class="s1">s_1 </span><span class="s4">= </span><span class="s5">0.5 </span><span class="s4">* </span><span class="s1">a</span><span class="s4">.</span><span class="s1">T</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">C</span><span class="s4">).</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">a</span><span class="s4">) - </span><span class="s5">0.5 </span><span class="s4">* </span><span class="s1">R</span><span class="s4">.</span><span class="s1">T</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">().</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">C</span><span class="s4">.</span><span class="s1">ravel</span><span class="s4">())</span>

            <span class="s1">b </span><span class="s4">= </span><span class="s1">C</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">y_train_ </span><span class="s4">- </span><span class="s1">pi</span><span class="s4">)  </span><span class="s2"># Line 13</span>
            <span class="s1">s_3 </span><span class="s4">= </span><span class="s1">b </span><span class="s4">- </span><span class="s1">K</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">R</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">b</span><span class="s4">))  </span><span class="s2"># Line 14</span>

            <span class="s1">d_Z</span><span class="s4">[</span><span class="s1">j</span><span class="s4">] = </span><span class="s1">s_1 </span><span class="s4">+ </span><span class="s1">s_2</span><span class="s4">.</span><span class="s1">T</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">s_3</span><span class="s4">)  </span><span class="s2"># Line 15</span>

        <span class="s3">return </span><span class="s1">Z</span><span class="s4">, </span><span class="s1">d_Z</span>

    <span class="s3">def </span><span class="s1">_posterior_mode</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">K</span><span class="s4">, </span><span class="s1">return_temporaries</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Mode-finding for binary Laplace GPC and fixed kernel. 
 
        This approximates the posterior of the latent function values for given 
        inputs and target observations with a Gaussian approximation and uses 
        Newton's iteration to find the mode of this approximation. 
        &quot;&quot;&quot;</span>
        <span class="s2"># Based on Algorithm 3.1 of GPML</span>

        <span class="s2"># If warm_start are enabled, we reuse the last solution for the</span>
        <span class="s2"># posterior mode as initialization; otherwise, we initialize with 0</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">warm_start</span>
            <span class="s3">and </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s6">&quot;f_cached&quot;</span><span class="s4">)</span>
            <span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">f_cached</span><span class="s4">.</span><span class="s1">shape </span><span class="s4">== </span><span class="s1">self</span><span class="s4">.</span><span class="s1">y_train_</span><span class="s4">.</span><span class="s1">shape</span>
        <span class="s4">):</span>
            <span class="s1">f </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">f_cached</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">f </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">zeros_like</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">y_train_</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>

        <span class="s2"># Use Newton's iteration method to find mode of Laplace approximation</span>
        <span class="s1">log_marginal_likelihood </span><span class="s4">= -</span><span class="s1">np</span><span class="s4">.</span><span class="s1">inf</span>
        <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">max_iter_predict</span><span class="s4">):</span>
            <span class="s2"># Line 4</span>
            <span class="s1">pi </span><span class="s4">= </span><span class="s1">expit</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
            <span class="s1">W </span><span class="s4">= </span><span class="s1">pi </span><span class="s4">* (</span><span class="s5">1 </span><span class="s4">- </span><span class="s1">pi</span><span class="s4">)</span>
            <span class="s2"># Line 5</span>
            <span class="s1">W_sr </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">sqrt</span><span class="s4">(</span><span class="s1">W</span><span class="s4">)</span>
            <span class="s1">W_sr_K </span><span class="s4">= </span><span class="s1">W_sr</span><span class="s4">[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">] * </span><span class="s1">K</span>
            <span class="s1">B </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">eye</span><span class="s4">(</span><span class="s1">W</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]) + </span><span class="s1">W_sr_K </span><span class="s4">* </span><span class="s1">W_sr</span>
            <span class="s1">L </span><span class="s4">= </span><span class="s1">cholesky</span><span class="s4">(</span><span class="s1">B</span><span class="s4">, </span><span class="s1">lower</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
            <span class="s2"># Line 6</span>
            <span class="s1">b </span><span class="s4">= </span><span class="s1">W </span><span class="s4">* </span><span class="s1">f </span><span class="s4">+ (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">y_train_ </span><span class="s4">- </span><span class="s1">pi</span><span class="s4">)</span>
            <span class="s2"># Line 7</span>
            <span class="s1">a </span><span class="s4">= </span><span class="s1">b </span><span class="s4">- </span><span class="s1">W_sr </span><span class="s4">* </span><span class="s1">cho_solve</span><span class="s4">((</span><span class="s1">L</span><span class="s4">, </span><span class="s3">True</span><span class="s4">), </span><span class="s1">W_sr_K</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">b</span><span class="s4">))</span>
            <span class="s2"># Line 8</span>
            <span class="s1">f </span><span class="s4">= </span><span class="s1">K</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">a</span><span class="s4">)</span>

            <span class="s2"># Line 10: Compute log marginal likelihood in loop and use as</span>
            <span class="s2">#          convergence criterion</span>
            <span class="s1">lml </span><span class="s4">= (</span>
                <span class="s4">-</span><span class="s5">0.5 </span><span class="s4">* </span><span class="s1">a</span><span class="s4">.</span><span class="s1">T</span><span class="s4">.</span><span class="s1">dot</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
                <span class="s4">- </span><span class="s1">np</span><span class="s4">.</span><span class="s1">log1p</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(-(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">y_train_ </span><span class="s4">* </span><span class="s5">2 </span><span class="s4">- </span><span class="s5">1</span><span class="s4">) * </span><span class="s1">f</span><span class="s4">)).</span><span class="s1">sum</span><span class="s4">()</span>
                <span class="s4">- </span><span class="s1">np</span><span class="s4">.</span><span class="s1">log</span><span class="s4">(</span><span class="s1">np</span><span class="s4">.</span><span class="s1">diag</span><span class="s4">(</span><span class="s1">L</span><span class="s4">)).</span><span class="s1">sum</span><span class="s4">()</span>
            <span class="s4">)</span>
            <span class="s2"># Check if we have converged (log marginal likelihood does</span>
            <span class="s2"># not decrease)</span>
            <span class="s2"># XXX: more complex convergence criterion</span>
            <span class="s3">if </span><span class="s1">lml </span><span class="s4">- </span><span class="s1">log_marginal_likelihood </span><span class="s4">&lt; </span><span class="s5">1e-10</span><span class="s4">:</span>
                <span class="s3">break</span>
            <span class="s1">log_marginal_likelihood </span><span class="s4">= </span><span class="s1">lml</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">f_cached </span><span class="s4">= </span><span class="s1">f  </span><span class="s2"># Remember solution for later warm-starts</span>
        <span class="s3">if </span><span class="s1">return_temporaries</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">log_marginal_likelihood</span><span class="s4">, (</span><span class="s1">pi</span><span class="s4">, </span><span class="s1">W_sr</span><span class="s4">, </span><span class="s1">L</span><span class="s4">, </span><span class="s1">b</span><span class="s4">, </span><span class="s1">a</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">log_marginal_likelihood</span>

    <span class="s3">def </span><span class="s1">_constrained_optimization</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">obj_func</span><span class="s4">, </span><span class="s1">initial_theta</span><span class="s4">, </span><span class="s1">bounds</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">optimizer </span><span class="s4">== </span><span class="s6">&quot;fmin_l_bfgs_b&quot;</span><span class="s4">:</span>
            <span class="s1">opt_res </span><span class="s4">= </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">optimize</span><span class="s4">.</span><span class="s1">minimize</span><span class="s4">(</span>
                <span class="s1">obj_func</span><span class="s4">, </span><span class="s1">initial_theta</span><span class="s4">, </span><span class="s1">method</span><span class="s4">=</span><span class="s6">&quot;L-BFGS-B&quot;</span><span class="s4">, </span><span class="s1">jac</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">bounds</span><span class="s4">=</span><span class="s1">bounds</span>
            <span class="s4">)</span>
            <span class="s1">_check_optimize_result</span><span class="s4">(</span><span class="s6">&quot;lbfgs&quot;</span><span class="s4">, </span><span class="s1">opt_res</span><span class="s4">)</span>
            <span class="s1">theta_opt</span><span class="s4">, </span><span class="s1">func_min </span><span class="s4">= </span><span class="s1">opt_res</span><span class="s4">.</span><span class="s1">x</span><span class="s4">, </span><span class="s1">opt_res</span><span class="s4">.</span><span class="s1">fun</span>
        <span class="s3">elif </span><span class="s1">callable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">optimizer</span><span class="s4">):</span>
            <span class="s1">theta_opt</span><span class="s4">, </span><span class="s1">func_min </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">optimizer</span><span class="s4">(</span><span class="s1">obj_func</span><span class="s4">, </span><span class="s1">initial_theta</span><span class="s4">, </span><span class="s1">bounds</span><span class="s4">=</span><span class="s1">bounds</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s6">&quot;Unknown optimizer %s.&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">optimizer</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">theta_opt</span><span class="s4">, </span><span class="s1">func_min</span>


<span class="s3">class </span><span class="s1">GaussianProcessClassifier</span><span class="s4">(</span><span class="s1">ClassifierMixin</span><span class="s4">, </span><span class="s1">BaseEstimator</span><span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Gaussian process classification (GPC) based on Laplace approximation. 
 
    The implementation is based on Algorithm 3.1, 3.2, and 5.1 from [RW2006]_. 
 
    Internally, the Laplace approximation is used for approximating the 
    non-Gaussian posterior by a Gaussian. 
 
    Currently, the implementation is restricted to using the logistic link 
    function. For multi-class classification, several binary one-versus rest 
    classifiers are fitted. Note that this class thus does not implement 
    a true multi-class Laplace approximation. 
 
    Read more in the :ref:`User Guide &lt;gaussian_process&gt;`. 
 
    .. versionadded:: 0.18 
 
    Parameters 
    ---------- 
    kernel : kernel instance, default=None 
        The kernel specifying the covariance function of the GP. If None is 
        passed, the kernel &quot;1.0 * RBF(1.0)&quot; is used as default. Note that 
        the kernel's hyperparameters are optimized during fitting. Also kernel 
        cannot be a `CompoundKernel`. 
 
    optimizer : 'fmin_l_bfgs_b', callable or None, default='fmin_l_bfgs_b' 
        Can either be one of the internally supported optimizers for optimizing 
        the kernel's parameters, specified by a string, or an externally 
        defined optimizer passed as a callable. If a callable is passed, it 
        must have the  signature:: 
 
            def optimizer(obj_func, initial_theta, bounds): 
                # * 'obj_func' is the objective function to be maximized, which 
                #   takes the hyperparameters theta as parameter and an 
                #   optional flag eval_gradient, which determines if the 
                #   gradient is returned additionally to the function value 
                # * 'initial_theta': the initial value for theta, which can be 
                #   used by local optimizers 
                # * 'bounds': the bounds on the values of theta 
                .... 
                # Returned are the best found hyperparameters theta and 
                # the corresponding value of the target function. 
                return theta_opt, func_min 
 
        Per default, the 'L-BFGS-B' algorithm from scipy.optimize.minimize 
        is used. If None is passed, the kernel's parameters are kept fixed. 
        Available internal optimizers are:: 
 
            'fmin_l_bfgs_b' 
 
    n_restarts_optimizer : int, default=0 
        The number of restarts of the optimizer for finding the kernel's 
        parameters which maximize the log-marginal likelihood. The first run 
        of the optimizer is performed from the kernel's initial parameters, 
        the remaining ones (if any) from thetas sampled log-uniform randomly 
        from the space of allowed theta-values. If greater than 0, all bounds 
        must be finite. Note that n_restarts_optimizer=0 implies that one 
        run is performed. 
 
    max_iter_predict : int, default=100 
        The maximum number of iterations in Newton's method for approximating 
        the posterior during predict. Smaller values will reduce computation 
        time at the cost of worse results. 
 
    warm_start : bool, default=False 
        If warm-starts are enabled, the solution of the last Newton iteration 
        on the Laplace approximation of the posterior mode is used as 
        initialization for the next call of _posterior_mode(). This can speed 
        up convergence when _posterior_mode is called several times on similar 
        problems as in hyperparameter optimization. See :term:`the Glossary 
        &lt;warm_start&gt;`. 
 
    copy_X_train : bool, default=True 
        If True, a persistent copy of the training data is stored in the 
        object. Otherwise, just a reference to the training data is stored, 
        which might cause predictions to change if the data is modified 
        externally. 
 
    random_state : int, RandomState instance or None, default=None 
        Determines random number generation used to initialize the centers. 
        Pass an int for reproducible results across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    multi_class : {'one_vs_rest', 'one_vs_one'}, default='one_vs_rest' 
        Specifies how multi-class classification problems are handled. 
        Supported are 'one_vs_rest' and 'one_vs_one'. In 'one_vs_rest', 
        one binary Gaussian process classifier is fitted for each class, which 
        is trained to separate this class from the rest. In 'one_vs_one', one 
        binary Gaussian process classifier is fitted for each pair of classes, 
        which is trained to separate these two classes. The predictions of 
        these binary predictors are combined into multi-class predictions. 
        Note that 'one_vs_one' does not support predicting probability 
        estimates. 
 
    n_jobs : int, default=None 
        The number of jobs to use for the computation: the specified 
        multiclass problems are computed in parallel. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    Attributes 
    ---------- 
    base_estimator_ : ``Estimator`` instance 
        The estimator instance that defines the likelihood function 
        using the observed data. 
 
    kernel_ : kernel instance 
        The kernel used for prediction. In case of binary classification, 
        the structure of the kernel is the same as the one passed as parameter 
        but with optimized hyperparameters. In case of multi-class 
        classification, a CompoundKernel is returned which consists of the 
        different kernels used in the one-versus-rest classifiers. 
 
    log_marginal_likelihood_value_ : float 
        The log-marginal-likelihood of ``self.kernel_.theta`` 
 
    classes_ : array-like of shape (n_classes,) 
        Unique class labels. 
 
    n_classes_ : int 
        The number of classes in the training data 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    GaussianProcessRegressor : Gaussian process regression (GPR). 
 
    References 
    ---------- 
    .. [RW2006] `Carl E. Rasmussen and Christopher K.I. Williams, 
       &quot;Gaussian Processes for Machine Learning&quot;, 
       MIT Press 2006 &lt;https://www.gaussianprocess.org/gpml/chapters/RW.pdf&gt;`_ 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.datasets import load_iris 
    &gt;&gt;&gt; from sklearn.gaussian_process import GaussianProcessClassifier 
    &gt;&gt;&gt; from sklearn.gaussian_process.kernels import RBF 
    &gt;&gt;&gt; X, y = load_iris(return_X_y=True) 
    &gt;&gt;&gt; kernel = 1.0 * RBF(1.0) 
    &gt;&gt;&gt; gpc = GaussianProcessClassifier(kernel=kernel, 
    ...         random_state=0).fit(X, y) 
    &gt;&gt;&gt; gpc.score(X, y) 
    0.9866... 
    &gt;&gt;&gt; gpc.predict_proba(X[:2,:]) 
    array([[0.83548752, 0.03228706, 0.13222543], 
           [0.79064206, 0.06525643, 0.14410151]]) 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s4">: </span><span class="s1">dict </span><span class="s4">= {</span>
        <span class="s6">&quot;kernel&quot;</span><span class="s4">: [</span><span class="s1">Kernel</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s6">&quot;optimizer&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s6">&quot;fmin_l_bfgs_b&quot;</span><span class="s4">}), </span><span class="s1">callable</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s6">&quot;n_restarts_optimizer&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s5">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s6">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s6">&quot;max_iter_predict&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s5">1</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s6">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s6">&quot;warm_start&quot;</span><span class="s4">: [</span><span class="s6">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s6">&quot;copy_X_train&quot;</span><span class="s4">: [</span><span class="s6">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s6">&quot;random_state&quot;</span><span class="s4">: [</span><span class="s6">&quot;random_state&quot;</span><span class="s4">],</span>
        <span class="s6">&quot;multi_class&quot;</span><span class="s4">: [</span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s6">&quot;one_vs_rest&quot;</span><span class="s4">, </span><span class="s6">&quot;one_vs_one&quot;</span><span class="s4">})],</span>
        <span class="s6">&quot;n_jobs&quot;</span><span class="s4">: [</span><span class="s1">Integral</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
    <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">kernel</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">optimizer</span><span class="s4">=</span><span class="s6">&quot;fmin_l_bfgs_b&quot;</span><span class="s4">,</span>
        <span class="s1">n_restarts_optimizer</span><span class="s4">=</span><span class="s5">0</span><span class="s4">,</span>
        <span class="s1">max_iter_predict</span><span class="s4">=</span><span class="s5">100</span><span class="s4">,</span>
        <span class="s1">warm_start</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">copy_X_train</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">random_state</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">multi_class</span><span class="s4">=</span><span class="s6">&quot;one_vs_rest&quot;</span><span class="s4">,</span>
        <span class="s1">n_jobs</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">kernel </span><span class="s4">= </span><span class="s1">kernel</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">optimizer </span><span class="s4">= </span><span class="s1">optimizer</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_restarts_optimizer </span><span class="s4">= </span><span class="s1">n_restarts_optimizer</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">max_iter_predict </span><span class="s4">= </span><span class="s1">max_iter_predict</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">warm_start </span><span class="s4">= </span><span class="s1">warm_start</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">copy_X_train </span><span class="s4">= </span><span class="s1">copy_X_train</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">random_state </span><span class="s4">= </span><span class="s1">random_state</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">multi_class </span><span class="s4">= </span><span class="s1">multi_class</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs </span><span class="s4">= </span><span class="s1">n_jobs</span>

    <span class="s4">@</span><span class="s1">_fit_context</span><span class="s4">(</span><span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">fit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Fit Gaussian process classification model. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) or list of object 
            Feature vectors or other representations of training data. 
 
        y : array-like of shape (n_samples,) 
            Target values, must be binary. 
 
        Returns 
        ------- 
        self : object 
            Returns an instance of self. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel</span><span class="s4">, </span><span class="s1">CompoundKernel</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s6">&quot;kernel cannot be a CompoundKernel&quot;</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel </span><span class="s3">is None or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">requires_vector_input</span><span class="s4">:</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">y </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">multi_output</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">ensure_2d</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s6">&quot;numeric&quot;</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">X</span><span class="s4">, </span><span class="s1">y </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span>
                <span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">multi_output</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">ensure_2d</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s3">None</span>
            <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">base_estimator_ </span><span class="s4">= </span><span class="s1">_BinaryGaussianProcessClassifierLaplace</span><span class="s4">(</span>
            <span class="s1">kernel</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel</span><span class="s4">,</span>
            <span class="s1">optimizer</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">optimizer</span><span class="s4">,</span>
            <span class="s1">n_restarts_optimizer</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_restarts_optimizer</span><span class="s4">,</span>
            <span class="s1">max_iter_predict</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">max_iter_predict</span><span class="s4">,</span>
            <span class="s1">warm_start</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">warm_start</span><span class="s4">,</span>
            <span class="s1">copy_X_train</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">copy_X_train</span><span class="s4">,</span>
            <span class="s1">random_state</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">random_state</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">classes_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">unique</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">n_classes_ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">.</span><span class="s1">size</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_classes_ </span><span class="s4">== </span><span class="s5">1</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s6">&quot;GaussianProcessClassifier requires 2 or more &quot;</span>
                <span class="s6">&quot;distinct classes; got %d class (only class %s &quot;</span>
                <span class="s6">&quot;is present)&quot; </span><span class="s4">% (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_classes_</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>
            <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_classes_ </span><span class="s4">&gt; </span><span class="s5">2</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">multi_class </span><span class="s4">== </span><span class="s6">&quot;one_vs_rest&quot;</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">base_estimator_ </span><span class="s4">= </span><span class="s1">OneVsRestClassifier</span><span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">base_estimator_</span><span class="s4">, </span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs</span>
                <span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">multi_class </span><span class="s4">== </span><span class="s6">&quot;one_vs_one&quot;</span><span class="s4">:</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">base_estimator_ </span><span class="s4">= </span><span class="s1">OneVsOneClassifier</span><span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">base_estimator_</span><span class="s4">, </span><span class="s1">n_jobs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_jobs</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s6">&quot;Unknown multi-class mode %s&quot; </span><span class="s4">% </span><span class="s1">self</span><span class="s4">.</span><span class="s1">multi_class</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">base_estimator_</span><span class="s4">.</span><span class="s1">fit</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_classes_ </span><span class="s4">&gt; </span><span class="s5">2</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">log_marginal_likelihood_value_ </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">mean</span><span class="s4">(</span>
                <span class="s4">[</span>
                    <span class="s1">estimator</span><span class="s4">.</span><span class="s1">log_marginal_likelihood</span><span class="s4">()</span>
                    <span class="s3">for </span><span class="s1">estimator </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">base_estimator_</span><span class="s4">.</span><span class="s1">estimators_</span>
                <span class="s4">]</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">log_marginal_likelihood_value_ </span><span class="s4">= (</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">base_estimator_</span><span class="s4">.</span><span class="s1">log_marginal_likelihood</span><span class="s4">()</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">predict</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Perform classification on an array of test vectors X. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) or list of object 
            Query points where the GP is evaluated for classification. 
 
        Returns 
        ------- 
        C : ndarray of shape (n_samples,) 
            Predicted target values for X, values are from ``classes_``. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel </span><span class="s3">is None or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">requires_vector_input</span><span class="s4">:</span>
            <span class="s1">X </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">ensure_2d</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s6">&quot;numeric&quot;</span><span class="s4">, </span><span class="s1">reset</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">X </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">ensure_2d</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">reset</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">base_estimator_</span><span class="s4">.</span><span class="s1">predict</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">predict_proba</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">X</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return probability estimates for the test vector X. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) or list of object 
            Query points where the GP is evaluated for classification. 
 
        Returns 
        ------- 
        C : array-like of shape (n_samples, n_classes) 
            Returns the probability of the samples for each class in 
            the model. The columns correspond to the classes in sorted 
            order, as they appear in the attribute :term:`classes_`. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_classes_ </span><span class="s4">&gt; </span><span class="s5">2 </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">multi_class </span><span class="s4">== </span><span class="s6">&quot;one_vs_one&quot;</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s6">&quot;one_vs_one multi-class mode does not support &quot;</span>
                <span class="s6">&quot;predicting probability estimates. Use &quot;</span>
                <span class="s6">&quot;one_vs_rest mode instead.&quot;</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel </span><span class="s3">is None or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">kernel</span><span class="s4">.</span><span class="s1">requires_vector_input</span><span class="s4">:</span>
            <span class="s1">X </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">ensure_2d</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s6">&quot;numeric&quot;</span><span class="s4">, </span><span class="s1">reset</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">X </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_data</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">ensure_2d</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">reset</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">base_estimator_</span><span class="s4">.</span><span class="s1">predict_proba</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">kernel_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return the kernel of the base estimator.&quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_classes_ </span><span class="s4">== </span><span class="s5">2</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">base_estimator_</span><span class="s4">.</span><span class="s1">kernel_</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">CompoundKernel</span><span class="s4">(</span>
                <span class="s4">[</span><span class="s1">estimator</span><span class="s4">.</span><span class="s1">kernel_ </span><span class="s3">for </span><span class="s1">estimator </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">base_estimator_</span><span class="s4">.</span><span class="s1">estimators_</span><span class="s4">]</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">log_marginal_likelihood</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">theta</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">eval_gradient</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">clone_kernel</span><span class="s4">=</span><span class="s3">True</span>
    <span class="s4">):</span>
        <span class="s0">&quot;&quot;&quot;Return log-marginal likelihood of theta for training data. 
 
        In the case of multi-class classification, the mean log-marginal 
        likelihood of the one-versus-rest classifiers are returned. 
 
        Parameters 
        ---------- 
        theta : array-like of shape (n_kernel_params,), default=None 
            Kernel hyperparameters for which the log-marginal likelihood is 
            evaluated. In the case of multi-class classification, theta may 
            be the  hyperparameters of the compound kernel or of an individual 
            kernel. In the latter case, all individual kernel get assigned the 
            same theta values. If None, the precomputed log_marginal_likelihood 
            of ``self.kernel_.theta`` is returned. 
 
        eval_gradient : bool, default=False 
            If True, the gradient of the log-marginal likelihood with respect 
            to the kernel hyperparameters at position theta is returned 
            additionally. Note that gradient computation is not supported 
            for non-binary classification. If True, theta must not be None. 
 
        clone_kernel : bool, default=True 
            If True, the kernel attribute is copied. If False, the kernel 
            attribute is modified, but may result in a performance improvement. 
 
        Returns 
        ------- 
        log_likelihood : float 
            Log-marginal likelihood of theta for training data. 
 
        log_likelihood_gradient : ndarray of shape (n_kernel_params,), optional 
            Gradient of the log-marginal likelihood with respect to the kernel 
            hyperparameters at position theta. 
            Only returned when `eval_gradient` is True. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">theta </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">eval_gradient</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s6">&quot;Gradient can only be evaluated for theta!=None&quot;</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">log_marginal_likelihood_value_</span>

        <span class="s1">theta </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">theta</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n_classes_ </span><span class="s4">== </span><span class="s5">2</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">base_estimator_</span><span class="s4">.</span><span class="s1">log_marginal_likelihood</span><span class="s4">(</span>
                <span class="s1">theta</span><span class="s4">, </span><span class="s1">eval_gradient</span><span class="s4">, </span><span class="s1">clone_kernel</span><span class="s4">=</span><span class="s1">clone_kernel</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">eval_gradient</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">(</span>
                    <span class="s6">&quot;Gradient of log-marginal-likelihood not implemented for &quot;</span>
                    <span class="s6">&quot;multi-class GPC.&quot;</span>
                <span class="s4">)</span>
            <span class="s1">estimators </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">base_estimator_</span><span class="s4">.</span><span class="s1">estimators_</span>
            <span class="s1">n_dims </span><span class="s4">= </span><span class="s1">estimators</span><span class="s4">[</span><span class="s5">0</span><span class="s4">].</span><span class="s1">kernel_</span><span class="s4">.</span><span class="s1">n_dims</span>
            <span class="s3">if </span><span class="s1">theta</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] == </span><span class="s1">n_dims</span><span class="s4">:  </span><span class="s2"># use same theta for all sub-kernels</span>
                <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">mean</span><span class="s4">(</span>
                    <span class="s4">[</span>
                        <span class="s1">estimator</span><span class="s4">.</span><span class="s1">log_marginal_likelihood</span><span class="s4">(</span>
                            <span class="s1">theta</span><span class="s4">, </span><span class="s1">clone_kernel</span><span class="s4">=</span><span class="s1">clone_kernel</span>
                        <span class="s4">)</span>
                        <span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">estimator </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">estimators</span><span class="s4">)</span>
                    <span class="s4">]</span>
                <span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">theta</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">] == </span><span class="s1">n_dims </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">]:</span>
                <span class="s2"># theta for compound kernel</span>
                <span class="s3">return </span><span class="s1">np</span><span class="s4">.</span><span class="s1">mean</span><span class="s4">(</span>
                    <span class="s4">[</span>
                        <span class="s1">estimator</span><span class="s4">.</span><span class="s1">log_marginal_likelihood</span><span class="s4">(</span>
                            <span class="s1">theta</span><span class="s4">[</span><span class="s1">n_dims </span><span class="s4">* </span><span class="s1">i </span><span class="s4">: </span><span class="s1">n_dims </span><span class="s4">* (</span><span class="s1">i </span><span class="s4">+ </span><span class="s5">1</span><span class="s4">)],</span>
                            <span class="s1">clone_kernel</span><span class="s4">=</span><span class="s1">clone_kernel</span><span class="s4">,</span>
                        <span class="s4">)</span>
                        <span class="s3">for </span><span class="s1">i</span><span class="s4">, </span><span class="s1">estimator </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s4">(</span><span class="s1">estimators</span><span class="s4">)</span>
                    <span class="s4">]</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                    <span class="s6">&quot;Shape of theta must be either %d or %d. &quot;</span>
                    <span class="s6">&quot;Obtained theta with shape %d.&quot;</span>
                    <span class="s4">% (</span><span class="s1">n_dims</span><span class="s4">, </span><span class="s1">n_dims </span><span class="s4">* </span><span class="s1">self</span><span class="s4">.</span><span class="s1">classes_</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">], </span><span class="s1">theta</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s5">0</span><span class="s4">])</span>
                <span class="s4">)</span>
</pre>
</body>
</html>