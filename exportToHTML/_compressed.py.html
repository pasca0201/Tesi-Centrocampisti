<html>
<head>
<title>_compressed.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #cf8e6d;}
.s4 { color: #7a7e85;}
.s5 { color: #2aacb8;}
.s6 { color: #6aab73;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_compressed.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Base class for sparse matrix formats using compressed storage.&quot;&quot;&quot;</span>
<span class="s1">__all__ </span><span class="s2">= []</span>

<span class="s3">from </span><span class="s1">warnings </span><span class="s3">import </span><span class="s1">warn</span>
<span class="s3">import </span><span class="s1">operator</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">_lib</span><span class="s2">.</span><span class="s1">_util </span><span class="s3">import </span><span class="s1">_prune_array</span><span class="s2">, </span><span class="s1">copy_if_needed</span>

<span class="s3">from </span><span class="s2">.</span><span class="s1">_base </span><span class="s3">import </span><span class="s1">_spbase</span><span class="s2">, </span><span class="s1">issparse</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">, </span><span class="s1">SparseEfficiencyWarning</span>
<span class="s3">from </span><span class="s2">.</span><span class="s1">_data </span><span class="s3">import </span><span class="s1">_data_matrix</span><span class="s2">, </span><span class="s1">_minmax_mixin</span>
<span class="s3">from </span><span class="s2">. </span><span class="s3">import </span><span class="s1">_sparsetools</span>
<span class="s3">from </span><span class="s2">.</span><span class="s1">_sparsetools </span><span class="s3">import </span><span class="s2">(</span><span class="s1">get_csr_submatrix</span><span class="s2">, </span><span class="s1">csr_sample_offsets</span><span class="s2">, </span><span class="s1">csr_todense</span><span class="s2">,</span>
                           <span class="s1">csr_sample_values</span><span class="s2">, </span><span class="s1">csr_row_index</span><span class="s2">, </span><span class="s1">csr_row_slice</span><span class="s2">,</span>
                           <span class="s1">csr_column_index1</span><span class="s2">, </span><span class="s1">csr_column_index2</span><span class="s2">)</span>
<span class="s3">from </span><span class="s2">.</span><span class="s1">_index </span><span class="s3">import </span><span class="s1">IndexMixin</span>
<span class="s3">from </span><span class="s2">.</span><span class="s1">_sputils </span><span class="s3">import </span><span class="s2">(</span><span class="s1">upcast</span><span class="s2">, </span><span class="s1">upcast_char</span><span class="s2">, </span><span class="s1">to_native</span><span class="s2">, </span><span class="s1">isdense</span><span class="s2">, </span><span class="s1">isshape</span><span class="s2">,</span>
                       <span class="s1">getdtype</span><span class="s2">, </span><span class="s1">isscalarlike</span><span class="s2">, </span><span class="s1">isintlike</span><span class="s2">, </span><span class="s1">downcast_intp_index</span><span class="s2">,</span>
                       <span class="s1">get_sum_dtype</span><span class="s2">, </span><span class="s1">check_shape</span><span class="s2">, </span><span class="s1">is_pydata_spmatrix</span><span class="s2">)</span>


<span class="s3">class </span><span class="s1">_cs_matrix</span><span class="s2">(</span><span class="s1">_data_matrix</span><span class="s2">, </span><span class="s1">_minmax_mixin</span><span class="s2">, </span><span class="s1">IndexMixin</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot; 
    base array/matrix class for compressed row- and column-oriented arrays/matrices 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=</span><span class="s3">None</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">None</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">False</span><span class="s2">):</span>
        <span class="s1">_data_matrix</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">arg1</span><span class="s2">)</span>
        <span class="s1">is_array </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">)</span>

        <span class="s3">if </span><span class="s1">issparse</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">):</span>
            <span class="s3">if </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">format </span><span class="s2">== </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s3">and </span><span class="s1">copy</span><span class="s2">:</span>
                <span class="s1">arg1 </span><span class="s2">= </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
            <span class="s3">else</span><span class="s2">:</span>
                <span class="s1">arg1 </span><span class="s2">= </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">asformat</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= (</span>
                <span class="s1">arg1</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">_shape</span>
            <span class="s2">)</span>

        <span class="s3">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">):</span>
            <span class="s3">if </span><span class="s1">isshape</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">allow_1d</span><span class="s2">=</span><span class="s1">is_array</span><span class="s2">):</span>
                <span class="s4"># It's a tuple of matrix dimensions (M, N)</span>
                <span class="s4"># create empty matrix</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">allow_1d</span><span class="s2">=</span><span class="s1">is_array</span><span class="s2">)</span>
                <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">)</span>
                <span class="s4"># Select index dtype large enough to pass array and</span>
                <span class="s4"># scalar parameters to sparsetools</span>
                <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">(</span><span class="s1">maxval</span><span class="s2">=</span><span class="s1">max</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">))</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">getdtype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">default</span><span class="s2">=</span><span class="s1">float</span><span class="s2">))</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">idx_dtype</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">M </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
            <span class="s3">else</span><span class="s2">:</span>
                <span class="s3">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">) == </span><span class="s5">2</span><span class="s2">:</span>
                    <span class="s4"># (data, ij) format</span>
                    <span class="s1">coo </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_coo_container</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
                    <span class="s1">arrays </span><span class="s2">= </span><span class="s1">coo</span><span class="s2">.</span><span class="s1">_coo_to_compressed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">arrays</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">sum_duplicates</span><span class="s2">()</span>
                <span class="s3">elif </span><span class="s1">len</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">) == </span><span class="s5">3</span><span class="s2">:</span>
                    <span class="s4"># (data, indices, indptr) format</span>
                    <span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">) = </span><span class="s1">arg1</span>

                    <span class="s4"># Select index dtype large enough to pass array and</span>
                    <span class="s4"># scalar parameters to sparsetools</span>
                    <span class="s1">maxval </span><span class="s2">= </span><span class="s3">None</span>
                    <span class="s3">if </span><span class="s1">shape </span><span class="s3">is not None and </span><span class="s5">0 </span><span class="s3">not in </span><span class="s1">shape</span><span class="s2">:</span>
                        <span class="s1">maxval </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)</span>
                    <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">((</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">),</span>
                                                <span class="s1">maxval</span><span class="s2">=</span><span class="s1">maxval</span><span class="s2">,</span>
                                                <span class="s1">check_contents</span><span class="s2">=</span><span class="s3">True</span><span class="s2">)</span>

                    <span class="s3">if not </span><span class="s1">copy</span><span class="s2">:</span>
                        <span class="s1">copy </span><span class="s2">= </span><span class="s1">copy_if_needed</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
                    <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
                <span class="s3">else</span><span class="s2">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">f&quot;unrecognized </span><span class="s3">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s3">} </span><span class="s6">&quot;</span>
                                     <span class="s6">f&quot;constructor input: </span><span class="s3">{</span><span class="s1">arg1</span><span class="s3">}</span><span class="s6">&quot;</span><span class="s2">)</span>

        <span class="s3">else</span><span class="s2">:</span>
            <span class="s4"># must be dense</span>
            <span class="s3">try</span><span class="s2">:</span>
                <span class="s1">arg1 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">)</span>
            <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e</span><span class="s2">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">f&quot;unrecognized </span><span class="s3">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s3">} </span><span class="s6">&quot;</span>
                                 <span class="s6">f&quot;constructor input: </span><span class="s3">{</span><span class="s1">arg1</span><span class="s3">}</span><span class="s6">&quot;</span><span class="s2">) </span><span class="s3">from </span><span class="s1">e</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">) </span><span class="s3">and </span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&lt; </span><span class="s5">2 </span><span class="s3">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s2">== </span><span class="s6">&quot;csc&quot;</span><span class="s2">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                    <span class="s6">f&quot;CSC arrays don't support </span><span class="s3">{</span><span class="s1">arg1</span><span class="s2">.</span><span class="s1">ndim</span><span class="s3">}</span><span class="s6">D input. Use 2D&quot;</span>
                <span class="s2">)</span>
            <span class="s1">coo </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_coo_container</span><span class="s2">(</span><span class="s1">arg1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">arrays </span><span class="s2">= </span><span class="s1">coo</span><span class="s2">.</span><span class="s1">_coo_to_compressed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">arrays</span>

        <span class="s4"># Read matrix dimensions given, if any</span>
        <span class="s3">if </span><span class="s1">shape </span><span class="s3">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">allow_1d</span><span class="s2">=</span><span class="s1">is_array</span><span class="s2">)</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s3">is None</span><span class="s2">:</span>
            <span class="s4"># shape not already set, try to infer dimensions</span>
            <span class="s3">try</span><span class="s2">:</span>
                <span class="s1">major_d </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">) - </span><span class="s5">1</span>
                <span class="s1">minor_d </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">max</span><span class="s2">() + </span><span class="s5">1</span>
            <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e</span><span class="s2">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">'unable to infer matrix dimensions'</span><span class="s2">) </span><span class="s3">from </span><span class="s1">e</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">major_d</span><span class="s2">, </span><span class="s1">minor_d</span><span class="s2">)), </span><span class="s1">allow_1d</span><span class="s2">=</span><span class="s1">is_array</span><span class="s2">)</span>

        <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is not None</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">False</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">check_format</span><span class="s2">(</span><span class="s1">full_check</span><span class="s2">=</span><span class="s3">False</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">_getnnz</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">None</span><span class="s2">):</span>
        <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s1">int</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">])</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s3">if </span><span class="s1">axis </span><span class="s3">in </span><span class="s2">(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">):</span>
                <span class="s3">return </span><span class="s1">int</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">])</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">'axis out of bounds'</span><span class="s2">)</span>
        <span class="s3">else</span><span class="s2">:</span>
            <span class="s3">if </span><span class="s1">axis </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s1">axis </span><span class="s2">+= </span><span class="s5">2</span>
            <span class="s1">axis</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">axis</span><span class="s2">, </span><span class="s5">1 </span><span class="s2">- </span><span class="s1">axis</span><span class="s2">))</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
            <span class="s3">if </span><span class="s1">axis </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s3">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">bincount</span><span class="s2">(</span><span class="s1">downcast_intp_index</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">),</span>
                                   <span class="s1">minlength</span><span class="s2">=</span><span class="s1">N</span><span class="s2">)</span>
            <span class="s3">elif </span><span class="s1">axis </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s3">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">)</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">'axis out of bounds'</span><span class="s2">)</span>

    <span class="s1">_getnnz</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">_getnnz</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s3">def </span><span class="s1">check_format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">full_check</span><span class="s2">=</span><span class="s3">True</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Check whether the array/matrix respects the CSR or CSC format. 
 
        Parameters 
        ---------- 
        full_check : bool, optional 
            If `True`, run rigorous check, scanning arrays for valid values. 
            Note that activating those check might copy arrays for casting, 
            modifying indices and index pointers' inplace. 
            If `False`, run basic checks on attributes. O(1) operations. 
            Default is `True`. 
        &quot;&quot;&quot;</span>
        <span class="s4"># index arrays should have integer data types</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">!= </span><span class="s6">'i'</span><span class="s2">:</span>
            <span class="s1">warn</span><span class="s2">(</span><span class="s6">f&quot;indptr array has non-integer dtype (</span><span class="s3">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">name</span><span class="s3">}</span><span class="s6">)&quot;</span><span class="s2">,</span>
                 <span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">3</span><span class="s2">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">kind </span><span class="s2">!= </span><span class="s6">'i'</span><span class="s2">:</span>
            <span class="s1">warn</span><span class="s2">(</span><span class="s6">f&quot;indices array has non-integer dtype (</span><span class="s3">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">name</span><span class="s3">}</span><span class="s6">)&quot;</span><span class="s2">,</span>
                 <span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">3</span><span class="s2">)</span>

        <span class="s4"># check array shapes</span>
        <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s2">[</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">.</span><span class="s1">ndim</span><span class="s2">]:</span>
            <span class="s3">if </span><span class="s1">x </span><span class="s2">!= </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">'data, indices, and indptr should be 1-D'</span><span class="s2">)</span>

        <span class="s4"># check index pointer. Use _swap to determine proper bounds</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">)</span>

        <span class="s3">if </span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">) != </span><span class="s1">M </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">f&quot;index pointer size </span><span class="s3">{</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">)</span><span class="s3">} </span><span class="s6">should be </span><span class="s3">{</span><span class="s1">M </span><span class="s2">+ </span><span class="s5">1</span><span class="s3">}</span><span class="s6">&quot;</span><span class="s2">)</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] != </span><span class="s5">0</span><span class="s2">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;index pointer should start with 0&quot;</span><span class="s2">)</span>

        <span class="s4"># check index and data arrays</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">) != </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">)):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;indices and data should have the same size&quot;</span><span class="s2">)</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] &gt; </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">)):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;Last value of index pointer should be less than &quot;</span>
                             <span class="s6">&quot;the size of index and data arrays&quot;</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">prune</span><span class="s2">()</span>

        <span class="s3">if </span><span class="s1">full_check</span><span class="s2">:</span>
            <span class="s4"># check format validity (more expensive)</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz </span><span class="s2">&gt; </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">max</span><span class="s2">() &gt;= </span><span class="s1">N</span><span class="s2">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">f&quot;indices must be &lt; </span><span class="s3">{</span><span class="s1">N</span><span class="s3">}</span><span class="s6">&quot;</span><span class="s2">)</span>
                <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">min</span><span class="s2">() &lt; </span><span class="s5">0</span><span class="s2">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;indices must be &gt;= 0&quot;</span><span class="s2">)</span>
                <span class="s3">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">).</span><span class="s1">min</span><span class="s2">() &lt; </span><span class="s5">0</span><span class="s2">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;indptr must be a non-decreasing sequence&quot;</span><span class="s2">)</span>

            <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">))</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">to_native</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">)</span>

        <span class="s4"># if not self.has_sorted_indices():</span>
        <span class="s4">#    warn('Indices were not in sorted order.  Sorting indices.')</span>
        <span class="s4">#    self.sort_indices()</span>
        <span class="s4">#    assert(self.has_sorted_indices())</span>
        <span class="s4"># TODO check for duplicates?</span>

    <span class="s4">#######################</span>
    <span class="s4"># Boolean comparisons #</span>
    <span class="s4">#######################</span>

    <span class="s3">def </span><span class="s1">_scalar_binopt</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Scalar version of self._binopt, for cases in which no new nonzeros 
        are added. Produces a new sparse array in canonical form. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">sum_duplicates</span><span class="s2">()</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_with_data</span><span class="s2">(</span><span class="s1">op</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">other</span><span class="s2">), </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">True</span><span class="s2">)</span>
        <span class="s1">res</span><span class="s2">.</span><span class="s1">eliminate_zeros</span><span class="s2">()</span>
        <span class="s3">return </span><span class="s1">res</span>

    <span class="s3">def </span><span class="s1">__eq__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s4"># Scalar other.</span>
        <span class="s3">if </span><span class="s1">isscalarlike</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s3">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
                <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">)</span>

            <span class="s3">if </span><span class="s1">other </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s1">warn</span><span class="s2">(</span><span class="s6">&quot;Comparing a sparse matrix with 0 using == is inefficient&quot;</span>
                     <span class="s6">&quot;, try using != instead.&quot;</span><span class="s2">, </span><span class="s1">SparseEfficiencyWarning</span><span class="s2">,</span>
                     <span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">3</span><span class="s2">)</span>
                <span class="s1">all_true </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">))</span>
                <span class="s1">inv </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_scalar_binopt</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">ne</span><span class="s2">)</span>
                <span class="s3">return </span><span class="s1">all_true </span><span class="s2">- </span><span class="s1">inv</span>
            <span class="s3">else</span><span class="s2">:</span>
                <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_scalar_binopt</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">eq</span><span class="s2">)</span>
        <span class="s4"># Dense other.</span>
        <span class="s3">elif </span><span class="s1">isdense</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">todense</span><span class="s2">() == </span><span class="s1">other</span>
        <span class="s4"># Pydata sparse other.</span>
        <span class="s3">elif </span><span class="s1">is_pydata_spmatrix</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>
        <span class="s4"># Sparse other.</span>
        <span class="s3">elif </span><span class="s1">issparse</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s1">warn</span><span class="s2">(</span><span class="s6">&quot;Comparing sparse matrices using == is inefficient, try using&quot;</span>
                 <span class="s6">&quot; != instead.&quot;</span><span class="s2">, </span><span class="s1">SparseEfficiencyWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">3</span><span class="s2">)</span>
            <span class="s4"># TODO sparse broadcasting</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
                <span class="s3">return False</span>
            <span class="s3">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s2">!= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">format</span><span class="s2">:</span>
                <span class="s1">other </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">asformat</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">)</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_binopt</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s6">'_ne_'</span><span class="s2">)</span>
            <span class="s1">all_true </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">))</span>
            <span class="s3">return </span><span class="s1">all_true </span><span class="s2">- </span><span class="s1">res</span>
        <span class="s3">else</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

    <span class="s3">def </span><span class="s1">__ne__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s4"># Scalar other.</span>
        <span class="s3">if </span><span class="s1">isscalarlike</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s3">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">isnan</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
                <span class="s1">warn</span><span class="s2">(</span><span class="s6">&quot;Comparing a sparse matrix with nan using != is&quot;</span>
                     <span class="s6">&quot; inefficient&quot;</span><span class="s2">, </span><span class="s1">SparseEfficiencyWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">3</span><span class="s2">)</span>
                <span class="s1">all_true </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">))</span>
                <span class="s3">return </span><span class="s1">all_true</span>
            <span class="s3">elif </span><span class="s1">other </span><span class="s2">!= </span><span class="s5">0</span><span class="s2">:</span>
                <span class="s1">warn</span><span class="s2">(</span><span class="s6">&quot;Comparing a sparse matrix with a nonzero scalar using !=&quot;</span>
                     <span class="s6">&quot; is inefficient, try using == instead.&quot;</span><span class="s2">,</span>
                     <span class="s1">SparseEfficiencyWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">3</span><span class="s2">)</span>
                <span class="s1">all_true </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">)</span>
                <span class="s1">inv </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_scalar_binopt</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">eq</span><span class="s2">)</span>
                <span class="s3">return </span><span class="s1">all_true </span><span class="s2">- </span><span class="s1">inv</span>
            <span class="s3">else</span><span class="s2">:</span>
                <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_scalar_binopt</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">ne</span><span class="s2">)</span>
        <span class="s4"># Dense other.</span>
        <span class="s3">elif </span><span class="s1">isdense</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">todense</span><span class="s2">() != </span><span class="s1">other</span>
        <span class="s4"># Pydata sparse other.</span>
        <span class="s3">elif </span><span class="s1">is_pydata_spmatrix</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>
        <span class="s4"># Sparse other.</span>
        <span class="s3">elif </span><span class="s1">issparse</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s4"># TODO sparse broadcasting</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
                <span class="s3">return True</span>
            <span class="s3">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s2">!= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">format</span><span class="s2">:</span>
                <span class="s1">other </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">asformat</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">)</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_binopt</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s6">'_ne_'</span><span class="s2">)</span>
        <span class="s3">else</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

    <span class="s3">def </span><span class="s1">_inequality</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">bad_scalar_msg</span><span class="s2">):</span>
        <span class="s4"># Scalar other.</span>
        <span class="s3">if </span><span class="s1">isscalarlike</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s3">if </span><span class="s5">0 </span><span class="s2">== </span><span class="s1">other </span><span class="s3">and </span><span class="s1">op_name </span><span class="s3">in </span><span class="s2">(</span><span class="s6">'_le_'</span><span class="s2">, </span><span class="s6">'_ge_'</span><span class="s2">):</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s6">&quot; &gt;= and &lt;= don't work with 0.&quot;</span><span class="s2">)</span>
            <span class="s3">elif </span><span class="s1">op</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
                <span class="s1">warn</span><span class="s2">(</span><span class="s1">bad_scalar_msg</span><span class="s2">, </span><span class="s1">SparseEfficiencyWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">3</span><span class="s2">)</span>
                <span class="s1">other_arr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">result_type</span><span class="s2">(</span><span class="s1">other</span><span class="s2">))</span>
                <span class="s1">other_arr</span><span class="s2">.</span><span class="s1">fill</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
                <span class="s1">other_arr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">other_arr</span><span class="s2">)</span>
                <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_binopt</span><span class="s2">(</span><span class="s1">other_arr</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">)</span>
            <span class="s3">else</span><span class="s2">:</span>
                <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_scalar_binopt</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">op</span><span class="s2">)</span>
        <span class="s4"># Dense other.</span>
        <span class="s3">elif </span><span class="s1">isdense</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s3">return </span><span class="s1">op</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">todense</span><span class="s2">(), </span><span class="s1">other</span><span class="s2">)</span>
        <span class="s4"># Sparse other.</span>
        <span class="s3">elif </span><span class="s1">issparse</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s4"># TODO sparse broadcasting</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;inconsistent shapes&quot;</span><span class="s2">)</span>
            <span class="s3">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s2">!= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">format</span><span class="s2">:</span>
                <span class="s1">other </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">asformat</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">)</span>
            <span class="s3">if </span><span class="s1">op_name </span><span class="s3">not in </span><span class="s2">(</span><span class="s6">'_ge_'</span><span class="s2">, </span><span class="s6">'_le_'</span><span class="s2">):</span>
                <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_binopt</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">)</span>

            <span class="s1">warn</span><span class="s2">(</span><span class="s6">&quot;Comparing sparse matrices using &gt;= and &lt;= is inefficient, &quot;</span>
                 <span class="s6">&quot;using &lt;, &gt;, or !=, instead.&quot;</span><span class="s2">,</span>
                 <span class="s1">SparseEfficiencyWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">3</span><span class="s2">)</span>
            <span class="s1">all_true </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">))</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_binopt</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s6">'_gt_' </span><span class="s3">if </span><span class="s1">op_name </span><span class="s2">== </span><span class="s6">'_le_' </span><span class="s3">else </span><span class="s6">'_lt_'</span><span class="s2">)</span>
            <span class="s3">return </span><span class="s1">all_true </span><span class="s2">- </span><span class="s1">res</span>
        <span class="s3">else</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

    <span class="s3">def </span><span class="s1">__lt__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_inequality</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">lt</span><span class="s2">, </span><span class="s6">'_lt_'</span><span class="s2">,</span>
                                <span class="s6">&quot;Comparing a sparse matrix with a scalar &quot;</span>
                                <span class="s6">&quot;greater than zero using &lt; is inefficient, &quot;</span>
                                <span class="s6">&quot;try using &gt;= instead.&quot;</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">__gt__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_inequality</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">gt</span><span class="s2">, </span><span class="s6">'_gt_'</span><span class="s2">,</span>
                                <span class="s6">&quot;Comparing a sparse matrix with a scalar &quot;</span>
                                <span class="s6">&quot;less than zero using &gt; is inefficient, &quot;</span>
                                <span class="s6">&quot;try using &lt;= instead.&quot;</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">__le__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_inequality</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">le</span><span class="s2">, </span><span class="s6">'_le_'</span><span class="s2">,</span>
                                <span class="s6">&quot;Comparing a sparse matrix with a scalar &quot;</span>
                                <span class="s6">&quot;greater than zero using &lt;= is inefficient, &quot;</span>
                                <span class="s6">&quot;try using &gt; instead.&quot;</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">__ge__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_inequality</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">operator</span><span class="s2">.</span><span class="s1">ge</span><span class="s2">, </span><span class="s6">'_ge_'</span><span class="s2">,</span>
                                <span class="s6">&quot;Comparing a sparse matrix with a scalar &quot;</span>
                                <span class="s6">&quot;less than zero using &gt;= is inefficient, &quot;</span>
                                <span class="s6">&quot;try using &lt; instead.&quot;</span><span class="s2">)</span>

    <span class="s4">#################################</span>
    <span class="s4"># Arithmetic operator overrides #</span>
    <span class="s4">#################################</span>

    <span class="s3">def </span><span class="s1">_add_dense</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s3">if </span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">f'Incompatible shapes (</span><span class="s3">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s3">} </span><span class="s6">and </span><span class="s3">{</span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape</span><span class="s3">}</span><span class="s6">)'</span><span class="s2">)</span>
        <span class="s1">dtype </span><span class="s2">= </span><span class="s1">upcast_char</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">)</span>
        <span class="s1">order </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s6">'CF'</span><span class="s2">)[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s1">order</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">True</span><span class="s2">)</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">result </span><span class="s3">if </span><span class="s1">result</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">c_contiguous </span><span class="s3">else </span><span class="s1">result</span><span class="s2">.</span><span class="s1">T</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">)</span>
        <span class="s1">csr_todense</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_container</span><span class="s2">(</span><span class="s1">result</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">False</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">_add_sparse</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_binopt</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s6">'_plus_'</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">_sub_sparse</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_binopt</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s6">'_minus_'</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Point-wise multiplication by array/matrix, vector, or scalar.&quot;&quot;&quot;</span>
        <span class="s4"># Scalar multiplication.</span>
        <span class="s3">if </span><span class="s1">isscalarlike</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mul_scalar</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
        <span class="s4"># Sparse matrix or vector.</span>
        <span class="s3">if </span><span class="s1">issparse</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
                <span class="s1">other </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
                <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_binopt</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s6">'_elmul_'</span><span class="s2">)</span>
            <span class="s4"># Single element.</span>
            <span class="s3">if </span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">):</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mul_scalar</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">toarray</span><span class="s2">()[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">])</span>
                <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
                    <span class="s3">return </span><span class="s1">result</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">((</span><span class="s5">1</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]))</span>
                <span class="s3">return </span><span class="s1">result</span>
            <span class="s3">if </span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== (</span><span class="s5">1</span><span class="s2">,):</span>
                <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mul_scalar</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">toarray</span><span class="s2">()[</span><span class="s5">0</span><span class="s2">])</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s3">in </span><span class="s2">((</span><span class="s5">1</span><span class="s2">,), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">)):</span>
                <span class="s3">return </span><span class="s1">other</span><span class="s2">.</span><span class="s1">_mul_scalar</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">())</span>

            <span class="s4"># broadcast. treat 1d like a row</span>
            <span class="s1">sM</span><span class="s2">, </span><span class="s1">sN </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span>
            <span class="s1">oM</span><span class="s2">, </span><span class="s1">oN </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">_shape_as_2d</span>
            <span class="s4"># A row times a column.</span>
            <span class="s3">if </span><span class="s1">sM </span><span class="s2">== </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">oN </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s3">return </span><span class="s1">other</span><span class="s2">.</span><span class="s1">_matmul_sparse</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">sM</span><span class="s2">, </span><span class="s1">sN</span><span class="s2">).</span><span class="s1">tocsc</span><span class="s2">())</span>
            <span class="s3">if </span><span class="s1">sN </span><span class="s2">== </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">oM </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_matmul_sparse</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">oM</span><span class="s2">, </span><span class="s1">oN</span><span class="s2">).</span><span class="s1">tocsc</span><span class="s2">())</span>

            <span class="s1">is_array </span><span class="s2">= </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">)</span>
            <span class="s4"># Other is a row.</span>
            <span class="s3">if </span><span class="s1">oM </span><span class="s2">== </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">sN </span><span class="s2">== </span><span class="s1">oN</span><span class="s2">:</span>
                <span class="s1">new_other </span><span class="s2">= </span><span class="s1">_make_diagonal_csr</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">toarray</span><span class="s2">().</span><span class="s1">ravel</span><span class="s2">(), </span><span class="s1">is_array</span><span class="s2">)</span>
                <span class="s1">result </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_matmul_sparse</span><span class="s2">(</span><span class="s1">new_other</span><span class="s2">)</span>
                <span class="s3">return </span><span class="s1">result </span><span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2 </span><span class="s3">else </span><span class="s1">result</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">((</span><span class="s5">1</span><span class="s2">, </span><span class="s1">oN</span><span class="s2">))</span>
            <span class="s4"># self is a row.</span>
            <span class="s3">if </span><span class="s1">sM </span><span class="s2">== </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">sN </span><span class="s2">== </span><span class="s1">oN</span><span class="s2">:</span>
                <span class="s1">copy </span><span class="s2">= </span><span class="s1">_make_diagonal_csr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">toarray</span><span class="s2">().</span><span class="s1">ravel</span><span class="s2">(), </span><span class="s1">is_array</span><span class="s2">)</span>
                <span class="s3">return </span><span class="s1">other</span><span class="s2">.</span><span class="s1">_matmul_sparse</span><span class="s2">(</span><span class="s1">copy</span><span class="s2">)</span>

            <span class="s4"># Other is a column.</span>
            <span class="s3">if </span><span class="s1">oN </span><span class="s2">== </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">sM </span><span class="s2">== </span><span class="s1">oM</span><span class="s2">:</span>
                <span class="s1">new_other </span><span class="s2">= </span><span class="s1">_make_diagonal_csr</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">toarray</span><span class="s2">().</span><span class="s1">ravel</span><span class="s2">(), </span><span class="s1">is_array</span><span class="s2">)</span>
                <span class="s3">return </span><span class="s1">new_other</span><span class="s2">.</span><span class="s1">_matmul_sparse</span><span class="s2">(</span><span class="s1">self</span><span class="s2">)</span>
            <span class="s4"># self is a column.</span>
            <span class="s3">if </span><span class="s1">sN </span><span class="s2">== </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">sM </span><span class="s2">== </span><span class="s1">oM</span><span class="s2">:</span>
                <span class="s1">new_self </span><span class="s2">= </span><span class="s1">_make_diagonal_csr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">toarray</span><span class="s2">().</span><span class="s1">ravel</span><span class="s2">(), </span><span class="s1">is_array</span><span class="s2">)</span>
                <span class="s3">return </span><span class="s1">new_self</span><span class="s2">.</span><span class="s1">_matmul_sparse</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;inconsistent shapes&quot;</span><span class="s2">)</span>

        <span class="s4"># Assume other is a dense matrix/array, which produces a single-item</span>
        <span class="s4"># object array if other isn't convertible to ndarray.</span>
        <span class="s1">other </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asanyarray</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>

        <span class="s3">if </span><span class="s1">other</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">&gt; </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">toarray</span><span class="s2">(), </span><span class="s1">other</span><span class="s2">)</span>
        <span class="s4"># Single element / wrapped object.</span>
        <span class="s3">if </span><span class="s1">other</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s3">if </span><span class="s1">other</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">object_</span><span class="s2">:</span>
                <span class="s4"># 'other' not convertible to ndarray.</span>
                <span class="s3">return </span><span class="s1">NotImplemented</span>
            <span class="s1">bshape </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_shapes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_mul_scalar</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">flat</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]).</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">bshape</span><span class="s2">)</span>
        <span class="s4"># Fast case for trivial sparse matrix.</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s3">in </span><span class="s2">((</span><span class="s5">1</span><span class="s2">,), (</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">)):</span>
            <span class="s1">bshape </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_shapes</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(), </span><span class="s1">other</span><span class="s2">).</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">bshape</span><span class="s2">)</span>

        <span class="s1">ret </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tocoo</span><span class="s2">()</span>
        <span class="s4"># Matching shapes.</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">ret</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">other</span><span class="s2">[</span><span class="s1">ret</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">])</span>
            <span class="s1">ret</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">data</span><span class="s2">.</span><span class="s1">view</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">).</span><span class="s1">ravel</span><span class="s2">()</span>
            <span class="s3">return </span><span class="s1">ret</span>

        <span class="s4"># convert other to 2d</span>
        <span class="s1">other2d </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_2d</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
        <span class="s4"># Sparse row vector times...</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] == </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s3">if </span><span class="s1">other2d</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] == </span><span class="s5">1</span><span class="s2">:  </span><span class="s4"># Dense column vector.</span>
                <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">ret</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">other2d</span><span class="s2">)</span>
            <span class="s3">elif </span><span class="s1">other2d</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] == </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]:  </span><span class="s4"># Dense 2d matrix.</span>
                <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">ret</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">other2d</span><span class="s2">[:, </span><span class="s1">ret</span><span class="s2">.</span><span class="s1">col</span><span class="s2">])</span>
            <span class="s3">else</span><span class="s2">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;inconsistent shapes&quot;</span><span class="s2">)</span>
            <span class="s1">row </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">repeat</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">other2d</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]), </span><span class="s1">ret</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">)</span>
            <span class="s1">col </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">tile</span><span class="s2">(</span><span class="s1">ret</span><span class="s2">.</span><span class="s1">col</span><span class="s2">, </span><span class="s1">other2d</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_coo_container</span><span class="s2">(</span>
                <span class="s2">(</span><span class="s1">data</span><span class="s2">.</span><span class="s1">view</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">).</span><span class="s1">ravel</span><span class="s2">(), (</span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">)),</span>
                <span class="s1">shape</span><span class="s2">=(</span><span class="s1">other2d</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]),</span>
                <span class="s1">copy</span><span class="s2">=</span><span class="s3">False</span>
            <span class="s2">)</span>
        <span class="s4"># Sparse column vector times...</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] == </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s3">if </span><span class="s1">other2d</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] == </span><span class="s5">1</span><span class="s2">:  </span><span class="s4"># Dense row vector.</span>
                <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">ret</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[:, </span><span class="s3">None</span><span class="s2">], </span><span class="s1">other2d</span><span class="s2">)</span>
            <span class="s3">elif </span><span class="s1">other2d</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] == </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]:  </span><span class="s4"># Dense 2d array.</span>
                <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">ret</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[:, </span><span class="s3">None</span><span class="s2">], </span><span class="s1">other2d</span><span class="s2">[</span><span class="s1">ret</span><span class="s2">.</span><span class="s1">row</span><span class="s2">])</span>
            <span class="s3">else</span><span class="s2">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;inconsistent shapes&quot;</span><span class="s2">)</span>
            <span class="s1">row </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">repeat</span><span class="s2">(</span><span class="s1">ret</span><span class="s2">.</span><span class="s1">row</span><span class="s2">, </span><span class="s1">other2d</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">])</span>
            <span class="s1">col </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">tile</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">other2d</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">ret</span><span class="s2">.</span><span class="s1">col</span><span class="s2">))</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_coo_container</span><span class="s2">(</span>
                <span class="s2">(</span><span class="s1">data</span><span class="s2">.</span><span class="s1">view</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">).</span><span class="s1">ravel</span><span class="s2">(), (</span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">)),</span>
                <span class="s1">shape</span><span class="s2">=(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">other2d</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]),</span>
                <span class="s1">copy</span><span class="s2">=</span><span class="s3">False</span>
            <span class="s2">)</span>
        <span class="s4"># Sparse matrix times dense row vector.</span>
        <span class="s3">if </span><span class="s1">other2d</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] == </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] == </span><span class="s1">other2d</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">]:</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">ret</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">other2d</span><span class="s2">[:, </span><span class="s1">ret</span><span class="s2">.</span><span class="s1">col</span><span class="s2">].</span><span class="s1">ravel</span><span class="s2">())</span>
        <span class="s4"># Sparse matrix times dense column vector.</span>
        <span class="s3">elif </span><span class="s1">other2d</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] == </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] == </span><span class="s1">other2d</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]:</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">multiply</span><span class="s2">(</span><span class="s1">ret</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">other2d</span><span class="s2">[</span><span class="s1">ret</span><span class="s2">.</span><span class="s1">row</span><span class="s2">].</span><span class="s1">ravel</span><span class="s2">())</span>
        <span class="s3">else</span><span class="s2">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;inconsistent shapes&quot;</span><span class="s2">)</span>
        <span class="s1">ret</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">data</span><span class="s2">.</span><span class="s1">view</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">ndarray</span><span class="s2">).</span><span class="s1">ravel</span><span class="s2">()</span>
        <span class="s3">return </span><span class="s1">ret</span>

    <span class="s4">###########################</span>
    <span class="s4"># Multiplication handlers #</span>
    <span class="s4">###########################</span>

    <span class="s3">def </span><span class="s1">_matmul_vector</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span>

        <span class="s4"># output array</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">upcast_char</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">))</span>

        <span class="s4"># csr_matvec or csc_matvec</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">_sparsetools</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s2">+ </span><span class="s6">'_matvec'</span><span class="s2">)</span>
        <span class="s1">fn</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">result</span><span class="s2">)</span>

        <span class="s3">return </span><span class="s1">result</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] </span><span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1 </span><span class="s3">else </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">_matmul_multivector</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span>
        <span class="s1">n_vecs </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]  </span><span class="s4"># number of column vectors</span>

        <span class="s1">result </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">((</span><span class="s1">M</span><span class="s2">, </span><span class="s1">n_vecs</span><span class="s2">),</span>
                          <span class="s1">dtype</span><span class="s2">=</span><span class="s1">upcast_char</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">char</span><span class="s2">))</span>

        <span class="s4"># csr_matvecs or csc_matvecs</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">_sparsetools</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s2">+ </span><span class="s6">'_matvecs'</span><span class="s2">)</span>
        <span class="s1">fn</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">n_vecs</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">,</span>
           <span class="s1">other</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">(), </span><span class="s1">result</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">())</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s1">result</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">((</span><span class="s1">n_vecs</span><span class="s2">,))</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">_matmul_sparse</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">K1 </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span>
        <span class="s4"># if other is 1d, treat as a **column**</span>
        <span class="s1">o_ndim </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">ndim</span>
        <span class="s3">if </span><span class="s1">o_ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4"># convert 1d array to a 2d column when on the right of @</span>
            <span class="s1">other </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">((</span><span class="s5">1</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])).</span><span class="s1">T  </span><span class="s4"># Note: converts to CSC</span>
        <span class="s1">K2</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">_shape</span>

        <span class="s4"># find new_shape: (M, N), (M,), (N,) or ()</span>
        <span class="s1">new_shape </span><span class="s2">= ()</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s1">new_shape </span><span class="s2">+= (</span><span class="s1">M</span><span class="s2">,)</span>
        <span class="s3">if </span><span class="s1">o_ndim </span><span class="s2">== </span><span class="s5">2</span><span class="s2">:</span>
            <span class="s1">new_shape </span><span class="s2">+= (</span><span class="s1">N</span><span class="s2">,)</span>

        <span class="s1">major_dim </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">))[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s1">other </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)  </span><span class="s4"># convert to this format</span>

        <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">,</span>
                                     <span class="s1">other</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">))</span>

        <span class="s1">fn </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">_sparsetools</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s2">+ </span><span class="s6">'_matmat_maxnnz'</span><span class="s2">)</span>
        <span class="s1">nnz </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">,</span>
                 <span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">),</span>
                 <span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">),</span>
                 <span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">),</span>
                 <span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">))</span>
        <span class="s3">if </span><span class="s1">nnz </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s3">if </span><span class="s1">new_shape </span><span class="s2">== ():</span>
                <span class="s3">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">upcast</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">))</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">new_shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">upcast</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">))</span>

        <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">,</span>
                                     <span class="s1">other</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">),</span>
                                    <span class="s1">maxval</span><span class="s2">=</span><span class="s1">nnz</span><span class="s2">)</span>

        <span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">major_dim </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">upcast</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">))</span>

        <span class="s1">fn </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">_sparsetools</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s2">+ </span><span class="s6">'_matmat'</span><span class="s2">)</span>
        <span class="s1">fn</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">),</span>
           <span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">),</span>
           <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">,</span>
           <span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">),</span>
           <span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">),</span>
           <span class="s1">other</span><span class="s2">.</span><span class="s1">data</span><span class="s2">,</span>
           <span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">data</span><span class="s2">)</span>

        <span class="s3">if </span><span class="s1">new_shape </span><span class="s2">== ():</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">data</span><span class="s2">[</span><span class="s5">0</span><span class="s2">])</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">new_shape</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">diagonal</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">=</span><span class="s5">0</span><span class="s2">):</span>
        <span class="s1">rows</span><span class="s2">, </span><span class="s1">cols </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s3">if </span><span class="s1">k </span><span class="s2">&lt;= -</span><span class="s1">rows </span><span class="s3">or </span><span class="s1">k </span><span class="s2">&gt;= </span><span class="s1">cols</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">_sparsetools</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s2">+ </span><span class="s6">&quot;_diagonal&quot;</span><span class="s2">)</span>
        <span class="s1">y </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">min</span><span class="s2">(</span><span class="s1">rows </span><span class="s2">+ </span><span class="s1">min</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s5">0</span><span class="s2">), </span><span class="s1">cols </span><span class="s2">- </span><span class="s1">max</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s5">0</span><span class="s2">)),</span>
                     <span class="s1">dtype</span><span class="s2">=</span><span class="s1">upcast</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">))</span>
        <span class="s1">fn</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">], </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">,</span>
           <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s1">y</span>

    <span class="s1">diagonal</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">diagonal</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">#####################</span>
    <span class="s4"># Other binary ops  #</span>
    <span class="s4">#####################</span>

    <span class="s3">def </span><span class="s1">_maximum_minimum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">npop</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">, </span><span class="s1">dense_check</span><span class="s2">):</span>
        <span class="s3">if </span><span class="s1">isscalarlike</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s3">if </span><span class="s1">dense_check</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
                <span class="s1">warn</span><span class="s2">(</span><span class="s6">&quot;Taking maximum (minimum) with &gt; 0 (&lt; 0) number results&quot;</span>
                     <span class="s6">&quot; to a dense matrix.&quot;</span><span class="s2">, </span><span class="s1">SparseEfficiencyWarning</span><span class="s2">,</span>
                     <span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">3</span><span class="s2">)</span>
                <span class="s1">other_arr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">other</span><span class="s2">).</span><span class="s1">dtype</span><span class="s2">)</span>
                <span class="s1">other_arr</span><span class="s2">.</span><span class="s1">fill</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>
                <span class="s1">other_arr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">other_arr</span><span class="s2">)</span>
                <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_binopt</span><span class="s2">(</span><span class="s1">other_arr</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">)</span>
            <span class="s3">else</span><span class="s2">:</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">sum_duplicates</span><span class="s2">()</span>
                <span class="s1">new_data </span><span class="s2">= </span><span class="s1">npop</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">other</span><span class="s2">))</span>
                <span class="s1">mat </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">((</span><span class="s1">new_data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">),</span>
                                     <span class="s1">dtype</span><span class="s2">=</span><span class="s1">new_data</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
                <span class="s3">return </span><span class="s1">mat</span>
        <span class="s3">elif </span><span class="s1">isdense</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s3">return </span><span class="s1">npop</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">todense</span><span class="s2">(), </span><span class="s1">other</span><span class="s2">)</span>
        <span class="s3">elif </span><span class="s1">issparse</span><span class="s2">(</span><span class="s1">other</span><span class="s2">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_binopt</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">op_name</span><span class="s2">)</span>
        <span class="s3">else</span><span class="s2">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">&quot;Operands not compatible.&quot;</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">maximum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maximum_minimum</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">,</span>
                                     <span class="s6">'_maximum_'</span><span class="s2">, </span><span class="s3">lambda </span><span class="s1">x</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) &gt; </span><span class="s5">0</span><span class="s2">)</span>

    <span class="s1">maximum</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">maximum</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s3">def </span><span class="s1">minimum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_maximum_minimum</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">minimum</span><span class="s2">,</span>
                                     <span class="s6">'_minimum_'</span><span class="s2">, </span><span class="s3">lambda </span><span class="s1">x</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) &lt; </span><span class="s5">0</span><span class="s2">)</span>

    <span class="s1">minimum</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">minimum</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">#####################</span>
    <span class="s4"># Reduce operations #</span>
    <span class="s4">#####################</span>

    <span class="s3">def </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s3">None</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s3">None</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s3">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Sum the array/matrix over the given axis.  If the axis is None, sum 
        over both rows and columns, returning a scalar. 
        &quot;&quot;&quot;</span>
        <span class="s4"># The _spbase base class already does axis=0 and axis=1 efficiently</span>
        <span class="s4"># so we only do the case axis=None here</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2 </span><span class="s3">and not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">'blocksize'</span><span class="s2">) </span><span class="s3">and</span>
                <span class="s1">axis </span><span class="s3">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(((</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">), (</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">2</span><span class="s2">)))[</span><span class="s5">0</span><span class="s2">]):</span>
            <span class="s4"># faster than multiplication for large minor axis in CSC/CSR</span>
            <span class="s1">res_dtype </span><span class="s2">= </span><span class="s1">get_sum_dtype</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">ret </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">) - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">res_dtype</span><span class="s2">)</span>

            <span class="s1">major_index</span><span class="s2">, </span><span class="s1">value </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_minor_reduce</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">add</span><span class="s2">)</span>
            <span class="s1">ret</span><span class="s2">[</span><span class="s1">major_index</span><span class="s2">] = </span><span class="s1">value</span>
            <span class="s1">ret </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ascontainer</span><span class="s2">(</span><span class="s1">ret</span><span class="s2">)</span>
            <span class="s3">if </span><span class="s1">axis </span><span class="s2">% </span><span class="s5">2 </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s1">ret </span><span class="s2">= </span><span class="s1">ret</span><span class="s2">.</span><span class="s1">T</span>

            <span class="s3">if </span><span class="s1">out </span><span class="s3">is not None and </span><span class="s1">out</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">ret</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">'dimensions do not match'</span><span class="s2">)</span>

            <span class="s3">return </span><span class="s1">ret</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">axis</span><span class="s2">=(), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">out</span><span class="s2">)</span>
        <span class="s3">else</span><span class="s2">:</span>
            <span class="s4"># _spbase handles the situations when axis is in {None, -2, -1, 0, 1}</span>
            <span class="s3">return </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">=</span><span class="s1">axis</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">out</span><span class="s2">)</span>

    <span class="s1">sum</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s3">def </span><span class="s1">_minor_reduce</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">ufunc</span><span class="s2">, </span><span class="s1">data</span><span class="s2">=</span><span class="s3">None</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Reduce nonzeros with a ufunc over the minor axis when non-empty 
 
        Can be applied to a function of self.data by supplying data parameter. 
 
        Warning: this does not call sum_duplicates() 
 
        Returns 
        ------- 
        major_index : array of ints 
            Major indices where nonzero 
 
        value : array of self.dtype 
            Reduce result for nonzeros in each major_index 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">data </span><span class="s3">is None</span><span class="s2">:</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span>
        <span class="s1">major_index </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">flatnonzero</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">))</span>
        <span class="s1">value </span><span class="s2">= </span><span class="s1">ufunc</span><span class="s2">.</span><span class="s1">reduceat</span><span class="s2">(</span><span class="s1">data</span><span class="s2">,</span>
                               <span class="s1">downcast_intp_index</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">major_index</span><span class="s2">]))</span>
        <span class="s3">return </span><span class="s1">major_index</span><span class="s2">, </span><span class="s1">value</span>

    <span class="s4">#######################</span>
    <span class="s4"># Getting and Setting #</span>
    <span class="s4">#######################</span>

    <span class="s3">def </span><span class="s1">_get_int</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">):</span>
        <span class="s3">if </span><span class="s5">0 </span><span class="s2">&lt;= </span><span class="s1">idx </span><span class="s2">&lt;= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]:</span>
            <span class="s1">spot </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">flatnonzero</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices </span><span class="s2">== </span><span class="s1">idx</span><span class="s2">)</span>
            <span class="s3">if </span><span class="s1">spot</span><span class="s2">.</span><span class="s1">size</span><span class="s2">:</span>
                <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">spot</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]]</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">.</span><span class="s1">type</span><span class="s2">(</span><span class="s5">0</span><span class="s2">)</span>
        <span class="s3">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s6">f'index (</span><span class="s3">{</span><span class="s1">idx</span><span class="s3">}</span><span class="s6">) out of range'</span><span class="s2">)</span>

<span class="s4">#    For now, 1d only has integer indexing. Soon we will add get_slice/array</span>
<span class="s4">#    def _get_slice(self, idx):</span>
<span class="s4">#        if idx == slice(None):</span>
<span class="s4">#            return self.copy()</span>
<span class="s4">#        if idx.step in (1, None):</span>
<span class="s4">#            major, minor = self._swap((0, idx))</span>
<span class="s4">#            ret = self._get_submatrix(major, minor, copy=True)</span>
<span class="s4">#            return ret.reshape(ret.shape[-1])</span>
<span class="s4">#</span>
<span class="s4">#        _slice = self._swap((self._minor_slice, self._major_slice))[0]</span>
<span class="s4">#        return _slice(idx)</span>
<span class="s4">#</span>
<span class="s4">#    def _get_array(self, idx):</span>
<span class="s4">#        idx = np.asarray(idx)</span>
<span class="s4">#        idx_dtype = self.indices.dtype</span>
<span class="s4">#        M, N = self._swap((1, self.shape[0]))</span>
<span class="s4">#        row = np.zeros_like(idx, dtype=idx_dtype)</span>
<span class="s4">#        major, minor = self._swap((row, idx))</span>
<span class="s4">#        major = np.asarray(major, dtype=idx_dtype)</span>
<span class="s4">#        minor = np.asarray(minor, dtype=idx_dtype)</span>
<span class="s4">#        if minor.size == 0:</span>
<span class="s4">#            return self.__class__([], dtype=self.dtype)</span>
<span class="s4">#        new_shape = minor.shape if minor.shape[0] &gt; 1 else (minor.shape[-1],)</span>
<span class="s4">#</span>
<span class="s4">#        val = np.empty(major.size, dtype=self.dtype)</span>
<span class="s4">#        csr_sample_values(M, N, self.indptr, self.indices, self.data,</span>
<span class="s4">#                          major.size, major.ravel(), minor.ravel(), val)</span>
<span class="s4">#        return self.__class__(val.reshape(new_shape))</span>

    <span class="s3">def </span><span class="s1">_get_intXint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">):</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s1">major</span><span class="s2">, </span><span class="s1">minor </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">))</span>
        <span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">data </span><span class="s2">= </span><span class="s1">get_csr_submatrix</span><span class="s2">(</span>
            <span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">,</span>
            <span class="s1">major</span><span class="s2">, </span><span class="s1">major </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">, </span><span class="s1">minor</span><span class="s2">, </span><span class="s1">minor </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s1">data</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">_get_sliceXslice</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">):</span>
        <span class="s1">major</span><span class="s2">, </span><span class="s1">minor </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">))</span>
        <span class="s3">if </span><span class="s1">major</span><span class="s2">.</span><span class="s1">step </span><span class="s3">in </span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s3">None</span><span class="s2">) </span><span class="s3">and </span><span class="s1">minor</span><span class="s2">.</span><span class="s1">step </span><span class="s3">in </span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s3">None</span><span class="s2">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_submatrix</span><span class="s2">(</span><span class="s1">major</span><span class="s2">, </span><span class="s1">minor</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">True</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_major_slice</span><span class="s2">(</span><span class="s1">major</span><span class="s2">).</span><span class="s1">_minor_slice</span><span class="s2">(</span><span class="s1">minor</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">_get_arrayXarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">):</span>
        <span class="s4"># inner indexing</span>
        <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s1">major</span><span class="s2">, </span><span class="s1">minor </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">))</span>
        <span class="s1">major </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">major</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">minor </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">minor</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>

        <span class="s1">val </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">major</span><span class="s2">.</span><span class="s1">size</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">csr_sample_values</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">,</span>
                          <span class="s1">major</span><span class="s2">.</span><span class="s1">size</span><span class="s2">, </span><span class="s1">major</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">(), </span><span class="s1">minor</span><span class="s2">.</span><span class="s1">ravel</span><span class="s2">(), </span><span class="s1">val</span><span class="s2">)</span>
        <span class="s3">if </span><span class="s1">major</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_ascontainer</span><span class="s2">(</span><span class="s1">val</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">val</span><span class="s2">.</span><span class="s1">reshape</span><span class="s2">(</span><span class="s1">major</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">))</span>

    <span class="s3">def </span><span class="s1">_get_columnXarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">):</span>
        <span class="s4"># outer indexing</span>
        <span class="s1">major</span><span class="s2">, </span><span class="s1">minor </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">))</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_major_index_fancy</span><span class="s2">(</span><span class="s1">major</span><span class="s2">).</span><span class="s1">_minor_index_fancy</span><span class="s2">(</span><span class="s1">minor</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">_major_index_fancy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Index along the major axis where idx is an array of ints. 
        &quot;&quot;&quot;</span>
        <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">))</span>
        <span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">).</span><span class="s1">ravel</span><span class="s2">()</span>

        <span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">)[</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s1">M </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">)</span>
        <span class="s1">new_shape </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">)) </span><span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2 </span><span class="s3">else </span><span class="s2">(</span><span class="s1">M</span><span class="s2">,)</span>
        <span class="s3">if </span><span class="s1">M </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">new_shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s1">row_nnz </span><span class="s2">= (</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">indices </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">] - </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">indices</span><span class="s2">]).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">idx_dtype</span><span class="s2">)</span>

        <span class="s1">res_indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">M</span><span class="s2">+</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">row_nnz</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">res_indptr</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:])</span>

        <span class="s1">nnz </span><span class="s2">= </span><span class="s1">res_indptr</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s1">res_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">res_data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">csr_row_index</span><span class="s2">(</span>
            <span class="s1">M</span><span class="s2">,</span>
            <span class="s1">indices</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">idx_dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">False</span><span class="s2">),</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">idx_dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">False</span><span class="s2">),</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">,</span>
            <span class="s1">res_indices</span><span class="s2">,</span>
            <span class="s1">res_data</span>
        <span class="s2">)</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">((</span><span class="s1">res_data</span><span class="s2">, </span><span class="s1">res_indices</span><span class="s2">, </span><span class="s1">res_indptr</span><span class="s2">),</span>
                              <span class="s1">shape</span><span class="s2">=</span><span class="s1">new_shape</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">False</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">_major_slice</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">False</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Index along the major axis where idx is a slice object. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">idx </span><span class="s2">== </span><span class="s1">slice</span><span class="s2">(</span><span class="s3">None</span><span class="s2">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">() </span><span class="s3">if </span><span class="s1">copy </span><span class="s3">else </span><span class="s1">self</span>

        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">)</span>
        <span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step </span><span class="s2">= </span><span class="s1">idx</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">(</span><span class="s1">M</span><span class="s2">)</span>
        <span class="s1">M </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step</span><span class="s2">))</span>
        <span class="s1">new_shape </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">)) </span><span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2 </span><span class="s3">else </span><span class="s2">(</span><span class="s1">M</span><span class="s2">,)</span>
        <span class="s3">if </span><span class="s1">M </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">new_shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s4"># Work out what slices are needed for `row_nnz`</span>
        <span class="s4"># start,stop can be -1, only if step is negative</span>
        <span class="s1">start0</span><span class="s2">, </span><span class="s1">stop0 </span><span class="s2">= </span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span>
        <span class="s3">if </span><span class="s1">stop </span><span class="s2">== -</span><span class="s5">1 </span><span class="s3">and </span><span class="s1">start </span><span class="s2">&gt;= </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">stop0 </span><span class="s2">= </span><span class="s3">None</span>
        <span class="s1">start1</span><span class="s2">, </span><span class="s1">stop1 </span><span class="s2">= </span><span class="s1">start </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">, </span><span class="s1">stop </span><span class="s2">+ </span><span class="s5">1</span>

        <span class="s1">row_nnz </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">start1</span><span class="s2">:</span><span class="s1">stop1</span><span class="s2">:</span><span class="s1">step</span><span class="s2">] - </span><span class="s1">\</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">start0</span><span class="s2">:</span><span class="s1">stop0</span><span class="s2">:</span><span class="s1">step</span><span class="s2">]</span>
        <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s1">res_indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">M</span><span class="s2">+</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">np</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">row_nnz</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">res_indptr</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:])</span>

        <span class="s3">if </span><span class="s1">step </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">all_idx </span><span class="s2">= </span><span class="s1">slice</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">start</span><span class="s2">], </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">stop</span><span class="s2">])</span>
            <span class="s1">res_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">[</span><span class="s1">all_idx</span><span class="s2">], </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>
            <span class="s1">res_data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">all_idx</span><span class="s2">], </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>
        <span class="s3">else</span><span class="s2">:</span>
            <span class="s1">nnz </span><span class="s2">= </span><span class="s1">res_indptr</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span>
            <span class="s1">res_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
            <span class="s1">res_data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">csr_row_slice</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">,</span>
                          <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">res_indices</span><span class="s2">, </span><span class="s1">res_data</span><span class="s2">)</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">((</span><span class="s1">res_data</span><span class="s2">, </span><span class="s1">res_indices</span><span class="s2">, </span><span class="s1">res_indptr</span><span class="s2">),</span>
                              <span class="s1">shape</span><span class="s2">=</span><span class="s1">new_shape</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">False</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">_minor_index_fancy</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Index along the minor axis where idx is an array of ints. 
        &quot;&quot;&quot;</span>
        <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">))</span>
        <span class="s1">indices </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">idx_dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">False</span><span class="s2">)</span>
        <span class="s1">indptr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">.</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">idx_dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">False</span><span class="s2">)</span>

        <span class="s1">idx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">).</span><span class="s1">ravel</span><span class="s2">()</span>

        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">)</span>
        <span class="s1">k </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">)</span>
        <span class="s1">new_shape </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">M</span><span class="s2">, </span><span class="s1">k</span><span class="s2">)) </span><span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">2 </span><span class="s3">else </span><span class="s2">(</span><span class="s1">k</span><span class="s2">,)</span>
        <span class="s3">if </span><span class="s1">k </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">new_shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s4"># pass 1: count idx entries and compute new indptr</span>
        <span class="s1">col_offsets </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros</span><span class="s2">(</span><span class="s1">N</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">res_indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty_like</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">csr_column_index1</span><span class="s2">(</span>
            <span class="s1">k</span><span class="s2">,</span>
            <span class="s1">idx</span><span class="s2">,</span>
            <span class="s1">M</span><span class="s2">,</span>
            <span class="s1">N</span><span class="s2">,</span>
            <span class="s1">indptr</span><span class="s2">,</span>
            <span class="s1">indices</span><span class="s2">,</span>
            <span class="s1">col_offsets</span><span class="s2">,</span>
            <span class="s1">res_indptr</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s4"># pass 2: copy indices/data for selected idxs</span>
        <span class="s1">col_order </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argsort</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">idx_dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">False</span><span class="s2">)</span>
        <span class="s1">nnz </span><span class="s2">= </span><span class="s1">res_indptr</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]</span>
        <span class="s1">res_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">res_data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">nnz</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">csr_column_index2</span><span class="s2">(</span><span class="s1">col_order</span><span class="s2">, </span><span class="s1">col_offsets</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">),</span>
                          <span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">res_indices</span><span class="s2">, </span><span class="s1">res_data</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">((</span><span class="s1">res_data</span><span class="s2">, </span><span class="s1">res_indices</span><span class="s2">, </span><span class="s1">res_indptr</span><span class="s2">),</span>
                              <span class="s1">shape</span><span class="s2">=</span><span class="s1">new_shape</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">False</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">_minor_slice</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">False</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Index along the minor axis where idx is a slice object. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">idx </span><span class="s2">== </span><span class="s1">slice</span><span class="s2">(</span><span class="s3">None</span><span class="s2">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">() </span><span class="s3">if </span><span class="s1">copy </span><span class="s3">else </span><span class="s1">self</span>

        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">)</span>
        <span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step </span><span class="s2">= </span><span class="s1">idx</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">(</span><span class="s1">N</span><span class="s2">)</span>
        <span class="s1">N </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step</span><span class="s2">))</span>
        <span class="s3">if </span><span class="s1">N </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">)), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s3">if </span><span class="s1">step </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_submatrix</span><span class="s2">(</span><span class="s1">minor</span><span class="s2">=</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>
        <span class="s4"># TODO: don't fall back to fancy indexing here</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_minor_index_fancy</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">start</span><span class="s2">, </span><span class="s1">stop</span><span class="s2">, </span><span class="s1">step</span><span class="s2">))</span>

    <span class="s3">def </span><span class="s1">_get_submatrix</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">major</span><span class="s2">=</span><span class="s3">None</span><span class="s2">, </span><span class="s1">minor</span><span class="s2">=</span><span class="s3">None</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">False</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Return a submatrix of this matrix. 
 
        major, minor: None, int, or slice with step 1 
        &quot;&quot;&quot;</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">)</span>
        <span class="s1">i0</span><span class="s2">, </span><span class="s1">i1 </span><span class="s2">= </span><span class="s1">_process_slice</span><span class="s2">(</span><span class="s1">major</span><span class="s2">, </span><span class="s1">M</span><span class="s2">)</span>
        <span class="s1">j0</span><span class="s2">, </span><span class="s1">j1 </span><span class="s2">= </span><span class="s1">_process_slice</span><span class="s2">(</span><span class="s1">minor</span><span class="s2">, </span><span class="s1">N</span><span class="s2">)</span>

        <span class="s3">if </span><span class="s1">i0 </span><span class="s2">== </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">j0 </span><span class="s2">== </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">i1 </span><span class="s2">== </span><span class="s1">M </span><span class="s3">and </span><span class="s1">j1 </span><span class="s2">== </span><span class="s1">N</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">() </span><span class="s3">if </span><span class="s1">copy </span><span class="s3">else </span><span class="s1">self</span>

        <span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">data </span><span class="s2">= </span><span class="s1">get_csr_submatrix</span><span class="s2">(</span>
            <span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">i0</span><span class="s2">, </span><span class="s1">i1</span><span class="s2">, </span><span class="s1">j0</span><span class="s2">, </span><span class="s1">j1</span><span class="s2">)</span>

        <span class="s1">shape </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">i1 </span><span class="s2">- </span><span class="s1">i0</span><span class="s2">, </span><span class="s1">j1 </span><span class="s2">- </span><span class="s1">j0</span><span class="s2">))</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">shape </span><span class="s2">= (</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">],)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">shape</span><span class="s2">,</span>
                              <span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">False</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">_set_int</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s1">major</span><span class="s2">, </span><span class="s1">minor </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s5">0</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_set_many</span><span class="s2">(</span><span class="s1">major</span><span class="s2">, </span><span class="s1">minor</span><span class="s2">, </span><span class="s1">x</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">_set_array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s1">major</span><span class="s2">, </span><span class="s1">minor </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">np</span><span class="s2">.</span><span class="s1">zeros_like</span><span class="s2">(</span><span class="s1">idx</span><span class="s2">), </span><span class="s1">idx</span><span class="s2">))</span>
        <span class="s1">broadcast </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] == </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">minor</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] != </span><span class="s5">1</span>
        <span class="s3">if </span><span class="s1">broadcast</span><span class="s2">:</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">repeat</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">])</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_set_many</span><span class="s2">(</span><span class="s1">major</span><span class="s2">, </span><span class="s1">minor</span><span class="s2">, </span><span class="s1">x</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">_set_intXint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s1">i</span><span class="s2">, </span><span class="s1">j </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_set_many</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">x</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">_set_arrayXarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s1">i</span><span class="s2">, </span><span class="s1">j </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_set_many</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">x</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">_set_arrayXarray_sparse</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s4"># clear entries that will be overwritten</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_zero_many</span><span class="s2">(*</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">row</span><span class="s2">, </span><span class="s1">col</span><span class="s2">)))</span>

        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">row</span><span class="s2">.</span><span class="s1">shape  </span><span class="s4"># matches col.shape</span>
        <span class="s1">broadcast_row </span><span class="s2">= </span><span class="s1">M </span><span class="s2">!= </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] == </span><span class="s5">1</span>
        <span class="s1">broadcast_col </span><span class="s2">= </span><span class="s1">N </span><span class="s2">!= </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">x</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] == </span><span class="s5">1</span>
        <span class="s1">r</span><span class="s2">, </span><span class="s1">c </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">row</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">col</span>

        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s3">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s3">return</span>

        <span class="s3">if </span><span class="s1">broadcast_row</span><span class="s2">:</span>
            <span class="s1">r </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">repeat</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">M</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">r</span><span class="s2">))</span>
            <span class="s1">c </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">tile</span><span class="s2">(</span><span class="s1">c</span><span class="s2">, </span><span class="s1">M</span><span class="s2">)</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">tile</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">M</span><span class="s2">)</span>
        <span class="s3">if </span><span class="s1">broadcast_col</span><span class="s2">:</span>
            <span class="s1">r </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">repeat</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s1">N</span><span class="s2">)</span>
            <span class="s1">c </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">tile</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">N</span><span class="s2">), </span><span class="s1">len</span><span class="s2">(</span><span class="s1">c</span><span class="s2">))</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">repeat</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">N</span><span class="s2">)</span>
        <span class="s4"># only assign entries in the new sparsity structure</span>
        <span class="s1">i</span><span class="s2">, </span><span class="s1">j </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">row</span><span class="s2">[</span><span class="s1">r</span><span class="s2">, </span><span class="s1">c</span><span class="s2">], </span><span class="s1">col</span><span class="s2">[</span><span class="s1">r</span><span class="s2">, </span><span class="s1">c</span><span class="s2">]))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_set_many</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">x</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">_setdiag</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">k</span><span class="s2">):</span>
        <span class="s3">if </span><span class="s5">0 </span><span class="s3">in </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s2">(</span><span class="s6">'diagonals cant be set in 1d arrays'</span><span class="s2">)</span>

        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span>
        <span class="s1">broadcast </span><span class="s2">= (</span><span class="s1">values</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">0</span><span class="s2">)</span>

        <span class="s3">if </span><span class="s1">k </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s3">if </span><span class="s1">broadcast</span><span class="s2">:</span>
                <span class="s1">max_index </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">M </span><span class="s2">+ </span><span class="s1">k</span><span class="s2">, </span><span class="s1">N</span><span class="s2">)</span>
            <span class="s3">else</span><span class="s2">:</span>
                <span class="s1">max_index </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">M </span><span class="s2">+ </span><span class="s1">k</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">values</span><span class="s2">))</span>
            <span class="s1">i </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(-</span><span class="s1">k</span><span class="s2">, </span><span class="s1">max_index </span><span class="s2">- </span><span class="s1">k</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">j </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">max_index</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s3">else</span><span class="s2">:</span>
            <span class="s3">if </span><span class="s1">broadcast</span><span class="s2">:</span>
                <span class="s1">max_index </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">- </span><span class="s1">k</span><span class="s2">)</span>
            <span class="s3">else</span><span class="s2">:</span>
                <span class="s1">max_index </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">- </span><span class="s1">k</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">values</span><span class="s2">))</span>
            <span class="s1">i </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">max_index</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">j </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">k </span><span class="s2">+ </span><span class="s1">max_index</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

        <span class="s3">if not </span><span class="s1">broadcast</span><span class="s2">:</span>
            <span class="s1">values </span><span class="s2">= </span><span class="s1">values</span><span class="s2">[:</span><span class="s1">len</span><span class="s2">(</span><span class="s1">i</span><span class="s2">)]</span>

        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)).</span><span class="s1">ravel</span><span class="s2">()</span>
        <span class="s3">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">squeeze</span><span class="s2">().</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">i</span><span class="s2">.</span><span class="s1">squeeze</span><span class="s2">().</span><span class="s1">shape</span><span class="s2">:</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">broadcast_to</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">i</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s3">if </span><span class="s1">x</span><span class="s2">.</span><span class="s1">size </span><span class="s2">== </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s3">return</span>

        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">))</span>
        <span class="s1">i</span><span class="s2">, </span><span class="s1">j </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">))</span>
        <span class="s1">n_samples </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">size</span>
        <span class="s1">offsets </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">ret </span><span class="s2">= </span><span class="s1">csr_sample_offsets</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">,</span>
                                 <span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">)</span>
        <span class="s3">if </span><span class="s1">ret </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4"># rinse and repeat</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">sum_duplicates</span><span class="s2">()</span>
            <span class="s1">csr_sample_offsets</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">,</span>
                               <span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">)</span>
        <span class="s3">if </span><span class="s2">-</span><span class="s5">1 </span><span class="s3">not in </span><span class="s1">offsets</span><span class="s2">:</span>
            <span class="s4"># only affects existing non-zero cells</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">offsets</span><span class="s2">] = </span><span class="s1">x</span>
            <span class="s3">return</span>

        <span class="s1">mask </span><span class="s2">= (</span><span class="s1">offsets </span><span class="s2">&lt;= -</span><span class="s5">1</span><span class="s2">)</span>
        <span class="s4"># Boundary between csc and convert to coo</span>
        <span class="s4"># The value 0.001 is justified in gh-19962#issuecomment-1920499678</span>
        <span class="s3">if </span><span class="s1">mask</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">() &lt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz </span><span class="s2">* </span><span class="s5">0.001</span><span class="s2">:</span>
            <span class="s4"># create new entries</span>
            <span class="s1">i </span><span class="s2">= </span><span class="s1">i</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]</span>
            <span class="s1">j </span><span class="s2">= </span><span class="s1">j</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_insert_many</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">x</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">])</span>
            <span class="s4"># replace existing entries</span>
            <span class="s1">mask </span><span class="s2">= ~</span><span class="s1">mask</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">offsets</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]] = </span><span class="s1">x</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]</span>
        <span class="s3">else</span><span class="s2">:</span>
            <span class="s4"># convert to coo for _set_diag</span>
            <span class="s1">coo </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tocoo</span><span class="s2">()</span>
            <span class="s1">coo</span><span class="s2">.</span><span class="s1">_setdiag</span><span class="s2">(</span><span class="s1">values</span><span class="s2">, </span><span class="s1">k</span><span class="s2">)</span>
            <span class="s1">arrays </span><span class="s2">= </span><span class="s1">coo</span><span class="s2">.</span><span class="s1">_coo_to_compressed</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">arrays</span>

    <span class="s3">def </span><span class="s1">_prepare_indices</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">):</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">)</span>

        <span class="s3">def </span><span class="s1">check_bounds</span><span class="s2">(</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">):</span>
            <span class="s1">idx </span><span class="s2">= </span><span class="s1">indices</span><span class="s2">.</span><span class="s1">max</span><span class="s2">()</span>
            <span class="s3">if </span><span class="s1">idx </span><span class="s2">&gt;= </span><span class="s1">bound</span><span class="s2">:</span>
                <span class="s3">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s6">'index (%d) out of range (&gt;= %d)' </span><span class="s2">%</span>
                                 <span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">))</span>
            <span class="s1">idx </span><span class="s2">= </span><span class="s1">indices</span><span class="s2">.</span><span class="s1">min</span><span class="s2">()</span>
            <span class="s3">if </span><span class="s1">idx </span><span class="s2">&lt; -</span><span class="s1">bound</span><span class="s2">:</span>
                <span class="s3">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s6">'index (%d) out of range (&lt; -%d)' </span><span class="s2">%</span>
                                 <span class="s2">(</span><span class="s1">idx</span><span class="s2">, </span><span class="s1">bound</span><span class="s2">))</span>

        <span class="s1">i </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)).</span><span class="s1">ravel</span><span class="s2">()</span>
        <span class="s1">j </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">j</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)).</span><span class="s1">ravel</span><span class="s2">()</span>
        <span class="s1">check_bounds</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">M</span><span class="s2">)</span>
        <span class="s1">check_bounds</span><span class="s2">(</span><span class="s1">j</span><span class="s2">, </span><span class="s1">N</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span>

    <span class="s3">def </span><span class="s1">_set_many</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Sets value at each (i, j) to x 
 
        Here (i,j) index major and minor respectively, and must not contain 
        duplicate entries. 
        &quot;&quot;&quot;</span>
        <span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_prepare_indices</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">)</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">atleast_1d</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)).</span><span class="s1">ravel</span><span class="s2">()</span>

        <span class="s1">n_samples </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">size</span>
        <span class="s1">offsets </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">ret </span><span class="s2">= </span><span class="s1">csr_sample_offsets</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">,</span>
                                 <span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">)</span>
        <span class="s3">if </span><span class="s1">ret </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4"># rinse and repeat</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">sum_duplicates</span><span class="s2">()</span>
            <span class="s1">csr_sample_offsets</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">,</span>
                               <span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">)</span>

        <span class="s3">if </span><span class="s2">-</span><span class="s5">1 </span><span class="s3">not in </span><span class="s1">offsets</span><span class="s2">:</span>
            <span class="s4"># only affects existing non-zero cells</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">offsets</span><span class="s2">] = </span><span class="s1">x</span>
            <span class="s3">return</span>

        <span class="s3">else</span><span class="s2">:</span>
            <span class="s1">warn</span><span class="s2">(</span><span class="s6">f&quot;Changing the sparsity structure of a </span><span class="s3">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s3">} </span><span class="s6">is&quot;</span>
                 <span class="s6">&quot; expensive. lil and dok are more efficient.&quot;</span><span class="s2">,</span>
                 <span class="s1">SparseEfficiencyWarning</span><span class="s2">, </span><span class="s1">stacklevel</span><span class="s2">=</span><span class="s5">3</span><span class="s2">)</span>
            <span class="s4"># replace where possible</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">offsets </span><span class="s2">&gt; -</span><span class="s5">1</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">offsets</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]] = </span><span class="s1">x</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]</span>
            <span class="s4"># only insertions remain</span>
            <span class="s1">mask </span><span class="s2">= ~</span><span class="s1">mask</span>
            <span class="s1">i </span><span class="s2">= </span><span class="s1">i</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]</span>
            <span class="s1">i</span><span class="s2">[</span><span class="s1">i </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">] += </span><span class="s1">M</span>
            <span class="s1">j </span><span class="s2">= </span><span class="s1">j</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]</span>
            <span class="s1">j</span><span class="s2">[</span><span class="s1">j </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">] += </span><span class="s1">N</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_insert_many</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">x</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">])</span>

    <span class="s3">def </span><span class="s1">_zero_many</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Sets value at each (i, j) to zero, preserving sparsity structure. 
 
        Here (i,j) index major and minor respectively. 
        &quot;&quot;&quot;</span>
        <span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_prepare_indices</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">)</span>

        <span class="s1">n_samples </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">i</span><span class="s2">)</span>
        <span class="s1">offsets </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">ret </span><span class="s2">= </span><span class="s1">csr_sample_offsets</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">,</span>
                                 <span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">)</span>
        <span class="s3">if </span><span class="s1">ret </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s4"># rinse and repeat</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">sum_duplicates</span><span class="s2">()</span>
            <span class="s1">csr_sample_offsets</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">,</span>
                               <span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">offsets</span><span class="s2">)</span>

        <span class="s4"># only assign zeros to the existing sparsity structure</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">offsets</span><span class="s2">[</span><span class="s1">offsets </span><span class="s2">&gt; -</span><span class="s5">1</span><span class="s2">]] = </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">_insert_many</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Inserts new nonzero at each (i, j) with value x 
 
        Here (i,j) index major and minor respectively. 
        i, j and x must be non-empty, 1d arrays. 
        Inserts each major group (e.g. all entries per row) at a time. 
        Maintains has_sorted_indices property. 
        Modifies i, j, x in place. 
        &quot;&quot;&quot;</span>
        <span class="s1">order </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">argsort</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">=</span><span class="s6">'mergesort'</span><span class="s2">)  </span><span class="s4"># stable for duplicates</span>
        <span class="s1">i </span><span class="s2">= </span><span class="s1">i</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span><span class="s1">order</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">=</span><span class="s6">'clip'</span><span class="s2">)</span>
        <span class="s1">j </span><span class="s2">= </span><span class="s1">j</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span><span class="s1">order</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">=</span><span class="s6">'clip'</span><span class="s2">)</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">take</span><span class="s2">(</span><span class="s1">order</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">=</span><span class="s6">'clip'</span><span class="s2">)</span>

        <span class="s1">do_sort </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">has_sorted_indices</span>

        <span class="s4"># Update index data type</span>
        <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">),</span>
                                    <span class="s1">maxval</span><span class="s2">=(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">] + </span><span class="s1">x</span><span class="s2">.</span><span class="s1">size</span><span class="s2">))</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">i </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">j </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">j</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>

        <span class="s4"># Collate old and new in chunks by major index</span>
        <span class="s1">indices_parts </span><span class="s2">= []</span>
        <span class="s1">data_parts </span><span class="s2">= []</span>
        <span class="s1">ui</span><span class="s2">, </span><span class="s1">ui_indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">unique</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">return_index</span><span class="s2">=</span><span class="s3">True</span><span class="s2">)</span>
        <span class="s1">ui_indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">ui_indptr</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">j</span><span class="s2">))</span>
        <span class="s1">new_nnzs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">ui_indptr</span><span class="s2">)</span>
        <span class="s1">prev </span><span class="s2">= </span><span class="s5">0</span>
        <span class="s3">for </span><span class="s1">c</span><span class="s2">, (</span><span class="s1">ii</span><span class="s2">, </span><span class="s1">js</span><span class="s2">, </span><span class="s1">je</span><span class="s2">) </span><span class="s3">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">zip</span><span class="s2">(</span><span class="s1">ui</span><span class="s2">, </span><span class="s1">ui_indptr</span><span class="s2">, </span><span class="s1">ui_indptr</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:])):</span>
            <span class="s4"># old entries</span>
            <span class="s1">start </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">prev</span><span class="s2">]</span>
            <span class="s1">stop </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">ii</span><span class="s2">]</span>
            <span class="s1">indices_parts</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">[</span><span class="s1">start</span><span class="s2">:</span><span class="s1">stop</span><span class="s2">])</span>
            <span class="s1">data_parts</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">start</span><span class="s2">:</span><span class="s1">stop</span><span class="s2">])</span>

            <span class="s4"># handle duplicate j: keep last setting</span>
            <span class="s1">uj</span><span class="s2">, </span><span class="s1">uj_indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">unique</span><span class="s2">(</span><span class="s1">j</span><span class="s2">[</span><span class="s1">js</span><span class="s2">:</span><span class="s1">je</span><span class="s2">][::-</span><span class="s5">1</span><span class="s2">], </span><span class="s1">return_index</span><span class="s2">=</span><span class="s3">True</span><span class="s2">)</span>
            <span class="s3">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">uj</span><span class="s2">) == </span><span class="s1">je </span><span class="s2">- </span><span class="s1">js</span><span class="s2">:</span>
                <span class="s1">indices_parts</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">j</span><span class="s2">[</span><span class="s1">js</span><span class="s2">:</span><span class="s1">je</span><span class="s2">])</span>
                <span class="s1">data_parts</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[</span><span class="s1">js</span><span class="s2">:</span><span class="s1">je</span><span class="s2">])</span>
            <span class="s3">else</span><span class="s2">:</span>
                <span class="s1">indices_parts</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">j</span><span class="s2">[</span><span class="s1">js</span><span class="s2">:</span><span class="s1">je</span><span class="s2">][::-</span><span class="s5">1</span><span class="s2">][</span><span class="s1">uj_indptr</span><span class="s2">])</span>
                <span class="s1">data_parts</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">x</span><span class="s2">[</span><span class="s1">js</span><span class="s2">:</span><span class="s1">je</span><span class="s2">][::-</span><span class="s5">1</span><span class="s2">][</span><span class="s1">uj_indptr</span><span class="s2">])</span>
                <span class="s1">new_nnzs</span><span class="s2">[</span><span class="s1">c</span><span class="s2">] = </span><span class="s1">len</span><span class="s2">(</span><span class="s1">uj</span><span class="s2">)</span>

            <span class="s1">prev </span><span class="s2">= </span><span class="s1">ii</span>

        <span class="s4"># remaining old entries</span>
        <span class="s1">start </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">ii</span><span class="s2">]</span>
        <span class="s1">indices_parts</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">[</span><span class="s1">start</span><span class="s2">:])</span>
        <span class="s1">data_parts</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">start</span><span class="s2">:])</span>

        <span class="s4"># update attributes</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">indices_parts</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">concatenate</span><span class="s2">(</span><span class="s1">data_parts</span><span class="s2">)</span>
        <span class="s1">nnzs </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">nnzs</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] = </span><span class="s1">idx_dtype</span><span class="s2">(</span><span class="s5">0</span><span class="s2">)</span>
        <span class="s1">indptr_diff </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">diff</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">)</span>
        <span class="s1">indptr_diff</span><span class="s2">[</span><span class="s1">ui</span><span class="s2">] += </span><span class="s1">new_nnzs</span>
        <span class="s1">nnzs</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:] = </span><span class="s1">indptr_diff</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">nnzs</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">nnzs</span><span class="s2">)</span>

        <span class="s3">if </span><span class="s1">do_sort</span><span class="s2">:</span>
            <span class="s4"># TODO: only sort where necessary</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">has_sorted_indices </span><span class="s2">= </span><span class="s3">False</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">sort_indices</span><span class="s2">()</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">check_format</span><span class="s2">(</span><span class="s1">full_check</span><span class="s2">=</span><span class="s3">False</span><span class="s2">)</span>

    <span class="s4">######################</span>
    <span class="s4"># Conversion methods #</span>
    <span class="s4">######################</span>

    <span class="s3">def </span><span class="s1">tocoo</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">True</span><span class="s2">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">csr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tocsr</span><span class="s2">()</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_coo_container</span><span class="s2">((</span><span class="s1">csr</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, (</span><span class="s1">csr</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">,)), </span><span class="s1">csr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">)</span>
        <span class="s1">major_dim</span><span class="s2">, </span><span class="s1">minor_dim </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s1">minor_indices </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span>
        <span class="s1">major_indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">minor_indices</span><span class="s2">), </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s1">_sparsetools</span><span class="s2">.</span><span class="s1">expandptr</span><span class="s2">(</span><span class="s1">major_dim</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">major_indices</span><span class="s2">)</span>
        <span class="s1">coords </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">((</span><span class="s1">major_indices</span><span class="s2">, </span><span class="s1">minor_indices</span><span class="s2">))</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_coo_container</span><span class="s2">(</span>
            <span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">coords</span><span class="s2">), </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s1">copy</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span>
        <span class="s2">)</span>

    <span class="s1">tocoo</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">tocoo</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s3">def </span><span class="s1">toarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">order</span><span class="s2">=</span><span class="s3">None</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s3">None</span><span class="s2">):</span>
        <span class="s3">if </span><span class="s1">out </span><span class="s3">is None and </span><span class="s1">order </span><span class="s3">is None</span><span class="s2">:</span>
            <span class="s1">order </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s6">'cf'</span><span class="s2">)[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s1">out </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_process_toarray_args</span><span class="s2">(</span><span class="s1">order</span><span class="s2">, </span><span class="s1">out</span><span class="s2">)</span>
        <span class="s3">if not </span><span class="s2">(</span><span class="s1">out</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">c_contiguous </span><span class="s3">or </span><span class="s1">out</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">f_contiguous</span><span class="s2">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">'Output array must be C or F contiguous'</span><span class="s2">)</span>
        <span class="s4"># align ideal order with output array order</span>
        <span class="s3">if </span><span class="s1">out</span><span class="s2">.</span><span class="s1">flags</span><span class="s2">.</span><span class="s1">c_contiguous</span><span class="s2">:</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tocsr</span><span class="s2">()</span>
            <span class="s1">y </span><span class="s2">= </span><span class="s1">out</span>
        <span class="s3">else</span><span class="s2">:</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">tocsc</span><span class="s2">()</span>
            <span class="s1">y </span><span class="s2">= </span><span class="s1">out</span><span class="s2">.</span><span class="s1">T</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">)</span>
        <span class="s1">csr_todense</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">x</span><span class="s2">.</span><span class="s1">data</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s1">out</span>

    <span class="s1">toarray</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">toarray</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">##############################################################</span>
    <span class="s4"># methods that examine or modify the internal data structure #</span>
    <span class="s4">##############################################################</span>

    <span class="s3">def </span><span class="s1">eliminate_zeros</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Remove zero entries from the array/matrix 
 
        This is an *in place* operation. 
        &quot;&quot;&quot;</span>
        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">)</span>
        <span class="s1">_sparsetools</span><span class="s2">.</span><span class="s1">csr_eliminate_zeros</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">prune</span><span class="s2">()  </span><span class="s4"># nnz may have changed</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">has_canonical_format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s0">&quot;&quot;&quot;Whether the array/matrix has sorted indices and no duplicates 
 
        Returns 
            - True: if the above applies 
            - False: otherwise 
 
        has_canonical_format implies has_sorted_indices, so if the latter flag 
        is False, so will the former be; if the former is found True, the 
        latter flag is also set. 
        &quot;&quot;&quot;</span>
        <span class="s4"># first check to see if result was cached</span>
        <span class="s3">if not </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">'_has_sorted_indices'</span><span class="s2">, </span><span class="s3">True</span><span class="s2">):</span>
            <span class="s4"># not sorted =&gt; not canonical</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_has_canonical_format </span><span class="s2">= </span><span class="s3">False</span>
        <span class="s3">elif not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">'_has_canonical_format'</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">has_canonical_format </span><span class="s2">= </span><span class="s1">bool</span><span class="s2">(</span>
                <span class="s1">_sparsetools</span><span class="s2">.</span><span class="s1">csr_has_canonical_format</span><span class="s2">(</span>
                    <span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">) - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">)</span>
                <span class="s2">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_has_canonical_format</span>

    <span class="s2">@</span><span class="s1">has_canonical_format</span><span class="s2">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">has_canonical_format</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">val</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_has_canonical_format </span><span class="s2">= </span><span class="s1">bool</span><span class="s2">(</span><span class="s1">val</span><span class="s2">)</span>
        <span class="s3">if </span><span class="s1">val</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">has_sorted_indices </span><span class="s2">= </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">sum_duplicates</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Eliminate duplicate entries by adding them together 
 
        This is an *in place* operation. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">has_canonical_format</span><span class="s2">:</span>
            <span class="s3">return</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">sort_indices</span><span class="s2">()</span>

        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">)</span>
        <span class="s1">_sparsetools</span><span class="s2">.</span><span class="s1">csr_sum_duplicates</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">prune</span><span class="s2">()  </span><span class="s4"># nnz may have changed</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">has_canonical_format </span><span class="s2">= </span><span class="s3">True</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">has_sorted_indices</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; bool</span><span class="s2">:</span>
        <span class="s0">&quot;&quot;&quot;Whether the indices are sorted 
 
        Returns 
            - True: if the indices of the array/matrix are in sorted order 
            - False: otherwise 
        &quot;&quot;&quot;</span>
        <span class="s4"># first check to see if result was cached</span>
        <span class="s3">if not </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">'_has_sorted_indices'</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_has_sorted_indices </span><span class="s2">= </span><span class="s1">bool</span><span class="s2">(</span>
                <span class="s1">_sparsetools</span><span class="s2">.</span><span class="s1">csr_has_sorted_indices</span><span class="s2">(</span>
                    <span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">) - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">)</span>
                <span class="s2">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_has_sorted_indices</span>

    <span class="s2">@</span><span class="s1">has_sorted_indices</span><span class="s2">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">has_sorted_indices</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">val</span><span class="s2">: </span><span class="s1">bool</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_has_sorted_indices </span><span class="s2">= </span><span class="s1">bool</span><span class="s2">(</span><span class="s1">val</span><span class="s2">)</span>


    <span class="s3">def </span><span class="s1">sorted_indices</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Return a copy of this array/matrix with sorted indices 
        &quot;&quot;&quot;</span>
        <span class="s1">A </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()</span>
        <span class="s1">A</span><span class="s2">.</span><span class="s1">sort_indices</span><span class="s2">()</span>
        <span class="s3">return </span><span class="s1">A</span>

        <span class="s4"># an alternative that has linear complexity is the following</span>
        <span class="s4"># although the previous option is typically faster</span>
        <span class="s4"># return self.toother().toother()</span>

    <span class="s3">def </span><span class="s1">sort_indices</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Sort the indices of this array/matrix *in place* 
        &quot;&quot;&quot;</span>

        <span class="s3">if not </span><span class="s1">self</span><span class="s2">.</span><span class="s1">has_sorted_indices</span><span class="s2">:</span>
            <span class="s1">_sparsetools</span><span class="s2">.</span><span class="s1">csr_sort_indices</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">) - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">,</span>
                                          <span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">has_sorted_indices </span><span class="s2">= </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">prune</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Remove empty space after all non-zero elements. 
        &quot;&quot;&quot;</span>
        <span class="s1">major_dim </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">)[</span><span class="s5">0</span><span class="s2">]</span>

        <span class="s3">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">) != </span><span class="s1">major_dim </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">'index pointer has invalid length'</span><span class="s2">)</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">) &lt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">'indices array has fewer than nnz elements'</span><span class="s2">)</span>
        <span class="s3">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">) &lt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">'data array has fewer than nnz elements'</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">indices </span><span class="s2">= </span><span class="s1">_prune_array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">[:</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">])</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">_prune_array</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[:</span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz</span><span class="s2">])</span>

    <span class="s3">def </span><span class="s1">resize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, *</span><span class="s1">shape</span><span class="s2">):</span>
        <span class="s1">shape </span><span class="s2">= </span><span class="s1">check_shape</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">allow_1d</span><span class="s2">=</span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">sparray</span><span class="s2">))</span>

        <span class="s3">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s6">'blocksize'</span><span class="s2">):</span>
            <span class="s1">bm</span><span class="s2">, </span><span class="s1">bn </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocksize</span>
            <span class="s1">new_M</span><span class="s2">, </span><span class="s1">rm </span><span class="s2">= </span><span class="s1">divmod</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">bm</span><span class="s2">)</span>
            <span class="s1">new_N</span><span class="s2">, </span><span class="s1">rn </span><span class="s2">= </span><span class="s1">divmod</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">], </span><span class="s1">bn</span><span class="s2">)</span>
            <span class="s3">if </span><span class="s1">rm </span><span class="s3">or </span><span class="s1">rn</span><span class="s2">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">f&quot;shape must be divisible into </span><span class="s3">{</span><span class="s1">self</span><span class="s2">.</span><span class="s1">blocksize</span><span class="s3">}</span><span class="s6">&quot;</span>
                                 <span class="s6">f&quot; blocks. Got </span><span class="s3">{</span><span class="s1">shape</span><span class="s3">}</span><span class="s6">&quot;</span><span class="s2">)</span>
            <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">] // </span><span class="s1">bm</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">[</span><span class="s5">1</span><span class="s2">] // </span><span class="s1">bn</span>
        <span class="s3">else</span><span class="s2">:</span>
            <span class="s1">new_M</span><span class="s2">, </span><span class="s1">new_N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">shape </span><span class="s3">if </span><span class="s1">len</span><span class="s2">(</span><span class="s1">shape</span><span class="s2">)&gt;</span><span class="s5">1 </span><span class="s3">else </span><span class="s2">(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">[</span><span class="s5">0</span><span class="s2">]))</span>
            <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_swap</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span><span class="s2">)</span>

        <span class="s3">if </span><span class="s1">new_M </span><span class="s2">&lt; </span><span class="s1">M</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">indices </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">[:</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">new_M</span><span class="s2">]]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[:</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">new_M</span><span class="s2">]]</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[:</span><span class="s1">new_M </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">]</span>
        <span class="s3">elif </span><span class="s1">new_M </span><span class="s2">&gt; </span><span class="s1">M</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">resize</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">new_M </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">)</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">M </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">:].</span><span class="s1">fill</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s1">M</span><span class="s2">])</span>

        <span class="s3">if </span><span class="s1">new_N </span><span class="s2">&lt; </span><span class="s1">N</span><span class="s2">:</span>
            <span class="s1">mask </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices </span><span class="s2">&lt; </span><span class="s1">new_N</span>
            <span class="s3">if not </span><span class="s1">np</span><span class="s2">.</span><span class="s1">all</span><span class="s2">(</span><span class="s1">mask</span><span class="s2">):</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">indices </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">data </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">[</span><span class="s1">mask</span><span class="s2">]</span>
                <span class="s1">major_index</span><span class="s2">, </span><span class="s1">val </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_minor_reduce</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">add</span><span class="s2">, </span><span class="s1">mask</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">.</span><span class="s1">fill</span><span class="s2">(</span><span class="s5">0</span><span class="s2">)</span>
                <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">[</span><span class="s5">1</span><span class="s2">:][</span><span class="s1">major_index</span><span class="s2">] = </span><span class="s1">val</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">cumsum</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">out</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_shape </span><span class="s2">= </span><span class="s1">shape</span>

    <span class="s1">resize</span><span class="s2">.</span><span class="s1">__doc__ </span><span class="s2">= </span><span class="s1">_spbase</span><span class="s2">.</span><span class="s1">resize</span><span class="s2">.</span><span class="s1">__doc__</span>

    <span class="s4">###################</span>
    <span class="s4"># utility methods #</span>
    <span class="s4">###################</span>

    <span class="s4"># needed by _data_matrix</span>
    <span class="s3">def </span><span class="s1">_with_data</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">copy</span><span class="s2">=</span><span class="s3">True</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;Returns a matrix with the same sparsity structure as self, 
        but with different data.  By default the structure arrays 
        (i.e. .indptr and .indices) are copied. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">copy</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">(),</span>
                                   <span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()),</span>
                                  <span class="s1">shape</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">,</span>
                                  <span class="s1">dtype</span><span class="s2">=</span><span class="s1">data</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
        <span class="s3">else</span><span class="s2">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">),</span>
                                  <span class="s1">shape</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">data</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>

    <span class="s3">def </span><span class="s1">_binopt</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">op</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot;apply the binary operation fn to two sparse matrices.&quot;&quot;&quot;</span>
        <span class="s1">other </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">(</span><span class="s1">other</span><span class="s2">)</span>

        <span class="s4"># e.g. csr_plus_csr, csr_minus_csr, etc.</span>
        <span class="s1">fn </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">_sparsetools</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format </span><span class="s2">+ </span><span class="s1">op </span><span class="s2">+ </span><span class="s1">self</span><span class="s2">.</span><span class="s1">format</span><span class="s2">)</span>

        <span class="s1">maxnnz </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">nnz </span><span class="s2">+ </span><span class="s1">other</span><span class="s2">.</span><span class="s1">nnz</span>
        <span class="s1">idx_dtype </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_index_dtype</span><span class="s2">((</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">,</span>
                                     <span class="s1">other</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">),</span>
                                    <span class="s1">maxval</span><span class="s2">=</span><span class="s1">maxnnz</span><span class="s2">)</span>
        <span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>
        <span class="s1">indices </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">maxnnz</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">)</span>

        <span class="s1">bool_ops </span><span class="s2">= [</span><span class="s6">'_ne_'</span><span class="s2">, </span><span class="s6">'_lt_'</span><span class="s2">, </span><span class="s6">'_gt_'</span><span class="s2">, </span><span class="s6">'_le_'</span><span class="s2">, </span><span class="s6">'_ge_'</span><span class="s2">]</span>
        <span class="s3">if </span><span class="s1">op </span><span class="s3">in </span><span class="s1">bool_ops</span><span class="s2">:</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">maxnnz</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">bool_</span><span class="s2">)</span>
        <span class="s3">else</span><span class="s2">:</span>
            <span class="s1">data </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">maxnnz</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">upcast</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">other</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">))</span>

        <span class="s1">M</span><span class="s2">, </span><span class="s1">N </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_shape_as_2d</span>
        <span class="s1">fn</span><span class="s2">(</span><span class="s1">M</span><span class="s2">, </span><span class="s1">N</span><span class="s2">,</span>
           <span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">),</span>
           <span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">),</span>
           <span class="s1">self</span><span class="s2">.</span><span class="s1">data</span><span class="s2">,</span>
           <span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">indptr</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">),</span>
           <span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">other</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">idx_dtype</span><span class="s2">),</span>
           <span class="s1">other</span><span class="s2">.</span><span class="s1">data</span><span class="s2">,</span>
           <span class="s1">indptr</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">data</span><span class="s2">)</span>

        <span class="s1">A </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">)</span>
        <span class="s1">A</span><span class="s2">.</span><span class="s1">prune</span><span class="s2">()</span>

        <span class="s3">return </span><span class="s1">A</span>

    <span class="s3">def </span><span class="s1">_divide_sparse</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Divide this matrix by a second sparse matrix. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">other</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">!= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">'inconsistent shapes'</span><span class="s2">)</span>

        <span class="s1">r </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_binopt</span><span class="s2">(</span><span class="s1">other</span><span class="s2">, </span><span class="s6">'_eldiv_'</span><span class="s2">)</span>

        <span class="s3">if </span><span class="s1">np</span><span class="s2">.</span><span class="s1">issubdtype</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">inexact</span><span class="s2">):</span>
            <span class="s4"># Eldiv leaves entries outside the combined sparsity</span>
            <span class="s4"># pattern empty, so they must be filled manually.</span>
            <span class="s4"># Everything outside of other's sparsity is NaN, and everything</span>
            <span class="s4"># inside it is either zero or defined by eldiv.</span>
            <span class="s1">out </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">empty</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">)</span>
            <span class="s1">out</span><span class="s2">.</span><span class="s1">fill</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span><span class="s2">)</span>
            <span class="s1">coords </span><span class="s2">= </span><span class="s1">other</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">()</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">ndim </span><span class="s2">== </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s1">coords </span><span class="s2">= (</span><span class="s1">coords</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">],)</span>
            <span class="s1">out</span><span class="s2">[</span><span class="s1">coords</span><span class="s2">] = </span><span class="s5">0</span>
            <span class="s1">r </span><span class="s2">= </span><span class="s1">r</span><span class="s2">.</span><span class="s1">tocoo</span><span class="s2">()</span>
            <span class="s1">out</span><span class="s2">[</span><span class="s1">r</span><span class="s2">.</span><span class="s1">coords</span><span class="s2">] = </span><span class="s1">r</span><span class="s2">.</span><span class="s1">data</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_container</span><span class="s2">(</span><span class="s1">out</span><span class="s2">)</span>
        <span class="s3">else</span><span class="s2">:</span>
            <span class="s4"># integers types go with nan &lt;-&gt; 0</span>
            <span class="s1">out </span><span class="s2">= </span><span class="s1">r</span>
            <span class="s3">return </span><span class="s1">out</span>


<span class="s3">def </span><span class="s1">_make_diagonal_csr</span><span class="s2">(</span><span class="s1">data</span><span class="s2">, </span><span class="s1">is_array</span><span class="s2">=</span><span class="s3">False</span><span class="s2">):</span>
    <span class="s0">&quot;&quot;&quot;build diagonal csc_array/csr_array =&gt; self._csr_container 
 
    Parameter `data` should be a raveled numpy array holding the 
    values on the diagonal of the resulting sparse matrix.  
    &quot;&quot;&quot;</span>
    <span class="s3">from </span><span class="s2">.</span><span class="s1">_csr </span><span class="s3">import </span><span class="s1">csr_array</span><span class="s2">, </span><span class="s1">csr_matrix</span>
    <span class="s1">csr_array </span><span class="s2">= </span><span class="s1">csr_array </span><span class="s3">if </span><span class="s1">is_array </span><span class="s3">else </span><span class="s1">csr_matrix</span>

    <span class="s1">N </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">data</span><span class="s2">)</span>
    <span class="s1">indptr </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">arange</span><span class="s2">(</span><span class="s1">N </span><span class="s2">+ </span><span class="s5">1</span><span class="s2">)</span>
    <span class="s1">indices </span><span class="s2">= </span><span class="s1">indptr</span><span class="s2">[:-</span><span class="s5">1</span><span class="s2">]</span>

    <span class="s3">return </span><span class="s1">csr_array</span><span class="s2">((</span><span class="s1">data</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">indptr</span><span class="s2">), </span><span class="s1">shape</span><span class="s2">=(</span><span class="s1">N</span><span class="s2">, </span><span class="s1">N</span><span class="s2">))</span>


<span class="s3">def </span><span class="s1">_process_slice</span><span class="s2">(</span><span class="s1">sl</span><span class="s2">, </span><span class="s1">num</span><span class="s2">):</span>
    <span class="s3">if </span><span class="s1">sl </span><span class="s3">is None</span><span class="s2">:</span>
        <span class="s1">i0</span><span class="s2">, </span><span class="s1">i1 </span><span class="s2">= </span><span class="s5">0</span><span class="s2">, </span><span class="s1">num</span>
    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">sl</span><span class="s2">, </span><span class="s1">slice</span><span class="s2">):</span>
        <span class="s1">i0</span><span class="s2">, </span><span class="s1">i1</span><span class="s2">, </span><span class="s1">stride </span><span class="s2">= </span><span class="s1">sl</span><span class="s2">.</span><span class="s1">indices</span><span class="s2">(</span><span class="s1">num</span><span class="s2">)</span>
        <span class="s3">if </span><span class="s1">stride </span><span class="s2">!= </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s6">'slicing with step != 1 not supported'</span><span class="s2">)</span>
        <span class="s1">i0 </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span><span class="s1">i0</span><span class="s2">, </span><span class="s1">i1</span><span class="s2">)  </span><span class="s4"># give an empty slice when i0 &gt; i1</span>
    <span class="s3">elif </span><span class="s1">isintlike</span><span class="s2">(</span><span class="s1">sl</span><span class="s2">):</span>
        <span class="s3">if </span><span class="s1">sl </span><span class="s2">&lt; </span><span class="s5">0</span><span class="s2">:</span>
            <span class="s1">sl </span><span class="s2">+= </span><span class="s1">num</span>
        <span class="s1">i0</span><span class="s2">, </span><span class="s1">i1 </span><span class="s2">= </span><span class="s1">sl</span><span class="s2">, </span><span class="s1">sl </span><span class="s2">+ </span><span class="s5">1</span>
        <span class="s3">if </span><span class="s1">i0 </span><span class="s2">&lt; </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">i1 </span><span class="s2">&gt; </span><span class="s1">num</span><span class="s2">:</span>
            <span class="s3">raise </span><span class="s1">IndexError</span><span class="s2">(</span><span class="s6">f'index out of bounds: 0 &lt;= </span><span class="s3">{</span><span class="s1">i0</span><span class="s3">} </span><span class="s6">&lt; </span><span class="s3">{</span><span class="s1">i1</span><span class="s3">} </span><span class="s6">&lt;= </span><span class="s3">{</span><span class="s1">num</span><span class="s3">}</span><span class="s6">'</span><span class="s2">)</span>
    <span class="s3">else</span><span class="s2">:</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s2">(</span><span class="s6">'expected slice or scalar'</span><span class="s2">)</span>

    <span class="s3">return </span><span class="s1">i0</span><span class="s2">, </span><span class="s1">i1</span>
</pre>
</body>
</html>