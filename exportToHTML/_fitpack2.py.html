<html>
<head>
<title>_fitpack2.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #cf8e6d;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_fitpack2.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
fitpack --- curve and surface fitting with splines 
 
fitpack is based on a collection of Fortran routines DIERCKX 
by P. Dierckx (see http://www.netlib.org/dierckx/) transformed 
to double routines by Pearu Peterson. 
&quot;&quot;&quot;</span>
<span class="s2"># Created by Pearu Peterson, June,August 2003</span>
<span class="s1">__all__ </span><span class="s3">= [</span>
    <span class="s4">'UnivariateSpline'</span><span class="s3">,</span>
    <span class="s4">'InterpolatedUnivariateSpline'</span><span class="s3">,</span>
    <span class="s4">'LSQUnivariateSpline'</span><span class="s3">,</span>
    <span class="s4">'BivariateSpline'</span><span class="s3">,</span>
    <span class="s4">'LSQBivariateSpline'</span><span class="s3">,</span>
    <span class="s4">'SmoothBivariateSpline'</span><span class="s3">,</span>
    <span class="s4">'LSQSphereBivariateSpline'</span><span class="s3">,</span>
    <span class="s4">'SmoothSphereBivariateSpline'</span><span class="s3">,</span>
    <span class="s4">'RectBivariateSpline'</span><span class="s3">,</span>
    <span class="s4">'RectSphereBivariateSpline'</span><span class="s3">]</span>


<span class="s5">import </span><span class="s1">warnings</span>

<span class="s5">from </span><span class="s1">numpy </span><span class="s5">import </span><span class="s1">zeros</span><span class="s3">, </span><span class="s1">concatenate</span><span class="s3">, </span><span class="s1">ravel</span><span class="s3">, </span><span class="s1">diff</span><span class="s3">, </span><span class="s1">array</span>
<span class="s5">import </span><span class="s1">numpy </span><span class="s5">as </span><span class="s1">np</span>

<span class="s5">from </span><span class="s3">. </span><span class="s5">import </span><span class="s1">_fitpack_impl</span>
<span class="s5">from </span><span class="s3">. </span><span class="s5">import </span><span class="s1">_dfitpack </span><span class="s5">as </span><span class="s1">dfitpack</span>


<span class="s1">dfitpack_int </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">types</span><span class="s3">.</span><span class="s1">intvar</span><span class="s3">.</span><span class="s1">dtype</span>


<span class="s2"># ############### Univariate spline ####################</span>

<span class="s1">_curfit_messages </span><span class="s3">= {</span><span class="s6">1</span><span class="s3">: </span><span class="s4">&quot;&quot;&quot; 
The required storage space exceeds the available storage space, as 
specified by the parameter nest: nest too small. If nest is already 
large (say nest &gt; m/2), it may also indicate that s is too small. 
The approximation returned is the weighted least-squares spline 
according to the knots t[0],t[1],...,t[n-1]. (n=nest) the parameter fp 
gives the corresponding weighted sum of squared residuals (fp&gt;s). 
&quot;&quot;&quot;</span><span class="s3">,</span>
                    <span class="s6">2</span><span class="s3">: </span><span class="s4">&quot;&quot;&quot; 
A theoretically impossible result was found during the iteration 
process for finding a smoothing spline with fp = s: s too small. 
There is an approximation returned but the corresponding weighted sum 
of squared residuals does not satisfy the condition abs(fp-s)/s &lt; tol.&quot;&quot;&quot;</span><span class="s3">,</span>
                    <span class="s6">3</span><span class="s3">: </span><span class="s4">&quot;&quot;&quot; 
The maximal number of iterations maxit (set to 20 by the program) 
allowed for finding a smoothing spline with fp=s has been reached: s 
too small. 
There is an approximation returned but the corresponding weighted sum 
of squared residuals does not satisfy the condition abs(fp-s)/s &lt; tol.&quot;&quot;&quot;</span><span class="s3">,</span>
                    <span class="s6">10</span><span class="s3">: </span><span class="s4">&quot;&quot;&quot; 
Error on entry, no approximation returned. The following conditions 
must hold: 
xb&lt;=x[0]&lt;x[1]&lt;...&lt;x[m-1]&lt;=xe, w[i]&gt;0, i=0..m-1 
if iopt=-1: 
  xb&lt;t[k+1]&lt;t[k+2]&lt;...&lt;t[n-k-2]&lt;xe&quot;&quot;&quot;</span>
                    <span class="s3">}</span>


<span class="s2"># UnivariateSpline, ext parameter can be an int or a string</span>
<span class="s1">_extrap_modes </span><span class="s3">= {</span><span class="s6">0</span><span class="s3">: </span><span class="s6">0</span><span class="s3">, </span><span class="s4">'extrapolate'</span><span class="s3">: </span><span class="s6">0</span><span class="s3">,</span>
                 <span class="s6">1</span><span class="s3">: </span><span class="s6">1</span><span class="s3">, </span><span class="s4">'zeros'</span><span class="s3">: </span><span class="s6">1</span><span class="s3">,</span>
                 <span class="s6">2</span><span class="s3">: </span><span class="s6">2</span><span class="s3">, </span><span class="s4">'raise'</span><span class="s3">: </span><span class="s6">2</span><span class="s3">,</span>
                 <span class="s6">3</span><span class="s3">: </span><span class="s6">3</span><span class="s3">, </span><span class="s4">'const'</span><span class="s3">: </span><span class="s6">3</span><span class="s3">}</span>


<span class="s5">class </span><span class="s1">UnivariateSpline</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; 
    1-D smoothing spline fit to a given set of data points. 
 
    Fits a spline y = spl(x) of degree `k` to the provided `x`, `y` data.  `s` 
    specifies the number of knots by specifying a smoothing condition. 
 
    Parameters 
    ---------- 
    x : (N,) array_like 
        1-D array of independent input data. Must be increasing; 
        must be strictly increasing if `s` is 0. 
    y : (N,) array_like 
        1-D array of dependent input data, of the same length as `x`. 
    w : (N,) array_like, optional 
        Weights for spline fitting.  Must be positive.  If `w` is None, 
        weights are all 1. Default is None. 
    bbox : (2,) array_like, optional 
        2-sequence specifying the boundary of the approximation interval. If 
        `bbox` is None, ``bbox=[x[0], x[-1]]``. Default is None. 
    k : int, optional 
        Degree of the smoothing spline.  Must be 1 &lt;= `k` &lt;= 5. 
        ``k = 3`` is a cubic spline. Default is 3. 
    s : float or None, optional 
        Positive smoothing factor used to choose the number of knots.  Number 
        of knots will be increased until the smoothing condition is satisfied:: 
 
            sum((w[i] * (y[i]-spl(x[i])))**2, axis=0) &lt;= s 
 
        However, because of numerical issues, the actual condition is:: 
 
            abs(sum((w[i] * (y[i]-spl(x[i])))**2, axis=0) - s) &lt; 0.001 * s 
 
        If `s` is None, `s` will be set as `len(w)` for a smoothing spline 
        that uses all data points. 
        If 0, spline will interpolate through all data points. This is 
        equivalent to `InterpolatedUnivariateSpline`. 
        Default is None. 
        The user can use the `s` to control the tradeoff between closeness 
        and smoothness of fit. Larger `s` means more smoothing while smaller 
        values of `s` indicate less smoothing. 
        Recommended values of `s` depend on the weights, `w`. If the weights 
        represent the inverse of the standard-deviation of `y`, then a good 
        `s` value should be found in the range (m-sqrt(2*m),m+sqrt(2*m)) 
        where m is the number of datapoints in `x`, `y`, and `w`. This means 
        ``s = len(w)`` should be a good value if ``1/w[i]`` is an 
        estimate of the standard deviation of ``y[i]``. 
    ext : int or str, optional 
        Controls the extrapolation mode for elements 
        not in the interval defined by the knot sequence. 
 
        * if ext=0 or 'extrapolate', return the extrapolated value. 
        * if ext=1 or 'zeros', return 0 
        * if ext=2 or 'raise', raise a ValueError 
        * if ext=3 or 'const', return the boundary value. 
 
        Default is 0. 
 
    check_finite : bool, optional 
        Whether to check that the input arrays contain only finite numbers. 
        Disabling may give a performance gain, but may result in problems 
        (crashes, non-termination or non-sensical results) if the inputs 
        do contain infinities or NaNs. 
        Default is False. 
 
    See Also 
    -------- 
    BivariateSpline : 
        a base class for bivariate splines. 
    SmoothBivariateSpline : 
        a smoothing bivariate spline through the given points 
    LSQBivariateSpline : 
        a bivariate spline using weighted least-squares fitting 
    RectSphereBivariateSpline : 
        a bivariate spline over a rectangular mesh on a sphere 
    SmoothSphereBivariateSpline : 
        a smoothing bivariate spline in spherical coordinates 
    LSQSphereBivariateSpline : 
        a bivariate spline in spherical coordinates using weighted 
        least-squares fitting 
    RectBivariateSpline : 
        a bivariate spline over a rectangular mesh 
    InterpolatedUnivariateSpline : 
        a interpolating univariate spline for a given set of data points. 
    bisplrep : 
        a function to find a bivariate B-spline representation of a surface 
    bisplev : 
        a function to evaluate a bivariate B-spline and its derivatives 
    splrep : 
        a function to find the B-spline representation of a 1-D curve 
    splev : 
        a function to evaluate a B-spline or its derivatives 
    sproot : 
        a function to find the roots of a cubic B-spline 
    splint : 
        a function to evaluate the definite integral of a B-spline between two 
        given points 
    spalde : 
        a function to evaluate all derivatives of a B-spline 
 
    Notes 
    ----- 
    The number of data points must be larger than the spline degree `k`. 
 
    **NaN handling**: If the input arrays contain ``nan`` values, the result 
    is not useful, since the underlying spline fitting routines cannot deal 
    with ``nan``. A workaround is to use zero weights for not-a-number 
    data points: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.interpolate import UnivariateSpline 
    &gt;&gt;&gt; x, y = np.array([1, 2, 3, 4]), np.array([1, np.nan, 3, 4]) 
    &gt;&gt;&gt; w = np.isnan(y) 
    &gt;&gt;&gt; y[w] = 0. 
    &gt;&gt;&gt; spl = UnivariateSpline(x, y, w=~w) 
 
    Notice the need to replace a ``nan`` by a numerical value (precise value 
    does not matter as long as the corresponding weight is zero.) 
 
    References 
    ---------- 
    Based on algorithms described in [1]_, [2]_, [3]_, and [4]_: 
 
    .. [1] P. Dierckx, &quot;An algorithm for smoothing, differentiation and 
       integration of experimental data using spline functions&quot;, 
       J.Comp.Appl.Maths 1 (1975) 165-184. 
    .. [2] P. Dierckx, &quot;A fast algorithm for smoothing data on a rectangular 
       grid while using spline functions&quot;, SIAM J.Numer.Anal. 19 (1982) 
       1286-1304. 
    .. [3] P. Dierckx, &quot;An improved algorithm for curve fitting with spline 
       functions&quot;, report tw54, Dept. Computer Science,K.U. Leuven, 1981. 
    .. [4] P. Dierckx, &quot;Curve and surface fitting with splines&quot;, Monographs on 
       Numerical Analysis, Oxford University Press, 1993. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.interpolate import UnivariateSpline 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; x = np.linspace(-3, 3, 50) 
    &gt;&gt;&gt; y = np.exp(-x**2) + 0.1 * rng.standard_normal(50) 
    &gt;&gt;&gt; plt.plot(x, y, 'ro', ms=5) 
 
    Use the default value for the smoothing parameter: 
 
    &gt;&gt;&gt; spl = UnivariateSpline(x, y) 
    &gt;&gt;&gt; xs = np.linspace(-3, 3, 1000) 
    &gt;&gt;&gt; plt.plot(xs, spl(xs), 'g', lw=3) 
 
    Manually change the amount of smoothing: 
 
    &gt;&gt;&gt; spl.set_smoothing_factor(0.5) 
    &gt;&gt;&gt; plt.plot(xs, spl(xs), 'b', lw=3) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>

    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">bbox</span><span class="s3">=[</span><span class="s5">None</span><span class="s3">]*</span><span class="s6">2</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s6">3</span><span class="s3">, </span><span class="s1">s</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
                 <span class="s1">ext</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">check_finite</span><span class="s3">=</span><span class="s5">False</span><span class="s3">):</span>

        <span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">bbox</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ext </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">validate_input</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">bbox</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">ext</span><span class="s3">,</span>
                                                      <span class="s1">check_finite</span><span class="s3">)</span>

        <span class="s2"># _data == x,y,w,xb,xe,k,s,n,t,c,fp,fpint,nrdata,ier</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">fpcurf0</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">w</span><span class="s3">=</span><span class="s1">w</span><span class="s3">, </span><span class="s1">xb</span><span class="s3">=</span><span class="s1">bbox</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
                                <span class="s1">xe</span><span class="s3">=</span><span class="s1">bbox</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">s</span><span class="s3">=</span><span class="s1">s</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">data</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">] == </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s2"># nest too small, setting to maximum bound</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_reset_nest</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_data </span><span class="s3">= </span><span class="s1">data</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_reset_class</span><span class="s3">()</span>

    <span class="s3">@</span><span class="s1">staticmethod</span>
    <span class="s5">def </span><span class="s1">validate_input</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">bbox</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">ext</span><span class="s3">, </span><span class="s1">check_finite</span><span class="s3">):</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">bbox </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">bbox</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">w </span><span class="s5">is not None</span><span class="s3">:</span>
            <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">w</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">check_finite</span><span class="s3">:</span>
            <span class="s1">w_finite </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">w</span><span class="s3">).</span><span class="s1">all</span><span class="s3">() </span><span class="s5">if </span><span class="s1">w </span><span class="s5">is not None else True</span>
            <span class="s5">if </span><span class="s3">(</span><span class="s5">not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">x</span><span class="s3">).</span><span class="s1">all</span><span class="s3">() </span><span class="s5">or not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">isfinite</span><span class="s3">(</span><span class="s1">y</span><span class="s3">).</span><span class="s1">all</span><span class="s3">() </span><span class="s5">or</span>
                    <span class="s5">not </span><span class="s1">w_finite</span><span class="s3">):</span>
                <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;x and y array must not contain &quot;</span>
                                 <span class="s4">&quot;NaNs or infs.&quot;</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">s </span><span class="s5">is None or </span><span class="s1">s </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s5">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) &gt;= </span><span class="s6">0.0</span><span class="s3">):</span>
                <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;x must be increasing if s &gt; 0&quot;</span><span class="s3">)</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s5">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) &gt; </span><span class="s6">0.0</span><span class="s3">):</span>
                <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;x must be strictly increasing if s = 0&quot;</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">size </span><span class="s3">!= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;x and y should have a same length&quot;</span><span class="s3">)</span>
        <span class="s5">elif </span><span class="s1">w </span><span class="s5">is not None and not </span><span class="s1">x</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s1">y</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s1">w</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;x, y, and w should have a same length&quot;</span><span class="s3">)</span>
        <span class="s5">elif </span><span class="s1">bbox</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= (</span><span class="s6">2</span><span class="s3">,):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;bbox shape should be (2,)&quot;</span><span class="s3">)</span>
        <span class="s5">elif not </span><span class="s3">(</span><span class="s6">1 </span><span class="s3">&lt;= </span><span class="s1">k </span><span class="s3">&lt;= </span><span class="s6">5</span><span class="s3">):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;k should be 1 &lt;= k &lt;= 5&quot;</span><span class="s3">)</span>
        <span class="s5">elif </span><span class="s1">s </span><span class="s5">is not None and not </span><span class="s1">s </span><span class="s3">&gt;= </span><span class="s6">0.0</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;s should be s &gt;= 0.0&quot;</span><span class="s3">)</span>

        <span class="s5">try</span><span class="s3">:</span>
            <span class="s1">ext </span><span class="s3">= </span><span class="s1">_extrap_modes</span><span class="s3">[</span><span class="s1">ext</span><span class="s3">]</span>
        <span class="s5">except </span><span class="s1">KeyError </span><span class="s5">as </span><span class="s1">e</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Unknown extrapolation mode %s.&quot; </span><span class="s3">% </span><span class="s1">ext</span><span class="s3">) </span><span class="s5">from </span><span class="s1">e</span>

        <span class="s5">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">bbox</span><span class="s3">, </span><span class="s1">ext</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s5">def </span><span class="s1">_from_tck</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">tck</span><span class="s3">, </span><span class="s1">ext</span><span class="s3">=</span><span class="s6">0</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Construct a spline object from given tck&quot;&quot;&quot;</span>
        <span class="s1">self </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__new__</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">)</span>
        <span class="s1">t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k </span><span class="s3">= </span><span class="s1">tck</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_eval_args </span><span class="s3">= </span><span class="s1">tck</span>
        <span class="s2"># _data == x,y,w,xb,xe,k,s,n,t,c,fp,fpint,nrdata,ier</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_data </span><span class="s3">= (</span><span class="s5">None</span><span class="s3">, </span><span class="s5">None</span><span class="s3">, </span><span class="s5">None</span><span class="s3">, </span><span class="s5">None</span><span class="s3">, </span><span class="s5">None</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s5">None</span><span class="s3">, </span><span class="s1">len</span><span class="s3">(</span><span class="s1">t</span><span class="s3">), </span><span class="s1">t</span><span class="s3">,</span>
                      <span class="s1">c</span><span class="s3">, </span><span class="s5">None</span><span class="s3">, </span><span class="s5">None</span><span class="s3">, </span><span class="s5">None</span><span class="s3">, </span><span class="s5">None</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">ext </span><span class="s3">= </span><span class="s1">ext</span>
        <span class="s5">return </span><span class="s1">self</span>

    <span class="s5">def </span><span class="s1">_reset_class</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_data</span>
        <span class="s1">n</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">ier </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s6">7</span><span class="s3">], </span><span class="s1">data</span><span class="s3">[</span><span class="s6">8</span><span class="s3">], </span><span class="s1">data</span><span class="s3">[</span><span class="s6">9</span><span class="s3">], </span><span class="s1">data</span><span class="s3">[</span><span class="s6">5</span><span class="s3">], </span><span class="s1">data</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_eval_args </span><span class="s3">= </span><span class="s1">t</span><span class="s3">[:</span><span class="s1">n</span><span class="s3">], </span><span class="s1">c</span><span class="s3">[:</span><span class="s1">n</span><span class="s3">], </span><span class="s1">k</span>
        <span class="s5">if </span><span class="s1">ier </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s2"># the spline returned has a residual sum of squares fp</span>
            <span class="s2"># such that abs(fp-s)/s &lt;= tol with tol a relative</span>
            <span class="s2"># tolerance set to 0.001 by the program</span>
            <span class="s5">pass</span>
        <span class="s5">elif </span><span class="s1">ier </span><span class="s3">== -</span><span class="s6">1</span><span class="s3">:</span>
            <span class="s2"># the spline returned is an interpolating spline</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_set_class</span><span class="s3">(</span><span class="s1">InterpolatedUnivariateSpline</span><span class="s3">)</span>
        <span class="s5">elif </span><span class="s1">ier </span><span class="s3">== -</span><span class="s6">2</span><span class="s3">:</span>
            <span class="s2"># the spline returned is the weighted least-squares</span>
            <span class="s2"># polynomial of degree k. In this extreme case fp gives</span>
            <span class="s2"># the upper bound fp0 for the smoothing factor s.</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">_set_class</span><span class="s3">(</span><span class="s1">LSQUnivariateSpline</span><span class="s3">)</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s2"># error</span>
            <span class="s5">if </span><span class="s1">ier </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
                <span class="s1">self</span><span class="s3">.</span><span class="s1">_set_class</span><span class="s3">(</span><span class="s1">LSQUnivariateSpline</span><span class="s3">)</span>
            <span class="s1">message </span><span class="s3">= </span><span class="s1">_curfit_messages</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">ier</span><span class="s3">, </span><span class="s4">'ier=%s' </span><span class="s3">% (</span><span class="s1">ier</span><span class="s3">))</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">message</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s6">3</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">_set_class</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">cls</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_spline_class </span><span class="s3">= </span><span class="s1">cls</span>
        <span class="s5">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s5">in </span><span class="s3">(</span><span class="s1">UnivariateSpline</span><span class="s3">, </span><span class="s1">InterpolatedUnivariateSpline</span><span class="s3">,</span>
                              <span class="s1">LSQUnivariateSpline</span><span class="s3">):</span>
            <span class="s1">self</span><span class="s3">.</span><span class="s1">__class__ </span><span class="s3">= </span><span class="s1">cls</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s2"># It's an unknown subclass -- don't change class. cf. #731</span>
            <span class="s5">pass</span>

    <span class="s5">def </span><span class="s1">_reset_nest</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">nest</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s6">10</span><span class="s3">]</span>
        <span class="s5">if </span><span class="s1">nest </span><span class="s5">is None</span><span class="s3">:</span>
            <span class="s1">k</span><span class="s3">, </span><span class="s1">m </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s6">5</span><span class="s3">], </span><span class="s1">len</span><span class="s3">(</span><span class="s1">data</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>
            <span class="s1">nest </span><span class="s3">= </span><span class="s1">m</span><span class="s3">+</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1  </span><span class="s2"># this is the maximum bound for nest</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s5">if not </span><span class="s1">n </span><span class="s3">&lt;= </span><span class="s1">nest</span><span class="s3">:</span>
                <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;`nest` can only be increased&quot;</span><span class="s3">)</span>
        <span class="s1">t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">fpint</span><span class="s3">, </span><span class="s1">nrdata </span><span class="s3">= (</span><span class="s1">np</span><span class="s3">.</span><span class="s1">resize</span><span class="s3">(</span><span class="s1">data</span><span class="s3">[</span><span class="s1">j</span><span class="s3">], </span><span class="s1">nest</span><span class="s3">) </span><span class="s5">for </span><span class="s1">j </span><span class="s5">in</span>
                               <span class="s3">[</span><span class="s6">8</span><span class="s3">, </span><span class="s6">9</span><span class="s3">, </span><span class="s6">11</span><span class="s3">, </span><span class="s6">12</span><span class="s3">])</span>

        <span class="s1">args </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[:</span><span class="s6">8</span><span class="s3">] + (</span><span class="s1">t</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">fpint</span><span class="s3">, </span><span class="s1">nrdata</span><span class="s3">, </span><span class="s1">data</span><span class="s3">[</span><span class="s6">13</span><span class="s3">])</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">fpcurf1</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s5">return </span><span class="s1">data</span>

    <span class="s5">def </span><span class="s1">set_smoothing_factor</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">s</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Continue spline computation with the given smoothing 
        factor s and with the knots found at the last call. 
 
        This routine modifies the spline in place. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_data</span>
        <span class="s5">if </span><span class="s1">data</span><span class="s3">[</span><span class="s6">6</span><span class="s3">] == -</span><span class="s6">1</span><span class="s3">:</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s4">'smoothing factor unchanged for'</span>
                          <span class="s4">'LSQ spline with fixed knots'</span><span class="s3">,</span>
                          <span class="s1">stacklevel</span><span class="s3">=</span><span class="s6">2</span><span class="s3">)</span>
            <span class="s5">return</span>
        <span class="s1">args </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[:</span><span class="s6">6</span><span class="s3">] + (</span><span class="s1">s</span><span class="s3">,) + </span><span class="s1">data</span><span class="s3">[</span><span class="s6">7</span><span class="s3">:]</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">fpcurf1</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">data</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">] == </span><span class="s6">1</span><span class="s3">:</span>
            <span class="s2"># nest too small, setting to maximum bound</span>
            <span class="s1">data </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_reset_nest</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_data </span><span class="s3">= </span><span class="s1">data</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_reset_class</span><span class="s3">()</span>

    <span class="s5">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">nu</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">ext</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Evaluate spline (or its nu-th derivative) at positions x. 
 
        Parameters 
        ---------- 
        x : array_like 
            A 1-D array of points at which to return the value of the smoothed 
            spline or its derivatives. Note: `x` can be unordered but the 
            evaluation is more efficient if `x` is (partially) ordered. 
        nu  : int 
            The order of derivative of the spline to compute. 
        ext : int 
            Controls the value returned for elements of `x` not in the 
            interval defined by the knot sequence. 
 
            * if ext=0 or 'extrapolate', return the extrapolated value. 
            * if ext=1 or 'zeros', return 0 
            * if ext=2 or 'raise', raise a ValueError 
            * if ext=3 or 'const', return the boundary value. 
 
            The default value is 0, passed from the initialization of 
            UnivariateSpline. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s2"># empty input yields empty output</span>
        <span class="s5">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s5">return </span><span class="s1">array</span><span class="s3">([])</span>
        <span class="s5">if </span><span class="s1">ext </span><span class="s5">is None</span><span class="s3">:</span>
            <span class="s1">ext </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ext</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s5">try</span><span class="s3">:</span>
                <span class="s1">ext </span><span class="s3">= </span><span class="s1">_extrap_modes</span><span class="s3">[</span><span class="s1">ext</span><span class="s3">]</span>
            <span class="s5">except </span><span class="s1">KeyError </span><span class="s5">as </span><span class="s1">e</span><span class="s3">:</span>
                <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Unknown extrapolation mode %s.&quot; </span><span class="s3">% </span><span class="s1">ext</span><span class="s3">) </span><span class="s5">from </span><span class="s1">e</span>
        <span class="s5">return </span><span class="s1">_fitpack_impl</span><span class="s3">.</span><span class="s1">splev</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_eval_args</span><span class="s3">, </span><span class="s1">der</span><span class="s3">=</span><span class="s1">nu</span><span class="s3">, </span><span class="s1">ext</span><span class="s3">=</span><span class="s1">ext</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">get_knots</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Return positions of interior knots of the spline. 
 
        Internally, the knot vector contains ``2*k`` additional boundary knots. 
        &quot;&quot;&quot;</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_data</span>
        <span class="s1">k</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s6">5</span><span class="s3">], </span><span class="s1">data</span><span class="s3">[</span><span class="s6">7</span><span class="s3">]</span>
        <span class="s5">return </span><span class="s1">data</span><span class="s3">[</span><span class="s6">8</span><span class="s3">][</span><span class="s1">k</span><span class="s3">:</span><span class="s1">n</span><span class="s3">-</span><span class="s1">k</span><span class="s3">]</span>

    <span class="s5">def </span><span class="s1">get_coeffs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Return spline coefficients.&quot;&quot;&quot;</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_data</span>
        <span class="s1">k</span><span class="s3">, </span><span class="s1">n </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[</span><span class="s6">5</span><span class="s3">], </span><span class="s1">data</span><span class="s3">[</span><span class="s6">7</span><span class="s3">]</span>
        <span class="s5">return </span><span class="s1">data</span><span class="s3">[</span><span class="s6">9</span><span class="s3">][:</span><span class="s1">n</span><span class="s3">-</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">]</span>

    <span class="s5">def </span><span class="s1">get_residual</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Return weighted sum of squared residuals of the spline approximation. 
 
           This is equivalent to:: 
 
                sum((w[i] * (y[i]-spl(x[i])))**2, axis=0) 
 
        &quot;&quot;&quot;</span>
        <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_data</span><span class="s3">[</span><span class="s6">10</span><span class="s3">]</span>

    <span class="s5">def </span><span class="s1">integral</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Return definite integral of the spline between two given points. 
 
        Parameters 
        ---------- 
        a : float 
            Lower limit of integration. 
        b : float 
            Upper limit of integration. 
 
        Returns 
        ------- 
        integral : float 
            The value of the definite integral of the spline between limits. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; from scipy.interpolate import UnivariateSpline 
        &gt;&gt;&gt; x = np.linspace(0, 3, 11) 
        &gt;&gt;&gt; y = x**2 
        &gt;&gt;&gt; spl = UnivariateSpline(x, y) 
        &gt;&gt;&gt; spl.integral(0, 3) 
        9.0 
 
        which agrees with :math:`\\int x^2 dx = x^3 / 3` between the limits 
        of 0 and 3. 
 
        A caveat is that this routine assumes the spline to be zero outside of 
        the data limits: 
 
        &gt;&gt;&gt; spl.integral(-1, 4) 
        9.0 
        &gt;&gt;&gt; spl.integral(-1, 0) 
        0.0 
 
        &quot;&quot;&quot;</span>
        <span class="s5">return </span><span class="s1">_fitpack_impl</span><span class="s3">.</span><span class="s1">splint</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_eval_args</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">derivatives</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Return all derivatives of the spline at the point x. 
 
        Parameters 
        ---------- 
        x : float 
            The point to evaluate the derivatives at. 
 
        Returns 
        ------- 
        der : ndarray, shape(k+1,) 
            Derivatives of the orders 0 to k. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; from scipy.interpolate import UnivariateSpline 
        &gt;&gt;&gt; x = np.linspace(0, 3, 11) 
        &gt;&gt;&gt; y = x**2 
        &gt;&gt;&gt; spl = UnivariateSpline(x, y) 
        &gt;&gt;&gt; spl.derivatives(1.5) 
        array([2.25, 3.0, 2.0, 0]) 
 
        &quot;&quot;&quot;</span>
        <span class="s5">return </span><span class="s1">_fitpack_impl</span><span class="s3">.</span><span class="s1">spalde</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_eval_args</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">roots</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Return the zeros of the spline. 
 
        Notes 
        ----- 
        Restriction: only cubic splines are supported by FITPACK. For non-cubic 
        splines, use `PPoly.root` (see below for an example). 
 
        Examples 
        -------- 
 
        For some data, this method may miss a root. This happens when one of 
        the spline knots (which FITPACK places automatically) happens to 
        coincide with the true root. A workaround is to convert to `PPoly`, 
        which uses a different root-finding algorithm. 
 
        For example, 
 
        &gt;&gt;&gt; x = [1.96, 1.97, 1.98, 1.99, 2.00, 2.01, 2.02, 2.03, 2.04, 2.05] 
        &gt;&gt;&gt; y = [-6.365470e-03, -4.790580e-03, -3.204320e-03, -1.607270e-03, 
        ...      4.440892e-16,  1.616930e-03,  3.243000e-03,  4.877670e-03, 
        ...      6.520430e-03,  8.170770e-03] 
        &gt;&gt;&gt; from scipy.interpolate import UnivariateSpline 
        &gt;&gt;&gt; spl = UnivariateSpline(x, y, s=0) 
        &gt;&gt;&gt; spl.roots() 
        array([], dtype=float64) 
 
        Converting to a PPoly object does find the roots at `x=2`: 
 
        &gt;&gt;&gt; from scipy.interpolate import splrep, PPoly 
        &gt;&gt;&gt; tck = splrep(x, y, s=0) 
        &gt;&gt;&gt; ppoly = PPoly.from_spline(tck) 
        &gt;&gt;&gt; ppoly.roots(extrapolate=False) 
        array([2.]) 
 
        See Also 
        -------- 
        sproot 
        PPoly.roots 
 
        &quot;&quot;&quot;</span>
        <span class="s1">k </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_data</span><span class="s3">[</span><span class="s6">5</span><span class="s3">]</span>
        <span class="s5">if </span><span class="s1">k </span><span class="s3">== </span><span class="s6">3</span><span class="s3">:</span>
            <span class="s1">t </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_eval_args</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
            <span class="s1">mest </span><span class="s3">= </span><span class="s6">3 </span><span class="s3">* (</span><span class="s1">len</span><span class="s3">(</span><span class="s1">t</span><span class="s3">) - </span><span class="s6">7</span><span class="s3">)</span>
            <span class="s5">return </span><span class="s1">_fitpack_impl</span><span class="s3">.</span><span class="s1">sproot</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_eval_args</span><span class="s3">, </span><span class="s1">mest</span><span class="s3">=</span><span class="s1">mest</span><span class="s3">)</span>
        <span class="s5">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span><span class="s4">'finding roots unsupported for '</span>
                                  <span class="s4">'non-cubic splines'</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">derivative</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s6">1</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct a new spline representing the derivative of this spline. 
 
        Parameters 
        ---------- 
        n : int, optional 
            Order of derivative to evaluate. Default: 1 
 
        Returns 
        ------- 
        spline : UnivariateSpline 
            Spline of order k2=k-n representing the derivative of this 
            spline. 
 
        See Also 
        -------- 
        splder, antiderivative 
 
        Notes 
        ----- 
 
        .. versionadded:: 0.13.0 
 
        Examples 
        -------- 
        This can be used for finding maxima of a curve: 
 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; from scipy.interpolate import UnivariateSpline 
        &gt;&gt;&gt; x = np.linspace(0, 10, 70) 
        &gt;&gt;&gt; y = np.sin(x) 
        &gt;&gt;&gt; spl = UnivariateSpline(x, y, k=4, s=0) 
 
        Now, differentiate the spline and find the zeros of the 
        derivative. (NB: `sproot` only works for order 3 splines, so we 
        fit an order 4 spline): 
 
        &gt;&gt;&gt; spl.derivative().roots() / np.pi 
        array([ 0.50000001,  1.5       ,  2.49999998]) 
 
        This agrees well with roots :math:`\\pi/2 + n\\pi` of 
        :math:`\\cos(x) = \\sin'(x)`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">tck </span><span class="s3">= </span><span class="s1">_fitpack_impl</span><span class="s3">.</span><span class="s1">splder</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_eval_args</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
        <span class="s2"># if self.ext is 'const', derivative.ext will be 'zeros'</span>
        <span class="s1">ext </span><span class="s3">= </span><span class="s6">1 </span><span class="s5">if </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ext </span><span class="s3">== </span><span class="s6">3 </span><span class="s5">else </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ext</span>
        <span class="s5">return </span><span class="s1">UnivariateSpline</span><span class="s3">.</span><span class="s1">_from_tck</span><span class="s3">(</span><span class="s1">tck</span><span class="s3">, </span><span class="s1">ext</span><span class="s3">=</span><span class="s1">ext</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">antiderivative</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">n</span><span class="s3">=</span><span class="s6">1</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct a new spline representing the antiderivative of this spline. 
 
        Parameters 
        ---------- 
        n : int, optional 
            Order of antiderivative to evaluate. Default: 1 
 
        Returns 
        ------- 
        spline : UnivariateSpline 
            Spline of order k2=k+n representing the antiderivative of this 
            spline. 
 
        Notes 
        ----- 
 
        .. versionadded:: 0.13.0 
 
        See Also 
        -------- 
        splantider, derivative 
 
        Examples 
        -------- 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; from scipy.interpolate import UnivariateSpline 
        &gt;&gt;&gt; x = np.linspace(0, np.pi/2, 70) 
        &gt;&gt;&gt; y = 1 / np.sqrt(1 - 0.8*np.sin(x)**2) 
        &gt;&gt;&gt; spl = UnivariateSpline(x, y, s=0) 
 
        The derivative is the inverse operation of the antiderivative, 
        although some floating point error accumulates: 
 
        &gt;&gt;&gt; spl(1.7), spl.antiderivative().derivative()(1.7) 
        (array(2.1565429877197317), array(2.1565429877201865)) 
 
        Antiderivative can be used to evaluate definite integrals: 
 
        &gt;&gt;&gt; ispl = spl.antiderivative() 
        &gt;&gt;&gt; ispl(np.pi/2) - ispl(0) 
        2.2572053588768486 
 
        This is indeed an approximation to the complete elliptic integral 
        :math:`K(m) = \\int_0^{\\pi/2} [1 - m\\sin^2 x]^{-1/2} dx`: 
 
        &gt;&gt;&gt; from scipy.special import ellipk 
        &gt;&gt;&gt; ellipk(0.8) 
        2.2572053268208538 
 
        &quot;&quot;&quot;</span>
        <span class="s1">tck </span><span class="s3">= </span><span class="s1">_fitpack_impl</span><span class="s3">.</span><span class="s1">splantider</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_eval_args</span><span class="s3">, </span><span class="s1">n</span><span class="s3">)</span>
        <span class="s5">return </span><span class="s1">UnivariateSpline</span><span class="s3">.</span><span class="s1">_from_tck</span><span class="s3">(</span><span class="s1">tck</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ext</span><span class="s3">)</span>


<span class="s5">class </span><span class="s1">InterpolatedUnivariateSpline</span><span class="s3">(</span><span class="s1">UnivariateSpline</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    1-D interpolating spline for a given set of data points. 
 
    Fits a spline y = spl(x) of degree `k` to the provided `x`, `y` data. 
    Spline function passes through all provided points. Equivalent to 
    `UnivariateSpline` with  `s` = 0. 
 
    Parameters 
    ---------- 
    x : (N,) array_like 
        Input dimension of data points -- must be strictly increasing 
    y : (N,) array_like 
        input dimension of data points 
    w : (N,) array_like, optional 
        Weights for spline fitting.  Must be positive.  If None (default), 
        weights are all 1. 
    bbox : (2,) array_like, optional 
        2-sequence specifying the boundary of the approximation interval. If 
        None (default), ``bbox=[x[0], x[-1]]``. 
    k : int, optional 
        Degree of the smoothing spline.  Must be ``1 &lt;= k &lt;= 5``. Default is 
        ``k = 3``, a cubic spline. 
    ext : int or str, optional 
        Controls the extrapolation mode for elements 
        not in the interval defined by the knot sequence. 
 
        * if ext=0 or 'extrapolate', return the extrapolated value. 
        * if ext=1 or 'zeros', return 0 
        * if ext=2 or 'raise', raise a ValueError 
        * if ext=3 of 'const', return the boundary value. 
 
        The default value is 0. 
 
    check_finite : bool, optional 
        Whether to check that the input arrays contain only finite numbers. 
        Disabling may give a performance gain, but may result in problems 
        (crashes, non-termination or non-sensical results) if the inputs 
        do contain infinities or NaNs. 
        Default is False. 
 
    See Also 
    -------- 
    UnivariateSpline : 
        a smooth univariate spline to fit a given set of data points. 
    LSQUnivariateSpline : 
        a spline for which knots are user-selected 
    SmoothBivariateSpline : 
        a smoothing bivariate spline through the given points 
    LSQBivariateSpline : 
        a bivariate spline using weighted least-squares fitting 
    splrep : 
        a function to find the B-spline representation of a 1-D curve 
    splev : 
        a function to evaluate a B-spline or its derivatives 
    sproot : 
        a function to find the roots of a cubic B-spline 
    splint : 
        a function to evaluate the definite integral of a B-spline between two 
        given points 
    spalde : 
        a function to evaluate all derivatives of a B-spline 
 
    Notes 
    ----- 
    The number of data points must be larger than the spline degree `k`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.interpolate import InterpolatedUnivariateSpline 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; x = np.linspace(-3, 3, 50) 
    &gt;&gt;&gt; y = np.exp(-x**2) + 0.1 * rng.standard_normal(50) 
    &gt;&gt;&gt; spl = InterpolatedUnivariateSpline(x, y) 
    &gt;&gt;&gt; plt.plot(x, y, 'ro', ms=5) 
    &gt;&gt;&gt; xs = np.linspace(-3, 3, 1000) 
    &gt;&gt;&gt; plt.plot(xs, spl(xs), 'g', lw=3, alpha=0.7) 
    &gt;&gt;&gt; plt.show() 
 
    Notice that the ``spl(x)`` interpolates `y`: 
 
    &gt;&gt;&gt; spl.get_residual() 
    0.0 
 
    &quot;&quot;&quot;</span>

    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">bbox</span><span class="s3">=[</span><span class="s5">None</span><span class="s3">]*</span><span class="s6">2</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s6">3</span><span class="s3">,</span>
                 <span class="s1">ext</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">check_finite</span><span class="s3">=</span><span class="s5">False</span><span class="s3">):</span>

        <span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">bbox</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ext </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">validate_input</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">bbox</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s5">None</span><span class="s3">,</span>
                                            <span class="s1">ext</span><span class="s3">, </span><span class="s1">check_finite</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) &gt; </span><span class="s6">0.0</span><span class="s3">):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'x must be strictly increasing'</span><span class="s3">)</span>

        <span class="s2"># _data == x,y,w,xb,xe,k,s,n,t,c,fp,fpint,nrdata,ier</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_data </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">fpcurf0</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">w</span><span class="s3">=</span><span class="s1">w</span><span class="s3">, </span><span class="s1">xb</span><span class="s3">=</span><span class="s1">bbox</span><span class="s3">[</span><span class="s6">0</span><span class="s3">],</span>
                                      <span class="s1">xe</span><span class="s3">=</span><span class="s1">bbox</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">s</span><span class="s3">=</span><span class="s6">0</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_reset_class</span><span class="s3">()</span>


<span class="s1">_fpchec_error_string </span><span class="s3">= </span><span class="s4">&quot;&quot;&quot;The input parameters have been rejected by fpchec. </span><span class="s5">\ 
</span><span class="s4">This means that at least one of the following conditions is violated: 
 
1) k+1 &lt;= n-k-1 &lt;= m 
2) t(1) &lt;= t(2) &lt;= ... &lt;= t(k+1) 
   t(n-k) &lt;= t(n-k+1) &lt;= ... &lt;= t(n) 
3) t(k+1) &lt; t(k+2) &lt; ... &lt; t(n-k) 
4) t(k+1) &lt;= x(i) &lt;= t(n-k) 
5) The conditions specified by Schoenberg and Whitney must hold 
   for at least one subset of data points, i.e., there must be a 
   subset of data points y(j) such that 
       t(j) &lt; y(j) &lt; t(j+k+1), j=1,2,...,n-k-1 
&quot;&quot;&quot;</span>


<span class="s5">class </span><span class="s1">LSQUnivariateSpline</span><span class="s3">(</span><span class="s1">UnivariateSpline</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    1-D spline with explicit internal knots. 
 
    Fits a spline y = spl(x) of degree `k` to the provided `x`, `y` data.  `t` 
    specifies the internal knots of the spline 
 
    Parameters 
    ---------- 
    x : (N,) array_like 
        Input dimension of data points -- must be increasing 
    y : (N,) array_like 
        Input dimension of data points 
    t : (M,) array_like 
        interior knots of the spline.  Must be in ascending order and:: 
 
            bbox[0] &lt; t[0] &lt; ... &lt; t[-1] &lt; bbox[-1] 
 
    w : (N,) array_like, optional 
        weights for spline fitting. Must be positive. If None (default), 
        weights are all 1. 
    bbox : (2,) array_like, optional 
        2-sequence specifying the boundary of the approximation interval. If 
        None (default), ``bbox = [x[0], x[-1]]``. 
    k : int, optional 
        Degree of the smoothing spline.  Must be 1 &lt;= `k` &lt;= 5. 
        Default is `k` = 3, a cubic spline. 
    ext : int or str, optional 
        Controls the extrapolation mode for elements 
        not in the interval defined by the knot sequence. 
 
        * if ext=0 or 'extrapolate', return the extrapolated value. 
        * if ext=1 or 'zeros', return 0 
        * if ext=2 or 'raise', raise a ValueError 
        * if ext=3 of 'const', return the boundary value. 
 
        The default value is 0. 
 
    check_finite : bool, optional 
        Whether to check that the input arrays contain only finite numbers. 
        Disabling may give a performance gain, but may result in problems 
        (crashes, non-termination or non-sensical results) if the inputs 
        do contain infinities or NaNs. 
        Default is False. 
 
    Raises 
    ------ 
    ValueError 
        If the interior knots do not satisfy the Schoenberg-Whitney conditions 
 
    See Also 
    -------- 
    UnivariateSpline : 
        a smooth univariate spline to fit a given set of data points. 
    InterpolatedUnivariateSpline : 
        a interpolating univariate spline for a given set of data points. 
    splrep : 
        a function to find the B-spline representation of a 1-D curve 
    splev : 
        a function to evaluate a B-spline or its derivatives 
    sproot : 
        a function to find the roots of a cubic B-spline 
    splint : 
        a function to evaluate the definite integral of a B-spline between two 
        given points 
    spalde : 
        a function to evaluate all derivatives of a B-spline 
 
    Notes 
    ----- 
    The number of data points must be larger than the spline degree `k`. 
 
    Knots `t` must satisfy the Schoenberg-Whitney conditions, 
    i.e., there must be a subset of data points ``x[j]`` such that 
    ``t[j] &lt; x[j] &lt; t[j+k+1]``, for ``j=0, 1,...,n-k-2``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.interpolate import LSQUnivariateSpline, UnivariateSpline 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; x = np.linspace(-3, 3, 50) 
    &gt;&gt;&gt; y = np.exp(-x**2) + 0.1 * rng.standard_normal(50) 
 
    Fit a smoothing spline with a pre-defined internal knots: 
 
    &gt;&gt;&gt; t = [-1, 0, 1] 
    &gt;&gt;&gt; spl = LSQUnivariateSpline(x, y, t) 
 
    &gt;&gt;&gt; xs = np.linspace(-3, 3, 1000) 
    &gt;&gt;&gt; plt.plot(x, y, 'ro', ms=5) 
    &gt;&gt;&gt; plt.plot(xs, spl(xs), 'g-', lw=3) 
    &gt;&gt;&gt; plt.show() 
 
    Check the knot vector: 
 
    &gt;&gt;&gt; spl.get_knots() 
    array([-3., -1., 0., 1., 3.]) 
 
    Constructing lsq spline using the knots from another spline: 
 
    &gt;&gt;&gt; x = np.arange(10) 
    &gt;&gt;&gt; s = UnivariateSpline(x, x, s=0) 
    &gt;&gt;&gt; s.get_knots() 
    array([ 0.,  2.,  3.,  4.,  5.,  6.,  7.,  9.]) 
    &gt;&gt;&gt; knt = s.get_knots() 
    &gt;&gt;&gt; s1 = LSQUnivariateSpline(x, x, knt[1:-1])    # Chop 1st and last knot 
    &gt;&gt;&gt; s1.get_knots() 
    array([ 0.,  2.,  3.,  4.,  5.,  6.,  7.,  9.]) 
 
    &quot;&quot;&quot;</span>

    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">w</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">bbox</span><span class="s3">=[</span><span class="s5">None</span><span class="s3">]*</span><span class="s6">2</span><span class="s3">, </span><span class="s1">k</span><span class="s3">=</span><span class="s6">3</span><span class="s3">,</span>
                 <span class="s1">ext</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">check_finite</span><span class="s3">=</span><span class="s5">False</span><span class="s3">):</span>

        <span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">bbox</span><span class="s3">, </span><span class="s1">self</span><span class="s3">.</span><span class="s1">ext </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">validate_input</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">bbox</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s5">None</span><span class="s3">,</span>
                                                      <span class="s1">ext</span><span class="s3">, </span><span class="s1">check_finite</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) &gt;= </span><span class="s6">0.0</span><span class="s3">):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'x must be increasing'</span><span class="s3">)</span>

        <span class="s2"># _data == x,y,w,xb,xe,k,s,n,t,c,fp,fpint,nrdata,ier</span>
        <span class="s1">xb </span><span class="s3">= </span><span class="s1">bbox</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s1">xe </span><span class="s3">= </span><span class="s1">bbox</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s5">if </span><span class="s1">xb </span><span class="s5">is None</span><span class="s3">:</span>
            <span class="s1">xb </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>
        <span class="s5">if </span><span class="s1">xe </span><span class="s5">is None</span><span class="s3">:</span>
            <span class="s1">xe </span><span class="s3">= </span><span class="s1">x</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">]</span>
        <span class="s1">t </span><span class="s3">= </span><span class="s1">concatenate</span><span class="s3">(([</span><span class="s1">xb</span><span class="s3">]*(</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1</span><span class="s3">), </span><span class="s1">t</span><span class="s3">, [</span><span class="s1">xe</span><span class="s3">]*(</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1</span><span class="s3">)))</span>
        <span class="s1">n </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">t</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">t</span><span class="s3">[</span><span class="s1">k</span><span class="s3">+</span><span class="s6">1</span><span class="s3">:</span><span class="s1">n</span><span class="s3">-</span><span class="s1">k</span><span class="s3">]-</span><span class="s1">t</span><span class="s3">[</span><span class="s1">k</span><span class="s3">:</span><span class="s1">n</span><span class="s3">-</span><span class="s1">k</span><span class="s3">-</span><span class="s6">1</span><span class="s3">] &gt; </span><span class="s6">0</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s6">0</span><span class="s3">):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'Interior knots t must satisfy '</span>
                             <span class="s4">'Schoenberg-Whitney conditions'</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">fpchec</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">k</span><span class="s3">) == </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">_fpchec_error_string</span><span class="s3">)</span>
        <span class="s1">data </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">fpcurfm1</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">t</span><span class="s3">, </span><span class="s1">w</span><span class="s3">=</span><span class="s1">w</span><span class="s3">, </span><span class="s1">xb</span><span class="s3">=</span><span class="s1">xb</span><span class="s3">, </span><span class="s1">xe</span><span class="s3">=</span><span class="s1">xe</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[:-</span><span class="s6">3</span><span class="s3">] + (</span><span class="s5">None</span><span class="s3">, </span><span class="s5">None</span><span class="s3">, </span><span class="s1">data</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">])</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_reset_class</span><span class="s3">()</span>


<span class="s2"># ############### Bivariate spline ####################</span>

<span class="s5">class </span><span class="s1">_BivariateSplineBase</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot; Base class for Bivariate spline s(x,y) interpolation on the rectangle 
    [xb,xe] x [yb, ye] calculated from a given set of data points 
    (x,y,z). 
 
    See Also 
    -------- 
    bisplrep : 
        a function to find a bivariate B-spline representation of a surface 
    bisplev : 
        a function to evaluate a bivariate B-spline and its derivatives 
    BivariateSpline : 
        a base class for bivariate splines. 
    SphereBivariateSpline : 
        a bivariate spline on a spherical grid 
    &quot;&quot;&quot;</span>

    <span class="s3">@</span><span class="s1">classmethod</span>
    <span class="s5">def </span><span class="s1">_from_tck</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">, </span><span class="s1">tck</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Construct a spline object from given tck and degree&quot;&quot;&quot;</span>
        <span class="s1">self </span><span class="s3">= </span><span class="s1">cls</span><span class="s3">.</span><span class="s1">__new__</span><span class="s3">(</span><span class="s1">cls</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">tck</span><span class="s3">) != </span><span class="s6">5</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;tck should be a 5 element tuple of tx,&quot;</span>
                             <span class="s4">&quot; ty, c, kx, ky&quot;</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">tck </span><span class="s3">= </span><span class="s1">tck</span><span class="s3">[:</span><span class="s6">3</span><span class="s3">]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">degrees </span><span class="s3">= </span><span class="s1">tck</span><span class="s3">[</span><span class="s6">3</span><span class="s3">:]</span>
        <span class="s5">return </span><span class="s1">self</span>

    <span class="s5">def </span><span class="s1">get_residual</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Return weighted sum of squared residuals of the spline 
        approximation: sum ((w[i]*(z[i]-s(x[i],y[i])))**2,axis=0) 
        &quot;&quot;&quot;</span>
        <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">fp</span>

    <span class="s5">def </span><span class="s1">get_knots</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Return a tuple (tx,ty) where tx,ty contain knots positions 
        of the spline with respect to x-, y-variable, respectively. 
        The position of interior and additional knots are given as 
        t[k+1:-k-1] and t[:k+1]=b, t[-k-1:]=e, respectively. 
        &quot;&quot;&quot;</span>
        <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tck</span><span class="s3">[:</span><span class="s6">2</span><span class="s3">]</span>

    <span class="s5">def </span><span class="s1">get_coeffs</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; Return spline coefficients.&quot;&quot;&quot;</span>
        <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tck</span><span class="s3">[</span><span class="s6">2</span><span class="s3">]</span>

    <span class="s5">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">dy</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">grid</span><span class="s3">=</span><span class="s5">True</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Evaluate the spline or its derivatives at given positions. 
 
        Parameters 
        ---------- 
        x, y : array_like 
            Input coordinates. 
 
            If `grid` is False, evaluate the spline at points ``(x[i], 
            y[i]), i=0, ..., len(x)-1``.  Standard Numpy broadcasting 
            is obeyed. 
 
            If `grid` is True: evaluate spline at the grid points 
            defined by the coordinate arrays x, y. The arrays must be 
            sorted to increasing order. 
 
            The ordering of axes is consistent with 
            ``np.meshgrid(..., indexing=&quot;ij&quot;)`` and inconsistent with the 
            default ordering ``np.meshgrid(..., indexing=&quot;xy&quot;)``. 
        dx : int 
            Order of x-derivative 
 
            .. versionadded:: 0.14.0 
        dy : int 
            Order of y-derivative 
 
            .. versionadded:: 0.14.0 
        grid : bool 
            Whether to evaluate the results on a grid spanned by the 
            input arrays, or at points specified by the input arrays. 
 
            .. versionadded:: 0.14.0 
 
        Examples 
        -------- 
        Suppose that we want to bilinearly interpolate an exponentially decaying 
        function in 2 dimensions. 
 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; from scipy.interpolate import RectBivariateSpline 
 
        We sample the function on a coarse grid. Note that the default indexing=&quot;xy&quot; 
        of meshgrid would result in an unexpected (transposed) result after 
        interpolation. 
 
        &gt;&gt;&gt; xarr = np.linspace(-3, 3, 100) 
        &gt;&gt;&gt; yarr = np.linspace(-3, 3, 100) 
        &gt;&gt;&gt; xgrid, ygrid = np.meshgrid(xarr, yarr, indexing=&quot;ij&quot;) 
 
        The function to interpolate decays faster along one axis than the other. 
 
        &gt;&gt;&gt; zdata = np.exp(-np.sqrt((xgrid / 2) ** 2 + ygrid**2)) 
 
        Next we sample on a finer grid using interpolation (kx=ky=1 for bilinear). 
 
        &gt;&gt;&gt; rbs = RectBivariateSpline(xarr, yarr, zdata, kx=1, ky=1) 
        &gt;&gt;&gt; xarr_fine = np.linspace(-3, 3, 200) 
        &gt;&gt;&gt; yarr_fine = np.linspace(-3, 3, 200) 
        &gt;&gt;&gt; xgrid_fine, ygrid_fine = np.meshgrid(xarr_fine, yarr_fine, indexing=&quot;ij&quot;) 
        &gt;&gt;&gt; zdata_interp = rbs(xgrid_fine, ygrid_fine, grid=False) 
 
        And check that the result agrees with the input by plotting both. 
 
        &gt;&gt;&gt; import matplotlib.pyplot as plt 
        &gt;&gt;&gt; fig = plt.figure() 
        &gt;&gt;&gt; ax1 = fig.add_subplot(1, 2, 1, aspect=&quot;equal&quot;) 
        &gt;&gt;&gt; ax2 = fig.add_subplot(1, 2, 2, aspect=&quot;equal&quot;) 
        &gt;&gt;&gt; ax1.imshow(zdata) 
        &gt;&gt;&gt; ax2.imshow(zdata_interp) 
        &gt;&gt;&gt; plt.show() 
        &quot;&quot;&quot;</span>
        <span class="s1">x </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>
        <span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">)</span>

        <span class="s1">tx</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tck</span><span class="s3">[:</span><span class="s6">3</span><span class="s3">]</span>
        <span class="s1">kx</span><span class="s3">, </span><span class="s1">ky </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">degrees</span>
        <span class="s5">if </span><span class="s1">grid</span><span class="s3">:</span>
            <span class="s5">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s6">0 </span><span class="s5">or </span><span class="s1">y</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s5">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">x</span><span class="s3">.</span><span class="s1">size</span><span class="s3">, </span><span class="s1">y</span><span class="s3">.</span><span class="s1">size</span><span class="s3">), </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">tck</span><span class="s3">[</span><span class="s6">2</span><span class="s3">].</span><span class="s1">dtype</span><span class="s3">)</span>

            <span class="s5">if </span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt;= </span><span class="s6">2</span><span class="s3">) </span><span class="s5">and </span><span class="s3">(</span><span class="s5">not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) &gt;= </span><span class="s6">0.0</span><span class="s3">)):</span>
                <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;x must be strictly increasing when `grid` is True&quot;</span><span class="s3">)</span>
            <span class="s5">if </span><span class="s3">(</span><span class="s1">y</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt;= </span><span class="s6">2</span><span class="s3">) </span><span class="s5">and </span><span class="s3">(</span><span class="s5">not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">y</span><span class="s3">) &gt;= </span><span class="s6">0.0</span><span class="s3">)):</span>
                <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;y must be strictly increasing when `grid` is True&quot;</span><span class="s3">)</span>

            <span class="s5">if </span><span class="s1">dx </span><span class="s5">or </span><span class="s1">dy</span><span class="s3">:</span>
                <span class="s1">z</span><span class="s3">, </span><span class="s1">ier </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">parder</span><span class="s3">(</span><span class="s1">tx</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">dy</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
                <span class="s5">if not </span><span class="s1">ier </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
                    <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Error code returned by parder: %s&quot; </span><span class="s3">% </span><span class="s1">ier</span><span class="s3">)</span>
            <span class="s5">else</span><span class="s3">:</span>
                <span class="s1">z</span><span class="s3">, </span><span class="s1">ier </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">bispev</span><span class="s3">(</span><span class="s1">tx</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
                <span class="s5">if not </span><span class="s1">ier </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
                    <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Error code returned by bispev: %s&quot; </span><span class="s3">% </span><span class="s1">ier</span><span class="s3">)</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s2"># standard Numpy broadcasting</span>
            <span class="s5">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
                <span class="s1">x</span><span class="s3">, </span><span class="s1">y </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">broadcast_arrays</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>

            <span class="s1">shape </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()</span>
            <span class="s1">y </span><span class="s3">= </span><span class="s1">y</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">()</span>

            <span class="s5">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s6">0 </span><span class="s5">or </span><span class="s1">y</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s5">return </span><span class="s1">np</span><span class="s3">.</span><span class="s1">zeros</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">tck</span><span class="s3">[</span><span class="s6">2</span><span class="s3">].</span><span class="s1">dtype</span><span class="s3">)</span>

            <span class="s5">if </span><span class="s1">dx </span><span class="s5">or </span><span class="s1">dy</span><span class="s3">:</span>
                <span class="s1">z</span><span class="s3">, </span><span class="s1">ier </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">pardeu</span><span class="s3">(</span><span class="s1">tx</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">dy</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
                <span class="s5">if not </span><span class="s1">ier </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
                    <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Error code returned by pardeu: %s&quot; </span><span class="s3">% </span><span class="s1">ier</span><span class="s3">)</span>
            <span class="s5">else</span><span class="s3">:</span>
                <span class="s1">z</span><span class="s3">, </span><span class="s1">ier </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">bispeu</span><span class="s3">(</span><span class="s1">tx</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">)</span>
                <span class="s5">if not </span><span class="s1">ier </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
                    <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Error code returned by bispeu: %s&quot; </span><span class="s3">% </span><span class="s1">ier</span><span class="s3">)</span>

            <span class="s1">z </span><span class="s3">= </span><span class="s1">z</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">)</span>
        <span class="s5">return </span><span class="s1">z</span>

    <span class="s5">def </span><span class="s1">partial_derivative</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">dy</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Construct a new spline representing a partial derivative of this 
        spline. 
 
        Parameters 
        ---------- 
        dx, dy : int 
            Orders of the derivative in x and y respectively. They must be 
            non-negative integers and less than the respective degree of the 
            original spline (self) in that direction (``kx``, ``ky``). 
 
        Returns 
        ------- 
        spline : 
            A new spline of degrees (``kx - dx``, ``ky - dy``) representing the 
            derivative of this spline. 
 
        Notes 
        ----- 
 
        .. versionadded:: 1.9.0 
 
        &quot;&quot;&quot;</span>
        <span class="s5">if </span><span class="s1">dx </span><span class="s3">== </span><span class="s6">0 </span><span class="s5">and </span><span class="s1">dy </span><span class="s3">== </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s5">return </span><span class="s1">self</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">kx</span><span class="s3">, </span><span class="s1">ky </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">degrees</span>
            <span class="s5">if not </span><span class="s3">(</span><span class="s1">dx </span><span class="s3">&gt;= </span><span class="s6">0 </span><span class="s5">and </span><span class="s1">dy </span><span class="s3">&gt;= </span><span class="s6">0</span><span class="s3">):</span>
                <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;order of derivative must be positive or&quot;</span>
                                 <span class="s4">&quot; zero&quot;</span><span class="s3">)</span>
            <span class="s5">if not </span><span class="s3">(</span><span class="s1">dx </span><span class="s3">&lt; </span><span class="s1">kx </span><span class="s5">and </span><span class="s1">dy </span><span class="s3">&lt; </span><span class="s1">ky</span><span class="s3">):</span>
                <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;order of derivative must be less than&quot;</span>
                                 <span class="s4">&quot; degree of spline&quot;</span><span class="s3">)</span>
            <span class="s1">tx</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tck</span><span class="s3">[:</span><span class="s6">3</span><span class="s3">]</span>
            <span class="s1">newc</span><span class="s3">, </span><span class="s1">ier </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">pardtc</span><span class="s3">(</span><span class="s1">tx</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">dy</span><span class="s3">)</span>
            <span class="s5">if </span><span class="s1">ier </span><span class="s3">!= </span><span class="s6">0</span><span class="s3">:</span>
                <span class="s2"># This should not happen under normal conditions.</span>
                <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;Unexpected error code returned by&quot;</span>
                                 <span class="s4">&quot; pardtc: %d&quot; </span><span class="s3">% </span><span class="s1">ier</span><span class="s3">)</span>
            <span class="s1">nx </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">tx</span><span class="s3">)</span>
            <span class="s1">ny </span><span class="s3">= </span><span class="s1">len</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">)</span>
            <span class="s1">newtx </span><span class="s3">= </span><span class="s1">tx</span><span class="s3">[</span><span class="s1">dx</span><span class="s3">:</span><span class="s1">nx </span><span class="s3">- </span><span class="s1">dx</span><span class="s3">]</span>
            <span class="s1">newty </span><span class="s3">= </span><span class="s1">ty</span><span class="s3">[</span><span class="s1">dy</span><span class="s3">:</span><span class="s1">ny </span><span class="s3">- </span><span class="s1">dy</span><span class="s3">]</span>
            <span class="s1">newkx</span><span class="s3">, </span><span class="s1">newky </span><span class="s3">= </span><span class="s1">kx </span><span class="s3">- </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">ky </span><span class="s3">- </span><span class="s1">dy</span>
            <span class="s1">newclen </span><span class="s3">= (</span><span class="s1">nx </span><span class="s3">- </span><span class="s1">dx </span><span class="s3">- </span><span class="s1">kx </span><span class="s3">- </span><span class="s6">1</span><span class="s3">) * (</span><span class="s1">ny </span><span class="s3">- </span><span class="s1">dy </span><span class="s3">- </span><span class="s1">ky </span><span class="s3">- </span><span class="s6">1</span><span class="s3">)</span>
            <span class="s5">return </span><span class="s1">_DerivedBivariateSpline</span><span class="s3">.</span><span class="s1">_from_tck</span><span class="s3">((</span><span class="s1">newtx</span><span class="s3">, </span><span class="s1">newty</span><span class="s3">,</span>
                                                      <span class="s1">newc</span><span class="s3">[:</span><span class="s1">newclen</span><span class="s3">],</span>
                                                      <span class="s1">newkx</span><span class="s3">, </span><span class="s1">newky</span><span class="s3">))</span>


<span class="s1">_surfit_messages </span><span class="s3">= {</span><span class="s6">1</span><span class="s3">: </span><span class="s4">&quot;&quot;&quot; 
The required storage space exceeds the available storage space: nxest 
or nyest too small, or s too small. 
The weighted least-squares spline corresponds to the current set of 
knots.&quot;&quot;&quot;</span><span class="s3">,</span>
                    <span class="s6">2</span><span class="s3">: </span><span class="s4">&quot;&quot;&quot; 
A theoretically impossible result was found during the iteration 
process for finding a smoothing spline with fp = s: s too small or 
badly chosen eps. 
Weighted sum of squared residuals does not satisfy abs(fp-s)/s &lt; tol.&quot;&quot;&quot;</span><span class="s3">,</span>
                    <span class="s6">3</span><span class="s3">: </span><span class="s4">&quot;&quot;&quot; 
the maximal number of iterations maxit (set to 20 by the program) 
allowed for finding a smoothing spline with fp=s has been reached: 
s too small. 
Weighted sum of squared residuals does not satisfy abs(fp-s)/s &lt; tol.&quot;&quot;&quot;</span><span class="s3">,</span>
                    <span class="s6">4</span><span class="s3">: </span><span class="s4">&quot;&quot;&quot; 
No more knots can be added because the number of b-spline coefficients 
(nx-kx-1)*(ny-ky-1) already exceeds the number of data points m: 
either s or m too small. 
The weighted least-squares spline corresponds to the current set of 
knots.&quot;&quot;&quot;</span><span class="s3">,</span>
                    <span class="s6">5</span><span class="s3">: </span><span class="s4">&quot;&quot;&quot; 
No more knots can be added because the additional knot would (quasi) 
coincide with an old one: s too small or too large a weight to an 
inaccurate data point. 
The weighted least-squares spline corresponds to the current set of 
knots.&quot;&quot;&quot;</span><span class="s3">,</span>
                    <span class="s6">10</span><span class="s3">: </span><span class="s4">&quot;&quot;&quot; 
Error on entry, no approximation returned. The following conditions 
must hold: 
xb&lt;=x[i]&lt;=xe, yb&lt;=y[i]&lt;=ye, w[i]&gt;0, i=0..m-1 
If iopt==-1, then 
  xb&lt;tx[kx+1]&lt;tx[kx+2]&lt;...&lt;tx[nx-kx-2]&lt;xe 
  yb&lt;ty[ky+1]&lt;ty[ky+2]&lt;...&lt;ty[ny-ky-2]&lt;ye&quot;&quot;&quot;</span><span class="s3">,</span>
                    <span class="s3">-</span><span class="s6">3</span><span class="s3">: </span><span class="s4">&quot;&quot;&quot; 
The coefficients of the spline returned have been computed as the 
minimal norm least-squares solution of a (numerically) rank deficient 
system (deficiency=%i). If deficiency is large, the results may be 
inaccurate. Deficiency may strongly depend on the value of eps.&quot;&quot;&quot;</span>
                    <span class="s3">}</span>


<span class="s5">class </span><span class="s1">BivariateSpline</span><span class="s3">(</span><span class="s1">_BivariateSplineBase</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Base class for bivariate splines. 
 
    This describes a spline ``s(x, y)`` of degrees ``kx`` and ``ky`` on 
    the rectangle ``[xb, xe] * [yb, ye]`` calculated from a given set 
    of data points ``(x, y, z)``. 
 
    This class is meant to be subclassed, not instantiated directly. 
    To construct these splines, call either `SmoothBivariateSpline` or 
    `LSQBivariateSpline` or `RectBivariateSpline`. 
 
    See Also 
    -------- 
    UnivariateSpline : 
        a smooth univariate spline to fit a given set of data points. 
    SmoothBivariateSpline : 
        a smoothing bivariate spline through the given points 
    LSQBivariateSpline : 
        a bivariate spline using weighted least-squares fitting 
    RectSphereBivariateSpline : 
        a bivariate spline over a rectangular mesh on a sphere 
    SmoothSphereBivariateSpline : 
        a smoothing bivariate spline in spherical coordinates 
    LSQSphereBivariateSpline : 
        a bivariate spline in spherical coordinates using weighted 
        least-squares fitting 
    RectBivariateSpline : 
        a bivariate spline over a rectangular mesh. 
    bisplrep : 
        a function to find a bivariate B-spline representation of a surface 
    bisplev : 
        a function to evaluate a bivariate B-spline and its derivatives 
    &quot;&quot;&quot;</span>

    <span class="s5">def </span><span class="s1">ev</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">xi</span><span class="s3">, </span><span class="s1">yi</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">dy</span><span class="s3">=</span><span class="s6">0</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Evaluate the spline at points 
 
        Returns the interpolated value at ``(xi[i], yi[i]), 
        i=0,...,len(xi)-1``. 
 
        Parameters 
        ---------- 
        xi, yi : array_like 
            Input coordinates. Standard Numpy broadcasting is obeyed. 
            The ordering of axes is consistent with 
            ``np.meshgrid(..., indexing=&quot;ij&quot;)`` and inconsistent with the 
            default ordering ``np.meshgrid(..., indexing=&quot;xy&quot;)``. 
        dx : int, optional 
            Order of x-derivative 
 
            .. versionadded:: 0.14.0 
        dy : int, optional 
            Order of y-derivative 
 
            .. versionadded:: 0.14.0 
 
        Examples 
        -------- 
        Suppose that we want to bilinearly interpolate an exponentially decaying 
        function in 2 dimensions. 
 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; from scipy.interpolate import RectBivariateSpline 
        &gt;&gt;&gt; def f(x, y): 
        ...     return np.exp(-np.sqrt((x / 2) ** 2 + y**2)) 
 
        We sample the function on a coarse grid and set up the interpolator. Note that 
        the default ``indexing=&quot;xy&quot;`` of meshgrid would result in an unexpected 
        (transposed) result after interpolation. 
 
        &gt;&gt;&gt; xarr = np.linspace(-3, 3, 21) 
        &gt;&gt;&gt; yarr = np.linspace(-3, 3, 21) 
        &gt;&gt;&gt; xgrid, ygrid = np.meshgrid(xarr, yarr, indexing=&quot;ij&quot;) 
        &gt;&gt;&gt; zdata = f(xgrid, ygrid) 
        &gt;&gt;&gt; rbs = RectBivariateSpline(xarr, yarr, zdata, kx=1, ky=1) 
 
        Next we sample the function along a diagonal slice through the coordinate space 
        on a finer grid using interpolation. 
 
        &gt;&gt;&gt; xinterp = np.linspace(-3, 3, 201) 
        &gt;&gt;&gt; yinterp = np.linspace(3, -3, 201) 
        &gt;&gt;&gt; zinterp = rbs.ev(xinterp, yinterp) 
 
        And check that the interpolation passes through the function evaluations as a 
        function of the distance from the origin along the slice. 
 
        &gt;&gt;&gt; import matplotlib.pyplot as plt 
        &gt;&gt;&gt; fig = plt.figure() 
        &gt;&gt;&gt; ax1 = fig.add_subplot(1, 1, 1) 
        &gt;&gt;&gt; ax1.plot(np.sqrt(xarr**2 + yarr**2), np.diag(zdata), &quot;or&quot;) 
        &gt;&gt;&gt; ax1.plot(np.sqrt(xinterp**2 + yinterp**2), zinterp, &quot;-b&quot;) 
        &gt;&gt;&gt; plt.show() 
        &quot;&quot;&quot;</span>
        <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">xi</span><span class="s3">, </span><span class="s1">yi</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">=</span><span class="s1">dx</span><span class="s3">, </span><span class="s1">dy</span><span class="s3">=</span><span class="s1">dy</span><span class="s3">, </span><span class="s1">grid</span><span class="s3">=</span><span class="s5">False</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">integral</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">xa</span><span class="s3">, </span><span class="s1">xb</span><span class="s3">, </span><span class="s1">ya</span><span class="s3">, </span><span class="s1">yb</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Evaluate the integral of the spline over area [xa,xb] x [ya,yb]. 
 
        Parameters 
        ---------- 
        xa, xb : float 
            The end-points of the x integration interval. 
        ya, yb : float 
            The end-points of the y integration interval. 
 
        Returns 
        ------- 
        integ : float 
            The value of the resulting integral. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">tx</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">tck</span><span class="s3">[:</span><span class="s6">3</span><span class="s3">]</span>
        <span class="s1">kx</span><span class="s3">, </span><span class="s1">ky </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">degrees</span>
        <span class="s5">return </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">dblint</span><span class="s3">(</span><span class="s1">tx</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">, </span><span class="s1">xa</span><span class="s3">, </span><span class="s1">xb</span><span class="s3">, </span><span class="s1">ya</span><span class="s3">, </span><span class="s1">yb</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">staticmethod</span>
    <span class="s5">def </span><span class="s1">_validate_input</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">, </span><span class="s1">eps</span><span class="s3">):</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">y</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">x</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s1">y</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s1">z</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'x, y, and z should have a same length'</span><span class="s3">)</span>

        <span class="s5">if </span><span class="s1">w </span><span class="s5">is not None</span><span class="s3">:</span>
            <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">w</span><span class="s3">)</span>
            <span class="s5">if </span><span class="s1">x</span><span class="s3">.</span><span class="s1">size </span><span class="s3">!= </span><span class="s1">w</span><span class="s3">.</span><span class="s1">size</span><span class="s3">:</span>
                <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'x, y, z, and w should have a same length'</span><span class="s3">)</span>
            <span class="s5">elif not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">w </span><span class="s3">&gt;= </span><span class="s6">0.0</span><span class="s3">):</span>
                <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'w should be positive'</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s3">(</span><span class="s1">eps </span><span class="s5">is not None</span><span class="s3">) </span><span class="s5">and </span><span class="s3">(</span><span class="s5">not </span><span class="s6">0.0 </span><span class="s3">&lt; </span><span class="s1">eps </span><span class="s3">&lt; </span><span class="s6">1.0</span><span class="s3">):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'eps should be between (0, 1)'</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">x</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt;= (</span><span class="s1">kx </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">) * (</span><span class="s1">ky </span><span class="s3">+ </span><span class="s6">1</span><span class="s3">):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'The length of x, y and z should be at least'</span>
                             <span class="s4">' (kx+1) * (ky+1)'</span><span class="s3">)</span>
        <span class="s5">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">w</span>


<span class="s5">class </span><span class="s1">_DerivedBivariateSpline</span><span class="s3">(</span><span class="s1">_BivariateSplineBase</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Bivariate spline constructed from the coefficients and knots of another 
    spline. 
 
    Notes 
    ----- 
    The class is not meant to be instantiated directly from the data to be 
    interpolated or smoothed. As a result, its ``fp`` attribute and 
    ``get_residual`` method are inherited but overridden; ``AttributeError`` is 
    raised when they are accessed. 
 
    The other inherited attributes can be used as usual. 
    &quot;&quot;&quot;</span>
    <span class="s1">_invalid_why </span><span class="s3">= (</span><span class="s4">&quot;is unavailable, because _DerivedBivariateSpline&quot;</span>
                    <span class="s4">&quot; instance is not constructed from data that are to be&quot;</span>
                    <span class="s4">&quot; interpolated or smoothed, but derived from the&quot;</span>
                    <span class="s4">&quot; underlying knots and coefficients of another spline&quot;</span>
                    <span class="s4">&quot; object&quot;</span><span class="s3">)</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s5">def </span><span class="s1">fp</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">raise </span><span class="s1">AttributeError</span><span class="s3">(</span><span class="s4">&quot;attribute </span><span class="s5">\&quot;</span><span class="s4">fp</span><span class="s5">\&quot; </span><span class="s4">%s&quot; </span><span class="s3">% </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_invalid_why</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">get_residual</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s5">raise </span><span class="s1">AttributeError</span><span class="s3">(</span><span class="s4">&quot;method </span><span class="s5">\&quot;</span><span class="s4">get_residual</span><span class="s5">\&quot; </span><span class="s4">%s&quot; </span><span class="s3">% </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_invalid_why</span><span class="s3">)</span>


<span class="s5">class </span><span class="s1">SmoothBivariateSpline</span><span class="s3">(</span><span class="s1">BivariateSpline</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Smooth bivariate spline approximation. 
 
    Parameters 
    ---------- 
    x, y, z : array_like 
        1-D sequences of data points (order is not important). 
    w : array_like, optional 
        Positive 1-D sequence of weights, of same length as `x`, `y` and `z`. 
    bbox : array_like, optional 
        Sequence of length 4 specifying the boundary of the rectangular 
        approximation domain.  By default, 
        ``bbox=[min(x), max(x), min(y), max(y)]``. 
    kx, ky : ints, optional 
        Degrees of the bivariate spline. Default is 3. 
    s : float, optional 
        Positive smoothing factor defined for estimation condition: 
        ``sum((w[i]*(z[i]-s(x[i], y[i])))**2, axis=0) &lt;= s`` 
        Default ``s=len(w)`` which should be a good value if ``1/w[i]`` is an 
        estimate of the standard deviation of ``z[i]``. 
    eps : float, optional 
        A threshold for determining the effective rank of an over-determined 
        linear system of equations. `eps` should have a value within the open 
        interval ``(0, 1)``, the default is 1e-16. 
 
    See Also 
    -------- 
    BivariateSpline : 
        a base class for bivariate splines. 
    UnivariateSpline : 
        a smooth univariate spline to fit a given set of data points. 
    LSQBivariateSpline : 
        a bivariate spline using weighted least-squares fitting 
    RectSphereBivariateSpline : 
        a bivariate spline over a rectangular mesh on a sphere 
    SmoothSphereBivariateSpline : 
        a smoothing bivariate spline in spherical coordinates 
    LSQSphereBivariateSpline : 
        a bivariate spline in spherical coordinates using weighted 
        least-squares fitting 
    RectBivariateSpline : 
        a bivariate spline over a rectangular mesh 
    bisplrep : 
        a function to find a bivariate B-spline representation of a surface 
    bisplev : 
        a function to evaluate a bivariate B-spline and its derivatives 
 
    Notes 
    ----- 
    The length of `x`, `y` and `z` should be at least ``(kx+1) * (ky+1)``. 
 
    If the input data is such that input dimensions have incommensurate 
    units and differ by many orders of magnitude, the interpolant may have 
    numerical artifacts. Consider rescaling the data before interpolating. 
 
    This routine constructs spline knot vectors automatically via the FITPACK 
    algorithm. The spline knots may be placed away from the data points. For 
    some data sets, this routine may fail to construct an interpolating spline, 
    even if one is requested via ``s=0`` parameter. In such situations, it is 
    recommended to use `bisplrep` / `bisplev` directly instead of this routine 
    and, if needed, increase the values of ``nxest`` and ``nyest`` parameters 
    of `bisplrep`. 
 
    For linear interpolation, prefer `LinearNDInterpolator`. 
    See ``https://gist.github.com/ev-br/8544371b40f414b7eaf3fe6217209bff`` 
    for discussion. 
 
    &quot;&quot;&quot;</span>

    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">w</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">bbox</span><span class="s3">=[</span><span class="s5">None</span><span class="s3">] * </span><span class="s6">4</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">=</span><span class="s6">3</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">=</span><span class="s6">3</span><span class="s3">, </span><span class="s1">s</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
                 <span class="s1">eps</span><span class="s3">=</span><span class="s6">1e-16</span><span class="s3">):</span>

        <span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">w </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_input</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">, </span><span class="s1">eps</span><span class="s3">)</span>
        <span class="s1">bbox </span><span class="s3">= </span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">bbox</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">bbox</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s6">4</span><span class="s3">,):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'bbox shape should be (4,)'</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">s </span><span class="s5">is not None and not </span><span class="s1">s </span><span class="s3">&gt;= </span><span class="s6">0.0</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;s should be s &gt;= 0.0&quot;</span><span class="s3">)</span>

        <span class="s1">xb</span><span class="s3">, </span><span class="s1">xe</span><span class="s3">, </span><span class="s1">yb</span><span class="s3">, </span><span class="s1">ye </span><span class="s3">= </span><span class="s1">bbox</span>
        <span class="s1">nx</span><span class="s3">, </span><span class="s1">tx</span><span class="s3">, </span><span class="s1">ny</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">wrk1</span><span class="s3">, </span><span class="s1">ier </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">surfit_smth</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">w</span><span class="s3">,</span>
                                                                <span class="s1">xb</span><span class="s3">, </span><span class="s1">xe</span><span class="s3">, </span><span class="s1">yb</span><span class="s3">,</span>
                                                                <span class="s1">ye</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">,</span>
                                                                <span class="s1">s</span><span class="s3">=</span><span class="s1">s</span><span class="s3">, </span><span class="s1">eps</span><span class="s3">=</span><span class="s1">eps</span><span class="s3">,</span>
                                                                <span class="s1">lwrk2</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">ier </span><span class="s3">&gt; </span><span class="s6">10</span><span class="s3">:          </span><span class="s2"># lwrk2 was to small, re-run</span>
            <span class="s1">nx</span><span class="s3">, </span><span class="s1">tx</span><span class="s3">, </span><span class="s1">ny</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">wrk1</span><span class="s3">, </span><span class="s1">ier </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">surfit_smth</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">w</span><span class="s3">,</span>
                                                                    <span class="s1">xb</span><span class="s3">, </span><span class="s1">xe</span><span class="s3">, </span><span class="s1">yb</span><span class="s3">,</span>
                                                                    <span class="s1">ye</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">,</span>
                                                                    <span class="s1">s</span><span class="s3">=</span><span class="s1">s</span><span class="s3">,</span>
                                                                    <span class="s1">eps</span><span class="s3">=</span><span class="s1">eps</span><span class="s3">,</span>
                                                                    <span class="s1">lwrk2</span><span class="s3">=</span><span class="s1">ier</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">ier </span><span class="s5">in </span><span class="s3">[</span><span class="s6">0</span><span class="s3">, -</span><span class="s6">1</span><span class="s3">, -</span><span class="s6">2</span><span class="s3">]:  </span><span class="s2"># normal return</span>
            <span class="s5">pass</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">message </span><span class="s3">= </span><span class="s1">_surfit_messages</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">ier</span><span class="s3">, </span><span class="s4">'ier=%s' </span><span class="s3">% (</span><span class="s1">ier</span><span class="s3">))</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">message</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s6">2</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">fp </span><span class="s3">= </span><span class="s1">fp</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">tck </span><span class="s3">= </span><span class="s1">tx</span><span class="s3">[:</span><span class="s1">nx</span><span class="s3">], </span><span class="s1">ty</span><span class="s3">[:</span><span class="s1">ny</span><span class="s3">], </span><span class="s1">c</span><span class="s3">[:(</span><span class="s1">nx</span><span class="s3">-</span><span class="s1">kx</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)*(</span><span class="s1">ny</span><span class="s3">-</span><span class="s1">ky</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">degrees </span><span class="s3">= </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span>


<span class="s5">class </span><span class="s1">LSQBivariateSpline</span><span class="s3">(</span><span class="s1">BivariateSpline</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Weighted least-squares bivariate spline approximation. 
 
    Parameters 
    ---------- 
    x, y, z : array_like 
        1-D sequences of data points (order is not important). 
    tx, ty : array_like 
        Strictly ordered 1-D sequences of knots coordinates. 
    w : array_like, optional 
        Positive 1-D array of weights, of the same length as `x`, `y` and `z`. 
    bbox : (4,) array_like, optional 
        Sequence of length 4 specifying the boundary of the rectangular 
        approximation domain.  By default, 
        ``bbox=[min(x,tx),max(x,tx), min(y,ty),max(y,ty)]``. 
    kx, ky : ints, optional 
        Degrees of the bivariate spline. Default is 3. 
    eps : float, optional 
        A threshold for determining the effective rank of an over-determined 
        linear system of equations. `eps` should have a value within the open 
        interval ``(0, 1)``, the default is 1e-16. 
 
    See Also 
    -------- 
    BivariateSpline : 
        a base class for bivariate splines. 
    UnivariateSpline : 
        a smooth univariate spline to fit a given set of data points. 
    SmoothBivariateSpline : 
        a smoothing bivariate spline through the given points 
    RectSphereBivariateSpline : 
        a bivariate spline over a rectangular mesh on a sphere 
    SmoothSphereBivariateSpline : 
        a smoothing bivariate spline in spherical coordinates 
    LSQSphereBivariateSpline : 
        a bivariate spline in spherical coordinates using weighted 
        least-squares fitting 
    RectBivariateSpline : 
        a bivariate spline over a rectangular mesh. 
    bisplrep : 
        a function to find a bivariate B-spline representation of a surface 
    bisplev : 
        a function to evaluate a bivariate B-spline and its derivatives 
 
    Notes 
    ----- 
    The length of `x`, `y` and `z` should be at least ``(kx+1) * (ky+1)``. 
 
    If the input data is such that input dimensions have incommensurate 
    units and differ by many orders of magnitude, the interpolant may have 
    numerical artifacts. Consider rescaling the data before interpolating. 
 
    &quot;&quot;&quot;</span>

    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">tx</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">w</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">bbox</span><span class="s3">=[</span><span class="s5">None</span><span class="s3">]*</span><span class="s6">4</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">=</span><span class="s6">3</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">=</span><span class="s6">3</span><span class="s3">,</span>
                 <span class="s1">eps</span><span class="s3">=</span><span class="s5">None</span><span class="s3">):</span>

        <span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">w </span><span class="s3">= </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_validate_input</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">, </span><span class="s1">eps</span><span class="s3">)</span>
        <span class="s1">bbox </span><span class="s3">= </span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">bbox</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">bbox</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s6">4</span><span class="s3">,):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'bbox shape should be (4,)'</span><span class="s3">)</span>

        <span class="s1">nx </span><span class="s3">= </span><span class="s6">2</span><span class="s3">*</span><span class="s1">kx</span><span class="s3">+</span><span class="s6">2</span><span class="s3">+</span><span class="s1">len</span><span class="s3">(</span><span class="s1">tx</span><span class="s3">)</span>
        <span class="s1">ny </span><span class="s3">= </span><span class="s6">2</span><span class="s3">*</span><span class="s1">ky</span><span class="s3">+</span><span class="s6">2</span><span class="s3">+</span><span class="s1">len</span><span class="s3">(</span><span class="s1">ty</span><span class="s3">)</span>
        <span class="s2"># The Fortran subroutine &quot;surfit&quot; (called as dfitpack.surfit_lsq)</span>
        <span class="s2"># requires that the knot arrays passed as input should be &quot;real</span>
        <span class="s2"># array(s) of dimension nmax&quot; where &quot;nmax&quot; refers to the greater of nx</span>
        <span class="s2"># and ny. We pad the tx1/ty1 arrays here so that this is satisfied, and</span>
        <span class="s2"># slice them to the desired sizes upon return.</span>
        <span class="s1">nmax </span><span class="s3">= </span><span class="s1">max</span><span class="s3">(</span><span class="s1">nx</span><span class="s3">, </span><span class="s1">ny</span><span class="s3">)</span>
        <span class="s1">tx1 </span><span class="s3">= </span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">nmax</span><span class="s3">,), </span><span class="s1">float</span><span class="s3">)</span>
        <span class="s1">ty1 </span><span class="s3">= </span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">nmax</span><span class="s3">,), </span><span class="s1">float</span><span class="s3">)</span>
        <span class="s1">tx1</span><span class="s3">[</span><span class="s1">kx</span><span class="s3">+</span><span class="s6">1</span><span class="s3">:</span><span class="s1">nx</span><span class="s3">-</span><span class="s1">kx</span><span class="s3">-</span><span class="s6">1</span><span class="s3">] = </span><span class="s1">tx</span>
        <span class="s1">ty1</span><span class="s3">[</span><span class="s1">ky</span><span class="s3">+</span><span class="s6">1</span><span class="s3">:</span><span class="s1">ny</span><span class="s3">-</span><span class="s1">ky</span><span class="s3">-</span><span class="s6">1</span><span class="s3">] = </span><span class="s1">ty</span>

        <span class="s1">xb</span><span class="s3">, </span><span class="s1">xe</span><span class="s3">, </span><span class="s1">yb</span><span class="s3">, </span><span class="s1">ye </span><span class="s3">= </span><span class="s1">bbox</span>
        <span class="s1">tx1</span><span class="s3">, </span><span class="s1">ty1</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">ier </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">surfit_lsq</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">nx</span><span class="s3">, </span><span class="s1">tx1</span><span class="s3">, </span><span class="s1">ny</span><span class="s3">, </span><span class="s1">ty1</span><span class="s3">,</span>
                                                   <span class="s1">w</span><span class="s3">, </span><span class="s1">xb</span><span class="s3">, </span><span class="s1">xe</span><span class="s3">, </span><span class="s1">yb</span><span class="s3">, </span><span class="s1">ye</span><span class="s3">,</span>
                                                   <span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">, </span><span class="s1">eps</span><span class="s3">, </span><span class="s1">lwrk2</span><span class="s3">=</span><span class="s6">1</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">ier </span><span class="s3">&gt; </span><span class="s6">10</span><span class="s3">:</span>
            <span class="s1">tx1</span><span class="s3">, </span><span class="s1">ty1</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">ier </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">surfit_lsq</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">,</span>
                                                       <span class="s1">nx</span><span class="s3">, </span><span class="s1">tx1</span><span class="s3">, </span><span class="s1">ny</span><span class="s3">, </span><span class="s1">ty1</span><span class="s3">, </span><span class="s1">w</span><span class="s3">,</span>
                                                       <span class="s1">xb</span><span class="s3">, </span><span class="s1">xe</span><span class="s3">, </span><span class="s1">yb</span><span class="s3">, </span><span class="s1">ye</span><span class="s3">,</span>
                                                       <span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">, </span><span class="s1">eps</span><span class="s3">, </span><span class="s1">lwrk2</span><span class="s3">=</span><span class="s1">ier</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">ier </span><span class="s5">in </span><span class="s3">[</span><span class="s6">0</span><span class="s3">, -</span><span class="s6">1</span><span class="s3">, -</span><span class="s6">2</span><span class="s3">]:  </span><span class="s2"># normal return</span>
            <span class="s5">pass</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s5">if </span><span class="s1">ier </span><span class="s3">&lt; -</span><span class="s6">2</span><span class="s3">:</span>
                <span class="s1">deficiency </span><span class="s3">= (</span><span class="s1">nx</span><span class="s3">-</span><span class="s1">kx</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)*(</span><span class="s1">ny</span><span class="s3">-</span><span class="s1">ky</span><span class="s3">-</span><span class="s6">1</span><span class="s3">)+</span><span class="s1">ier</span>
                <span class="s1">message </span><span class="s3">= </span><span class="s1">_surfit_messages</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(-</span><span class="s6">3</span><span class="s3">) % (</span><span class="s1">deficiency</span><span class="s3">)</span>
            <span class="s5">else</span><span class="s3">:</span>
                <span class="s1">message </span><span class="s3">= </span><span class="s1">_surfit_messages</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">ier</span><span class="s3">, </span><span class="s4">'ier=%s' </span><span class="s3">% (</span><span class="s1">ier</span><span class="s3">))</span>
            <span class="s1">warnings</span><span class="s3">.</span><span class="s1">warn</span><span class="s3">(</span><span class="s1">message</span><span class="s3">, </span><span class="s1">stacklevel</span><span class="s3">=</span><span class="s6">2</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">fp </span><span class="s3">= </span><span class="s1">fp</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">tck </span><span class="s3">= </span><span class="s1">tx1</span><span class="s3">[:</span><span class="s1">nx</span><span class="s3">], </span><span class="s1">ty1</span><span class="s3">[:</span><span class="s1">ny</span><span class="s3">], </span><span class="s1">c</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">degrees </span><span class="s3">= </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span>


<span class="s5">class </span><span class="s1">RectBivariateSpline</span><span class="s3">(</span><span class="s1">BivariateSpline</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Bivariate spline approximation over a rectangular mesh. 
 
    Can be used for both smoothing and interpolating data. 
 
    Parameters 
    ---------- 
    x,y : array_like 
        1-D arrays of coordinates in strictly ascending order. 
        Evaluated points outside the data range will be extrapolated. 
    z : array_like 
        2-D array of data with shape (x.size,y.size). 
    bbox : array_like, optional 
        Sequence of length 4 specifying the boundary of the rectangular 
        approximation domain, which means the start and end spline knots of 
        each dimension are set by these values. By default, 
        ``bbox=[min(x), max(x), min(y), max(y)]``. 
    kx, ky : ints, optional 
        Degrees of the bivariate spline. Default is 3. 
    s : float, optional 
        Positive smoothing factor defined for estimation condition: 
        ``sum((z[i]-f(x[i], y[i]))**2, axis=0) &lt;= s`` where f is a spline 
        function. Default is ``s=0``, which is for interpolation. 
 
    See Also 
    -------- 
    BivariateSpline : 
        a base class for bivariate splines. 
    UnivariateSpline : 
        a smooth univariate spline to fit a given set of data points. 
    SmoothBivariateSpline : 
        a smoothing bivariate spline through the given points 
    LSQBivariateSpline : 
        a bivariate spline using weighted least-squares fitting 
    RectSphereBivariateSpline : 
        a bivariate spline over a rectangular mesh on a sphere 
    SmoothSphereBivariateSpline : 
        a smoothing bivariate spline in spherical coordinates 
    LSQSphereBivariateSpline : 
        a bivariate spline in spherical coordinates using weighted 
        least-squares fitting 
    bisplrep : 
        a function to find a bivariate B-spline representation of a surface 
    bisplev : 
        a function to evaluate a bivariate B-spline and its derivatives 
 
    Notes 
    ----- 
 
    If the input data is such that input dimensions have incommensurate 
    units and differ by many orders of magnitude, the interpolant may have 
    numerical artifacts. Consider rescaling the data before interpolating. 
 
    &quot;&quot;&quot;</span>

    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">bbox</span><span class="s3">=[</span><span class="s5">None</span><span class="s3">] * </span><span class="s6">4</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">=</span><span class="s6">3</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">=</span><span class="s6">3</span><span class="s3">, </span><span class="s1">s</span><span class="s3">=</span><span class="s6">0</span><span class="s3">):</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">bbox </span><span class="s3">= </span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">x</span><span class="s3">), </span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">y</span><span class="s3">), </span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">bbox</span><span class="s3">)</span>
        <span class="s1">z </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">x</span><span class="s3">) &gt; </span><span class="s6">0.0</span><span class="s3">):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'x must be strictly increasing'</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">y</span><span class="s3">) &gt; </span><span class="s6">0.0</span><span class="s3">):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'y must be strictly increasing'</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">x</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s1">z</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'x dimension of z must have same number of '</span>
                             <span class="s4">'elements as x'</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">y</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s1">z</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'y dimension of z must have same number of '</span>
                             <span class="s4">'elements as y'</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">bbox</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">== (</span><span class="s6">4</span><span class="s3">,):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'bbox shape should be (4,)'</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">s </span><span class="s5">is not None and not </span><span class="s1">s </span><span class="s3">&gt;= </span><span class="s6">0.0</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;s should be s &gt;= 0.0&quot;</span><span class="s3">)</span>

        <span class="s1">z </span><span class="s3">= </span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">z</span><span class="s3">)</span>
        <span class="s1">xb</span><span class="s3">, </span><span class="s1">xe</span><span class="s3">, </span><span class="s1">yb</span><span class="s3">, </span><span class="s1">ye </span><span class="s3">= </span><span class="s1">bbox</span>
        <span class="s1">nx</span><span class="s3">, </span><span class="s1">tx</span><span class="s3">, </span><span class="s1">ny</span><span class="s3">, </span><span class="s1">ty</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">ier </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">regrid_smth</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">z</span><span class="s3">, </span><span class="s1">xb</span><span class="s3">, </span><span class="s1">xe</span><span class="s3">, </span><span class="s1">yb</span><span class="s3">,</span>
                                                          <span class="s1">ye</span><span class="s3">, </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span><span class="s3">, </span><span class="s1">s</span><span class="s3">)</span>

        <span class="s5">if </span><span class="s1">ier </span><span class="s5">not in </span><span class="s3">[</span><span class="s6">0</span><span class="s3">, -</span><span class="s6">1</span><span class="s3">, -</span><span class="s6">2</span><span class="s3">]:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s1">_surfit_messages</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">ier</span><span class="s3">, </span><span class="s4">'ier=%s' </span><span class="s3">% (</span><span class="s1">ier</span><span class="s3">))</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">fp </span><span class="s3">= </span><span class="s1">fp</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">tck </span><span class="s3">= </span><span class="s1">tx</span><span class="s3">[:</span><span class="s1">nx</span><span class="s3">], </span><span class="s1">ty</span><span class="s3">[:</span><span class="s1">ny</span><span class="s3">], </span><span class="s1">c</span><span class="s3">[:(</span><span class="s1">nx </span><span class="s3">- </span><span class="s1">kx </span><span class="s3">- </span><span class="s6">1</span><span class="s3">) * (</span><span class="s1">ny </span><span class="s3">- </span><span class="s1">ky </span><span class="s3">- </span><span class="s6">1</span><span class="s3">)]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">degrees </span><span class="s3">= </span><span class="s1">kx</span><span class="s3">, </span><span class="s1">ky</span>


<span class="s1">_spherefit_messages </span><span class="s3">= </span><span class="s1">_surfit_messages</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
<span class="s1">_spherefit_messages</span><span class="s3">[</span><span class="s6">10</span><span class="s3">] = </span><span class="s4">&quot;&quot;&quot; 
ERROR. On entry, the input data are controlled on validity. The following 
       restrictions must be satisfied: 
            -1&lt;=iopt&lt;=1,  m&gt;=2, ntest&gt;=8 ,npest &gt;=8, 0&lt;eps&lt;1, 
            0&lt;=teta(i)&lt;=pi, 0&lt;=phi(i)&lt;=2*pi, w(i)&gt;0, i=1,...,m 
            lwrk1 &gt;= 185+52*v+10*u+14*u*v+8*(u-1)*v**2+8*m 
            kwrk &gt;= m+(ntest-7)*(npest-7) 
            if iopt=-1: 8&lt;=nt&lt;=ntest , 9&lt;=np&lt;=npest 
                        0&lt;tt(5)&lt;tt(6)&lt;...&lt;tt(nt-4)&lt;pi 
                        0&lt;tp(5)&lt;tp(6)&lt;...&lt;tp(np-4)&lt;2*pi 
            if iopt&gt;=0: s&gt;=0 
            if one of these conditions is found to be violated,control 
            is immediately repassed to the calling program. in that 
            case there is no approximation returned.&quot;&quot;&quot;</span>
<span class="s1">_spherefit_messages</span><span class="s3">[-</span><span class="s6">3</span><span class="s3">] = </span><span class="s4">&quot;&quot;&quot; 
WARNING. The coefficients of the spline returned have been computed as the 
         minimal norm least-squares solution of a (numerically) rank 
         deficient system (deficiency=%i, rank=%i). Especially if the rank 
         deficiency, which is computed by 6+(nt-8)*(np-7)+ier, is large, 
         the results may be inaccurate. They could also seriously depend on 
         the value of eps.&quot;&quot;&quot;</span>


<span class="s5">class </span><span class="s1">SphereBivariateSpline</span><span class="s3">(</span><span class="s1">_BivariateSplineBase</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Bivariate spline s(x,y) of degrees 3 on a sphere, calculated from a 
    given set of data points (theta,phi,r). 
 
    .. versionadded:: 0.11.0 
 
    See Also 
    -------- 
    bisplrep : 
        a function to find a bivariate B-spline representation of a surface 
    bisplev : 
        a function to evaluate a bivariate B-spline and its derivatives 
    UnivariateSpline : 
        a smooth univariate spline to fit a given set of data points. 
    SmoothBivariateSpline : 
        a smoothing bivariate spline through the given points 
    LSQUnivariateSpline : 
        a univariate spline using weighted least-squares fitting 
    &quot;&quot;&quot;</span>

    <span class="s5">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">dtheta</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">dphi</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">grid</span><span class="s3">=</span><span class="s5">True</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Evaluate the spline or its derivatives at given positions. 
 
        Parameters 
        ---------- 
        theta, phi : array_like 
            Input coordinates. 
 
            If `grid` is False, evaluate the spline at points 
            ``(theta[i], phi[i]), i=0, ..., len(x)-1``.  Standard 
            Numpy broadcasting is obeyed. 
 
            If `grid` is True: evaluate spline at the grid points 
            defined by the coordinate arrays theta, phi. The arrays 
            must be sorted to increasing order. 
            The ordering of axes is consistent with 
            ``np.meshgrid(..., indexing=&quot;ij&quot;)`` and inconsistent with the 
            default ordering ``np.meshgrid(..., indexing=&quot;xy&quot;)``. 
        dtheta : int, optional 
            Order of theta-derivative 
 
            .. versionadded:: 0.14.0 
        dphi : int 
            Order of phi-derivative 
 
            .. versionadded:: 0.14.0 
        grid : bool 
            Whether to evaluate the results on a grid spanned by the 
            input arrays, or at points specified by the input arrays. 
 
            .. versionadded:: 0.14.0 
 
        Examples 
        -------- 
 
        Suppose that we want to use splines to interpolate a bivariate function on a 
        sphere. The value of the function is known on a grid of longitudes and 
        colatitudes. 
 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; from scipy.interpolate import RectSphereBivariateSpline 
        &gt;&gt;&gt; def f(theta, phi): 
        ...     return np.sin(theta) * np.cos(phi) 
 
        We evaluate the function on the grid. Note that the default indexing=&quot;xy&quot; 
        of meshgrid would result in an unexpected (transposed) result after 
        interpolation. 
 
        &gt;&gt;&gt; thetaarr = np.linspace(0, np.pi, 22)[1:-1] 
        &gt;&gt;&gt; phiarr = np.linspace(0, 2 * np.pi, 21)[:-1] 
        &gt;&gt;&gt; thetagrid, phigrid = np.meshgrid(thetaarr, phiarr, indexing=&quot;ij&quot;) 
        &gt;&gt;&gt; zdata = f(thetagrid, phigrid) 
 
        We next set up the interpolator and use it to evaluate the function 
        on a finer grid. 
 
        &gt;&gt;&gt; rsbs = RectSphereBivariateSpline(thetaarr, phiarr, zdata) 
        &gt;&gt;&gt; thetaarr_fine = np.linspace(0, np.pi, 200) 
        &gt;&gt;&gt; phiarr_fine = np.linspace(0, 2 * np.pi, 200) 
        &gt;&gt;&gt; zdata_fine = rsbs(thetaarr_fine, phiarr_fine) 
 
        Finally we plot the coarsly-sampled input data alongside the 
        finely-sampled interpolated data to check that they agree. 
 
        &gt;&gt;&gt; import matplotlib.pyplot as plt 
        &gt;&gt;&gt; fig = plt.figure() 
        &gt;&gt;&gt; ax1 = fig.add_subplot(1, 2, 1) 
        &gt;&gt;&gt; ax2 = fig.add_subplot(1, 2, 2) 
        &gt;&gt;&gt; ax1.imshow(zdata) 
        &gt;&gt;&gt; ax2.imshow(zdata_fine) 
        &gt;&gt;&gt; plt.show() 
        &quot;&quot;&quot;</span>
        <span class="s1">theta </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">theta</span><span class="s3">)</span>
        <span class="s1">phi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">phi</span><span class="s3">)</span>

        <span class="s5">if </span><span class="s1">theta</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s5">and </span><span class="s3">(</span><span class="s1">theta</span><span class="s3">.</span><span class="s1">min</span><span class="s3">() &lt; </span><span class="s6">0. </span><span class="s5">or </span><span class="s1">theta</span><span class="s3">.</span><span class="s1">max</span><span class="s3">() &gt; </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;requested theta out of bounds.&quot;</span><span class="s3">)</span>

        <span class="s5">return </span><span class="s1">_BivariateSplineBase</span><span class="s3">.</span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">,</span>
                                             <span class="s1">dx</span><span class="s3">=</span><span class="s1">dtheta</span><span class="s3">, </span><span class="s1">dy</span><span class="s3">=</span><span class="s1">dphi</span><span class="s3">, </span><span class="s1">grid</span><span class="s3">=</span><span class="s1">grid</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">ev</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">dtheta</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">dphi</span><span class="s3">=</span><span class="s6">0</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Evaluate the spline at points 
 
        Returns the interpolated value at ``(theta[i], phi[i]), 
        i=0,...,len(theta)-1``. 
 
        Parameters 
        ---------- 
        theta, phi : array_like 
            Input coordinates. Standard Numpy broadcasting is obeyed. 
            The ordering of axes is consistent with 
            np.meshgrid(..., indexing=&quot;ij&quot;) and inconsistent with the 
            default ordering np.meshgrid(..., indexing=&quot;xy&quot;). 
        dtheta : int, optional 
            Order of theta-derivative 
 
            .. versionadded:: 0.14.0 
        dphi : int, optional 
            Order of phi-derivative 
 
            .. versionadded:: 0.14.0 
 
        Examples 
        -------- 
        Suppose that we want to use splines to interpolate a bivariate function on a 
        sphere. The value of the function is known on a grid of longitudes and 
        colatitudes. 
 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; from scipy.interpolate import RectSphereBivariateSpline 
        &gt;&gt;&gt; def f(theta, phi): 
        ...     return np.sin(theta) * np.cos(phi) 
 
        We evaluate the function on the grid. Note that the default indexing=&quot;xy&quot; 
        of meshgrid would result in an unexpected (transposed) result after 
        interpolation. 
 
        &gt;&gt;&gt; thetaarr = np.linspace(0, np.pi, 22)[1:-1] 
        &gt;&gt;&gt; phiarr = np.linspace(0, 2 * np.pi, 21)[:-1] 
        &gt;&gt;&gt; thetagrid, phigrid = np.meshgrid(thetaarr, phiarr, indexing=&quot;ij&quot;) 
        &gt;&gt;&gt; zdata = f(thetagrid, phigrid) 
 
        We next set up the interpolator and use it to evaluate the function 
        at points not on the original grid. 
 
        &gt;&gt;&gt; rsbs = RectSphereBivariateSpline(thetaarr, phiarr, zdata) 
        &gt;&gt;&gt; thetainterp = np.linspace(thetaarr[0], thetaarr[-1], 200) 
        &gt;&gt;&gt; phiinterp = np.linspace(phiarr[0], phiarr[-1], 200) 
        &gt;&gt;&gt; zinterp = rsbs.ev(thetainterp, phiinterp) 
 
        Finally we plot the original data for a diagonal slice through the 
        initial grid, and the spline approximation along the same slice. 
 
        &gt;&gt;&gt; import matplotlib.pyplot as plt 
        &gt;&gt;&gt; fig = plt.figure() 
        &gt;&gt;&gt; ax1 = fig.add_subplot(1, 1, 1) 
        &gt;&gt;&gt; ax1.plot(np.sin(thetaarr) * np.sin(phiarr), np.diag(zdata), &quot;or&quot;) 
        &gt;&gt;&gt; ax1.plot(np.sin(thetainterp) * np.sin(phiinterp), zinterp, &quot;-b&quot;) 
        &gt;&gt;&gt; plt.show() 
        &quot;&quot;&quot;</span>
        <span class="s5">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">dtheta</span><span class="s3">=</span><span class="s1">dtheta</span><span class="s3">, </span><span class="s1">dphi</span><span class="s3">=</span><span class="s1">dphi</span><span class="s3">, </span><span class="s1">grid</span><span class="s3">=</span><span class="s5">False</span><span class="s3">)</span>


<span class="s5">class </span><span class="s1">SmoothSphereBivariateSpline</span><span class="s3">(</span><span class="s1">SphereBivariateSpline</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Smooth bivariate spline approximation in spherical coordinates. 
 
    .. versionadded:: 0.11.0 
 
    Parameters 
    ---------- 
    theta, phi, r : array_like 
        1-D sequences of data points (order is not important). Coordinates 
        must be given in radians. Theta must lie within the interval 
        ``[0, pi]``, and phi must lie within the interval ``[0, 2pi]``. 
    w : array_like, optional 
        Positive 1-D sequence of weights. 
    s : float, optional 
        Positive smoothing factor defined for estimation condition: 
        ``sum((w(i)*(r(i) - s(theta(i), phi(i))))**2, axis=0) &lt;= s`` 
        Default ``s=len(w)`` which should be a good value if ``1/w[i]`` is an 
        estimate of the standard deviation of ``r[i]``. 
    eps : float, optional 
        A threshold for determining the effective rank of an over-determined 
        linear system of equations. `eps` should have a value within the open 
        interval ``(0, 1)``, the default is 1e-16. 
 
    See Also 
    -------- 
    BivariateSpline : 
        a base class for bivariate splines. 
    UnivariateSpline : 
        a smooth univariate spline to fit a given set of data points. 
    SmoothBivariateSpline : 
        a smoothing bivariate spline through the given points 
    LSQBivariateSpline : 
        a bivariate spline using weighted least-squares fitting 
    RectSphereBivariateSpline : 
        a bivariate spline over a rectangular mesh on a sphere 
    LSQSphereBivariateSpline : 
        a bivariate spline in spherical coordinates using weighted 
        least-squares fitting 
    RectBivariateSpline : 
        a bivariate spline over a rectangular mesh. 
    bisplrep : 
        a function to find a bivariate B-spline representation of a surface 
    bisplev : 
        a function to evaluate a bivariate B-spline and its derivatives 
 
    Notes 
    ----- 
    For more information, see the FITPACK_ site about this function. 
 
    .. _FITPACK: http://www.netlib.org/dierckx/sphere.f 
 
    Examples 
    -------- 
    Suppose we have global data on a coarse grid (the input data does not 
    have to be on a grid): 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; theta = np.linspace(0., np.pi, 7) 
    &gt;&gt;&gt; phi = np.linspace(0., 2*np.pi, 9) 
    &gt;&gt;&gt; data = np.empty((theta.shape[0], phi.shape[0])) 
    &gt;&gt;&gt; data[:,0], data[0,:], data[-1,:] = 0., 0., 0. 
    &gt;&gt;&gt; data[1:-1,1], data[1:-1,-1] = 1., 1. 
    &gt;&gt;&gt; data[1,1:-1], data[-2,1:-1] = 1., 1. 
    &gt;&gt;&gt; data[2:-2,2], data[2:-2,-2] = 2., 2. 
    &gt;&gt;&gt; data[2,2:-2], data[-3,2:-2] = 2., 2. 
    &gt;&gt;&gt; data[3,3:-2] = 3. 
    &gt;&gt;&gt; data = np.roll(data, 4, 1) 
 
    We need to set up the interpolator object 
 
    &gt;&gt;&gt; lats, lons = np.meshgrid(theta, phi) 
    &gt;&gt;&gt; from scipy.interpolate import SmoothSphereBivariateSpline 
    &gt;&gt;&gt; lut = SmoothSphereBivariateSpline(lats.ravel(), lons.ravel(), 
    ...                                   data.T.ravel(), s=3.5) 
 
    As a first test, we'll see what the algorithm returns when run on the 
    input coordinates 
 
    &gt;&gt;&gt; data_orig = lut(theta, phi) 
 
    Finally we interpolate the data to a finer grid 
 
    &gt;&gt;&gt; fine_lats = np.linspace(0., np.pi, 70) 
    &gt;&gt;&gt; fine_lons = np.linspace(0., 2 * np.pi, 90) 
 
    &gt;&gt;&gt; data_smth = lut(fine_lats, fine_lons) 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; ax1 = fig.add_subplot(131) 
    &gt;&gt;&gt; ax1.imshow(data, interpolation='nearest') 
    &gt;&gt;&gt; ax2 = fig.add_subplot(132) 
    &gt;&gt;&gt; ax2.imshow(data_orig, interpolation='nearest') 
    &gt;&gt;&gt; ax3 = fig.add_subplot(133) 
    &gt;&gt;&gt; ax3.imshow(data_smth, interpolation='nearest') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>

    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">w</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">s</span><span class="s3">=</span><span class="s6">0.</span><span class="s3">, </span><span class="s1">eps</span><span class="s3">=</span><span class="s6">1E-16</span><span class="s3">):</span>

        <span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">r </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">theta</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">phi</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

        <span class="s2"># input validation</span>
        <span class="s5">if not </span><span class="s3">((</span><span class="s6">0.0 </span><span class="s3">&lt;= </span><span class="s1">theta</span><span class="s3">).</span><span class="s1">all</span><span class="s3">() </span><span class="s5">and </span><span class="s3">(</span><span class="s1">theta </span><span class="s3">&lt;= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">).</span><span class="s1">all</span><span class="s3">()):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'theta should be between [0, pi]'</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s3">((</span><span class="s6">0.0 </span><span class="s3">&lt;= </span><span class="s1">phi</span><span class="s3">).</span><span class="s1">all</span><span class="s3">() </span><span class="s5">and </span><span class="s3">(</span><span class="s1">phi </span><span class="s3">&lt;= </span><span class="s6">2.0 </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">).</span><span class="s1">all</span><span class="s3">()):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'phi should be between [0, 2pi]'</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">w </span><span class="s5">is not None</span><span class="s3">:</span>
            <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">w</span><span class="s3">)</span>
            <span class="s5">if not </span><span class="s3">(</span><span class="s1">w </span><span class="s3">&gt;= </span><span class="s6">0.0</span><span class="s3">).</span><span class="s1">all</span><span class="s3">():</span>
                <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'w should be positive'</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">s </span><span class="s3">&gt;= </span><span class="s6">0.0</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'s should be positive'</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s6">0.0 </span><span class="s3">&lt; </span><span class="s1">eps </span><span class="s3">&lt; </span><span class="s6">1.0</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'eps should be between (0, 1)'</span><span class="s3">)</span>

        <span class="s1">nt_</span><span class="s3">, </span><span class="s1">tt_</span><span class="s3">, </span><span class="s1">np_</span><span class="s3">, </span><span class="s1">tp_</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">ier </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">spherfit_smth</span><span class="s3">(</span><span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">,</span>
                                                                <span class="s1">r</span><span class="s3">, </span><span class="s1">w</span><span class="s3">=</span><span class="s1">w</span><span class="s3">, </span><span class="s1">s</span><span class="s3">=</span><span class="s1">s</span><span class="s3">,</span>
                                                                <span class="s1">eps</span><span class="s3">=</span><span class="s1">eps</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">ier </span><span class="s5">not in </span><span class="s3">[</span><span class="s6">0</span><span class="s3">, -</span><span class="s6">1</span><span class="s3">, -</span><span class="s6">2</span><span class="s3">]:</span>
            <span class="s1">message </span><span class="s3">= </span><span class="s1">_spherefit_messages</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">ier</span><span class="s3">, </span><span class="s4">'ier=%s' </span><span class="s3">% (</span><span class="s1">ier</span><span class="s3">))</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">message</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">fp </span><span class="s3">= </span><span class="s1">fp</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">tck </span><span class="s3">= </span><span class="s1">tt_</span><span class="s3">[:</span><span class="s1">nt_</span><span class="s3">], </span><span class="s1">tp_</span><span class="s3">[:</span><span class="s1">np_</span><span class="s3">], </span><span class="s1">c</span><span class="s3">[:(</span><span class="s1">nt_ </span><span class="s3">- </span><span class="s6">4</span><span class="s3">) * (</span><span class="s1">np_ </span><span class="s3">- </span><span class="s6">4</span><span class="s3">)]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">degrees </span><span class="s3">= (</span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">dtheta</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">dphi</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">grid</span><span class="s3">=</span><span class="s5">True</span><span class="s3">):</span>

        <span class="s1">theta </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">theta</span><span class="s3">)</span>
        <span class="s1">phi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">phi</span><span class="s3">)</span>

        <span class="s5">if </span><span class="s1">phi</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s5">and </span><span class="s3">(</span><span class="s1">phi</span><span class="s3">.</span><span class="s1">min</span><span class="s3">() &lt; </span><span class="s6">0. </span><span class="s5">or </span><span class="s1">phi</span><span class="s3">.</span><span class="s1">max</span><span class="s3">() &gt; </span><span class="s6">2. </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;requested phi out of bounds.&quot;</span><span class="s3">)</span>

        <span class="s5">return </span><span class="s1">SphereBivariateSpline</span><span class="s3">.</span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">dtheta</span><span class="s3">=</span><span class="s1">dtheta</span><span class="s3">,</span>
                                              <span class="s1">dphi</span><span class="s3">=</span><span class="s1">dphi</span><span class="s3">, </span><span class="s1">grid</span><span class="s3">=</span><span class="s1">grid</span><span class="s3">)</span>


<span class="s5">class </span><span class="s1">LSQSphereBivariateSpline</span><span class="s3">(</span><span class="s1">SphereBivariateSpline</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Weighted least-squares bivariate spline approximation in spherical 
    coordinates. 
 
    Determines a smoothing bicubic spline according to a given 
    set of knots in the `theta` and `phi` directions. 
 
    .. versionadded:: 0.11.0 
 
    Parameters 
    ---------- 
    theta, phi, r : array_like 
        1-D sequences of data points (order is not important). Coordinates 
        must be given in radians. Theta must lie within the interval 
        ``[0, pi]``, and phi must lie within the interval ``[0, 2pi]``. 
    tt, tp : array_like 
        Strictly ordered 1-D sequences of knots coordinates. 
        Coordinates must satisfy ``0 &lt; tt[i] &lt; pi``, ``0 &lt; tp[i] &lt; 2*pi``. 
    w : array_like, optional 
        Positive 1-D sequence of weights, of the same length as `theta`, `phi` 
        and `r`. 
    eps : float, optional 
        A threshold for determining the effective rank of an over-determined 
        linear system of equations. `eps` should have a value within the 
        open interval ``(0, 1)``, the default is 1e-16. 
 
    See Also 
    -------- 
    BivariateSpline : 
        a base class for bivariate splines. 
    UnivariateSpline : 
        a smooth univariate spline to fit a given set of data points. 
    SmoothBivariateSpline : 
        a smoothing bivariate spline through the given points 
    LSQBivariateSpline : 
        a bivariate spline using weighted least-squares fitting 
    RectSphereBivariateSpline : 
        a bivariate spline over a rectangular mesh on a sphere 
    SmoothSphereBivariateSpline : 
        a smoothing bivariate spline in spherical coordinates 
    RectBivariateSpline : 
        a bivariate spline over a rectangular mesh. 
    bisplrep : 
        a function to find a bivariate B-spline representation of a surface 
    bisplev : 
        a function to evaluate a bivariate B-spline and its derivatives 
 
    Notes 
    ----- 
    For more information, see the FITPACK_ site about this function. 
 
    .. _FITPACK: http://www.netlib.org/dierckx/sphere.f 
 
    Examples 
    -------- 
    Suppose we have global data on a coarse grid (the input data does not 
    have to be on a grid): 
 
    &gt;&gt;&gt; from scipy.interpolate import LSQSphereBivariateSpline 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; theta = np.linspace(0, np.pi, num=7) 
    &gt;&gt;&gt; phi = np.linspace(0, 2*np.pi, num=9) 
    &gt;&gt;&gt; data = np.empty((theta.shape[0], phi.shape[0])) 
    &gt;&gt;&gt; data[:,0], data[0,:], data[-1,:] = 0., 0., 0. 
    &gt;&gt;&gt; data[1:-1,1], data[1:-1,-1] = 1., 1. 
    &gt;&gt;&gt; data[1,1:-1], data[-2,1:-1] = 1., 1. 
    &gt;&gt;&gt; data[2:-2,2], data[2:-2,-2] = 2., 2. 
    &gt;&gt;&gt; data[2,2:-2], data[-3,2:-2] = 2., 2. 
    &gt;&gt;&gt; data[3,3:-2] = 3. 
    &gt;&gt;&gt; data = np.roll(data, 4, 1) 
 
    We need to set up the interpolator object. Here, we must also specify the 
    coordinates of the knots to use. 
 
    &gt;&gt;&gt; lats, lons = np.meshgrid(theta, phi) 
    &gt;&gt;&gt; knotst, knotsp = theta.copy(), phi.copy() 
    &gt;&gt;&gt; knotst[0] += .0001 
    &gt;&gt;&gt; knotst[-1] -= .0001 
    &gt;&gt;&gt; knotsp[0] += .0001 
    &gt;&gt;&gt; knotsp[-1] -= .0001 
    &gt;&gt;&gt; lut = LSQSphereBivariateSpline(lats.ravel(), lons.ravel(), 
    ...                                data.T.ravel(), knotst, knotsp) 
 
    As a first test, we'll see what the algorithm returns when run on the 
    input coordinates 
 
    &gt;&gt;&gt; data_orig = lut(theta, phi) 
 
    Finally we interpolate the data to a finer grid 
 
    &gt;&gt;&gt; fine_lats = np.linspace(0., np.pi, 70) 
    &gt;&gt;&gt; fine_lons = np.linspace(0., 2*np.pi, 90) 
    &gt;&gt;&gt; data_lsq = lut(fine_lats, fine_lons) 
 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; ax1 = fig.add_subplot(131) 
    &gt;&gt;&gt; ax1.imshow(data, interpolation='nearest') 
    &gt;&gt;&gt; ax2 = fig.add_subplot(132) 
    &gt;&gt;&gt; ax2.imshow(data_orig, interpolation='nearest') 
    &gt;&gt;&gt; ax3 = fig.add_subplot(133) 
    &gt;&gt;&gt; ax3.imshow(data_lsq, interpolation='nearest') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>

    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">tt</span><span class="s3">, </span><span class="s1">tp</span><span class="s3">, </span><span class="s1">w</span><span class="s3">=</span><span class="s5">None</span><span class="s3">, </span><span class="s1">eps</span><span class="s3">=</span><span class="s6">1E-16</span><span class="s3">):</span>

        <span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">r </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">theta</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">phi</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>
        <span class="s1">tt</span><span class="s3">, </span><span class="s1">tp </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">tt</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>

        <span class="s5">if not </span><span class="s3">((</span><span class="s6">0.0 </span><span class="s3">&lt;= </span><span class="s1">theta</span><span class="s3">).</span><span class="s1">all</span><span class="s3">() </span><span class="s5">and </span><span class="s3">(</span><span class="s1">theta </span><span class="s3">&lt;= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">).</span><span class="s1">all</span><span class="s3">()):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'theta should be between [0, pi]'</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s3">((</span><span class="s6">0.0 </span><span class="s3">&lt;= </span><span class="s1">phi</span><span class="s3">).</span><span class="s1">all</span><span class="s3">() </span><span class="s5">and </span><span class="s3">(</span><span class="s1">phi </span><span class="s3">&lt;= </span><span class="s6">2</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">).</span><span class="s1">all</span><span class="s3">()):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'phi should be between [0, 2pi]'</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s3">((</span><span class="s6">0.0 </span><span class="s3">&lt; </span><span class="s1">tt</span><span class="s3">).</span><span class="s1">all</span><span class="s3">() </span><span class="s5">and </span><span class="s3">(</span><span class="s1">tt </span><span class="s3">&lt; </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">).</span><span class="s1">all</span><span class="s3">()):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'tt should be between (0, pi)'</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s3">((</span><span class="s6">0.0 </span><span class="s3">&lt; </span><span class="s1">tp</span><span class="s3">).</span><span class="s1">all</span><span class="s3">() </span><span class="s5">and </span><span class="s3">(</span><span class="s1">tp </span><span class="s3">&lt; </span><span class="s6">2</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">).</span><span class="s1">all</span><span class="s3">()):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'tp should be between (0, 2pi)'</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">w </span><span class="s5">is not None</span><span class="s3">:</span>
            <span class="s1">w </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">w</span><span class="s3">)</span>
            <span class="s5">if not </span><span class="s3">(</span><span class="s1">w </span><span class="s3">&gt;= </span><span class="s6">0.0</span><span class="s3">).</span><span class="s1">all</span><span class="s3">():</span>
                <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'w should be positive'</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s6">0.0 </span><span class="s3">&lt; </span><span class="s1">eps </span><span class="s3">&lt; </span><span class="s6">1.0</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'eps should be between (0, 1)'</span><span class="s3">)</span>

        <span class="s1">nt_</span><span class="s3">, </span><span class="s1">np_ </span><span class="s3">= </span><span class="s6">8 </span><span class="s3">+ </span><span class="s1">len</span><span class="s3">(</span><span class="s1">tt</span><span class="s3">), </span><span class="s6">8 </span><span class="s3">+ </span><span class="s1">len</span><span class="s3">(</span><span class="s1">tp</span><span class="s3">)</span>
        <span class="s1">tt_</span><span class="s3">, </span><span class="s1">tp_ </span><span class="s3">= </span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">nt_</span><span class="s3">,), </span><span class="s1">float</span><span class="s3">), </span><span class="s1">zeros</span><span class="s3">((</span><span class="s1">np_</span><span class="s3">,), </span><span class="s1">float</span><span class="s3">)</span>
        <span class="s1">tt_</span><span class="s3">[</span><span class="s6">4</span><span class="s3">:-</span><span class="s6">4</span><span class="s3">], </span><span class="s1">tp_</span><span class="s3">[</span><span class="s6">4</span><span class="s3">:-</span><span class="s6">4</span><span class="s3">] = </span><span class="s1">tt</span><span class="s3">, </span><span class="s1">tp</span>
        <span class="s1">tt_</span><span class="s3">[-</span><span class="s6">4</span><span class="s3">:], </span><span class="s1">tp_</span><span class="s3">[-</span><span class="s6">4</span><span class="s3">:] = </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">, </span><span class="s6">2. </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span>
        <span class="s1">tt_</span><span class="s3">, </span><span class="s1">tp_</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">ier </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">spherfit_lsq</span><span class="s3">(</span><span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">tt_</span><span class="s3">, </span><span class="s1">tp_</span><span class="s3">,</span>
                                                     <span class="s1">w</span><span class="s3">=</span><span class="s1">w</span><span class="s3">, </span><span class="s1">eps</span><span class="s3">=</span><span class="s1">eps</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">ier </span><span class="s3">&gt; </span><span class="s6">0</span><span class="s3">:</span>
            <span class="s1">message </span><span class="s3">= </span><span class="s1">_spherefit_messages</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">ier</span><span class="s3">, </span><span class="s4">'ier=%s' </span><span class="s3">% (</span><span class="s1">ier</span><span class="s3">))</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">message</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">fp </span><span class="s3">= </span><span class="s1">fp</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">tck </span><span class="s3">= </span><span class="s1">tt_</span><span class="s3">, </span><span class="s1">tp_</span><span class="s3">, </span><span class="s1">c</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">degrees </span><span class="s3">= (</span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">)</span>

    <span class="s5">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">dtheta</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">dphi</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">grid</span><span class="s3">=</span><span class="s5">True</span><span class="s3">):</span>

        <span class="s1">theta </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">theta</span><span class="s3">)</span>
        <span class="s1">phi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">phi</span><span class="s3">)</span>

        <span class="s5">if </span><span class="s1">phi</span><span class="s3">.</span><span class="s1">size </span><span class="s3">&gt; </span><span class="s6">0 </span><span class="s5">and </span><span class="s3">(</span><span class="s1">phi</span><span class="s3">.</span><span class="s1">min</span><span class="s3">() &lt; </span><span class="s6">0. </span><span class="s5">or </span><span class="s1">phi</span><span class="s3">.</span><span class="s1">max</span><span class="s3">() &gt; </span><span class="s6">2. </span><span class="s3">* </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">&quot;requested phi out of bounds.&quot;</span><span class="s3">)</span>

        <span class="s5">return </span><span class="s1">SphereBivariateSpline</span><span class="s3">.</span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">dtheta</span><span class="s3">=</span><span class="s1">dtheta</span><span class="s3">,</span>
                                              <span class="s1">dphi</span><span class="s3">=</span><span class="s1">dphi</span><span class="s3">, </span><span class="s1">grid</span><span class="s3">=</span><span class="s1">grid</span><span class="s3">)</span>


<span class="s1">_spfit_messages </span><span class="s3">= </span><span class="s1">_surfit_messages</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
<span class="s1">_spfit_messages</span><span class="s3">[</span><span class="s6">10</span><span class="s3">] = </span><span class="s4">&quot;&quot;&quot; 
ERROR: on entry, the input data are controlled on validity 
       the following restrictions must be satisfied. 
          -1&lt;=iopt(1)&lt;=1, 0&lt;=iopt(2)&lt;=1, 0&lt;=iopt(3)&lt;=1, 
          -1&lt;=ider(1)&lt;=1, 0&lt;=ider(2)&lt;=1, ider(2)=0 if iopt(2)=0. 
          -1&lt;=ider(3)&lt;=1, 0&lt;=ider(4)&lt;=1, ider(4)=0 if iopt(3)=0. 
          mu &gt;= mumin (see above), mv &gt;= 4, nuest &gt;=8, nvest &gt;= 8, 
          kwrk&gt;=5+mu+mv+nuest+nvest, 
          lwrk &gt;= 12+nuest*(mv+nvest+3)+nvest*24+4*mu+8*mv+max(nuest,mv+nvest) 
          0&lt; u(i-1)&lt;u(i)&lt; pi,i=2,..,mu, 
          -pi&lt;=v(1)&lt; pi, v(1)&lt;v(i-1)&lt;v(i)&lt;v(1)+2*pi, i=3,...,mv 
          if iopt(1)=-1: 8&lt;=nu&lt;=min(nuest,mu+6+iopt(2)+iopt(3)) 
                         0&lt;tu(5)&lt;tu(6)&lt;...&lt;tu(nu-4)&lt; pi 
                         8&lt;=nv&lt;=min(nvest,mv+7) 
                         v(1)&lt;tv(5)&lt;tv(6)&lt;...&lt;tv(nv-4)&lt;v(1)+2*pi 
                         the schoenberg-whitney conditions, i.e. there must be 
                         subset of grid coordinates uu(p) and vv(q) such that 
                            tu(p) &lt; uu(p) &lt; tu(p+4) ,p=1,...,nu-4 
                            (iopt(2)=1 and iopt(3)=1 also count for a uu-value 
                            tv(q) &lt; vv(q) &lt; tv(q+4) ,q=1,...,nv-4 
                            (vv(q) is either a value v(j) or v(j)+2*pi) 
          if iopt(1)&gt;=0: s&gt;=0 
          if s=0: nuest&gt;=mu+6+iopt(2)+iopt(3), nvest&gt;=mv+7 
       if one of these conditions is found to be violated,control is 
       immediately repassed to the calling program. in that case there is no 
       approximation returned.&quot;&quot;&quot;</span>


<span class="s5">class </span><span class="s1">RectSphereBivariateSpline</span><span class="s3">(</span><span class="s1">SphereBivariateSpline</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Bivariate spline approximation over a rectangular mesh on a sphere. 
 
    Can be used for smoothing data. 
 
    .. versionadded:: 0.11.0 
 
    Parameters 
    ---------- 
    u : array_like 
        1-D array of colatitude coordinates in strictly ascending order. 
        Coordinates must be given in radians and lie within the open interval 
        ``(0, pi)``. 
    v : array_like 
        1-D array of longitude coordinates in strictly ascending order. 
        Coordinates must be given in radians. First element (``v[0]``) must lie 
        within the interval ``[-pi, pi)``. Last element (``v[-1]``) must satisfy 
        ``v[-1] &lt;= v[0] + 2*pi``. 
    r : array_like 
        2-D array of data with shape ``(u.size, v.size)``. 
    s : float, optional 
        Positive smoothing factor defined for estimation condition 
        (``s=0`` is for interpolation). 
    pole_continuity : bool or (bool, bool), optional 
        Order of continuity at the poles ``u=0`` (``pole_continuity[0]``) and 
        ``u=pi`` (``pole_continuity[1]``).  The order of continuity at the pole 
        will be 1 or 0 when this is True or False, respectively. 
        Defaults to False. 
    pole_values : float or (float, float), optional 
        Data values at the poles ``u=0`` and ``u=pi``.  Either the whole 
        parameter or each individual element can be None.  Defaults to None. 
    pole_exact : bool or (bool, bool), optional 
        Data value exactness at the poles ``u=0`` and ``u=pi``.  If True, the 
        value is considered to be the right function value, and it will be 
        fitted exactly. If False, the value will be considered to be a data 
        value just like the other data values.  Defaults to False. 
    pole_flat : bool or (bool, bool), optional 
        For the poles at ``u=0`` and ``u=pi``, specify whether or not the 
        approximation has vanishing derivatives.  Defaults to False. 
 
    See Also 
    -------- 
    BivariateSpline : 
        a base class for bivariate splines. 
    UnivariateSpline : 
        a smooth univariate spline to fit a given set of data points. 
    SmoothBivariateSpline : 
        a smoothing bivariate spline through the given points 
    LSQBivariateSpline : 
        a bivariate spline using weighted least-squares fitting 
    SmoothSphereBivariateSpline : 
        a smoothing bivariate spline in spherical coordinates 
    LSQSphereBivariateSpline : 
        a bivariate spline in spherical coordinates using weighted 
        least-squares fitting 
    RectBivariateSpline : 
        a bivariate spline over a rectangular mesh. 
    bisplrep : 
        a function to find a bivariate B-spline representation of a surface 
    bisplev : 
        a function to evaluate a bivariate B-spline and its derivatives 
 
    Notes 
    ----- 
    Currently, only the smoothing spline approximation (``iopt[0] = 0`` and 
    ``iopt[0] = 1`` in the FITPACK routine) is supported.  The exact 
    least-squares spline approximation is not implemented yet. 
 
    When actually performing the interpolation, the requested `v` values must 
    lie within the same length 2pi interval that the original `v` values were 
    chosen from. 
 
    For more information, see the FITPACK_ site about this function. 
 
    .. _FITPACK: http://www.netlib.org/dierckx/spgrid.f 
 
    Examples 
    -------- 
    Suppose we have global data on a coarse grid 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; lats = np.linspace(10, 170, 9) * np.pi / 180. 
    &gt;&gt;&gt; lons = np.linspace(0, 350, 18) * np.pi / 180. 
    &gt;&gt;&gt; data = np.dot(np.atleast_2d(90. - np.linspace(-80., 80., 18)).T, 
    ...               np.atleast_2d(180. - np.abs(np.linspace(0., 350., 9)))).T 
 
    We want to interpolate it to a global one-degree grid 
 
    &gt;&gt;&gt; new_lats = np.linspace(1, 180, 180) * np.pi / 180 
    &gt;&gt;&gt; new_lons = np.linspace(1, 360, 360) * np.pi / 180 
    &gt;&gt;&gt; new_lats, new_lons = np.meshgrid(new_lats, new_lons) 
 
    We need to set up the interpolator object 
 
    &gt;&gt;&gt; from scipy.interpolate import RectSphereBivariateSpline 
    &gt;&gt;&gt; lut = RectSphereBivariateSpline(lats, lons, data) 
 
    Finally we interpolate the data.  The `RectSphereBivariateSpline` object 
    only takes 1-D arrays as input, therefore we need to do some reshaping. 
 
    &gt;&gt;&gt; data_interp = lut.ev(new_lats.ravel(), 
    ...                      new_lons.ravel()).reshape((360, 180)).T 
 
    Looking at the original and the interpolated data, one can see that the 
    interpolant reproduces the original data very well: 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; ax1 = fig.add_subplot(211) 
    &gt;&gt;&gt; ax1.imshow(data, interpolation='nearest') 
    &gt;&gt;&gt; ax2 = fig.add_subplot(212) 
    &gt;&gt;&gt; ax2.imshow(data_interp, interpolation='nearest') 
    &gt;&gt;&gt; plt.show() 
 
    Choosing the optimal value of ``s`` can be a delicate task. Recommended 
    values for ``s`` depend on the accuracy of the data values.  If the user 
    has an idea of the statistical errors on the data, she can also find a 
    proper estimate for ``s``. By assuming that, if she specifies the 
    right ``s``, the interpolator will use a spline ``f(u,v)`` which exactly 
    reproduces the function underlying the data, she can evaluate 
    ``sum((r(i,j)-s(u(i),v(j)))**2)`` to find a good estimate for this ``s``. 
    For example, if she knows that the statistical errors on her 
    ``r(i,j)``-values are not greater than 0.1, she may expect that a good 
    ``s`` should have a value not larger than ``u.size * v.size * (0.1)**2``. 
 
    If nothing is known about the statistical error in ``r(i,j)``, ``s`` must 
    be determined by trial and error.  The best is then to start with a very 
    large value of ``s`` (to determine the least-squares polynomial and the 
    corresponding upper bound ``fp0`` for ``s``) and then to progressively 
    decrease the value of ``s`` (say by a factor 10 in the beginning, i.e. 
    ``s = fp0 / 10, fp0 / 100, ...``  and more carefully as the approximation 
    shows more detail) to obtain closer fits. 
 
    The interpolation results for different values of ``s`` give some insight 
    into this process: 
 
    &gt;&gt;&gt; fig2 = plt.figure() 
    &gt;&gt;&gt; s = [3e9, 2e9, 1e9, 1e8] 
    &gt;&gt;&gt; for idx, sval in enumerate(s, 1): 
    ...     lut = RectSphereBivariateSpline(lats, lons, data, s=sval) 
    ...     data_interp = lut.ev(new_lats.ravel(), 
    ...                          new_lons.ravel()).reshape((360, 180)).T 
    ...     ax = fig2.add_subplot(2, 2, idx) 
    ...     ax.imshow(data_interp, interpolation='nearest') 
    ...     ax.set_title(f&quot;s = {sval:g}&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>

    <span class="s5">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">u</span><span class="s3">, </span><span class="s1">v</span><span class="s3">, </span><span class="s1">r</span><span class="s3">, </span><span class="s1">s</span><span class="s3">=</span><span class="s6">0.</span><span class="s3">, </span><span class="s1">pole_continuity</span><span class="s3">=</span><span class="s5">False</span><span class="s3">, </span><span class="s1">pole_values</span><span class="s3">=</span><span class="s5">None</span><span class="s3">,</span>
                 <span class="s1">pole_exact</span><span class="s3">=</span><span class="s5">False</span><span class="s3">, </span><span class="s1">pole_flat</span><span class="s3">=</span><span class="s5">False</span><span class="s3">):</span>
        <span class="s1">iopt </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([</span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, </span><span class="s6">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dfitpack_int</span><span class="s3">)</span>
        <span class="s1">ider </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">([-</span><span class="s6">1</span><span class="s3">, </span><span class="s6">0</span><span class="s3">, -</span><span class="s6">1</span><span class="s3">, </span><span class="s6">0</span><span class="s3">], </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dfitpack_int</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">pole_values </span><span class="s5">is None</span><span class="s3">:</span>
            <span class="s1">pole_values </span><span class="s3">= (</span><span class="s5">None</span><span class="s3">, </span><span class="s5">None</span><span class="s3">)</span>
        <span class="s5">elif </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">pole_values</span><span class="s3">, (</span><span class="s1">float</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">, </span><span class="s1">np</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">)):</span>
            <span class="s1">pole_values </span><span class="s3">= (</span><span class="s1">pole_values</span><span class="s3">, </span><span class="s1">pole_values</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">pole_continuity</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">):</span>
            <span class="s1">pole_continuity </span><span class="s3">= (</span><span class="s1">pole_continuity</span><span class="s3">, </span><span class="s1">pole_continuity</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">pole_exact</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">):</span>
            <span class="s1">pole_exact </span><span class="s3">= (</span><span class="s1">pole_exact</span><span class="s3">, </span><span class="s1">pole_exact</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">pole_flat</span><span class="s3">, </span><span class="s1">bool</span><span class="s3">):</span>
            <span class="s1">pole_flat </span><span class="s3">= (</span><span class="s1">pole_flat</span><span class="s3">, </span><span class="s1">pole_flat</span><span class="s3">)</span>

        <span class="s1">r0</span><span class="s3">, </span><span class="s1">r1 </span><span class="s3">= </span><span class="s1">pole_values</span>
        <span class="s1">iopt</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:] = </span><span class="s1">pole_continuity</span>
        <span class="s5">if </span><span class="s1">r0 </span><span class="s5">is None</span><span class="s3">:</span>
            <span class="s1">ider</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = -</span><span class="s6">1</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">ider</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] = </span><span class="s1">pole_exact</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>

        <span class="s5">if </span><span class="s1">r1 </span><span class="s5">is None</span><span class="s3">:</span>
            <span class="s1">ider</span><span class="s3">[</span><span class="s6">2</span><span class="s3">] = -</span><span class="s6">1</span>
        <span class="s5">else</span><span class="s3">:</span>
            <span class="s1">ider</span><span class="s3">[</span><span class="s6">2</span><span class="s3">] = </span><span class="s1">pole_exact</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]</span>

        <span class="s1">ider</span><span class="s3">[</span><span class="s6">1</span><span class="s3">], </span><span class="s1">ider</span><span class="s3">[</span><span class="s6">3</span><span class="s3">] = </span><span class="s1">pole_flat</span>

        <span class="s1">u</span><span class="s3">, </span><span class="s1">v </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">u</span><span class="s3">), </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">v</span><span class="s3">)</span>
        <span class="s1">r </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>

        <span class="s5">if not </span><span class="s3">(</span><span class="s6">0.0 </span><span class="s3">&lt; </span><span class="s1">u</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s5">and </span><span class="s1">u</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">] &lt; </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'u should be between (0, pi)'</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s3">-</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi </span><span class="s3">&lt;= </span><span class="s1">v</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] &lt; </span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'v[0] should be between [-pi, pi)'</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">v</span><span class="s3">[-</span><span class="s6">1</span><span class="s3">] &lt;= </span><span class="s1">v</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] + </span><span class="s6">2</span><span class="s3">*</span><span class="s1">np</span><span class="s3">.</span><span class="s1">pi</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'v[-1] should be v[0] + 2pi or less '</span><span class="s3">)</span>

        <span class="s5">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">u</span><span class="s3">) &gt; </span><span class="s6">0.0</span><span class="s3">):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'u must be strictly increasing'</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">np</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">np</span><span class="s3">.</span><span class="s1">diff</span><span class="s3">(</span><span class="s1">v</span><span class="s3">) &gt; </span><span class="s6">0.0</span><span class="s3">):</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'v must be strictly increasing'</span><span class="s3">)</span>

        <span class="s5">if not </span><span class="s1">u</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s1">r</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'u dimension of r must have same number of '</span>
                             <span class="s4">'elements as u'</span><span class="s3">)</span>
        <span class="s5">if not </span><span class="s1">v</span><span class="s3">.</span><span class="s1">size </span><span class="s3">== </span><span class="s1">r</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">1</span><span class="s3">]:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'v dimension of r must have same number of '</span>
                             <span class="s4">'elements as v'</span><span class="s3">)</span>

        <span class="s5">if </span><span class="s1">pole_continuity</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] </span><span class="s5">is False and </span><span class="s1">pole_flat</span><span class="s3">[</span><span class="s6">1</span><span class="s3">] </span><span class="s5">is True</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'if pole_continuity is False, so must be '</span>
                             <span class="s4">'pole_flat'</span><span class="s3">)</span>
        <span class="s5">if </span><span class="s1">pole_continuity</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s5">is False and </span><span class="s1">pole_flat</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] </span><span class="s5">is True</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'if pole_continuity is False, so must be '</span>
                             <span class="s4">'pole_flat'</span><span class="s3">)</span>

        <span class="s5">if not </span><span class="s1">s </span><span class="s3">&gt;= </span><span class="s6">0.0</span><span class="s3">:</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">'s should be positive'</span><span class="s3">)</span>

        <span class="s1">r </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">r</span><span class="s3">)</span>
        <span class="s1">nu</span><span class="s3">, </span><span class="s1">tu</span><span class="s3">, </span><span class="s1">nv</span><span class="s3">, </span><span class="s1">tv</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">fp</span><span class="s3">, </span><span class="s1">ier </span><span class="s3">= </span><span class="s1">dfitpack</span><span class="s3">.</span><span class="s1">regrid_smth_spher</span><span class="s3">(</span><span class="s1">iopt</span><span class="s3">, </span><span class="s1">ider</span><span class="s3">,</span>
                                                                <span class="s1">u</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(),</span>
                                                                <span class="s1">v</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(),</span>
                                                                <span class="s1">r</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(),</span>
                                                                <span class="s1">r0</span><span class="s3">, </span><span class="s1">r1</span><span class="s3">, </span><span class="s1">s</span><span class="s3">)</span>

        <span class="s5">if </span><span class="s1">ier </span><span class="s5">not in </span><span class="s3">[</span><span class="s6">0</span><span class="s3">, -</span><span class="s6">1</span><span class="s3">, -</span><span class="s6">2</span><span class="s3">]:</span>
            <span class="s1">msg </span><span class="s3">= </span><span class="s1">_spfit_messages</span><span class="s3">.</span><span class="s1">get</span><span class="s3">(</span><span class="s1">ier</span><span class="s3">, </span><span class="s4">'ier=%s' </span><span class="s3">% (</span><span class="s1">ier</span><span class="s3">))</span>
            <span class="s5">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s1">msg</span><span class="s3">)</span>

        <span class="s1">self</span><span class="s3">.</span><span class="s1">fp </span><span class="s3">= </span><span class="s1">fp</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">tck </span><span class="s3">= </span><span class="s1">tu</span><span class="s3">[:</span><span class="s1">nu</span><span class="s3">], </span><span class="s1">tv</span><span class="s3">[:</span><span class="s1">nv</span><span class="s3">], </span><span class="s1">c</span><span class="s3">[:(</span><span class="s1">nu </span><span class="s3">- </span><span class="s6">4</span><span class="s3">) * (</span><span class="s1">nv</span><span class="s3">-</span><span class="s6">4</span><span class="s3">)]</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">degrees </span><span class="s3">= (</span><span class="s6">3</span><span class="s3">, </span><span class="s6">3</span><span class="s3">)</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">v0 </span><span class="s3">= </span><span class="s1">v</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]</span>

    <span class="s5">def </span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">dtheta</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">dphi</span><span class="s3">=</span><span class="s6">0</span><span class="s3">, </span><span class="s1">grid</span><span class="s3">=</span><span class="s5">True</span><span class="s3">):</span>

        <span class="s1">theta </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">theta</span><span class="s3">)</span>
        <span class="s1">phi </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">phi</span><span class="s3">)</span>

        <span class="s5">return </span><span class="s1">SphereBivariateSpline</span><span class="s3">.</span><span class="s1">__call__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">theta</span><span class="s3">, </span><span class="s1">phi</span><span class="s3">, </span><span class="s1">dtheta</span><span class="s3">=</span><span class="s1">dtheta</span><span class="s3">,</span>
                                              <span class="s1">dphi</span><span class="s3">=</span><span class="s1">dphi</span><span class="s3">, </span><span class="s1">grid</span><span class="s3">=</span><span class="s1">grid</span><span class="s3">)</span>
</pre>
</body>
</html>