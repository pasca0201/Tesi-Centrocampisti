<html>
<head>
<title>sqltypes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sqltypes.py</font>
</center></td></tr></table>
<pre><span class="s0"># sql/sqltypes.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>
<span class="s0"># mypy: allow-untyped-defs, allow-untyped-calls</span>

<span class="s2">&quot;&quot;&quot;SQL specific types. 
 
&quot;&quot;&quot;</span>
<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">import </span><span class="s1">collections</span><span class="s4">.</span><span class="s1">abc </span><span class="s3">as </span><span class="s1">collections_abc</span>
<span class="s3">import </span><span class="s1">datetime </span><span class="s3">as </span><span class="s1">dt</span>
<span class="s3">import </span><span class="s1">decimal</span>
<span class="s3">import </span><span class="s1">enum</span>
<span class="s3">import </span><span class="s1">json</span>
<span class="s3">import </span><span class="s1">pickle</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Dict</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">overload</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Sequence</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Tuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Type</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TypeVar</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>
<span class="s3">from </span><span class="s1">uuid </span><span class="s3">import </span><span class="s1">UUID </span><span class="s3">as </span><span class="s1">_python_UUID</span>

<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">coercions</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">elements</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">operators</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">roles</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">type_api</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_NONE_NAME</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">NO_ARG</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">SchemaEventTarget</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">cache_key </span><span class="s3">import </span><span class="s1">HasCacheKey</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">quoted_name</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">Slice</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">TypeCoerce </span><span class="s3">as </span><span class="s1">type_coerce  </span><span class="s0"># noqa</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">type_api </span><span class="s3">import </span><span class="s1">Emulated</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">type_api </span><span class="s3">import </span><span class="s1">NativeForEmulated  </span><span class="s0"># noqa</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">type_api </span><span class="s3">import </span><span class="s1">to_instance </span><span class="s3">as </span><span class="s1">to_instance</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">type_api </span><span class="s3">import </span><span class="s1">TypeDecorator </span><span class="s3">as </span><span class="s1">TypeDecorator</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">type_api </span><span class="s3">import </span><span class="s1">TypeEngine </span><span class="s3">as </span><span class="s1">TypeEngine</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">type_api </span><span class="s3">import </span><span class="s1">TypeEngineMixin</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">type_api </span><span class="s3">import </span><span class="s1">Variant  </span><span class="s0"># noqa</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">visitors </span><span class="s3">import </span><span class="s1">InternalTraversal</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">event</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">exc</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">inspection</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">processors</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util </span><span class="s3">import </span><span class="s1">langhelpers</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util </span><span class="s3">import </span><span class="s1">OrderedDict</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">is_literal</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Literal</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">typing_get_args</span>

<span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_ColumnExpressionArgument</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_TypeEngineArgument</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">operators </span><span class="s3">import </span><span class="s1">OperatorType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">schema </span><span class="s3">import </span><span class="s1">MetaData</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">type_api </span><span class="s3">import </span><span class="s1">_BindProcessorType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">type_api </span><span class="s3">import </span><span class="s1">_ComparatorFactory</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">type_api </span><span class="s3">import </span><span class="s1">_MatchedOnType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">type_api </span><span class="s3">import </span><span class="s1">_ResultProcessorType</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">Dialect</span>

<span class="s1">_T </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_T&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s5">&quot;Any&quot;</span><span class="s4">)</span>
<span class="s1">_CT </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_CT&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s1">Any</span><span class="s4">)</span>
<span class="s1">_TE </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_TE&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s5">&quot;TypeEngine[Any]&quot;</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">HasExpressionLookup</span><span class="s4">(</span><span class="s1">TypeEngineMixin</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Mixin expression adaptations based on lookup tables. 
 
    These rules are currently used by the numeric, integer and date types 
    which have detailed cross-expression coercion rules. 
 
    &quot;&quot;&quot;</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_expression_adaptations</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

    <span class="s3">class </span><span class="s1">Comparator</span><span class="s4">(</span><span class="s1">TypeEngine</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">_CT</span><span class="s4">]):</span>
        <span class="s1">__slots__ </span><span class="s4">= ()</span>

        <span class="s1">_blank_dict </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span>

        <span class="s3">def </span><span class="s1">_adapt_expression</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">op</span><span class="s4">: </span><span class="s1">OperatorType</span><span class="s4">,</span>
            <span class="s1">other_comparator</span><span class="s4">: </span><span class="s1">TypeEngine</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s4">) </span><span class="s1">-&gt; Tuple</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
            <span class="s1">othertype </span><span class="s4">= </span><span class="s1">other_comparator</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">_type_affinity</span>
            <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
                <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">, </span><span class="s1">HasExpressionLookup</span><span class="s4">)</span>
            <span class="s1">lookup </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">_expression_adaptations</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span>
                <span class="s1">op</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_blank_dict</span>
            <span class="s4">).</span><span class="s1">get</span><span class="s4">(</span><span class="s1">othertype</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">lookup </span><span class="s3">is </span><span class="s1">othertype</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s4">(</span><span class="s1">op</span><span class="s4">, </span><span class="s1">other_comparator</span><span class="s4">.</span><span class="s1">type</span><span class="s4">)</span>
            <span class="s3">elif </span><span class="s1">lookup </span><span class="s3">is </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">_type_affinity</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s4">(</span><span class="s1">op</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s4">(</span><span class="s1">op</span><span class="s4">, </span><span class="s1">to_instance</span><span class="s4">(</span><span class="s1">lookup</span><span class="s4">))</span>

    <span class="s1">comparator_factory</span><span class="s4">: </span><span class="s1">_ComparatorFactory</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s1">Comparator</span>


<span class="s3">class </span><span class="s1">Concatenable</span><span class="s4">(</span><span class="s1">TypeEngineMixin</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A mixin that marks a type as supporting 'concatenation', 
    typically strings.&quot;&quot;&quot;</span>

    <span class="s3">class </span><span class="s1">Comparator</span><span class="s4">(</span><span class="s1">TypeEngine</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
        <span class="s1">__slots__ </span><span class="s4">= ()</span>

        <span class="s3">def </span><span class="s1">_adapt_expression</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">op</span><span class="s4">: </span><span class="s1">OperatorType</span><span class="s4">,</span>
            <span class="s1">other_comparator</span><span class="s4">: </span><span class="s1">TypeEngine</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s4">) </span><span class="s1">-&gt; Tuple</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
            <span class="s3">if </span><span class="s1">op </span><span class="s3">is </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">add </span><span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span>
                <span class="s1">other_comparator</span><span class="s4">,</span>
                <span class="s4">(</span><span class="s1">Concatenable</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">, </span><span class="s1">NullType</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">),</span>
            <span class="s4">):</span>
                <span class="s3">return </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">concat_op</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span><span class="s4">.</span><span class="s1">type</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">_adapt_expression</span><span class="s4">(</span><span class="s1">op</span><span class="s4">, </span><span class="s1">other_comparator</span><span class="s4">)</span>

    <span class="s1">comparator_factory</span><span class="s4">: </span><span class="s1">_ComparatorFactory</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s1">Comparator</span>


<span class="s3">class </span><span class="s1">Indexable</span><span class="s4">(</span><span class="s1">TypeEngineMixin</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A mixin that marks a type as supporting indexing operations, 
    such as array or JSON structures. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">class </span><span class="s1">Comparator</span><span class="s4">(</span><span class="s1">TypeEngine</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
        <span class="s1">__slots__ </span><span class="s4">= ()</span>

        <span class="s3">def </span><span class="s1">_setup_getitem</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">index</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

        <span class="s3">def </span><span class="s1">__getitem__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">index</span><span class="s4">):</span>
            <span class="s4">(</span>
                <span class="s1">adjusted_op</span><span class="s4">,</span>
                <span class="s1">adjusted_right_expr</span><span class="s4">,</span>
                <span class="s1">result_type</span><span class="s4">,</span>
            <span class="s4">) = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_setup_getitem</span><span class="s4">(</span><span class="s1">index</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">operate</span><span class="s4">(</span>
                <span class="s1">adjusted_op</span><span class="s4">, </span><span class="s1">adjusted_right_expr</span><span class="s4">, </span><span class="s1">result_type</span><span class="s4">=</span><span class="s1">result_type</span>
            <span class="s4">)</span>

    <span class="s1">comparator_factory</span><span class="s4">: </span><span class="s1">_ComparatorFactory</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s1">Comparator</span>


<span class="s3">class </span><span class="s1">String</span><span class="s4">(</span><span class="s1">Concatenable</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;The base for all string and character types. 
 
    In SQL, corresponds to VARCHAR. 
 
    The `length` field is usually required when the `String` type is 
    used within a CREATE TABLE statement, as VARCHAR requires a length 
    on most databases. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;string&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">length</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">collation</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create a string-holding type. 
 
        :param length: optional, a length for the column for use in 
          DDL and CAST expressions.  May be safely omitted if no ``CREATE 
          TABLE`` will be issued.  Certain databases may require a 
          ``length`` for use in DDL, and will raise an exception when 
          the ``CREATE TABLE`` DDL is issued if a ``VARCHAR`` 
          with no length is included.  Whether the value is 
          interpreted as bytes or characters is database specific. 
 
        :param collation: Optional, a column-level collation for 
          use in DDL and CAST expressions.  Renders using the 
          COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. 
          E.g.: 
 
          .. sourcecode:: pycon+sql 
 
            &gt;&gt;&gt; from sqlalchemy import cast, select, String 
            &gt;&gt;&gt; print(select(cast('some string', String(collation='utf8')))) 
            {printsql}SELECT CAST(:param_1 AS VARCHAR COLLATE utf8) AS anon_1 
 
          .. note:: 
 
            In most cases, the :class:`.Unicode` or :class:`.UnicodeText` 
            datatypes should be used for a :class:`_schema.Column` that expects 
            to store non-ascii data. These datatypes will ensure that the 
            correct types are used on the database. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">length </span><span class="s4">= </span><span class="s1">length</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">collation </span><span class="s4">= </span><span class="s1">collation</span>

    <span class="s3">def </span><span class="s1">_with_collation</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">collation</span><span class="s4">):</span>
        <span class="s1">new_type </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">()</span>
        <span class="s1">new_type</span><span class="s4">.</span><span class="s1">collation </span><span class="s4">= </span><span class="s1">collation</span>
        <span class="s3">return </span><span class="s1">new_type</span>

    <span class="s3">def </span><span class="s1">_resolve_for_literal</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s0"># I was SO PROUD of my regex trick, but we dont need it.</span>
        <span class="s0"># re.search(r&quot;[^\u0000-\u007F]&quot;, value)</span>

        <span class="s3">if </span><span class="s1">value</span><span class="s4">.</span><span class="s1">isascii</span><span class="s4">():</span>
            <span class="s3">return </span><span class="s1">_STRING</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_UNICODE</span>

    <span class="s3">def </span><span class="s1">literal_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
            <span class="s1">value </span><span class="s4">= </span><span class="s1">value</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s5">&quot;'&quot;</span><span class="s4">, </span><span class="s5">&quot;''&quot;</span><span class="s4">)</span>

            <span class="s3">if </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">identifier_preparer</span><span class="s4">.</span><span class="s1">_double_percents</span><span class="s4">:</span>
                <span class="s1">value </span><span class="s4">= </span><span class="s1">value</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s5">&quot;%&quot;</span><span class="s4">, </span><span class="s5">&quot;%%&quot;</span><span class="s4">)</span>

            <span class="s3">return </span><span class="s5">&quot;'%s'&quot; </span><span class="s4">% </span><span class="s1">value</span>

        <span class="s3">return </span><span class="s1">process</span>

    <span class="s3">def </span><span class="s1">bind_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">result_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">):</span>
        <span class="s3">return None</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">python_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">str</span>

    <span class="s3">def </span><span class="s1">get_dbapi_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">dbapi</span><span class="s4">.</span><span class="s1">STRING</span>


<span class="s3">class </span><span class="s1">Text</span><span class="s4">(</span><span class="s1">String</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A variably sized string type. 
 
    In SQL, usually corresponds to CLOB or TEXT.  In general, TEXT objects 
    do not have a length; while some databases will accept a length 
    argument here, it will be rejected by others. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;text&quot;</span>


<span class="s3">class </span><span class="s1">Unicode</span><span class="s4">(</span><span class="s1">String</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A variable length Unicode string type. 
 
    The :class:`.Unicode` type is a :class:`.String` subclass that assumes 
    input and output strings that may contain non-ASCII characters, and for 
    some backends implies an underlying column type that is explicitly 
    supporting of non-ASCII data, such as ``NVARCHAR`` on Oracle and SQL 
    Server.  This will impact the output of ``CREATE TABLE`` statements and 
    ``CAST`` functions at the dialect level. 
 
    The character encoding used by the :class:`.Unicode` type that is used to 
    transmit and receive data to the database is usually determined by the 
    DBAPI itself. All modern DBAPIs accommodate non-ASCII strings but may have 
    different methods of managing database encodings; if necessary, this 
    encoding should be configured as detailed in the notes for the target DBAPI 
    in the :ref:`dialect_toplevel` section. 
 
    In modern SQLAlchemy, use of the :class:`.Unicode` datatype does not 
    imply any encoding/decoding behavior within SQLAlchemy itself.  In Python 
    3, all string objects are inherently Unicode capable, and SQLAlchemy 
    does not produce bytestring objects nor does it accommodate a DBAPI that 
    does not return Python Unicode objects in result sets for string values. 
 
    .. warning:: Some database backends, particularly SQL Server with pyodbc, 
       are known to have undesirable behaviors regarding data that is noted 
       as being of ``NVARCHAR`` type as opposed to ``VARCHAR``, including 
       datatype mismatch errors and non-use of indexes.  See the section 
       on :meth:`.DialectEvents.do_setinputsizes` for background on working 
       around unicode character issues for backends like SQL Server with 
       pyodbc as well as cx_Oracle. 
 
    .. seealso:: 
 
        :class:`.UnicodeText` - unlengthed textual counterpart 
        to :class:`.Unicode`. 
 
        :meth:`.DialectEvents.do_setinputsizes` 
 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;unicode&quot;</span>


<span class="s3">class </span><span class="s1">UnicodeText</span><span class="s4">(</span><span class="s1">Text</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;An unbounded-length Unicode string type. 
 
    See :class:`.Unicode` for details on the unicode 
    behavior of this object. 
 
    Like :class:`.Unicode`, usage the :class:`.UnicodeText` type implies a 
    unicode-capable type being used on the backend, such as 
    ``NCLOB``, ``NTEXT``. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;unicode_text&quot;</span>


<span class="s3">class </span><span class="s1">Integer</span><span class="s4">(</span><span class="s1">HasExpressionLookup</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;A type for ``int`` integers.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;integer&quot;</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_memoized_property</span>
        <span class="s3">def </span><span class="s1">_type_affinity</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Type</span><span class="s4">[</span><span class="s1">Integer</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">get_dbapi_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">dbapi</span><span class="s4">.</span><span class="s1">NUMBER</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">python_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">int</span>

    <span class="s3">def </span><span class="s1">_resolve_for_literal</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">value</span><span class="s4">.</span><span class="s1">bit_length</span><span class="s4">() &gt;= </span><span class="s6">32</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_BIGINTEGER</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">literal_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">str</span><span class="s4">(</span><span class="s1">int</span><span class="s4">(</span><span class="s1">value</span><span class="s4">))</span>

        <span class="s3">return </span><span class="s1">process</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_expression_adaptations</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">{</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">add</span><span class="s4">: {</span>
                <span class="s1">Date</span><span class="s4">: </span><span class="s1">Date</span><span class="s4">,</span>
                <span class="s1">Integer</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">,</span>
                <span class="s1">Numeric</span><span class="s4">: </span><span class="s1">Numeric</span><span class="s4">,</span>
            <span class="s4">},</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">mul</span><span class="s4">: {</span>
                <span class="s1">Interval</span><span class="s4">: </span><span class="s1">Interval</span><span class="s4">,</span>
                <span class="s1">Integer</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">,</span>
                <span class="s1">Numeric</span><span class="s4">: </span><span class="s1">Numeric</span><span class="s4">,</span>
            <span class="s4">},</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">truediv</span><span class="s4">: {</span><span class="s1">Integer</span><span class="s4">: </span><span class="s1">Numeric</span><span class="s4">, </span><span class="s1">Numeric</span><span class="s4">: </span><span class="s1">Numeric</span><span class="s4">},</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">floordiv</span><span class="s4">: {</span><span class="s1">Integer</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">, </span><span class="s1">Numeric</span><span class="s4">: </span><span class="s1">Numeric</span><span class="s4">},</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">: {</span><span class="s1">Integer</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">, </span><span class="s1">Numeric</span><span class="s4">: </span><span class="s1">Numeric</span><span class="s4">},</span>
        <span class="s4">}</span>


<span class="s3">class </span><span class="s1">SmallInteger</span><span class="s4">(</span><span class="s1">Integer</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A type for smaller ``int`` integers. 
 
    Typically generates a ``SMALLINT`` in DDL, and otherwise acts like 
    a normal :class:`.Integer` on the Python side. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;small_integer&quot;</span>


<span class="s3">class </span><span class="s1">BigInteger</span><span class="s4">(</span><span class="s1">Integer</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A type for bigger ``int`` integers. 
 
    Typically generates a ``BIGINT`` in DDL, and otherwise acts like 
    a normal :class:`.Integer` on the Python side. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;big_integer&quot;</span>


<span class="s1">_N </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_N&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s1">Union</span><span class="s4">[</span><span class="s1">decimal</span><span class="s4">.</span><span class="s1">Decimal</span><span class="s4">, </span><span class="s1">float</span><span class="s4">])</span>


<span class="s3">class </span><span class="s1">Numeric</span><span class="s4">(</span><span class="s1">HasExpressionLookup</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">_N</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Base for non-integer numeric types, such as 
    ``NUMERIC``, ``FLOAT``, ``DECIMAL``, and other variants. 
 
    The :class:`.Numeric` datatype when used directly will render DDL 
    corresponding to precision numerics if available, such as 
    ``NUMERIC(precision, scale)``.  The :class:`.Float` subclass will 
    attempt to render a floating-point datatype such as ``FLOAT(precision)``. 
 
    :class:`.Numeric` returns Python ``decimal.Decimal`` objects by default, 
    based on the default value of ``True`` for the 
    :paramref:`.Numeric.asdecimal` parameter.  If this parameter is set to 
    False, returned values are coerced to Python ``float`` objects. 
 
    The :class:`.Float` subtype, being more specific to floating point, 
    defaults the :paramref:`.Float.asdecimal` flag to False so that the 
    default Python datatype is ``float``. 
 
    .. note:: 
 
        When using a :class:`.Numeric` datatype against a database type that 
        returns Python floating point values to the driver, the accuracy of the 
        decimal conversion indicated by :paramref:`.Numeric.asdecimal` may be 
        limited.   The behavior of specific numeric/floating point datatypes 
        is a product of the SQL datatype in use, the Python :term:`DBAPI` 
        in use, as well as strategies that may be present within 
        the SQLAlchemy dialect in use.   Users requiring specific precision/ 
        scale are encouraged to experiment with the available datatypes 
        in order to determine the best results. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;numeric&quot;</span>

    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_memoized_property</span>
        <span class="s3">def </span><span class="s1">_type_affinity</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Type</span><span class="s4">[</span><span class="s1">Numeric</span><span class="s4">[</span><span class="s1">_N</span><span class="s4">]]: ...</span>

    <span class="s1">_default_decimal_return_scale </span><span class="s4">= </span><span class="s6">10</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">: </span><span class="s1">Numeric</span><span class="s4">[</span><span class="s1">decimal</span><span class="s4">.</span><span class="s1">Decimal</span><span class="s4">],</span>
        <span class="s1">precision</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = ...,</span>
        <span class="s1">scale</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = ...,</span>
        <span class="s1">decimal_return_scale</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = ...,</span>
        <span class="s1">asdecimal</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">True</span><span class="s4">] = ...,</span>
    <span class="s4">): ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">: </span><span class="s1">Numeric</span><span class="s4">[</span><span class="s1">float</span><span class="s4">],</span>
        <span class="s1">precision</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = ...,</span>
        <span class="s1">scale</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = ...,</span>
        <span class="s1">decimal_return_scale</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = ...,</span>
        <span class="s1">asdecimal</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">False</span><span class="s4">] = ...,</span>
    <span class="s4">): ...</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">precision</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">scale</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">decimal_return_scale</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">asdecimal</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Construct a Numeric. 
 
        :param precision: the numeric precision for use in DDL ``CREATE 
          TABLE``. 
 
        :param scale: the numeric scale for use in DDL ``CREATE TABLE``. 
 
        :param asdecimal: default True.  Return whether or not 
          values should be sent as Python Decimal objects, or 
          as floats.   Different DBAPIs send one or the other based on 
          datatypes - the Numeric type will ensure that return values 
          are one or the other across DBAPIs consistently. 
 
        :param decimal_return_scale: Default scale to use when converting 
         from floats to Python decimals.  Floating point values will typically 
         be much longer due to decimal inaccuracy, and most floating point 
         database types don't have a notion of &quot;scale&quot;, so by default the 
         float type looks for the first ten decimal places when converting. 
         Specifying this value will override that length.  Types which 
         do include an explicit &quot;.scale&quot; value, such as the base 
         :class:`.Numeric` as well as the MySQL float types, will use the 
         value of &quot;.scale&quot; as the default for decimal_return_scale, if not 
         otherwise specified. 
 
        When using the ``Numeric`` type, care should be taken to ensure 
        that the asdecimal setting is appropriate for the DBAPI in use - 
        when Numeric applies a conversion from Decimal-&gt;float or float-&gt; 
        Decimal, this conversion incurs an additional performance overhead 
        for all result columns received. 
 
        DBAPIs that return Decimal natively (e.g. psycopg2) will have 
        better accuracy and higher performance with a setting of ``True``, 
        as the native translation to Decimal reduces the amount of floating- 
        point issues at play, and the Numeric type itself doesn't need 
        to apply any further conversions.  However, another DBAPI which 
        returns floats natively *will* incur an additional conversion 
        overhead, and is still subject to floating point data loss - in 
        which case ``asdecimal=False`` will at least remove the extra 
        conversion overhead. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">precision </span><span class="s4">= </span><span class="s1">precision</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">scale </span><span class="s4">= </span><span class="s1">scale</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">decimal_return_scale </span><span class="s4">= </span><span class="s1">decimal_return_scale</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">asdecimal </span><span class="s4">= </span><span class="s1">asdecimal</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_effective_decimal_return_scale</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">decimal_return_scale </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">decimal_return_scale</span>
        <span class="s3">elif </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s5">&quot;scale&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">) </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">scale</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_default_decimal_return_scale</span>

    <span class="s3">def </span><span class="s1">get_dbapi_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">dbapi</span><span class="s4">.</span><span class="s1">NUMBER</span>

    <span class="s3">def </span><span class="s1">literal_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">str</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">process</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">python_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">asdecimal</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">decimal</span><span class="s4">.</span><span class="s1">Decimal</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">float</span>

    <span class="s3">def </span><span class="s1">bind_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">supports_native_decimal</span><span class="s4">:</span>
            <span class="s3">return None</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">processors</span><span class="s4">.</span><span class="s1">to_float</span>

    <span class="s3">def </span><span class="s1">result_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">asdecimal</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">supports_native_decimal</span><span class="s4">:</span>
                <span class="s0"># we're a &quot;numeric&quot;, DBAPI will give us Decimal directly</span>
                <span class="s3">return None</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s0"># we're a &quot;numeric&quot;, DBAPI returns floats, convert.</span>
                <span class="s3">return </span><span class="s1">processors</span><span class="s4">.</span><span class="s1">to_decimal_processor_factory</span><span class="s4">(</span>
                    <span class="s1">decimal</span><span class="s4">.</span><span class="s1">Decimal</span><span class="s4">,</span>
                    <span class="s4">(</span>
                        <span class="s1">self</span><span class="s4">.</span><span class="s1">scale</span>
                        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">scale </span><span class="s3">is not None</span>
                        <span class="s3">else </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_default_decimal_return_scale</span>
                    <span class="s4">),</span>
                <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">supports_native_decimal</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">processors</span><span class="s4">.</span><span class="s1">to_float</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return None</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_expression_adaptations</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s4">{</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">mul</span><span class="s4">: {</span>
                <span class="s1">Interval</span><span class="s4">: </span><span class="s1">Interval</span><span class="s4">,</span>
                <span class="s1">Numeric</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">,</span>
                <span class="s1">Integer</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">,</span>
            <span class="s4">},</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">truediv</span><span class="s4">: {</span>
                <span class="s1">Numeric</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">,</span>
                <span class="s1">Integer</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">,</span>
            <span class="s4">},</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">add</span><span class="s4">: {</span><span class="s1">Numeric</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">, </span><span class="s1">Integer</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">},</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">: {</span><span class="s1">Numeric</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">, </span><span class="s1">Integer</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">},</span>
        <span class="s4">}</span>


<span class="s3">class </span><span class="s1">Float</span><span class="s4">(</span><span class="s1">Numeric</span><span class="s4">[</span><span class="s1">_N</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Type representing floating point types, such as ``FLOAT`` or ``REAL``. 
 
    This type returns Python ``float`` objects by default, unless the 
    :paramref:`.Float.asdecimal` flag is set to ``True``, in which case they 
    are coerced to ``decimal.Decimal`` objects. 
 
    When a :paramref:`.Float.precision` is not provided in a 
    :class:`_types.Float` type some backend may compile this type as 
    an 8 bytes / 64 bit float datatype. To use a 4 bytes / 32 bit float 
    datatype a precision &lt;= 24 can usually be provided or the 
    :class:`_types.REAL` type can be used. 
    This is known to be the case in the PostgreSQL and MSSQL dialects 
    that render the type as ``FLOAT`` that's in both an alias of 
    ``DOUBLE PRECISION``. Other third party dialects may have similar 
    behavior. 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;float&quot;</span>

    <span class="s1">scale </span><span class="s4">= </span><span class="s3">None</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">: </span><span class="s1">Float</span><span class="s4">[</span><span class="s1">float</span><span class="s4">],</span>
        <span class="s1">precision</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = ...,</span>
        <span class="s1">asdecimal</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">False</span><span class="s4">] = ...,</span>
        <span class="s1">decimal_return_scale</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = ...,</span>
    <span class="s4">): ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">: </span><span class="s1">Float</span><span class="s4">[</span><span class="s1">decimal</span><span class="s4">.</span><span class="s1">Decimal</span><span class="s4">],</span>
        <span class="s1">precision</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = ...,</span>
        <span class="s1">asdecimal</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">True</span><span class="s4">] = ...,</span>
        <span class="s1">decimal_return_scale</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = ...,</span>
    <span class="s4">): ...</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">: </span><span class="s1">Float</span><span class="s4">[</span><span class="s1">_N</span><span class="s4">],</span>
        <span class="s1">precision</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">asdecimal</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">decimal_return_scale</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s5">r&quot;&quot;&quot; 
        Construct a Float. 
 
        :param precision: the numeric precision for use in DDL ``CREATE 
           TABLE``. Backends **should** attempt to ensure this precision 
           indicates a number of digits for the generic 
           :class:`_sqltypes.Float` datatype. 
 
           .. note:: For the Oracle backend, the 
              :paramref:`_sqltypes.Float.precision` parameter is not accepted 
              when rendering DDL, as Oracle does not support float precision 
              specified as a number of decimal places. Instead, use the 
              Oracle-specific :class:`_oracle.FLOAT` datatype and specify the 
              :paramref:`_oracle.FLOAT.binary_precision` parameter. This is new 
              in version 2.0 of SQLAlchemy. 
 
              To create a database agnostic :class:`_types.Float` that 
              separately specifies binary precision for Oracle, use 
              :meth:`_types.TypeEngine.with_variant` as follows:: 
 
                    from sqlalchemy import Column 
                    from sqlalchemy import Float 
                    from sqlalchemy.dialects import oracle 
 
                    Column( 
                        &quot;float_data&quot;, 
                        Float(5).with_variant(oracle.FLOAT(binary_precision=16), &quot;oracle&quot;) 
                    ) 
 
        :param asdecimal: the same flag as that of :class:`.Numeric`, but 
          defaults to ``False``.   Note that setting this flag to ``True`` 
          results in floating point conversion. 
 
        :param decimal_return_scale: Default scale to use when converting 
         from floats to Python decimals.  Floating point values will typically 
         be much longer due to decimal inaccuracy, and most floating point 
         database types don't have a notion of &quot;scale&quot;, so by default the 
         float type looks for the first ten decimal places when converting. 
         Specifying this value will override that length.  Note that the 
         MySQL float types, which do include &quot;scale&quot;, will use &quot;scale&quot; 
         as the default for decimal_return_scale, if not otherwise specified. 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">precision </span><span class="s4">= </span><span class="s1">precision</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">asdecimal </span><span class="s4">= </span><span class="s1">asdecimal</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">decimal_return_scale </span><span class="s4">= </span><span class="s1">decimal_return_scale</span>

    <span class="s3">def </span><span class="s1">result_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">asdecimal</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">processors</span><span class="s4">.</span><span class="s1">to_decimal_processor_factory</span><span class="s4">(</span>
                <span class="s1">decimal</span><span class="s4">.</span><span class="s1">Decimal</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_effective_decimal_return_scale</span>
            <span class="s4">)</span>
        <span class="s3">elif </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">supports_native_decimal</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">processors</span><span class="s4">.</span><span class="s1">to_float</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return None</span>


<span class="s3">class </span><span class="s1">Double</span><span class="s4">(</span><span class="s1">Float</span><span class="s4">[</span><span class="s1">_N</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;A type for double ``FLOAT`` floating point types. 
 
    Typically generates a ``DOUBLE`` or ``DOUBLE_PRECISION`` in DDL, 
    and otherwise acts like a normal :class:`.Float` on the Python 
    side. 
 
    .. versionadded:: 2.0 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;double&quot;</span>


<span class="s3">class </span><span class="s1">_RenderISO8601NoT</span><span class="s4">:</span>
    <span class="s3">def </span><span class="s1">_literal_processor_datetime</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_literal_processor_portion</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_literal_processor_date</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_literal_processor_portion</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">, </span><span class="s6">0</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_literal_processor_time</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_literal_processor_portion</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_literal_processor_portion</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">_portion</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
        <span class="s3">assert </span><span class="s1">_portion </span><span class="s3">in </span><span class="s4">(</span><span class="s3">None</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">_portion </span><span class="s3">is not None</span><span class="s4">:</span>

            <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                <span class="s3">return </span><span class="s5">f&quot;&quot;&quot;'</span><span class="s3">{</span><span class="s1">value</span><span class="s4">.</span><span class="s1">isoformat</span><span class="s4">().</span><span class="s1">split</span><span class="s4">(</span><span class="s5">&quot;T&quot;</span><span class="s4">)[</span><span class="s1">_portion</span><span class="s4">]</span><span class="s3">}</span><span class="s5">'&quot;&quot;&quot;</span>

        <span class="s3">else</span><span class="s4">:</span>

            <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                <span class="s3">return </span><span class="s5">f&quot;&quot;&quot;'</span><span class="s3">{</span><span class="s1">value</span><span class="s4">.</span><span class="s1">isoformat</span><span class="s4">().</span><span class="s1">replace</span><span class="s4">(</span><span class="s5">&quot;T&quot;</span><span class="s4">, </span><span class="s5">&quot; &quot;</span><span class="s4">)</span><span class="s3">}</span><span class="s5">'&quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">process</span>


<span class="s3">class </span><span class="s1">DateTime</span><span class="s4">(</span>
    <span class="s1">_RenderISO8601NoT</span><span class="s4">, </span><span class="s1">HasExpressionLookup</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">dt</span><span class="s4">.</span><span class="s1">datetime</span><span class="s4">]</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A type for ``datetime.datetime()`` objects. 
 
    Date and time types return objects from the Python ``datetime`` 
    module.  Most DBAPIs have built in support for the datetime 
    module, with the noted exception of SQLite.  In the case of 
    SQLite, date and time types are stored as strings which are then 
    converted back to datetime objects when rows are returned. 
 
    For the time representation within the datetime type, some 
    backends include additional options, such as timezone support and 
    fractional seconds support.  For fractional seconds, use the 
    dialect-specific datatype, such as :class:`.mysql.TIME`.  For 
    timezone support, use at least the :class:`_types.TIMESTAMP` datatype, 
    if not the dialect-specific datatype object. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;datetime&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">timezone</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Construct a new :class:`.DateTime`. 
 
        :param timezone: boolean.  Indicates that the datetime type should 
         enable timezone support, if available on the 
         **base date/time-holding type only**.   It is recommended 
         to make use of the :class:`_types.TIMESTAMP` datatype directly when 
         using this flag, as some databases include separate generic 
         date/time-holding types distinct from the timezone-capable 
         TIMESTAMP datatype, such as Oracle. 
 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">timezone </span><span class="s4">= </span><span class="s1">timezone</span>

    <span class="s3">def </span><span class="s1">get_dbapi_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">dbapi</span><span class="s4">.</span><span class="s1">DATETIME</span>

    <span class="s3">def </span><span class="s1">_resolve_for_literal</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s1">with_timezone </span><span class="s4">= </span><span class="s1">value</span><span class="s4">.</span><span class="s1">tzinfo </span><span class="s3">is not None</span>
        <span class="s3">if </span><span class="s1">with_timezone </span><span class="s3">and not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">timezone</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">DATETIME_TIMEZONE</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">literal_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_literal_processor_datetime</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">python_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">dt</span><span class="s4">.</span><span class="s1">datetime</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_expression_adaptations</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0"># Based on</span>
        <span class="s0"># https://www.postgresql.org/docs/current/static/functions-datetime.html.</span>

        <span class="s3">return </span><span class="s4">{</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">add</span><span class="s4">: {</span><span class="s1">Interval</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">},</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">: {</span><span class="s1">Interval</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">, </span><span class="s1">DateTime</span><span class="s4">: </span><span class="s1">Interval</span><span class="s4">},</span>
        <span class="s4">}</span>


<span class="s3">class </span><span class="s1">Date</span><span class="s4">(</span><span class="s1">_RenderISO8601NoT</span><span class="s4">, </span><span class="s1">HasExpressionLookup</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">dt</span><span class="s4">.</span><span class="s1">date</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;A type for ``datetime.date()`` objects.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;date&quot;</span>

    <span class="s3">def </span><span class="s1">get_dbapi_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">dbapi</span><span class="s4">.</span><span class="s1">DATETIME</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">python_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">dt</span><span class="s4">.</span><span class="s1">date</span>

    <span class="s3">def </span><span class="s1">literal_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_literal_processor_date</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_expression_adaptations</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0"># Based on</span>
        <span class="s0"># https://www.postgresql.org/docs/current/static/functions-datetime.html.</span>

        <span class="s3">return </span><span class="s4">{</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">add</span><span class="s4">: {</span>
                <span class="s1">Integer</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">,</span>
                <span class="s1">Interval</span><span class="s4">: </span><span class="s1">DateTime</span><span class="s4">,</span>
                <span class="s1">Time</span><span class="s4">: </span><span class="s1">DateTime</span><span class="s4">,</span>
            <span class="s4">},</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">: {</span>
                <span class="s0"># date - integer = date</span>
                <span class="s1">Integer</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">,</span>
                <span class="s0"># date - date = integer.</span>
                <span class="s1">Date</span><span class="s4">: </span><span class="s1">Integer</span><span class="s4">,</span>
                <span class="s1">Interval</span><span class="s4">: </span><span class="s1">DateTime</span><span class="s4">,</span>
                <span class="s0"># date - datetime = interval,</span>
                <span class="s0"># this one is not in the PG docs</span>
                <span class="s0"># but works</span>
                <span class="s1">DateTime</span><span class="s4">: </span><span class="s1">Interval</span><span class="s4">,</span>
            <span class="s4">},</span>
        <span class="s4">}</span>


<span class="s3">class </span><span class="s1">Time</span><span class="s4">(</span><span class="s1">_RenderISO8601NoT</span><span class="s4">, </span><span class="s1">HasExpressionLookup</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">dt</span><span class="s4">.</span><span class="s1">time</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;A type for ``datetime.time()`` objects.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;time&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">timezone</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">timezone </span><span class="s4">= </span><span class="s1">timezone</span>

    <span class="s3">def </span><span class="s1">get_dbapi_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">dbapi</span><span class="s4">.</span><span class="s1">DATETIME</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">python_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">dt</span><span class="s4">.</span><span class="s1">time</span>

    <span class="s3">def </span><span class="s1">_resolve_for_literal</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s1">with_timezone </span><span class="s4">= </span><span class="s1">value</span><span class="s4">.</span><span class="s1">tzinfo </span><span class="s3">is not None</span>
        <span class="s3">if </span><span class="s1">with_timezone </span><span class="s3">and not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">timezone</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">TIME_TIMEZONE</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_expression_adaptations</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0"># Based on</span>
        <span class="s0"># https://www.postgresql.org/docs/current/static/functions-datetime.html.</span>

        <span class="s3">return </span><span class="s4">{</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">add</span><span class="s4">: {</span><span class="s1">Date</span><span class="s4">: </span><span class="s1">DateTime</span><span class="s4">, </span><span class="s1">Interval</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">},</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">: {</span><span class="s1">Time</span><span class="s4">: </span><span class="s1">Interval</span><span class="s4">, </span><span class="s1">Interval</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">},</span>
        <span class="s4">}</span>

    <span class="s3">def </span><span class="s1">literal_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_literal_processor_time</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">_Binary</span><span class="s4">(</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">bytes</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Define base behavior for binary types.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">length</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">length </span><span class="s4">= </span><span class="s1">length</span>

    <span class="s3">def </span><span class="s1">literal_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
            <span class="s0"># TODO: this is useless for real world scenarios; implement</span>
            <span class="s0"># real binary literals</span>
            <span class="s1">value </span><span class="s4">= </span><span class="s1">value</span><span class="s4">.</span><span class="s1">decode</span><span class="s4">(</span>
                <span class="s1">dialect</span><span class="s4">.</span><span class="s1">_legacy_binary_type_literal_encoding</span>
            <span class="s4">).</span><span class="s1">replace</span><span class="s4">(</span><span class="s5">&quot;'&quot;</span><span class="s4">, </span><span class="s5">&quot;''&quot;</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s5">&quot;'%s'&quot; </span><span class="s4">% </span><span class="s1">value</span>

        <span class="s3">return </span><span class="s1">process</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">python_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">bytes</span>

    <span class="s0"># Python 3 - sqlite3 doesn't need the `Binary` conversion</span>
    <span class="s0"># here, though pg8000 does to indicate &quot;bytea&quot;</span>
    <span class="s3">def </span><span class="s1">bind_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">dbapi </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return None</span>

        <span class="s1">DBAPIBinary </span><span class="s4">= </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">dbapi</span><span class="s4">.</span><span class="s1">Binary</span>

        <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">DBAPIBinary</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return None</span>

        <span class="s3">return </span><span class="s1">process</span>

    <span class="s0"># Python 3 has native bytes() type</span>
    <span class="s0"># both sqlite3 and pg8000 seem to return it,</span>
    <span class="s0"># psycopg2 as of 2.5 returns 'memoryview'</span>
    <span class="s3">def </span><span class="s1">result_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">returns_native_bytes</span><span class="s4">:</span>
            <span class="s3">return None</span>

        <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">value </span><span class="s4">= </span><span class="s1">bytes</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">value</span>

        <span class="s3">return </span><span class="s1">process</span>

    <span class="s3">def </span><span class="s1">coerce_compared_value</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">op</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;See :meth:`.TypeEngine.coerce_compared_value` for a description.&quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">coerce_compared_value</span><span class="s4">(</span><span class="s1">op</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_dbapi_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">dbapi</span><span class="s4">.</span><span class="s1">BINARY</span>


<span class="s3">class </span><span class="s1">LargeBinary</span><span class="s4">(</span><span class="s1">_Binary</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;A type for large binary byte data. 
 
    The :class:`.LargeBinary` type corresponds to a large and/or unlengthed 
    binary type for the target platform, such as BLOB on MySQL and BYTEA for 
    PostgreSQL.  It also handles the necessary conversions for the DBAPI. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;large_binary&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">length</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Construct a LargeBinary type. 
 
        :param length: optional, a length for the column for use in 
          DDL statements, for those binary types that accept a length, 
          such as the MySQL BLOB type. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_Binary</span><span class="s4">.</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">length</span><span class="s4">=</span><span class="s1">length</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">SchemaType</span><span class="s4">(</span><span class="s1">SchemaEventTarget</span><span class="s4">, </span><span class="s1">TypeEngineMixin</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Add capabilities to a type which allow for schema-level DDL to be 
    associated with a type. 
 
    Supports types that must be explicitly created/dropped (i.e. PG ENUM type) 
    as well as types that are complimented by table or schema level 
    constraints, triggers, and other rules. 
 
    :class:`.SchemaType` classes can also be targets for the 
    :meth:`.DDLEvents.before_parent_attach` and 
    :meth:`.DDLEvents.after_parent_attach` events, where the events fire off 
    surrounding the association of the type object with a parent 
    :class:`_schema.Column`. 
 
    .. seealso:: 
 
        :class:`.Enum` 
 
        :class:`.Boolean` 
 
 
    &quot;&quot;&quot;</span>

    <span class="s1">_use_schema_map </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">schema</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">metadata</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">MetaData</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">inherit_schema</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">quote</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_create_events</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">_adapted_from</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">SchemaType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s3">if </span><span class="s1">name </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">quoted_name</span><span class="s4">(</span><span class="s1">name</span><span class="s4">, </span><span class="s1">quote</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">schema </span><span class="s4">= </span><span class="s1">schema</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">metadata </span><span class="s4">= </span><span class="s1">metadata</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">inherit_schema </span><span class="s4">= </span><span class="s1">inherit_schema</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_create_events </span><span class="s4">= </span><span class="s1">_create_events</span>

        <span class="s3">if </span><span class="s1">_create_events </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">metadata</span><span class="s4">:</span>
            <span class="s1">event</span><span class="s4">.</span><span class="s1">listen</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">metadata</span><span class="s4">,</span>
                <span class="s5">&quot;before_create&quot;</span><span class="s4">,</span>
                <span class="s1">util</span><span class="s4">.</span><span class="s1">portable_instancemethod</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_on_metadata_create</span><span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s1">event</span><span class="s4">.</span><span class="s1">listen</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">metadata</span><span class="s4">,</span>
                <span class="s5">&quot;after_drop&quot;</span><span class="s4">,</span>
                <span class="s1">util</span><span class="s4">.</span><span class="s1">portable_instancemethod</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_on_metadata_drop</span><span class="s4">),</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">_adapted_from</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">_join</span><span class="s4">(</span><span class="s1">_adapted_from</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_set_parent</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">parent</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s0"># set parent hook is when this type is associated with a column.</span>
        <span class="s0"># Column calls it for all SchemaEventTarget instances, either the</span>
        <span class="s0"># base type and/or variants in _variant_mapping.</span>

        <span class="s0"># we want to register a second hook to trigger when that column is</span>
        <span class="s0"># associated with a table.  in that event, we and all of our variants</span>
        <span class="s0"># may want to set up some state on the table such as a CheckConstraint</span>
        <span class="s0"># that will conditionally render at DDL render time.</span>

        <span class="s0"># the base SchemaType also sets up events for</span>
        <span class="s0"># on_table/metadata_create/drop in this method, which is used by</span>
        <span class="s0"># &quot;native&quot; types with a separate CREATE/DROP e.g. Postgresql.ENUM</span>

        <span class="s1">parent</span><span class="s4">.</span><span class="s1">_on_table_attach</span><span class="s4">(</span><span class="s1">util</span><span class="s4">.</span><span class="s1">portable_instancemethod</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_set_table</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">_variant_mapping_for_set_table</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">column</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">_variant_mapping</span><span class="s4">:</span>
            <span class="s1">variant_mapping </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">column</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">_variant_mapping</span><span class="s4">)</span>
            <span class="s1">variant_mapping</span><span class="s4">[</span><span class="s5">&quot;_default&quot;</span><span class="s4">] = </span><span class="s1">column</span><span class="s4">.</span><span class="s1">type</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">variant_mapping </span><span class="s4">= </span><span class="s3">None</span>
        <span class="s3">return </span><span class="s1">variant_mapping</span>

    <span class="s3">def </span><span class="s1">_set_table</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">, </span><span class="s1">table</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">inherit_schema</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">schema </span><span class="s4">= </span><span class="s1">table</span><span class="s4">.</span><span class="s1">schema</span>
        <span class="s3">elif </span><span class="s1">self</span><span class="s4">.</span><span class="s1">metadata </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">schema </span><span class="s3">is None and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">metadata</span><span class="s4">.</span><span class="s1">schema</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">schema </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">metadata</span><span class="s4">.</span><span class="s1">schema</span>

        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_create_events</span><span class="s4">:</span>
            <span class="s3">return</span>

        <span class="s1">variant_mapping </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_variant_mapping_for_set_table</span><span class="s4">(</span><span class="s1">column</span><span class="s4">)</span>

        <span class="s1">event</span><span class="s4">.</span><span class="s1">listen</span><span class="s4">(</span>
            <span class="s1">table</span><span class="s4">,</span>
            <span class="s5">&quot;before_create&quot;</span><span class="s4">,</span>
            <span class="s1">util</span><span class="s4">.</span><span class="s1">portable_instancemethod</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_on_table_create</span><span class="s4">, {</span><span class="s5">&quot;variant_mapping&quot;</span><span class="s4">: </span><span class="s1">variant_mapping</span><span class="s4">}</span>
            <span class="s4">),</span>
        <span class="s4">)</span>
        <span class="s1">event</span><span class="s4">.</span><span class="s1">listen</span><span class="s4">(</span>
            <span class="s1">table</span><span class="s4">,</span>
            <span class="s5">&quot;after_drop&quot;</span><span class="s4">,</span>
            <span class="s1">util</span><span class="s4">.</span><span class="s1">portable_instancemethod</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_on_table_drop</span><span class="s4">, {</span><span class="s5">&quot;variant_mapping&quot;</span><span class="s4">: </span><span class="s1">variant_mapping</span><span class="s4">}</span>
            <span class="s4">),</span>
        <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">metadata </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s0"># if SchemaType were created w/ a metadata argument, these</span>
            <span class="s0"># events would already have been associated with that metadata</span>
            <span class="s0"># and would preclude an association with table.metadata</span>
            <span class="s1">event</span><span class="s4">.</span><span class="s1">listen</span><span class="s4">(</span>
                <span class="s1">table</span><span class="s4">.</span><span class="s1">metadata</span><span class="s4">,</span>
                <span class="s5">&quot;before_create&quot;</span><span class="s4">,</span>
                <span class="s1">util</span><span class="s4">.</span><span class="s1">portable_instancemethod</span><span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">_on_metadata_create</span><span class="s4">,</span>
                    <span class="s4">{</span><span class="s5">&quot;variant_mapping&quot;</span><span class="s4">: </span><span class="s1">variant_mapping</span><span class="s4">},</span>
                <span class="s4">),</span>
            <span class="s4">)</span>
            <span class="s1">event</span><span class="s4">.</span><span class="s1">listen</span><span class="s4">(</span>
                <span class="s1">table</span><span class="s4">.</span><span class="s1">metadata</span><span class="s4">,</span>
                <span class="s5">&quot;after_drop&quot;</span><span class="s4">,</span>
                <span class="s1">util</span><span class="s4">.</span><span class="s1">portable_instancemethod</span><span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">_on_metadata_drop</span><span class="s4">,</span>
                    <span class="s4">{</span><span class="s5">&quot;variant_mapping&quot;</span><span class="s4">: </span><span class="s1">variant_mapping</span><span class="s4">},</span>
                <span class="s4">),</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">copy</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">adapt</span><span class="s4">(</span>
            <span class="s1">cast</span><span class="s4">(</span><span class="s5">&quot;Type[TypeEngine[Any]]&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">),</span>
            <span class="s1">_create_events</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s1">metadata</span><span class="s4">=(</span>
                <span class="s1">kw</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;_to_metadata&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">metadata</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">metadata </span><span class="s3">is not None</span>
                <span class="s3">else None</span>
            <span class="s4">),</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">adapt</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">_TE</span><span class="s4">], **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; _TE</span><span class="s4">: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">adapt</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">TypeEngineMixin</span><span class="s4">], **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">adapt</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">TypeEngineMixin</span><span class="s4">]], **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s1">kw</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s5">&quot;_create_events&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>
        <span class="s1">kw</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s5">&quot;_adapted_from&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">adapt</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">create</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">bind</span><span class="s4">, </span><span class="s1">checkfirst</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Issue CREATE DDL for this type, if applicable.&quot;&quot;&quot;</span>

        <span class="s1">t </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect_impl</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">t</span><span class="s4">, </span><span class="s1">SchemaType</span><span class="s4">) </span><span class="s3">and </span><span class="s1">t</span><span class="s4">.</span><span class="s1">__class__ </span><span class="s3">is not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">:</span>
            <span class="s1">t</span><span class="s4">.</span><span class="s1">create</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">, </span><span class="s1">checkfirst</span><span class="s4">=</span><span class="s1">checkfirst</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">drop</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">bind</span><span class="s4">, </span><span class="s1">checkfirst</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Issue DROP DDL for this type, if applicable.&quot;&quot;&quot;</span>

        <span class="s1">t </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect_impl</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">t</span><span class="s4">, </span><span class="s1">SchemaType</span><span class="s4">) </span><span class="s3">and </span><span class="s1">t</span><span class="s4">.</span><span class="s1">__class__ </span><span class="s3">is not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">:</span>
            <span class="s1">t</span><span class="s4">.</span><span class="s1">drop</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">, </span><span class="s1">checkfirst</span><span class="s4">=</span><span class="s1">checkfirst</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_on_table_create</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">target</span><span class="s4">, </span><span class="s1">bind</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_impl_for_variant</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">kw</span><span class="s4">):</span>
            <span class="s3">return</span>

        <span class="s1">t </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect_impl</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">t</span><span class="s4">, </span><span class="s1">SchemaType</span><span class="s4">) </span><span class="s3">and </span><span class="s1">t</span><span class="s4">.</span><span class="s1">__class__ </span><span class="s3">is not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">:</span>
            <span class="s1">t</span><span class="s4">.</span><span class="s1">_on_table_create</span><span class="s4">(</span><span class="s1">target</span><span class="s4">, </span><span class="s1">bind</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_on_table_drop</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">target</span><span class="s4">, </span><span class="s1">bind</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_impl_for_variant</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">kw</span><span class="s4">):</span>
            <span class="s3">return</span>

        <span class="s1">t </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect_impl</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">t</span><span class="s4">, </span><span class="s1">SchemaType</span><span class="s4">) </span><span class="s3">and </span><span class="s1">t</span><span class="s4">.</span><span class="s1">__class__ </span><span class="s3">is not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">:</span>
            <span class="s1">t</span><span class="s4">.</span><span class="s1">_on_table_drop</span><span class="s4">(</span><span class="s1">target</span><span class="s4">, </span><span class="s1">bind</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_on_metadata_create</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">target</span><span class="s4">, </span><span class="s1">bind</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_impl_for_variant</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">kw</span><span class="s4">):</span>
            <span class="s3">return</span>

        <span class="s1">t </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect_impl</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">t</span><span class="s4">, </span><span class="s1">SchemaType</span><span class="s4">) </span><span class="s3">and </span><span class="s1">t</span><span class="s4">.</span><span class="s1">__class__ </span><span class="s3">is not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">:</span>
            <span class="s1">t</span><span class="s4">.</span><span class="s1">_on_metadata_create</span><span class="s4">(</span><span class="s1">target</span><span class="s4">, </span><span class="s1">bind</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_on_metadata_drop</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">target</span><span class="s4">, </span><span class="s1">bind</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_impl_for_variant</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">kw</span><span class="s4">):</span>
            <span class="s3">return</span>

        <span class="s1">t </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dialect_impl</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">t</span><span class="s4">, </span><span class="s1">SchemaType</span><span class="s4">) </span><span class="s3">and </span><span class="s1">t</span><span class="s4">.</span><span class="s1">__class__ </span><span class="s3">is not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">:</span>
            <span class="s1">t</span><span class="s4">.</span><span class="s1">_on_metadata_drop</span><span class="s4">(</span><span class="s1">target</span><span class="s4">, </span><span class="s1">bind</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_is_impl_for_variant</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">variant_mapping </span><span class="s4">= </span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;variant_mapping&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">variant_mapping</span><span class="s4">:</span>
            <span class="s3">return True</span>

        <span class="s0"># for types that have _variant_mapping, all the impls in the map</span>
        <span class="s0"># that are SchemaEventTarget subclasses get set up as event holders.</span>
        <span class="s0"># this is so that constructs that need</span>
        <span class="s0"># to be associated with the Table at dialect-agnostic time etc. like</span>
        <span class="s0"># CheckConstraints can be set up with that table.  they then add</span>
        <span class="s0"># to these constraints a DDL check_rule that among other things</span>
        <span class="s0"># will check this _is_impl_for_variant() method to determine when</span>
        <span class="s0"># the dialect is known that we are part of the table's DDL sequence.</span>

        <span class="s0"># since PostgreSQL is the only DB that has ARRAY this can only</span>
        <span class="s0"># be integration tested by PG-specific tests</span>
        <span class="s3">def </span><span class="s1">_we_are_the_impl</span><span class="s4">(</span><span class="s1">typ</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s4">(</span>
                <span class="s1">typ </span><span class="s3">is </span><span class="s1">self</span>
                <span class="s3">or </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">typ</span><span class="s4">, </span><span class="s1">ARRAY</span><span class="s4">)</span>
                <span class="s3">and </span><span class="s1">typ</span><span class="s4">.</span><span class="s1">item_type </span><span class="s3">is </span><span class="s1">self  </span><span class="s0"># type: ignore[comparison-overlap]</span>
            <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">name </span><span class="s3">in </span><span class="s1">variant_mapping </span><span class="s3">and </span><span class="s1">_we_are_the_impl</span><span class="s4">(</span>
            <span class="s1">variant_mapping</span><span class="s4">[</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">name</span><span class="s4">]</span>
        <span class="s4">):</span>
            <span class="s3">return True</span>
        <span class="s3">elif </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">name </span><span class="s3">not in </span><span class="s1">variant_mapping</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_we_are_the_impl</span><span class="s4">(</span><span class="s1">variant_mapping</span><span class="s4">[</span><span class="s5">&quot;_default&quot;</span><span class="s4">])</span>


<span class="s3">class </span><span class="s1">Enum</span><span class="s4">(</span><span class="s1">String</span><span class="s4">, </span><span class="s1">SchemaType</span><span class="s4">, </span><span class="s1">Emulated</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">enum</span><span class="s4">.</span><span class="s1">Enum</span><span class="s4">]]):</span>
    <span class="s2">&quot;&quot;&quot;Generic Enum Type. 
 
    The :class:`.Enum` type provides a set of possible string values 
    which the column is constrained towards. 
 
    The :class:`.Enum` type will make use of the backend's native &quot;ENUM&quot; 
    type if one is available; otherwise, it uses a VARCHAR datatype. 
    An option also exists to automatically produce a CHECK constraint 
    when the VARCHAR (so called &quot;non-native&quot;) variant is produced; 
    see the  :paramref:`.Enum.create_constraint` flag. 
 
    The :class:`.Enum` type also provides in-Python validation of string 
    values during both read and write operations.  When reading a value 
    from the database in a result set, the string value is always checked 
    against the list of possible values and a ``LookupError`` is raised 
    if no match is found.  When passing a value to the database as a 
    plain string within a SQL statement, if the 
    :paramref:`.Enum.validate_strings` parameter is 
    set to True, a ``LookupError`` is raised for any string value that's 
    not located in the given list of possible values; note that this 
    impacts usage of LIKE expressions with enumerated values (an unusual 
    use case). 
 
    The source of enumerated values may be a list of string values, or 
    alternatively a PEP-435-compliant enumerated class.  For the purposes 
    of the :class:`.Enum` datatype, this class need only provide a 
    ``__members__`` method. 
 
    When using an enumerated class, the enumerated objects are used 
    both for input and output, rather than strings as is the case with 
    a plain-string enumerated type:: 
 
        import enum 
        from sqlalchemy import Enum 
 
        class MyEnum(enum.Enum): 
            one = 1 
            two = 2 
            three = 3 
 
        t = Table( 
            'data', MetaData(), 
            Column('value', Enum(MyEnum)) 
        ) 
 
        connection.execute(t.insert(), {&quot;value&quot;: MyEnum.two}) 
        assert connection.scalar(t.select()) is MyEnum.two 
 
    Above, the string names of each element, e.g. &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, 
    are persisted to the database; the values of the Python Enum, here 
    indicated as integers, are **not** used; the value of each enum can 
    therefore be any kind of Python object whether or not it is persistable. 
 
    In order to persist the values and not the names, the 
    :paramref:`.Enum.values_callable` parameter may be used.   The value of 
    this parameter is a user-supplied callable, which  is intended to be used 
    with a PEP-435-compliant enumerated class and  returns a list of string 
    values to be persisted.   For a simple enumeration that uses string values, 
    a callable such as  ``lambda x: [e.value for e in x]`` is sufficient. 
 
    .. seealso:: 
 
        :ref:`orm_declarative_mapped_column_enums` - background on using 
        the :class:`_sqltypes.Enum` datatype with the ORM's 
        :ref:`ORM Annotated Declarative &lt;orm_declarative_mapped_column&gt;` 
        feature. 
 
        :class:`_postgresql.ENUM` - PostgreSQL-specific type, 
        which has additional functionality. 
 
        :class:`.mysql.ENUM` - MySQL-specific type 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;enum&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">enums</span><span class="s4">: </span><span class="s1">object</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">):</span>
        <span class="s2">r&quot;&quot;&quot;Construct an enum. 
 
        Keyword arguments which don't apply to a specific backend are ignored 
        by that backend. 
 
        :param \*enums: either exactly one PEP-435 compliant enumerated type 
           or one or more string labels. 
 
        :param create_constraint: defaults to False.  When creating a 
           non-native enumerated type, also build a CHECK constraint on the 
           database against the valid values. 
 
           .. note:: it is strongly recommended that the CHECK constraint 
              have an explicit name in order to support schema-management 
              concerns.  This can be established either by setting the 
              :paramref:`.Enum.name` parameter or by setting up an 
              appropriate naming convention; see 
              :ref:`constraint_naming_conventions` for background. 
 
           .. versionchanged:: 1.4 - this flag now defaults to False, meaning 
              no CHECK constraint is generated for a non-native enumerated 
              type. 
 
        :param metadata: Associate this type directly with a ``MetaData`` 
           object. For types that exist on the target database as an 
           independent schema construct (PostgreSQL), this type will be 
           created and dropped within ``create_all()`` and ``drop_all()`` 
           operations. If the type is not associated with any ``MetaData`` 
           object, it will associate itself with each ``Table`` in which it is 
           used, and will be created when any of those individual tables are 
           created, after a check is performed for its existence. The type is 
           only dropped when ``drop_all()`` is called for that ``Table`` 
           object's metadata, however. 
 
           The value of the :paramref:`_schema.MetaData.schema` parameter of 
           the :class:`_schema.MetaData` object, if set, will be used as the 
           default value of the :paramref:`_types.Enum.schema` on this object 
           if an explicit value is not otherwise supplied. 
 
           .. versionchanged:: 1.4.12 :class:`_types.Enum` inherits the 
              :paramref:`_schema.MetaData.schema` parameter of the 
              :class:`_schema.MetaData` object if present, when passed using 
              the :paramref:`_types.Enum.metadata` parameter. 
 
        :param name: The name of this type. This is required for PostgreSQL 
           and any future supported database which requires an explicitly 
           named type, or an explicitly named constraint in order to generate 
           the type and/or a table that uses it. If a PEP-435 enumerated 
           class was used, its name (converted to lower case) is used by 
           default. 
 
        :param native_enum: Use the database's native ENUM type when 
           available. Defaults to True. When False, uses VARCHAR + check 
           constraint for all backends. When False, the VARCHAR length can be 
           controlled with :paramref:`.Enum.length`; currently &quot;length&quot; is 
           ignored if native_enum=True. 
 
        :param length: Allows specifying a custom length for the VARCHAR 
           when a non-native enumeration datatype is used.  By default it uses 
           the length of the longest value. 
 
           .. versionchanged:: 2.0.0 The :paramref:`.Enum.length` parameter 
              is used unconditionally for ``VARCHAR`` rendering regardless of 
              the :paramref:`.Enum.native_enum` parameter, for those backends 
              where ``VARCHAR`` is used for enumerated datatypes. 
 
 
        :param schema: Schema name of this type. For types that exist on the 
           target database as an independent schema construct (PostgreSQL), 
           this parameter specifies the named schema in which the type is 
           present. 
 
           If not present, the schema name will be taken from the 
           :class:`_schema.MetaData` collection if passed as 
           :paramref:`_types.Enum.metadata`, for a :class:`_schema.MetaData` 
           that includes the :paramref:`_schema.MetaData.schema` parameter. 
 
           .. versionchanged:: 1.4.12 :class:`_types.Enum` inherits the 
              :paramref:`_schema.MetaData.schema` parameter of the 
              :class:`_schema.MetaData` object if present, when passed using 
              the :paramref:`_types.Enum.metadata` parameter. 
 
           Otherwise, if the :paramref:`_types.Enum.inherit_schema` flag is set 
           to ``True``, the schema will be inherited from the associated 
           :class:`_schema.Table` object if any; when 
           :paramref:`_types.Enum.inherit_schema` is at its default of 
           ``False``, the owning table's schema is **not** used. 
 
 
        :param quote: Set explicit quoting preferences for the type's name. 
 
        :param inherit_schema: When ``True``, the &quot;schema&quot; from the owning 
           :class:`_schema.Table` 
           will be copied to the &quot;schema&quot; attribute of this 
           :class:`.Enum`, replacing whatever value was passed for the 
           ``schema`` attribute.   This also takes effect when using the 
           :meth:`_schema.Table.to_metadata` operation. 
 
        :param validate_strings: when True, string values that are being 
           passed to the database in a SQL statement will be checked 
           for validity against the list of enumerated values.  Unrecognized 
           values will result in a ``LookupError`` being raised. 
 
        :param values_callable: A callable which will be passed the PEP-435 
           compliant enumerated type, which should then return a list of string 
           values to be persisted. This allows for alternate usages such as 
           using the string value of an enum to be persisted to the database 
           instead of its name. The callable must return the values to be 
           persisted in the same order as iterating through the Enum's 
           ``__member__`` attribute. For example 
           ``lambda x: [i.value for i in x]``. 
 
           .. versionadded:: 1.2.3 
 
        :param sort_key_function: a Python callable which may be used as the 
           &quot;key&quot; argument in the Python ``sorted()`` built-in.   The SQLAlchemy 
           ORM requires that primary key columns which are mapped must 
           be sortable in some way.  When using an unsortable enumeration 
           object such as a Python 3 ``Enum`` object, this parameter may be 
           used to set a default sort key function for the objects.  By 
           default, the database value of the enumeration is used as the 
           sorting function. 
 
           .. versionadded:: 1.3.8 
 
        :param omit_aliases: A boolean that when true will remove aliases from 
           pep 435 enums. defaults to ``True``. 
 
           .. versionchanged:: 2.0 This parameter now defaults to True. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_enum_init</span><span class="s4">(</span><span class="s1">enums</span><span class="s4">, </span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_enums_argument</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">enum_class </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">enum_class</span><span class="s4">]</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">enums</span>

    <span class="s3">def </span><span class="s1">_enum_init</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">enums</span><span class="s4">, </span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;internal init for :class:`.Enum` and subclasses. 
 
        friendly init helper used by subclasses to remove 
        all the Enum-specific keyword arguments from kw.  Allows all 
        other arguments in kw to pass through. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">native_enum </span><span class="s4">= </span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;native_enum&quot;</span><span class="s4">, </span><span class="s3">True</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">create_constraint </span><span class="s4">= </span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;create_constraint&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">values_callable </span><span class="s4">= </span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;values_callable&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_sort_key_function </span><span class="s4">= </span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;sort_key_function&quot;</span><span class="s4">, </span><span class="s1">NO_ARG</span><span class="s4">)</span>
        <span class="s1">length_arg </span><span class="s4">= </span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;length&quot;</span><span class="s4">, </span><span class="s1">NO_ARG</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_omit_aliases </span><span class="s4">= </span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;omit_aliases&quot;</span><span class="s4">, </span><span class="s3">True</span><span class="s4">)</span>
        <span class="s1">_disable_warnings </span><span class="s4">= </span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;_disable_warnings&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>
        <span class="s1">values</span><span class="s4">, </span><span class="s1">objects </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_parse_into_values</span><span class="s4">(</span><span class="s1">enums</span><span class="s4">, </span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_setup_for_values</span><span class="s4">(</span><span class="s1">values</span><span class="s4">, </span><span class="s1">objects</span><span class="s4">, </span><span class="s1">kw</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">validate_strings </span><span class="s4">= </span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;validate_strings&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">enums</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_default_length </span><span class="s4">= </span><span class="s1">length </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">x</span><span class="s4">) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">enums</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_default_length </span><span class="s4">= </span><span class="s1">length </span><span class="s4">= </span><span class="s6">0</span>

        <span class="s3">if </span><span class="s1">length_arg </span><span class="s3">is not </span><span class="s1">NO_ARG</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s4">(</span>
                <span class="s3">not </span><span class="s1">_disable_warnings</span>
                <span class="s3">and </span><span class="s1">length_arg </span><span class="s3">is not None</span>
                <span class="s3">and </span><span class="s1">length_arg </span><span class="s4">&lt; </span><span class="s1">length</span>
            <span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                    <span class="s5">&quot;When provided, length must be larger or equal&quot;</span>
                    <span class="s5">&quot; than the length of the longest enum value. %s &lt; %s&quot;</span>
                    <span class="s4">% (</span><span class="s1">length_arg</span><span class="s4">, </span><span class="s1">length</span><span class="s4">)</span>
                <span class="s4">)</span>
            <span class="s1">length </span><span class="s4">= </span><span class="s1">length_arg</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_valid_lookup</span><span class="s4">[</span><span class="s3">None</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_object_lookup</span><span class="s4">[</span><span class="s3">None</span><span class="s4">] = </span><span class="s3">None</span>

        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">length</span><span class="s4">=</span><span class="s1">length</span><span class="s4">)</span>

        <span class="s0"># assign name to the given enum class if no other name, and this</span>
        <span class="s0"># enum is not an &quot;empty&quot; enum.  if the enum is &quot;empty&quot; we assume</span>
        <span class="s0"># this is a template enum that will be used to generate</span>
        <span class="s0"># new Enum classes.</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">enum_class </span><span class="s3">and </span><span class="s1">values</span><span class="s4">:</span>
            <span class="s1">kw</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">enum_class</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">.</span><span class="s1">lower</span><span class="s4">())</span>
        <span class="s1">SchemaType</span><span class="s4">.</span><span class="s1">__init__</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">name</span><span class="s4">=</span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">),</span>
            <span class="s1">schema</span><span class="s4">=</span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;schema&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">),</span>
            <span class="s1">metadata</span><span class="s4">=</span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;metadata&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">),</span>
            <span class="s1">inherit_schema</span><span class="s4">=</span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;inherit_schema&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">),</span>
            <span class="s1">quote</span><span class="s4">=</span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;quote&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">),</span>
            <span class="s1">_create_events</span><span class="s4">=</span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;_create_events&quot;</span><span class="s4">, </span><span class="s3">True</span><span class="s4">),</span>
            <span class="s1">_adapted_from</span><span class="s4">=</span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;_adapted_from&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">),</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_parse_into_values</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">enums</span><span class="s4">, </span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">enums </span><span class="s3">and </span><span class="s5">&quot;_enums&quot; </span><span class="s3">in </span><span class="s1">kw</span><span class="s4">:</span>
            <span class="s1">enums </span><span class="s4">= </span><span class="s1">kw</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;_enums&quot;</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">enums</span><span class="s4">) == </span><span class="s6">1 </span><span class="s3">and </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">enums</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s5">&quot;__members__&quot;</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">enum_class </span><span class="s4">= </span><span class="s1">enums</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

            <span class="s1">_members </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">enum_class</span><span class="s4">.</span><span class="s1">__members__</span>

            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_omit_aliases </span><span class="s3">is True</span><span class="s4">:</span>
                <span class="s0"># remove aliases</span>
                <span class="s1">members </span><span class="s4">= </span><span class="s1">OrderedDict</span><span class="s4">(</span>
                    <span class="s4">(</span><span class="s1">n</span><span class="s4">, </span><span class="s1">v</span><span class="s4">) </span><span class="s3">for </span><span class="s1">n</span><span class="s4">, </span><span class="s1">v </span><span class="s3">in </span><span class="s1">_members</span><span class="s4">.</span><span class="s1">items</span><span class="s4">() </span><span class="s3">if </span><span class="s1">v</span><span class="s4">.</span><span class="s1">name </span><span class="s4">== </span><span class="s1">n</span>
                <span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">members </span><span class="s4">= </span><span class="s1">_members</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">values_callable</span><span class="s4">:</span>
                <span class="s1">values </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">values_callable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">enum_class</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">values </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">members</span><span class="s4">)</span>
            <span class="s1">objects </span><span class="s4">= [</span><span class="s1">members</span><span class="s4">[</span><span class="s1">k</span><span class="s4">] </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">members</span><span class="s4">]</span>
            <span class="s3">return </span><span class="s1">values</span><span class="s4">, </span><span class="s1">objects</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">enum_class </span><span class="s4">= </span><span class="s3">None</span>
            <span class="s3">return </span><span class="s1">enums</span><span class="s4">, </span><span class="s1">enums</span>

    <span class="s3">def </span><span class="s1">_resolve_for_literal</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Enum</span><span class="s4">:</span>
        <span class="s1">tv </span><span class="s4">= </span><span class="s1">type</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
        <span class="s1">typ </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_resolve_for_python_type</span><span class="s4">(</span><span class="s1">tv</span><span class="s4">, </span><span class="s1">tv</span><span class="s4">, </span><span class="s1">tv</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">typ </span><span class="s3">is not None</span>
        <span class="s3">return </span><span class="s1">typ</span>

    <span class="s3">def </span><span class="s1">_resolve_for_python_type</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">python_type</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">matched_on</span><span class="s4">: </span><span class="s1">_MatchedOnType</span><span class="s4">,</span>
        <span class="s1">matched_on_flattened</span><span class="s4">: </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">Enum</span><span class="s4">]:</span>
        <span class="s0"># &quot;generic form&quot; indicates we were placed in a type map</span>
        <span class="s0"># as ``sqlalchemy.Enum(enum.Enum)`` which indicates we need to</span>
        <span class="s0"># get enumerated values from the datatype</span>
        <span class="s1">we_are_generic_form </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_enums_argument </span><span class="s4">== [</span><span class="s1">enum</span><span class="s4">.</span><span class="s1">Enum</span><span class="s4">]</span>

        <span class="s1">native_enum </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s3">if not </span><span class="s1">we_are_generic_form </span><span class="s3">and </span><span class="s1">python_type </span><span class="s3">is </span><span class="s1">matched_on</span><span class="s4">:</span>
            <span class="s0"># if we have enumerated values, and the incoming python</span>
            <span class="s0"># type is exactly the one that matched in the type map,</span>
            <span class="s0"># then we use these enumerated values and dont try to parse</span>
            <span class="s0"># what's incoming</span>
            <span class="s1">enum_args </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_enums_argument</span>

        <span class="s3">elif </span><span class="s1">is_literal</span><span class="s4">(</span><span class="s1">python_type</span><span class="s4">):</span>
            <span class="s0"># for a literal, where we need to get its contents, parse it out.</span>
            <span class="s1">enum_args </span><span class="s4">= </span><span class="s1">typing_get_args</span><span class="s4">(</span><span class="s1">python_type</span><span class="s4">)</span>
            <span class="s1">bad_args </span><span class="s4">= [</span><span class="s1">arg </span><span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">enum_args </span><span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">arg</span><span class="s4">, </span><span class="s1">str</span><span class="s4">)]</span>
            <span class="s3">if </span><span class="s1">bad_args</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                    <span class="s5">f&quot;Can't create string-based Enum datatype from non-string &quot;</span>
                    <span class="s5">f&quot;values: </span><span class="s3">{</span><span class="s5">', '</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">repr</span><span class="s4">(</span><span class="s1">x</span><span class="s4">) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">bad_args</span><span class="s4">)</span><span class="s3">}</span><span class="s5">.  Please &quot;</span>
                    <span class="s5">f&quot;provide an explicit Enum datatype for this Python type&quot;</span>
                <span class="s4">)</span>
            <span class="s1">native_enum </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">python_type</span><span class="s4">, </span><span class="s1">type</span><span class="s4">) </span><span class="s3">and </span><span class="s1">issubclass</span><span class="s4">(</span>
            <span class="s1">python_type</span><span class="s4">, </span><span class="s1">enum</span><span class="s4">.</span><span class="s1">Enum</span>
        <span class="s4">):</span>
            <span class="s0"># same for an enum.Enum</span>
            <span class="s1">enum_args </span><span class="s4">= [</span><span class="s1">python_type</span><span class="s4">]</span>

        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">enum_args </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_enums_argument</span>

        <span class="s0"># make a new Enum that looks like this one.</span>
        <span class="s0"># arguments or other rules</span>
        <span class="s1">kw </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_make_enum_kw</span><span class="s4">({})</span>

        <span class="s3">if </span><span class="s1">native_enum </span><span class="s3">is False</span><span class="s4">:</span>
            <span class="s1">kw</span><span class="s4">[</span><span class="s5">&quot;native_enum&quot;</span><span class="s4">] = </span><span class="s3">False</span>

        <span class="s1">kw</span><span class="s4">[</span><span class="s5">&quot;length&quot;</span><span class="s4">] = </span><span class="s1">NO_ARG </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">length </span><span class="s4">== </span><span class="s6">0 </span><span class="s3">else </span><span class="s1">self</span><span class="s4">.</span><span class="s1">length</span>
        <span class="s3">return </span><span class="s1">cast</span><span class="s4">(</span>
            <span class="s1">Enum</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_generic_type_affinity</span><span class="s4">(</span><span class="s1">_enums</span><span class="s4">=</span><span class="s1">enum_args</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">),  </span><span class="s0"># type: ignore  # noqa: E501</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_setup_for_values</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">values</span><span class="s4">, </span><span class="s1">objects</span><span class="s4">, </span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">enums </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">values</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_valid_lookup </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">zip</span><span class="s4">(</span><span class="s1">reversed</span><span class="s4">(</span><span class="s1">objects</span><span class="s4">), </span><span class="s1">reversed</span><span class="s4">(</span><span class="s1">values</span><span class="s4">)))</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_object_lookup </span><span class="s4">= </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">zip</span><span class="s4">(</span><span class="s1">values</span><span class="s4">, </span><span class="s1">objects</span><span class="s4">))</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_valid_lookup</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span>
            <span class="s4">[</span>
                <span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_valid_lookup</span><span class="s4">[</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_object_lookup</span><span class="s4">[</span><span class="s1">value</span><span class="s4">]])</span>
                <span class="s3">for </span><span class="s1">value </span><span class="s3">in </span><span class="s1">values</span>
            <span class="s4">]</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">sort_key_function</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_sort_key_function </span><span class="s3">is </span><span class="s1">NO_ARG</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_db_value_for_elem</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_sort_key_function</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">native</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">native_enum</span>

    <span class="s3">def </span><span class="s1">_db_value_for_elem</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">elem</span><span class="s4">):</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_valid_lookup</span><span class="s4">[</span><span class="s1">elem</span><span class="s4">]</span>
        <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
            <span class="s0"># for unknown string values, we return as is.  While we can</span>
            <span class="s0"># validate these if we wanted, that does not allow for lesser-used</span>
            <span class="s0"># end-user use cases, such as using a LIKE comparison with an enum,</span>
            <span class="s0"># or for an application that wishes to apply string tests to an</span>
            <span class="s0"># ENUM (see [ticket:3725]).  While we can decide to differentiate</span>
            <span class="s0"># here between an INSERT statement and a criteria used in a SELECT,</span>
            <span class="s0"># for now we're staying conservative w/ behavioral changes (perhaps</span>
            <span class="s0"># someone has a trigger that handles strings on INSERT)</span>
            <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">validate_strings </span><span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">elem</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
                <span class="s3">return </span><span class="s1">elem</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">LookupError</span><span class="s4">(</span>
                    <span class="s5">&quot;'%s' is not among the defined enum values. &quot;</span>
                    <span class="s5">&quot;Enum name: %s. Possible values: %s&quot;</span>
                    <span class="s4">% (</span>
                        <span class="s1">elem</span><span class="s4">,</span>
                        <span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">,</span>
                        <span class="s1">langhelpers</span><span class="s4">.</span><span class="s1">repr_tuple_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">enums</span><span class="s4">),</span>
                    <span class="s4">)</span>
                <span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>

    <span class="s3">class </span><span class="s1">Comparator</span><span class="s4">(</span><span class="s1">String</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]):</span>
        <span class="s1">__slots__ </span><span class="s4">= ()</span>

        <span class="s1">type</span><span class="s4">: </span><span class="s1">String</span>

        <span class="s3">def </span><span class="s1">_adapt_expression</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">op</span><span class="s4">: </span><span class="s1">OperatorType</span><span class="s4">,</span>
            <span class="s1">other_comparator</span><span class="s4">: </span><span class="s1">TypeEngine</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s4">) </span><span class="s1">-&gt; Tuple</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
            <span class="s1">op</span><span class="s4">, </span><span class="s1">typ </span><span class="s4">= </span><span class="s1">super</span><span class="s4">().</span><span class="s1">_adapt_expression</span><span class="s4">(</span><span class="s1">op</span><span class="s4">, </span><span class="s1">other_comparator</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">op </span><span class="s3">is </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">concat_op</span><span class="s4">:</span>
                <span class="s1">typ </span><span class="s4">= </span><span class="s1">String</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span><span class="s4">.</span><span class="s1">length</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">op</span><span class="s4">, </span><span class="s1">typ</span>

    <span class="s1">comparator_factory </span><span class="s4">= </span><span class="s1">Comparator</span>

    <span class="s3">def </span><span class="s1">_object_value_for_elem</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">elem</span><span class="s4">):</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_object_lookup</span><span class="s4">[</span><span class="s1">elem</span><span class="s4">]</span>
        <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">err</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">LookupError</span><span class="s4">(</span>
                <span class="s5">&quot;'%s' is not among the defined enum values. &quot;</span>
                <span class="s5">&quot;Enum name: %s. Possible values: %s&quot;</span>
                <span class="s4">% (</span>
                    <span class="s1">elem</span><span class="s4">,</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">,</span>
                    <span class="s1">langhelpers</span><span class="s4">.</span><span class="s1">repr_tuple_names</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">enums</span><span class="s4">),</span>
                <span class="s4">)</span>
            <span class="s4">) </span><span class="s3">from </span><span class="s1">err</span>

    <span class="s3">def </span><span class="s1">__repr__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">util</span><span class="s4">.</span><span class="s1">generic_repr</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">additional_kw</span><span class="s4">=[</span>
                <span class="s4">(</span><span class="s5">&quot;native_enum&quot;</span><span class="s4">, </span><span class="s3">True</span><span class="s4">),</span>
                <span class="s4">(</span><span class="s5">&quot;create_constraint&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">),</span>
                <span class="s4">(</span><span class="s5">&quot;length&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_default_length</span><span class="s4">),</span>
            <span class="s4">],</span>
            <span class="s1">to_inspect</span><span class="s4">=[</span><span class="s1">Enum</span><span class="s4">, </span><span class="s1">SchemaType</span><span class="s4">],</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">as_generic</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">allow_nulltype</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">args </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">enums</span>
        <span class="s3">except </span><span class="s1">AttributeError</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">(</span>
                <span class="s5">&quot;TypeEngine.as_generic() heuristic &quot;</span>
                <span class="s5">&quot;is undefined for types that inherit Enum but do not have &quot;</span>
                <span class="s5">&quot;an `enums` attribute.&quot;</span>
            <span class="s4">) </span><span class="s3">from None</span>

        <span class="s3">return </span><span class="s1">util</span><span class="s4">.</span><span class="s1">constructor_copy</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_generic_type_affinity</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">, </span><span class="s1">_disable_warnings</span><span class="s4">=</span><span class="s3">True</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_make_enum_kw</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">kw</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s5">&quot;validate_strings&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">validate_strings</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">:</span>
            <span class="s1">kw</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s5">&quot;name&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s1">kw</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s5">&quot;schema&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">schema</span><span class="s4">)</span>
        <span class="s1">kw</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s5">&quot;inherit_schema&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">inherit_schema</span><span class="s4">)</span>
        <span class="s1">kw</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s5">&quot;metadata&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">metadata</span><span class="s4">)</span>
        <span class="s1">kw</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s5">&quot;native_enum&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">native_enum</span><span class="s4">)</span>
        <span class="s1">kw</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s5">&quot;values_callable&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">values_callable</span><span class="s4">)</span>
        <span class="s1">kw</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s5">&quot;create_constraint&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">create_constraint</span><span class="s4">)</span>
        <span class="s1">kw</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s5">&quot;length&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">length</span><span class="s4">)</span>
        <span class="s1">kw</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s5">&quot;omit_aliases&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_omit_aliases</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">kw</span>

    <span class="s3">def </span><span class="s1">adapt_to_emulated</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">impltype</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_make_enum_kw</span><span class="s4">(</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s1">kw</span><span class="s4">[</span><span class="s5">&quot;_disable_warnings&quot;</span><span class="s4">] = </span><span class="s3">True</span>
        <span class="s1">kw</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s5">&quot;_create_events&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s5">&quot;_enums&quot; </span><span class="s3">in </span><span class="s1">kw</span>
        <span class="s3">return </span><span class="s1">impltype</span><span class="s4">(**</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">adapt</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">cls</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">kw</span><span class="s4">[</span><span class="s5">&quot;_enums&quot;</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_enums_argument</span>
        <span class="s1">kw</span><span class="s4">[</span><span class="s5">&quot;_disable_warnings&quot;</span><span class="s4">] = </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">adapt</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_should_create_constraint</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">compiler</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_impl_for_variant</span><span class="s4">(</span><span class="s1">compiler</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">kw</span><span class="s4">):</span>
            <span class="s3">return False</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s3">not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">native_enum </span><span class="s3">or not </span><span class="s1">compiler</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">supports_native_enum</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.schema&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">_set_table</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">, </span><span class="s1">table</span><span class="s4">):</span>
        <span class="s1">schema </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_schema</span>
        <span class="s1">SchemaType</span><span class="s4">.</span><span class="s1">_set_table</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">, </span><span class="s1">table</span><span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">create_constraint</span><span class="s4">:</span>
            <span class="s3">return</span>

        <span class="s1">variant_mapping </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_variant_mapping_for_set_table</span><span class="s4">(</span><span class="s1">column</span><span class="s4">)</span>

        <span class="s1">e </span><span class="s4">= </span><span class="s1">schema</span><span class="s4">.</span><span class="s1">CheckConstraint</span><span class="s4">(</span>
            <span class="s1">type_coerce</span><span class="s4">(</span><span class="s1">column</span><span class="s4">, </span><span class="s1">String</span><span class="s4">()).</span><span class="s1">in_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">enums</span><span class="s4">),</span>
            <span class="s1">name</span><span class="s4">=</span><span class="s1">_NONE_NAME </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s3">is None else </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">,</span>
            <span class="s1">_create_rule</span><span class="s4">=</span><span class="s1">util</span><span class="s4">.</span><span class="s1">portable_instancemethod</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_should_create_constraint</span><span class="s4">,</span>
                <span class="s4">{</span><span class="s5">&quot;variant_mapping&quot;</span><span class="s4">: </span><span class="s1">variant_mapping</span><span class="s4">},</span>
            <span class="s4">),</span>
            <span class="s1">_type_bound</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">e</span><span class="s4">.</span><span class="s1">table </span><span class="s3">is </span><span class="s1">table</span>

    <span class="s3">def </span><span class="s1">literal_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s1">parent_processor </span><span class="s4">= </span><span class="s1">super</span><span class="s4">().</span><span class="s1">literal_processor</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
            <span class="s1">value </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_db_value_for_elem</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">parent_processor</span><span class="s4">:</span>
                <span class="s1">value </span><span class="s4">= </span><span class="s1">parent_processor</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">value</span>

        <span class="s3">return </span><span class="s1">process</span>

    <span class="s3">def </span><span class="s1">bind_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s1">parent_processor </span><span class="s4">= </span><span class="s1">super</span><span class="s4">().</span><span class="s1">bind_processor</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
            <span class="s1">value </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_db_value_for_elem</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">parent_processor</span><span class="s4">:</span>
                <span class="s1">value </span><span class="s4">= </span><span class="s1">parent_processor</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">value</span>

        <span class="s3">return </span><span class="s1">process</span>

    <span class="s3">def </span><span class="s1">result_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">):</span>
        <span class="s1">parent_processor </span><span class="s4">= </span><span class="s1">super</span><span class="s4">().</span><span class="s1">result_processor</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">parent_processor</span><span class="s4">:</span>
                <span class="s1">value </span><span class="s4">= </span><span class="s1">parent_processor</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>

            <span class="s1">value </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_object_value_for_elem</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">value</span>

        <span class="s3">return </span><span class="s1">process</span>

    <span class="s3">def </span><span class="s1">copy</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">SchemaType</span><span class="s4">.</span><span class="s1">copy</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">python_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">enum_class</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">enum_class</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">python_type</span>


<span class="s3">class </span><span class="s1">PickleType</span><span class="s4">(</span><span class="s1">TypeDecorator</span><span class="s4">[</span><span class="s1">object</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Holds Python objects, which are serialized using pickle. 
 
    PickleType builds upon the Binary type to apply Python's 
    ``pickle.dumps()`` to incoming objects, and ``pickle.loads()`` on 
    the way out, allowing any pickleable Python object to be stored as 
    a serialized binary field. 
 
    To allow ORM change events to propagate for elements associated 
    with :class:`.PickleType`, see :ref:`mutable_toplevel`. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">impl </span><span class="s4">= </span><span class="s1">LargeBinary</span>
    <span class="s1">cache_ok </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">protocol</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= </span><span class="s1">pickle</span><span class="s4">.</span><span class="s1">HIGHEST_PROTOCOL</span><span class="s4">,</span>
        <span class="s1">pickler</span><span class="s4">: </span><span class="s1">Any </span><span class="s4">= </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">comparator</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Callable</span><span class="s4">[[</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">], </span><span class="s1">bool</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">impl</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Construct a PickleType. 
 
        :param protocol: defaults to ``pickle.HIGHEST_PROTOCOL``. 
 
        :param pickler: defaults to pickle.  May be any object with 
          pickle-compatible ``dumps`` and ``loads`` methods. 
 
        :param comparator: a 2-arg callable predicate used 
          to compare values of this type.  If left as ``None``, 
          the Python &quot;equals&quot; operator is used to compare values. 
 
        :param impl: A binary-storing :class:`_types.TypeEngine` class or 
          instance to use in place of the default :class:`_types.LargeBinary`. 
          For example the :class: `_mysql.LONGBLOB` class may be more effective 
          when using MySQL. 
 
          .. versionadded:: 1.4.20 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">protocol </span><span class="s4">= </span><span class="s1">protocol</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">pickler </span><span class="s4">= </span><span class="s1">pickler </span><span class="s3">or </span><span class="s1">pickle</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">comparator </span><span class="s4">= </span><span class="s1">comparator</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">()</span>

        <span class="s3">if </span><span class="s1">impl</span><span class="s4">:</span>
            <span class="s0"># custom impl is not necessarily a LargeBinary subclass.</span>
            <span class="s0"># make an exception to typing for this</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">impl </span><span class="s4">= </span><span class="s1">to_instance</span><span class="s4">(</span><span class="s1">impl</span><span class="s4">)  </span><span class="s0"># type: ignore</span>

    <span class="s3">def </span><span class="s1">__reduce__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">PickleType</span><span class="s4">, (</span><span class="s1">self</span><span class="s4">.</span><span class="s1">protocol</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">comparator</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">bind_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s1">impl_processor </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">impl_instance</span><span class="s4">.</span><span class="s1">bind_processor</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">)</span>
        <span class="s1">dumps </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">pickler</span><span class="s4">.</span><span class="s1">dumps</span>
        <span class="s1">protocol </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">protocol</span>
        <span class="s3">if </span><span class="s1">impl_processor</span><span class="s4">:</span>
            <span class="s1">fixed_impl_processor </span><span class="s4">= </span><span class="s1">impl_processor</span>

            <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s1">value </span><span class="s4">= </span><span class="s1">dumps</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">protocol</span><span class="s4">)</span>
                <span class="s3">return </span><span class="s1">fixed_impl_processor</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>

        <span class="s3">else</span><span class="s4">:</span>

            <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s1">value </span><span class="s4">= </span><span class="s1">dumps</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">protocol</span><span class="s4">)</span>
                <span class="s3">return </span><span class="s1">value</span>

        <span class="s3">return </span><span class="s1">process</span>

    <span class="s3">def </span><span class="s1">result_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">):</span>
        <span class="s1">impl_processor </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">impl_instance</span><span class="s4">.</span><span class="s1">result_processor</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">)</span>
        <span class="s1">loads </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">pickler</span><span class="s4">.</span><span class="s1">loads</span>
        <span class="s3">if </span><span class="s1">impl_processor</span><span class="s4">:</span>
            <span class="s1">fixed_impl_processor </span><span class="s4">= </span><span class="s1">impl_processor</span>

            <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                <span class="s1">value </span><span class="s4">= </span><span class="s1">fixed_impl_processor</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">value </span><span class="s3">is None</span><span class="s4">:</span>
                    <span class="s3">return None</span>
                <span class="s3">return </span><span class="s1">loads</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>

        <span class="s3">else</span><span class="s4">:</span>

            <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                <span class="s3">if </span><span class="s1">value </span><span class="s3">is None</span><span class="s4">:</span>
                    <span class="s3">return None</span>
                <span class="s3">return </span><span class="s1">loads</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">process</span>

    <span class="s3">def </span><span class="s1">compare_values</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">comparator</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">comparator</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">x </span><span class="s4">== </span><span class="s1">y</span>


<span class="s3">class </span><span class="s1">Boolean</span><span class="s4">(</span><span class="s1">SchemaType</span><span class="s4">, </span><span class="s1">Emulated</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;A bool datatype. 
 
    :class:`.Boolean` typically uses BOOLEAN or SMALLINT on the DDL side, 
    and on the Python side deals in ``True`` or ``False``. 
 
    The :class:`.Boolean` datatype currently has two levels of assertion 
    that the values persisted are simple true/false values.  For all 
    backends, only the Python values ``None``, ``True``, ``False``, ``1`` 
    or ``0`` are accepted as parameter values.   For those backends that 
    don't support a &quot;native boolean&quot; datatype, an option exists to 
    also create a CHECK constraint on the target column 
 
    .. versionchanged:: 1.2 the :class:`.Boolean` datatype now asserts that 
       incoming Python values are already in pure boolean form. 
 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;boolean&quot;</span>
    <span class="s1">native </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">create_constraint</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">_create_events</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">_adapted_from</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">SchemaType</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Construct a Boolean. 
 
        :param create_constraint: defaults to False.  If the boolean 
          is generated as an int/smallint, also create a CHECK constraint 
          on the table that ensures 1 or 0 as a value. 
 
          .. note:: it is strongly recommended that the CHECK constraint 
             have an explicit name in order to support schema-management 
             concerns.  This can be established either by setting the 
             :paramref:`.Boolean.name` parameter or by setting up an 
             appropriate naming convention; see 
             :ref:`constraint_naming_conventions` for background. 
 
          .. versionchanged:: 1.4 - this flag now defaults to False, meaning 
             no CHECK constraint is generated for a non-native enumerated 
             type. 
 
        :param name: if a CHECK constraint is generated, specify 
          the name of the constraint. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">create_constraint </span><span class="s4">= </span><span class="s1">create_constraint</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s4">= </span><span class="s1">name</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_create_events </span><span class="s4">= </span><span class="s1">_create_events</span>
        <span class="s3">if </span><span class="s1">_adapted_from</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">_join</span><span class="s4">(</span><span class="s1">_adapted_from</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">copy</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s0"># override SchemaType.copy() to not include to_metadata logic</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">adapt</span><span class="s4">(</span>
            <span class="s1">cast</span><span class="s4">(</span><span class="s5">&quot;Type[TypeEngine[Any]]&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">),</span>
            <span class="s1">_create_events</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_should_create_constraint</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">compiler</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_is_impl_for_variant</span><span class="s4">(</span><span class="s1">compiler</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">kw</span><span class="s4">):</span>
            <span class="s3">return False</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s3">not </span><span class="s1">compiler</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">supports_native_boolean</span>
            <span class="s3">and </span><span class="s1">compiler</span><span class="s4">.</span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">non_native_boolean_check_constraint</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.schema&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">_set_table</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">, </span><span class="s1">table</span><span class="s4">):</span>
        <span class="s1">schema </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_schema</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">create_constraint</span><span class="s4">:</span>
            <span class="s3">return</span>

        <span class="s1">variant_mapping </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_variant_mapping_for_set_table</span><span class="s4">(</span><span class="s1">column</span><span class="s4">)</span>

        <span class="s1">e </span><span class="s4">= </span><span class="s1">schema</span><span class="s4">.</span><span class="s1">CheckConstraint</span><span class="s4">(</span>
            <span class="s1">type_coerce</span><span class="s4">(</span><span class="s1">column</span><span class="s4">, </span><span class="s1">self</span><span class="s4">).</span><span class="s1">in_</span><span class="s4">([</span><span class="s6">0</span><span class="s4">, </span><span class="s6">1</span><span class="s4">]),</span>
            <span class="s1">name</span><span class="s4">=</span><span class="s1">_NONE_NAME </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name </span><span class="s3">is None else </span><span class="s1">self</span><span class="s4">.</span><span class="s1">name</span><span class="s4">,</span>
            <span class="s1">_create_rule</span><span class="s4">=</span><span class="s1">util</span><span class="s4">.</span><span class="s1">portable_instancemethod</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_should_create_constraint</span><span class="s4">,</span>
                <span class="s4">{</span><span class="s5">&quot;variant_mapping&quot;</span><span class="s4">: </span><span class="s1">variant_mapping</span><span class="s4">},</span>
            <span class="s4">),</span>
            <span class="s1">_type_bound</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">e</span><span class="s4">.</span><span class="s1">table </span><span class="s3">is </span><span class="s1">table</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">python_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">bool</span>

    <span class="s1">_strict_bools </span><span class="s4">= </span><span class="s1">frozenset</span><span class="s4">([</span><span class="s3">None</span><span class="s4">, </span><span class="s3">True</span><span class="s4">, </span><span class="s3">False</span><span class="s4">])</span>

    <span class="s3">def </span><span class="s1">_strict_as_bool</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">value </span><span class="s3">not in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_strict_bools</span><span class="s4">:</span>
            <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">int</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;Not a boolean value: %r&quot; </span><span class="s4">% (</span><span class="s1">value</span><span class="s4">,))</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                    <span class="s5">&quot;Value %r is not None, True, or False&quot; </span><span class="s4">% (</span><span class="s1">value</span><span class="s4">,)</span>
                <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">value</span>

    <span class="s3">def </span><span class="s1">literal_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s1">compiler </span><span class="s4">= </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">statement_compiler</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s1">true </span><span class="s4">= </span><span class="s1">compiler</span><span class="s4">.</span><span class="s1">visit_true</span><span class="s4">(</span><span class="s3">None</span><span class="s4">)</span>
        <span class="s1">false </span><span class="s4">= </span><span class="s1">compiler</span><span class="s4">.</span><span class="s1">visit_false</span><span class="s4">(</span><span class="s3">None</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">true </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_strict_as_bool</span><span class="s4">(</span><span class="s1">value</span><span class="s4">) </span><span class="s3">else </span><span class="s1">false</span>

        <span class="s3">return </span><span class="s1">process</span>

    <span class="s3">def </span><span class="s1">bind_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s1">_strict_as_bool </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_strict_as_bool</span>

        <span class="s1">_coerce</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">], </span><span class="s1">Type</span><span class="s4">[</span><span class="s1">int</span><span class="s4">]]</span>

        <span class="s3">if </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">supports_native_boolean</span><span class="s4">:</span>
            <span class="s1">_coerce </span><span class="s4">= </span><span class="s1">bool</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">_coerce </span><span class="s4">= </span><span class="s1">int</span>

        <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
            <span class="s1">value </span><span class="s4">= </span><span class="s1">_strict_as_bool</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
            <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s1">value </span><span class="s4">= </span><span class="s1">_coerce</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">value</span>

        <span class="s3">return </span><span class="s1">process</span>

    <span class="s3">def </span><span class="s1">result_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">supports_native_boolean</span><span class="s4">:</span>
            <span class="s3">return None</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">processors</span><span class="s4">.</span><span class="s1">int_to_boolean</span>


<span class="s3">class </span><span class="s1">_AbstractInterval</span><span class="s4">(</span><span class="s1">HasExpressionLookup</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">dt</span><span class="s4">.</span><span class="s1">timedelta</span><span class="s4">]):</span>
    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_expression_adaptations</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s0"># Based on</span>
        <span class="s0"># https://www.postgresql.org/docs/current/static/functions-datetime.html.</span>

        <span class="s3">return </span><span class="s4">{</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">add</span><span class="s4">: {</span>
                <span class="s1">Date</span><span class="s4">: </span><span class="s1">DateTime</span><span class="s4">,</span>
                <span class="s1">Interval</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">,</span>
                <span class="s1">DateTime</span><span class="s4">: </span><span class="s1">DateTime</span><span class="s4">,</span>
                <span class="s1">Time</span><span class="s4">: </span><span class="s1">Time</span><span class="s4">,</span>
            <span class="s4">},</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">sub</span><span class="s4">: {</span><span class="s1">Interval</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">},</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">mul</span><span class="s4">: {</span><span class="s1">Numeric</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">},</span>
            <span class="s1">operators</span><span class="s4">.</span><span class="s1">truediv</span><span class="s4">: {</span><span class="s1">Numeric</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">},</span>
        <span class="s4">}</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">ro_non_memoized_property</span>
    <span class="s3">def </span><span class="s1">_type_affinity</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Type</span><span class="s4">[</span><span class="s1">Interval</span><span class="s4">]:</span>
        <span class="s3">return </span><span class="s1">Interval</span>


<span class="s3">class </span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Emulated</span><span class="s4">, </span><span class="s1">_AbstractInterval</span><span class="s4">, </span><span class="s1">TypeDecorator</span><span class="s4">[</span><span class="s1">dt</span><span class="s4">.</span><span class="s1">timedelta</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;A type for ``datetime.timedelta()`` objects. 
 
    The Interval type deals with ``datetime.timedelta`` objects.  In 
    PostgreSQL and Oracle, the native ``INTERVAL`` type is used; for others, 
    the value is stored as a date which is relative to the &quot;epoch&quot; 
    (Jan. 1, 1970). 
 
    Note that the ``Interval`` type does not currently provide date arithmetic 
    operations on platforms which do not support interval types natively. Such 
    operations usually require transformation of both sides of the expression 
    (such as, conversion of both sides into integer epoch values first) which 
    currently is a manual procedure (such as via 
    :attr:`~sqlalchemy.sql.expression.func`). 
 
    &quot;&quot;&quot;</span>

    <span class="s1">impl </span><span class="s4">= </span><span class="s1">DateTime</span>
    <span class="s1">epoch </span><span class="s4">= </span><span class="s1">dt</span><span class="s4">.</span><span class="s1">datetime</span><span class="s4">.</span><span class="s1">fromtimestamp</span><span class="s4">(</span><span class="s6">0</span><span class="s4">, </span><span class="s1">dt</span><span class="s4">.</span><span class="s1">timezone</span><span class="s4">.</span><span class="s1">utc</span><span class="s4">).</span><span class="s1">replace</span><span class="s4">(</span><span class="s1">tzinfo</span><span class="s4">=</span><span class="s3">None</span><span class="s4">)</span>
    <span class="s1">cache_ok </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">native</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
        <span class="s1">second_precision</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">day_precision</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Construct an Interval object. 
 
        :param native: when True, use the actual 
          INTERVAL type provided by the database, if 
          supported (currently PostgreSQL, Oracle). 
          Otherwise, represent the interval data as 
          an epoch value regardless. 
 
        :param second_precision: For native interval types 
          which support a &quot;fractional seconds precision&quot; parameter, 
          i.e. Oracle and PostgreSQL 
 
        :param day_precision: for native interval types which 
          support a &quot;day precision&quot; parameter, i.e. Oracle. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">native </span><span class="s4">= </span><span class="s1">native</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">second_precision </span><span class="s4">= </span><span class="s1">second_precision</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">day_precision </span><span class="s4">= </span><span class="s1">day_precision</span>

    <span class="s3">class </span><span class="s1">Comparator</span><span class="s4">(</span>
        <span class="s1">TypeDecorator</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">_CT</span><span class="s4">],</span>
        <span class="s1">_AbstractInterval</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">_CT</span><span class="s4">],</span>
    <span class="s4">):</span>
        <span class="s1">__slots__ </span><span class="s4">= ()</span>

    <span class="s1">comparator_factory </span><span class="s4">= </span><span class="s1">Comparator</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">python_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">dt</span><span class="s4">.</span><span class="s1">timedelta</span>

    <span class="s3">def </span><span class="s1">adapt_to_emulated</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">impltype</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">_AbstractInterval</span><span class="s4">.</span><span class="s1">adapt</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">impltype</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">coerce_compared_value</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">op</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">impl_instance</span><span class="s4">.</span><span class="s1">coerce_compared_value</span><span class="s4">(</span><span class="s1">op</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">bind_processor</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">: </span><span class="s1">Dialect</span>
    <span class="s4">) </span><span class="s1">-&gt; _BindProcessorType</span><span class="s4">[</span><span class="s1">dt</span><span class="s4">.</span><span class="s1">timedelta</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">impl_instance</span><span class="s4">, </span><span class="s1">DateTime</span><span class="s4">)</span>
        <span class="s1">impl_processor </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">impl_instance</span><span class="s4">.</span><span class="s1">bind_processor</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">)</span>
        <span class="s1">epoch </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">epoch</span>
        <span class="s3">if </span><span class="s1">impl_processor</span><span class="s4">:</span>
            <span class="s1">fixed_impl_processor </span><span class="s4">= </span><span class="s1">impl_processor</span>

            <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span>
                <span class="s1">value</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dt</span><span class="s4">.</span><span class="s1">timedelta</span><span class="s4">],</span>
            <span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s1">dt_value </span><span class="s4">= </span><span class="s1">epoch </span><span class="s4">+ </span><span class="s1">value</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">dt_value </span><span class="s4">= </span><span class="s3">None</span>
                <span class="s3">return </span><span class="s1">fixed_impl_processor</span><span class="s4">(</span><span class="s1">dt_value</span><span class="s4">)</span>

        <span class="s3">else</span><span class="s4">:</span>

            <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span>
                <span class="s1">value</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">dt</span><span class="s4">.</span><span class="s1">timedelta</span><span class="s4">],</span>
            <span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s1">dt_value </span><span class="s4">= </span><span class="s1">epoch </span><span class="s4">+ </span><span class="s1">value</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">dt_value </span><span class="s4">= </span><span class="s3">None</span>
                <span class="s3">return </span><span class="s1">dt_value</span>

        <span class="s3">return </span><span class="s1">process</span>

    <span class="s3">def </span><span class="s1">result_processor</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">: </span><span class="s1">Dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; _ResultProcessorType</span><span class="s4">[</span><span class="s1">dt</span><span class="s4">.</span><span class="s1">timedelta</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">impl_instance</span><span class="s4">, </span><span class="s1">DateTime</span><span class="s4">)</span>
        <span class="s1">impl_processor </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">impl_instance</span><span class="s4">.</span><span class="s1">result_processor</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">)</span>
        <span class="s1">epoch </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">epoch</span>
        <span class="s3">if </span><span class="s1">impl_processor</span><span class="s4">:</span>
            <span class="s1">fixed_impl_processor </span><span class="s4">= </span><span class="s1">impl_processor</span>

            <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">dt</span><span class="s4">.</span><span class="s1">timedelta</span><span class="s4">]:</span>
                <span class="s1">dt_value </span><span class="s4">= </span><span class="s1">fixed_impl_processor</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">dt_value </span><span class="s3">is None</span><span class="s4">:</span>
                    <span class="s3">return None</span>
                <span class="s3">return </span><span class="s1">dt_value </span><span class="s4">- </span><span class="s1">epoch</span>

        <span class="s3">else</span><span class="s4">:</span>

            <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">dt</span><span class="s4">.</span><span class="s1">timedelta</span><span class="s4">]:</span>
                <span class="s3">if </span><span class="s1">value </span><span class="s3">is None</span><span class="s4">:</span>
                    <span class="s3">return None</span>
                <span class="s3">return </span><span class="s1">value </span><span class="s4">- </span><span class="s1">epoch  </span><span class="s0"># type: ignore</span>

        <span class="s3">return </span><span class="s1">process</span>


<span class="s3">class </span><span class="s1">JSON</span><span class="s4">(</span><span class="s1">Indexable</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent a SQL JSON type. 
 
    .. note::  :class:`_types.JSON` 
       is provided as a facade for vendor-specific 
       JSON types.  Since it supports JSON SQL operations, it only 
       works on backends that have an actual JSON type, currently: 
 
       * PostgreSQL - see :class:`sqlalchemy.dialects.postgresql.JSON` and 
         :class:`sqlalchemy.dialects.postgresql.JSONB` for backend-specific 
         notes 
 
       * MySQL - see 
         :class:`sqlalchemy.dialects.mysql.JSON` for backend-specific notes 
 
       * SQLite as of version 3.9 - see 
         :class:`sqlalchemy.dialects.sqlite.JSON` for backend-specific notes 
 
       * Microsoft SQL Server 2016 and later - see 
         :class:`sqlalchemy.dialects.mssql.JSON` for backend-specific notes 
 
    :class:`_types.JSON` is part of the Core in support of the growing 
    popularity of native JSON datatypes. 
 
    The :class:`_types.JSON` type stores arbitrary JSON format data, e.g.:: 
 
        data_table = Table('data_table', metadata, 
            Column('id', Integer, primary_key=True), 
            Column('data', JSON) 
        ) 
 
        with engine.connect() as conn: 
            conn.execute( 
                data_table.insert(), 
                {&quot;data&quot;: {&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;}} 
            ) 
 
    **JSON-Specific Expression Operators** 
 
    The :class:`_types.JSON` 
    datatype provides these additional SQL operations: 
 
    * Keyed index operations:: 
 
        data_table.c.data['some key'] 
 
    * Integer index operations:: 
 
        data_table.c.data[3] 
 
    * Path index operations:: 
 
        data_table.c.data[('key_1', 'key_2', 5, ..., 'key_n')] 
 
    * Data casters for specific JSON element types, subsequent to an index 
      or path operation being invoked:: 
 
        data_table.c.data[&quot;some key&quot;].as_integer() 
 
      .. versionadded:: 1.3.11 
 
    Additional operations may be available from the dialect-specific versions 
    of :class:`_types.JSON`, such as 
    :class:`sqlalchemy.dialects.postgresql.JSON` and 
    :class:`sqlalchemy.dialects.postgresql.JSONB` which both offer additional 
    PostgreSQL-specific operations. 
 
    **Casting JSON Elements to Other Types** 
 
    Index operations, i.e. those invoked by calling upon the expression using 
    the Python bracket operator as in ``some_column['some key']``, return an 
    expression object whose type defaults to :class:`_types.JSON` by default, 
    so that 
    further JSON-oriented instructions may be called upon the result type. 
    However, it is likely more common that an index operation is expected 
    to return a specific scalar element, such as a string or integer.  In 
    order to provide access to these elements in a backend-agnostic way, 
    a series of data casters are provided: 
 
    * :meth:`.JSON.Comparator.as_string` - return the element as a string 
 
    * :meth:`.JSON.Comparator.as_boolean` - return the element as a boolean 
 
    * :meth:`.JSON.Comparator.as_float` - return the element as a float 
 
    * :meth:`.JSON.Comparator.as_integer` - return the element as an integer 
 
    These data casters are implemented by supporting dialects in order to 
    assure that comparisons to the above types will work as expected, such as:: 
 
        # integer comparison 
        data_table.c.data[&quot;some_integer_key&quot;].as_integer() == 5 
 
        # boolean comparison 
        data_table.c.data[&quot;some_boolean&quot;].as_boolean() == True 
 
    .. versionadded:: 1.3.11 Added type-specific casters for the basic JSON 
       data element types. 
 
    .. note:: 
 
        The data caster functions are new in version 1.3.11, and supersede 
        the previous documented approaches of using CAST; for reference, 
        this looked like:: 
 
           from sqlalchemy import cast, type_coerce 
           from sqlalchemy import String, JSON 
           cast( 
               data_table.c.data['some_key'], String 
           ) == type_coerce(55, JSON) 
 
        The above case now works directly as:: 
 
            data_table.c.data['some_key'].as_integer() == 5 
 
        For details on the previous comparison approach within the 1.3.x 
        series, see the documentation for SQLAlchemy 1.2 or the included HTML 
        files in the doc/ directory of the version's distribution. 
 
    **Detecting Changes in JSON columns when using the ORM** 
 
    The :class:`_types.JSON` type, when used with the SQLAlchemy ORM, does not 
    detect in-place mutations to the structure.  In order to detect these, the 
    :mod:`sqlalchemy.ext.mutable` extension must be used, most typically 
    using the :class:`.MutableDict` class.  This extension will 
    allow &quot;in-place&quot; changes to the datastructure to produce events which 
    will be detected by the unit of work.  See the example at :class:`.HSTORE` 
    for a simple example involving a dictionary. 
 
    Alternatively, assigning a JSON structure to an ORM element that 
    replaces the old one will always trigger a change event. 
 
    **Support for JSON null vs. SQL NULL** 
 
    When working with NULL values, the :class:`_types.JSON` type recommends the 
    use of two specific constants in order to differentiate between a column 
    that evaluates to SQL NULL, e.g. no value, vs. the JSON-encoded string of 
    ``&quot;null&quot;``. To insert or select against a value that is SQL NULL, use the 
    constant :func:`.null`. This symbol may be passed as a parameter value 
    specifically when using the :class:`_types.JSON` datatype, which contains 
    special logic that interprets this symbol to mean that the column value 
    should be SQL NULL as opposed to JSON ``&quot;null&quot;``:: 
 
        from sqlalchemy import null 
        conn.execute(table.insert(), {&quot;json_value&quot;: null()}) 
 
    To insert or select against a value that is JSON ``&quot;null&quot;``, use the 
    constant :attr:`_types.JSON.NULL`:: 
 
        conn.execute(table.insert(), {&quot;json_value&quot;: JSON.NULL}) 
 
    The :class:`_types.JSON` type supports a flag 
    :paramref:`_types.JSON.none_as_null` which when set to True will result 
    in the Python constant ``None`` evaluating to the value of SQL 
    NULL, and when set to False results in the Python constant 
    ``None`` evaluating to the value of JSON ``&quot;null&quot;``.    The Python 
    value ``None`` may be used in conjunction with either 
    :attr:`_types.JSON.NULL` and :func:`.null` in order to indicate NULL 
    values, but care must be taken as to the value of the 
    :paramref:`_types.JSON.none_as_null` in these cases. 
 
    **Customizing the JSON Serializer** 
 
    The JSON serializer and deserializer used by :class:`_types.JSON` 
    defaults to 
    Python's ``json.dumps`` and ``json.loads`` functions; in the case of the 
    psycopg2 dialect, psycopg2 may be using its own custom loader function. 
 
    In order to affect the serializer / deserializer, they are currently 
    configurable at the :func:`_sa.create_engine` level via the 
    :paramref:`_sa.create_engine.json_serializer` and 
    :paramref:`_sa.create_engine.json_deserializer` parameters.  For example, 
    to turn off ``ensure_ascii``:: 
 
        engine = create_engine( 
            &quot;sqlite://&quot;, 
            json_serializer=lambda obj: json.dumps(obj, ensure_ascii=False)) 
 
    .. versionchanged:: 1.3.7 
 
        SQLite dialect's ``json_serializer`` and ``json_deserializer`` 
        parameters renamed from ``_json_serializer`` and 
        ``_json_deserializer``. 
 
    .. seealso:: 
 
        :class:`sqlalchemy.dialects.postgresql.JSON` 
 
        :class:`sqlalchemy.dialects.postgresql.JSONB` 
 
        :class:`sqlalchemy.dialects.mysql.JSON` 
 
        :class:`sqlalchemy.dialects.sqlite.JSON` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;JSON&quot;</span>

    <span class="s1">hashable </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">NULL </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">symbol</span><span class="s4">(</span><span class="s5">&quot;JSON_NULL&quot;</span><span class="s4">)</span>
    <span class="s5">&quot;&quot;&quot;Describe the json value of NULL. 
 
    This value is used to force the JSON value of ``&quot;null&quot;`` to be 
    used as the value.   A value of Python ``None`` will be recognized 
    either as SQL NULL or JSON ``&quot;null&quot;``, based on the setting 
    of the :paramref:`_types.JSON.none_as_null` flag; the 
    :attr:`_types.JSON.NULL` 
    constant can be used to always resolve to JSON ``&quot;null&quot;`` regardless 
    of this setting.  This is in contrast to the :func:`_expression.null` 
    construct, 
    which always resolves to SQL NULL.  E.g.:: 
 
        from sqlalchemy import null 
        from sqlalchemy.dialects.postgresql import JSON 
 
        # will *always* insert SQL NULL 
        obj1 = MyObject(json_value=null()) 
 
        # will *always* insert JSON string &quot;null&quot; 
        obj2 = MyObject(json_value=JSON.NULL) 
 
        session.add_all([obj1, obj2]) 
        session.commit() 
 
    In order to set JSON NULL as a default value for a column, the most 
    transparent method is to use :func:`_expression.text`:: 
 
        Table( 
            'my_table', metadata, 
            Column('json_data', JSON, default=text(&quot;'null'&quot;)) 
        ) 
 
    While it is possible to use :attr:`_types.JSON.NULL` in this context, the 
    :attr:`_types.JSON.NULL` value will be returned as the value of the 
    column, 
    which in the context of the ORM or other repurposing of the default 
    value, may not be desirable.  Using a SQL expression means the value 
    will be re-fetched from the database within the context of retrieving 
    generated defaults. 
 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">none_as_null</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Construct a :class:`_types.JSON` type. 
 
        :param none_as_null=False: if True, persist the value ``None`` as a 
         SQL NULL value, not the JSON encoding of ``null``. Note that when this 
         flag is False, the :func:`.null` construct can still be used to 
         persist a NULL value, which may be passed directly as a parameter 
         value that is specially interpreted by the :class:`_types.JSON` type 
         as SQL NULL:: 
 
             from sqlalchemy import null 
             conn.execute(table.insert(), {&quot;data&quot;: null()}) 
 
         .. note:: 
 
              :paramref:`_types.JSON.none_as_null` does **not** apply to the 
              values passed to :paramref:`_schema.Column.default` and 
              :paramref:`_schema.Column.server_default`; a value of ``None`` 
              passed for these parameters means &quot;no default present&quot;. 
 
              Additionally, when used in SQL comparison expressions, the 
              Python value ``None`` continues to refer to SQL null, and not 
              JSON NULL.  The :paramref:`_types.JSON.none_as_null` flag refers 
              explicitly to the **persistence** of the value within an 
              INSERT or UPDATE statement.   The :attr:`_types.JSON.NULL` 
              value should be used for SQL expressions that wish to compare to 
              JSON null. 
 
         .. seealso:: 
 
              :attr:`.types.JSON.NULL` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">none_as_null </span><span class="s4">= </span><span class="s1">none_as_null</span>

    <span class="s3">class </span><span class="s1">JSONElementType</span><span class="s4">(</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]):</span>
        <span class="s2">&quot;&quot;&quot;Common function for index / path elements in a JSON expression.&quot;&quot;&quot;</span>

        <span class="s1">_integer </span><span class="s4">= </span><span class="s1">Integer</span><span class="s4">()</span>
        <span class="s1">_string </span><span class="s4">= </span><span class="s1">String</span><span class="s4">()</span>

        <span class="s3">def </span><span class="s1">string_bind_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_string</span><span class="s4">.</span><span class="s1">_cached_bind_processor</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">string_literal_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_string</span><span class="s4">.</span><span class="s1">_cached_literal_processor</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">bind_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
            <span class="s1">int_processor </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_integer</span><span class="s4">.</span><span class="s1">_cached_bind_processor</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">)</span>
            <span class="s1">string_processor </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">string_bind_processor</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">)</span>

            <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                <span class="s3">if </span><span class="s1">int_processor </span><span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">int</span><span class="s4">):</span>
                    <span class="s1">value </span><span class="s4">= </span><span class="s1">int_processor</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
                <span class="s3">elif </span><span class="s1">string_processor </span><span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
                    <span class="s1">value </span><span class="s4">= </span><span class="s1">string_processor</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
                <span class="s3">return </span><span class="s1">value</span>

            <span class="s3">return </span><span class="s1">process</span>

        <span class="s3">def </span><span class="s1">literal_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
            <span class="s1">int_processor </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_integer</span><span class="s4">.</span><span class="s1">_cached_literal_processor</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">)</span>
            <span class="s1">string_processor </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">string_literal_processor</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">)</span>

            <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                <span class="s3">if </span><span class="s1">int_processor </span><span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">int</span><span class="s4">):</span>
                    <span class="s1">value </span><span class="s4">= </span><span class="s1">int_processor</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
                <span class="s3">elif </span><span class="s1">string_processor </span><span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
                    <span class="s1">value </span><span class="s4">= </span><span class="s1">string_processor</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">()</span>

                <span class="s3">return </span><span class="s1">value</span>

            <span class="s3">return </span><span class="s1">process</span>

    <span class="s3">class </span><span class="s1">JSONIndexType</span><span class="s4">(</span><span class="s1">JSONElementType</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Placeholder for the datatype of a JSON index value. 
 
        This allows execution-time processing of JSON index values 
        for special syntaxes. 
 
        &quot;&quot;&quot;</span>

    <span class="s3">class </span><span class="s1">JSONIntIndexType</span><span class="s4">(</span><span class="s1">JSONIndexType</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Placeholder for the datatype of a JSON index value. 
 
        This allows execution-time processing of JSON index values 
        for special syntaxes. 
 
        &quot;&quot;&quot;</span>

    <span class="s3">class </span><span class="s1">JSONStrIndexType</span><span class="s4">(</span><span class="s1">JSONIndexType</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Placeholder for the datatype of a JSON index value. 
 
        This allows execution-time processing of JSON index values 
        for special syntaxes. 
 
        &quot;&quot;&quot;</span>

    <span class="s3">class </span><span class="s1">JSONPathType</span><span class="s4">(</span><span class="s1">JSONElementType</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Placeholder type for JSON path operations. 
 
        This allows execution-time processing of a path-based 
        index value into a specific SQL syntax. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;json_path&quot;</span>

    <span class="s3">class </span><span class="s1">Comparator</span><span class="s4">(</span><span class="s1">Indexable</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">], </span><span class="s1">Concatenable</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
        <span class="s2">&quot;&quot;&quot;Define comparison operations for :class:`_types.JSON`.&quot;&quot;&quot;</span>

        <span class="s1">__slots__ </span><span class="s4">= ()</span>

        <span class="s3">def </span><span class="s1">_setup_getitem</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">index</span><span class="s4">):</span>
            <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">index</span><span class="s4">, </span><span class="s1">str</span><span class="s4">) </span><span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span>
                <span class="s1">index</span><span class="s4">, </span><span class="s1">collections_abc</span><span class="s4">.</span><span class="s1">Sequence</span>
            <span class="s4">):</span>
                <span class="s1">index </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                    <span class="s1">roles</span><span class="s4">.</span><span class="s1">BinaryElementRole</span><span class="s4">,</span>
                    <span class="s1">index</span><span class="s4">,</span>
                    <span class="s1">expr</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span><span class="s4">,</span>
                    <span class="s1">operator</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">json_path_getitem_op</span><span class="s4">,</span>
                    <span class="s1">bindparam_type</span><span class="s4">=</span><span class="s1">JSON</span><span class="s4">.</span><span class="s1">JSONPathType</span><span class="s4">,</span>
                <span class="s4">)</span>

                <span class="s1">operator </span><span class="s4">= </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">json_path_getitem_op</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s1">index </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                    <span class="s1">roles</span><span class="s4">.</span><span class="s1">BinaryElementRole</span><span class="s4">,</span>
                    <span class="s1">index</span><span class="s4">,</span>
                    <span class="s1">expr</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span><span class="s4">,</span>
                    <span class="s1">operator</span><span class="s4">=</span><span class="s1">operators</span><span class="s4">.</span><span class="s1">json_getitem_op</span><span class="s4">,</span>
                    <span class="s1">bindparam_type</span><span class="s4">=(</span>
                        <span class="s1">JSON</span><span class="s4">.</span><span class="s1">JSONIntIndexType</span>
                        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">index</span><span class="s4">, </span><span class="s1">int</span><span class="s4">)</span>
                        <span class="s3">else </span><span class="s1">JSON</span><span class="s4">.</span><span class="s1">JSONStrIndexType</span>
                    <span class="s4">),</span>
                <span class="s4">)</span>
                <span class="s1">operator </span><span class="s4">= </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">json_getitem_op</span>

            <span class="s3">return </span><span class="s1">operator</span><span class="s4">, </span><span class="s1">index</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span>

        <span class="s3">def </span><span class="s1">as_boolean</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
            <span class="s2">&quot;&quot;&quot;Consider an indexed value as boolean. 
 
            This is similar to using :class:`_sql.type_coerce`, and will 
            usually not apply a ``CAST()``. 
 
            e.g.:: 
 
                stmt = select( 
                    mytable.c.json_column['some_data'].as_boolean() 
                ).where( 
                    mytable.c.json_column['some_data'].as_boolean() == True 
                ) 
 
            .. versionadded:: 1.3.11 
 
            &quot;&quot;&quot;</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_binary_w_type</span><span class="s4">(</span><span class="s1">Boolean</span><span class="s4">(), </span><span class="s5">&quot;as_boolean&quot;</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">as_string</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
            <span class="s2">&quot;&quot;&quot;Consider an indexed value as string. 
 
            This is similar to using :class:`_sql.type_coerce`, and will 
            usually not apply a ``CAST()``. 
 
            e.g.:: 
 
                stmt = select( 
                    mytable.c.json_column['some_data'].as_string() 
                ).where( 
                    mytable.c.json_column['some_data'].as_string() == 
                    'some string' 
                ) 
 
            .. versionadded:: 1.3.11 
 
            &quot;&quot;&quot;</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_binary_w_type</span><span class="s4">(</span><span class="s1">Unicode</span><span class="s4">(), </span><span class="s5">&quot;as_string&quot;</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">as_integer</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
            <span class="s2">&quot;&quot;&quot;Consider an indexed value as integer. 
 
            This is similar to using :class:`_sql.type_coerce`, and will 
            usually not apply a ``CAST()``. 
 
            e.g.:: 
 
                stmt = select( 
                    mytable.c.json_column['some_data'].as_integer() 
                ).where( 
                    mytable.c.json_column['some_data'].as_integer() == 5 
                ) 
 
            .. versionadded:: 1.3.11 
 
            &quot;&quot;&quot;</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_binary_w_type</span><span class="s4">(</span><span class="s1">Integer</span><span class="s4">(), </span><span class="s5">&quot;as_integer&quot;</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">as_float</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
            <span class="s2">&quot;&quot;&quot;Consider an indexed value as float. 
 
            This is similar to using :class:`_sql.type_coerce`, and will 
            usually not apply a ``CAST()``. 
 
            e.g.:: 
 
                stmt = select( 
                    mytable.c.json_column['some_data'].as_float() 
                ).where( 
                    mytable.c.json_column['some_data'].as_float() == 29.75 
                ) 
 
            .. versionadded:: 1.3.11 
 
            &quot;&quot;&quot;</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_binary_w_type</span><span class="s4">(</span><span class="s1">Float</span><span class="s4">(), </span><span class="s5">&quot;as_float&quot;</span><span class="s4">)</span>

        <span class="s3">def </span><span class="s1">as_numeric</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">precision</span><span class="s4">, </span><span class="s1">scale</span><span class="s4">, </span><span class="s1">asdecimal</span><span class="s4">=</span><span class="s3">True</span><span class="s4">):</span>
            <span class="s2">&quot;&quot;&quot;Consider an indexed value as numeric/decimal. 
 
            This is similar to using :class:`_sql.type_coerce`, and will 
            usually not apply a ``CAST()``. 
 
            e.g.:: 
 
                stmt = select( 
                    mytable.c.json_column['some_data'].as_numeric(10, 6) 
                ).where( 
                    mytable.c. 
                    json_column['some_data'].as_numeric(10, 6) == 29.75 
                ) 
 
            .. versionadded:: 1.4.0b2 
 
            &quot;&quot;&quot;</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_binary_w_type</span><span class="s4">(</span>
                <span class="s1">Numeric</span><span class="s4">(</span><span class="s1">precision</span><span class="s4">, </span><span class="s1">scale</span><span class="s4">, </span><span class="s1">asdecimal</span><span class="s4">=</span><span class="s1">asdecimal</span><span class="s4">), </span><span class="s5">&quot;as_numeric&quot;</span>
            <span class="s4">)</span>

        <span class="s3">def </span><span class="s1">as_json</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
            <span class="s2">&quot;&quot;&quot;Consider an indexed value as JSON. 
 
            This is similar to using :class:`_sql.type_coerce`, and will 
            usually not apply a ``CAST()``. 
 
            e.g.:: 
 
                stmt = select(mytable.c.json_column['some_data'].as_json()) 
 
            This is typically the default behavior of indexed elements in any 
            case. 
 
            Note that comparison of full JSON structures may not be 
            supported by all backends. 
 
            .. versionadded:: 1.3.11 
 
            &quot;&quot;&quot;</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span>

        <span class="s3">def </span><span class="s1">_binary_w_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">typ</span><span class="s4">, </span><span class="s1">method_name</span><span class="s4">):</span>
            <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span><span class="s4">, </span><span class="s1">elements</span><span class="s4">.</span><span class="s1">BinaryExpression</span>
            <span class="s4">) </span><span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span><span class="s4">.</span><span class="s1">operator </span><span class="s3">not in </span><span class="s4">(</span>
                <span class="s1">operators</span><span class="s4">.</span><span class="s1">json_getitem_op</span><span class="s4">,</span>
                <span class="s1">operators</span><span class="s4">.</span><span class="s1">json_path_getitem_op</span><span class="s4">,</span>
            <span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                    <span class="s5">&quot;The JSON cast operator JSON.%s() only works with a JSON &quot;</span>
                    <span class="s5">&quot;index expression e.g. col['q'].%s()&quot;</span>
                    <span class="s4">% (</span><span class="s1">method_name</span><span class="s4">, </span><span class="s1">method_name</span><span class="s4">)</span>
                <span class="s4">)</span>
            <span class="s1">expr </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span><span class="s4">.</span><span class="s1">_clone</span><span class="s4">()</span>
            <span class="s1">expr</span><span class="s4">.</span><span class="s1">type </span><span class="s4">= </span><span class="s1">typ</span>
            <span class="s3">return </span><span class="s1">expr</span>

    <span class="s1">comparator_factory </span><span class="s4">= </span><span class="s1">Comparator</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">python_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">dict</span>

    <span class="s4">@</span><span class="s1">property  </span><span class="s0"># type: ignore  # mypy property bug</span>
    <span class="s3">def </span><span class="s1">should_evaluate_none</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Alias of :attr:`_types.JSON.none_as_null`&quot;&quot;&quot;</span>
        <span class="s3">return not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">none_as_null</span>

    <span class="s4">@</span><span class="s1">should_evaluate_none</span><span class="s4">.</span><span class="s1">setter</span>
    <span class="s3">def </span><span class="s1">should_evaluate_none</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">none_as_null </span><span class="s4">= </span><span class="s3">not </span><span class="s1">value</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_str_impl</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">String</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_make_bind_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">string_process</span><span class="s4">, </span><span class="s1">json_serializer</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">string_process</span><span class="s4">:</span>

            <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                <span class="s3">if </span><span class="s1">value </span><span class="s3">is </span><span class="s1">self</span><span class="s4">.</span><span class="s1">NULL</span><span class="s4">:</span>
                    <span class="s1">value </span><span class="s4">= </span><span class="s3">None</span>
                <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">elements</span><span class="s4">.</span><span class="s1">Null</span><span class="s4">) </span><span class="s3">or </span><span class="s4">(</span>
                    <span class="s1">value </span><span class="s3">is None and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">none_as_null</span>
                <span class="s4">):</span>
                    <span class="s3">return None</span>

                <span class="s1">serialized </span><span class="s4">= </span><span class="s1">json_serializer</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
                <span class="s3">return </span><span class="s1">string_process</span><span class="s4">(</span><span class="s1">serialized</span><span class="s4">)</span>

        <span class="s3">else</span><span class="s4">:</span>

            <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                <span class="s3">if </span><span class="s1">value </span><span class="s3">is </span><span class="s1">self</span><span class="s4">.</span><span class="s1">NULL</span><span class="s4">:</span>
                    <span class="s1">value </span><span class="s4">= </span><span class="s3">None</span>
                <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">elements</span><span class="s4">.</span><span class="s1">Null</span><span class="s4">) </span><span class="s3">or </span><span class="s4">(</span>
                    <span class="s1">value </span><span class="s3">is None and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">none_as_null</span>
                <span class="s4">):</span>
                    <span class="s3">return None</span>

                <span class="s3">return </span><span class="s1">json_serializer</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">process</span>

    <span class="s3">def </span><span class="s1">bind_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s1">string_process </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_str_impl</span><span class="s4">.</span><span class="s1">bind_processor</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">)</span>
        <span class="s1">json_serializer </span><span class="s4">= </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">_json_serializer </span><span class="s3">or </span><span class="s1">json</span><span class="s4">.</span><span class="s1">dumps</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_make_bind_processor</span><span class="s4">(</span><span class="s1">string_process</span><span class="s4">, </span><span class="s1">json_serializer</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">result_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">):</span>
        <span class="s1">string_process </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_str_impl</span><span class="s4">.</span><span class="s1">result_processor</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">)</span>
        <span class="s1">json_deserializer </span><span class="s4">= </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">_json_deserializer </span><span class="s3">or </span><span class="s1">json</span><span class="s4">.</span><span class="s1">loads</span>

        <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
            <span class="s3">if </span><span class="s1">value </span><span class="s3">is None</span><span class="s4">:</span>
                <span class="s3">return None</span>
            <span class="s3">if </span><span class="s1">string_process</span><span class="s4">:</span>
                <span class="s1">value </span><span class="s4">= </span><span class="s1">string_process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
            <span class="s3">return </span><span class="s1">json_deserializer</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">process</span>


<span class="s3">class </span><span class="s1">ARRAY</span><span class="s4">(</span>
    <span class="s1">SchemaEventTarget</span><span class="s4">, </span><span class="s1">Indexable</span><span class="s4">, </span><span class="s1">Concatenable</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represent a SQL Array type. 
 
    .. note::  This type serves as the basis for all ARRAY operations. 
       However, currently **only the PostgreSQL backend has support for SQL 
       arrays in SQLAlchemy**. It is recommended to use the PostgreSQL-specific 
       :class:`sqlalchemy.dialects.postgresql.ARRAY` type directly when using 
       ARRAY types with PostgreSQL, as it provides additional operators 
       specific to that backend. 
 
    :class:`_types.ARRAY` is part of the Core in support of various SQL 
    standard functions such as :class:`_functions.array_agg` 
    which explicitly involve 
    arrays; however, with the exception of the PostgreSQL backend and possibly 
    some third-party dialects, no other SQLAlchemy built-in dialect has support 
    for this type. 
 
    An :class:`_types.ARRAY` type is constructed given the &quot;type&quot; 
    of element:: 
 
        mytable = Table(&quot;mytable&quot;, metadata, 
                Column(&quot;data&quot;, ARRAY(Integer)) 
            ) 
 
    The above type represents an N-dimensional array, 
    meaning a supporting backend such as PostgreSQL will interpret values 
    with any number of dimensions automatically.   To produce an INSERT 
    construct that passes in a 1-dimensional array of integers:: 
 
        connection.execute( 
                mytable.insert(), 
                {&quot;data&quot;: [1,2,3]} 
        ) 
 
    The :class:`_types.ARRAY` type can be constructed given a fixed number 
    of dimensions:: 
 
        mytable = Table(&quot;mytable&quot;, metadata, 
                Column(&quot;data&quot;, ARRAY(Integer, dimensions=2)) 
            ) 
 
    Sending a number of dimensions is optional, but recommended if the 
    datatype is to represent arrays of more than one dimension.  This number 
    is used: 
 
    * When emitting the type declaration itself to the database, e.g. 
      ``INTEGER[][]`` 
 
    * When translating Python values to database values, and vice versa, e.g. 
      an ARRAY of :class:`.Unicode` objects uses this number to efficiently 
      access the string values inside of array structures without resorting 
      to per-row type inspection 
 
    * When used with the Python ``getitem`` accessor, the number of dimensions 
      serves to define the kind of type that the ``[]`` operator should 
      return, e.g. for an ARRAY of INTEGER with two dimensions:: 
 
          &gt;&gt;&gt; expr = table.c.column[5]  # returns ARRAY(Integer, dimensions=1) 
          &gt;&gt;&gt; expr = expr[6]  # returns Integer 
 
    For 1-dimensional arrays, an :class:`_types.ARRAY` instance with no 
    dimension parameter will generally assume single-dimensional behaviors. 
 
    SQL expressions of type :class:`_types.ARRAY` have support for &quot;index&quot; and 
    &quot;slice&quot; behavior.  The ``[]`` operator produces expression 
    constructs which will produce the appropriate SQL, both for 
    SELECT statements:: 
 
        select(mytable.c.data[5], mytable.c.data[2:7]) 
 
    as well as UPDATE statements when the :meth:`_expression.Update.values` 
    method is used:: 
 
        mytable.update().values({ 
            mytable.c.data[5]: 7, 
            mytable.c.data[2:7]: [1, 2, 3] 
        }) 
 
    Indexed access is one-based by default; 
    for zero-based index conversion, set :paramref:`_types.ARRAY.zero_indexes`. 
 
    The :class:`_types.ARRAY` type also provides for the operators 
    :meth:`.types.ARRAY.Comparator.any` and 
    :meth:`.types.ARRAY.Comparator.all`. The PostgreSQL-specific version of 
    :class:`_types.ARRAY` also provides additional operators. 
 
    .. container:: topic 
 
        **Detecting Changes in ARRAY columns when using the ORM** 
 
        The :class:`_sqltypes.ARRAY` type, when used with the SQLAlchemy ORM, 
        does not detect in-place mutations to the array. In order to detect 
        these, the :mod:`sqlalchemy.ext.mutable` extension must be used, using 
        the :class:`.MutableList` class:: 
 
            from sqlalchemy import ARRAY 
            from sqlalchemy.ext.mutable import MutableList 
 
            class SomeOrmClass(Base): 
                # ... 
 
                data = Column(MutableList.as_mutable(ARRAY(Integer))) 
 
        This extension will allow &quot;in-place&quot; changes such to the array 
        such as ``.append()`` to produce events which will be detected by the 
        unit of work.  Note that changes to elements **inside** the array, 
        including subarrays that are mutated in place, are **not** detected. 
 
        Alternatively, assigning a new array value to an ORM element that 
        replaces the old one will always trigger a change event. 
 
    .. seealso:: 
 
        :class:`sqlalchemy.dialects.postgresql.ARRAY` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;ARRAY&quot;</span>

    <span class="s1">_is_array </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">zero_indexes </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s5">&quot;&quot;&quot;If True, Python zero-based indexes should be interpreted as one-based 
    on the SQL expression side.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">item_type</span><span class="s4">: </span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">as_tuple</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">dimensions</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">int</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">zero_indexes</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Construct an :class:`_types.ARRAY`. 
 
        E.g.:: 
 
          Column('myarray', ARRAY(Integer)) 
 
        Arguments are: 
 
        :param item_type: The data type of items of this array. Note that 
          dimensionality is irrelevant here, so multi-dimensional arrays like 
          ``INTEGER[][]``, are constructed as ``ARRAY(Integer)``, not as 
          ``ARRAY(ARRAY(Integer))`` or such. 
 
        :param as_tuple=False: Specify whether return results 
          should be converted to tuples from lists.  This parameter is 
          not generally needed as a Python list corresponds well 
          to a SQL array. 
 
        :param dimensions: if non-None, the ARRAY will assume a fixed 
         number of dimensions.   This impacts how the array is declared 
         on the database, how it goes about interpreting Python and 
         result values, as well as how expression behavior in conjunction 
         with the &quot;getitem&quot; operator works.  See the description at 
         :class:`_types.ARRAY` for additional detail. 
 
        :param zero_indexes=False: when True, index values will be converted 
         between Python zero-based and SQL one-based indexes, e.g. 
         a value of one will be added to all index values before passing 
         to the database. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">item_type</span><span class="s4">, </span><span class="s1">ARRAY</span><span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;Do not nest ARRAY types; ARRAY(basetype) &quot;</span>
                <span class="s5">&quot;handles multi-dimensional arrays of basetype&quot;</span>
            <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">item_type</span><span class="s4">, </span><span class="s1">type</span><span class="s4">):</span>
            <span class="s1">item_type </span><span class="s4">= </span><span class="s1">item_type</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">item_type </span><span class="s4">= </span><span class="s1">item_type</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">as_tuple </span><span class="s4">= </span><span class="s1">as_tuple</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">dimensions </span><span class="s4">= </span><span class="s1">dimensions</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">zero_indexes </span><span class="s4">= </span><span class="s1">zero_indexes</span>

    <span class="s3">class </span><span class="s1">Comparator</span><span class="s4">(</span>
        <span class="s1">Indexable</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
        <span class="s1">Concatenable</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]],</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Define comparison operations for :class:`_types.ARRAY`. 
 
        More operators are available on the dialect-specific form 
        of this type.  See :class:`.postgresql.ARRAY.Comparator`. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">__slots__ </span><span class="s4">= ()</span>

        <span class="s1">type</span><span class="s4">: </span><span class="s1">ARRAY</span>

        <span class="s3">def </span><span class="s1">_setup_getitem</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">index</span><span class="s4">):</span>
            <span class="s1">arr_type </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span>

            <span class="s1">return_type</span><span class="s4">: </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>

            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">index</span><span class="s4">, </span><span class="s1">slice</span><span class="s4">):</span>
                <span class="s1">return_type </span><span class="s4">= </span><span class="s1">arr_type</span>
                <span class="s3">if </span><span class="s1">arr_type</span><span class="s4">.</span><span class="s1">zero_indexes</span><span class="s4">:</span>
                    <span class="s1">index </span><span class="s4">= </span><span class="s1">slice</span><span class="s4">(</span><span class="s1">index</span><span class="s4">.</span><span class="s1">start </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">, </span><span class="s1">index</span><span class="s4">.</span><span class="s1">stop </span><span class="s4">+ </span><span class="s6">1</span><span class="s4">, </span><span class="s1">index</span><span class="s4">.</span><span class="s1">step</span><span class="s4">)</span>
                <span class="s1">slice_ </span><span class="s4">= </span><span class="s1">Slice</span><span class="s4">(</span>
                    <span class="s1">index</span><span class="s4">.</span><span class="s1">start</span><span class="s4">, </span><span class="s1">index</span><span class="s4">.</span><span class="s1">stop</span><span class="s4">, </span><span class="s1">index</span><span class="s4">.</span><span class="s1">step</span><span class="s4">, </span><span class="s1">_name</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span><span class="s4">.</span><span class="s1">key</span>
                <span class="s4">)</span>
                <span class="s3">return </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">getitem</span><span class="s4">, </span><span class="s1">slice_</span><span class="s4">, </span><span class="s1">return_type</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s1">arr_type</span><span class="s4">.</span><span class="s1">zero_indexes</span><span class="s4">:</span>
                    <span class="s1">index </span><span class="s4">+= </span><span class="s6">1</span>
                <span class="s3">if </span><span class="s1">arr_type</span><span class="s4">.</span><span class="s1">dimensions </span><span class="s3">is None or </span><span class="s1">arr_type</span><span class="s4">.</span><span class="s1">dimensions </span><span class="s4">== </span><span class="s6">1</span><span class="s4">:</span>
                    <span class="s1">return_type </span><span class="s4">= </span><span class="s1">arr_type</span><span class="s4">.</span><span class="s1">item_type</span>
                <span class="s3">else</span><span class="s4">:</span>
                    <span class="s1">adapt_kw </span><span class="s4">= {</span><span class="s5">&quot;dimensions&quot;</span><span class="s4">: </span><span class="s1">arr_type</span><span class="s4">.</span><span class="s1">dimensions </span><span class="s4">- </span><span class="s6">1</span><span class="s4">}</span>
                    <span class="s1">return_type </span><span class="s4">= </span><span class="s1">arr_type</span><span class="s4">.</span><span class="s1">adapt</span><span class="s4">(</span>
                        <span class="s1">arr_type</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">, **</span><span class="s1">adapt_kw</span>
                    <span class="s4">)</span>

                <span class="s3">return </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">getitem</span><span class="s4">, </span><span class="s1">index</span><span class="s4">, </span><span class="s1">return_type</span>

        <span class="s3">def </span><span class="s1">contains</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">arg</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
            <span class="s2">&quot;&quot;&quot;``ARRAY.contains()`` not implemented for the base ARRAY type. 
            Use the dialect-specific ARRAY type. 
 
            .. seealso:: 
 
                :class:`_postgresql.ARRAY` - PostgreSQL specific version. 
            &quot;&quot;&quot;</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">(</span>
                <span class="s5">&quot;ARRAY.contains() not implemented for the base &quot;</span>
                <span class="s5">&quot;ARRAY type; please use the dialect-specific ARRAY type&quot;</span>
            <span class="s4">)</span>

        <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.elements&quot;</span><span class="s4">)</span>
        <span class="s3">def </span><span class="s1">any</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
            <span class="s2">&quot;&quot;&quot;Return ``other operator ANY (array)`` clause. 
 
            .. legacy:: This method is an :class:`_types.ARRAY` - specific 
                construct that is now superseded by the :func:`_sql.any_` 
                function, which features a different calling style. The 
                :func:`_sql.any_` function is also mirrored at the method level 
                via the :meth:`_sql.ColumnOperators.any_` method. 
 
            Usage of array-specific :meth:`_types.ARRAY.Comparator.any` 
            is as follows:: 
 
                from sqlalchemy.sql import operators 
 
                conn.execute( 
                    select(table.c.data).where( 
                            table.c.data.any(7, operator=operators.lt) 
                        ) 
                ) 
 
            :param other: expression to be compared 
            :param operator: an operator object from the 
             :mod:`sqlalchemy.sql.operators` 
             package, defaults to :func:`.operators.eq`. 
 
            .. seealso:: 
 
                :func:`_expression.any_` 
 
                :meth:`.types.ARRAY.Comparator.all` 
 
            &quot;&quot;&quot;</span>
            <span class="s1">elements </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_elements</span>
            <span class="s1">operator </span><span class="s4">= </span><span class="s1">operator </span><span class="s3">if </span><span class="s1">operator </span><span class="s3">else </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">eq</span>

            <span class="s1">arr_type </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span>

            <span class="s3">return </span><span class="s1">elements</span><span class="s4">.</span><span class="s1">CollectionAggregate</span><span class="s4">.</span><span class="s1">_create_any</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span><span class="s4">).</span><span class="s1">operate</span><span class="s4">(</span>
                <span class="s1">operators</span><span class="s4">.</span><span class="s1">mirror</span><span class="s4">(</span><span class="s1">operator</span><span class="s4">),</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                    <span class="s1">roles</span><span class="s4">.</span><span class="s1">BinaryElementRole</span><span class="s4">,</span>
                    <span class="s1">element</span><span class="s4">=</span><span class="s1">other</span><span class="s4">,</span>
                    <span class="s1">operator</span><span class="s4">=</span><span class="s1">operator</span><span class="s4">,</span>
                    <span class="s1">expr</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span><span class="s4">,</span>
                    <span class="s1">bindparam_type</span><span class="s4">=</span><span class="s1">arr_type</span><span class="s4">.</span><span class="s1">item_type</span><span class="s4">,</span>
                <span class="s4">),</span>
            <span class="s4">)</span>

        <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.sql.elements&quot;</span><span class="s4">)</span>
        <span class="s3">def </span><span class="s1">all</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">other</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">=</span><span class="s3">None</span><span class="s4">):</span>
            <span class="s2">&quot;&quot;&quot;Return ``other operator ALL (array)`` clause. 
 
            .. legacy:: This method is an :class:`_types.ARRAY` - specific 
                construct that is now superseded by the :func:`_sql.all_` 
                function, which features a different calling style. The 
                :func:`_sql.all_` function is also mirrored at the method level 
                via the :meth:`_sql.ColumnOperators.all_` method. 
 
            Usage of array-specific :meth:`_types.ARRAY.Comparator.all` 
            is as follows:: 
 
                from sqlalchemy.sql import operators 
 
                conn.execute( 
                    select(table.c.data).where( 
                            table.c.data.all(7, operator=operators.lt) 
                        ) 
                ) 
 
            :param other: expression to be compared 
            :param operator: an operator object from the 
             :mod:`sqlalchemy.sql.operators` 
             package, defaults to :func:`.operators.eq`. 
 
            .. seealso:: 
 
                :func:`_expression.all_` 
 
                :meth:`.types.ARRAY.Comparator.any` 
 
            &quot;&quot;&quot;</span>
            <span class="s1">elements </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">sql_elements</span>
            <span class="s1">operator </span><span class="s4">= </span><span class="s1">operator </span><span class="s3">if </span><span class="s1">operator </span><span class="s3">else </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">eq</span>

            <span class="s1">arr_type </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">type</span>

            <span class="s3">return </span><span class="s1">elements</span><span class="s4">.</span><span class="s1">CollectionAggregate</span><span class="s4">.</span><span class="s1">_create_all</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span><span class="s4">).</span><span class="s1">operate</span><span class="s4">(</span>
                <span class="s1">operators</span><span class="s4">.</span><span class="s1">mirror</span><span class="s4">(</span><span class="s1">operator</span><span class="s4">),</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                    <span class="s1">roles</span><span class="s4">.</span><span class="s1">BinaryElementRole</span><span class="s4">,</span>
                    <span class="s1">element</span><span class="s4">=</span><span class="s1">other</span><span class="s4">,</span>
                    <span class="s1">operator</span><span class="s4">=</span><span class="s1">operator</span><span class="s4">,</span>
                    <span class="s1">expr</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span><span class="s4">,</span>
                    <span class="s1">bindparam_type</span><span class="s4">=</span><span class="s1">arr_type</span><span class="s4">.</span><span class="s1">item_type</span><span class="s4">,</span>
                <span class="s4">),</span>
            <span class="s4">)</span>

    <span class="s1">comparator_factory </span><span class="s4">= </span><span class="s1">Comparator</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">hashable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">as_tuple</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">python_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">list</span>

    <span class="s3">def </span><span class="s1">compare_values</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">x</span><span class="s4">, </span><span class="s1">y</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">x </span><span class="s4">== </span><span class="s1">y</span>

    <span class="s3">def </span><span class="s1">_set_parent</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">parent</span><span class="s4">, </span><span class="s1">outer</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Support SchemaEventTarget&quot;&quot;&quot;</span>

        <span class="s3">if not </span><span class="s1">outer </span><span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">item_type</span><span class="s4">, </span><span class="s1">SchemaEventTarget</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">item_type</span><span class="s4">.</span><span class="s1">_set_parent</span><span class="s4">(</span><span class="s1">parent</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_set_parent_with_dispatch</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">parent</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Support SchemaEventTarget&quot;&quot;&quot;</span>

        <span class="s1">super</span><span class="s4">().</span><span class="s1">_set_parent_with_dispatch</span><span class="s4">(</span><span class="s1">parent</span><span class="s4">, </span><span class="s1">outer</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">item_type</span><span class="s4">, </span><span class="s1">SchemaEventTarget</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">item_type</span><span class="s4">.</span><span class="s1">_set_parent_with_dispatch</span><span class="s4">(</span><span class="s1">parent</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">literal_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s1">item_proc </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">item_type</span><span class="s4">.</span><span class="s1">dialect_impl</span><span class="s4">(</span><span class="s1">dialect</span><span class="s4">).</span><span class="s1">literal_processor</span><span class="s4">(</span>
            <span class="s1">dialect</span>
        <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">item_proc </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s3">return None</span>

        <span class="s3">def </span><span class="s1">to_str</span><span class="s4">(</span><span class="s1">elements</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s5">f&quot;[</span><span class="s3">{</span><span class="s5">', '</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">elements</span><span class="s4">)</span><span class="s3">}</span><span class="s5">]&quot;</span>

        <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
            <span class="s1">inner </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_apply_item_processor</span><span class="s4">(</span>
                <span class="s1">value</span><span class="s4">, </span><span class="s1">item_proc</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dimensions</span><span class="s4">, </span><span class="s1">to_str</span>
            <span class="s4">)</span>
            <span class="s3">return </span><span class="s1">inner</span>

        <span class="s3">return </span><span class="s1">process</span>

    <span class="s3">def </span><span class="s1">_apply_item_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">arr</span><span class="s4">, </span><span class="s1">itemproc</span><span class="s4">, </span><span class="s1">dim</span><span class="s4">, </span><span class="s1">collection_callable</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Helper method that can be used by bind_processor(), 
        literal_processor(), etc. to apply an item processor to elements of 
        an array value, taking into account the 'dimensions' for this 
        array type. 
 
        See the Postgresql ARRAY datatype for usage examples. 
 
        .. versionadded:: 2.0 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">dim </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">arr </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">arr</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">dim </span><span class="s4">== </span><span class="s6">1</span>
            <span class="s3">or </span><span class="s1">dim </span><span class="s3">is None</span>
            <span class="s3">and </span><span class="s4">(</span>
                <span class="s0"># this has to be (list, tuple), or at least</span>
                <span class="s0"># not hasattr('__iter__'), since Py3K strings</span>
                <span class="s0"># etc. have __iter__</span>
                <span class="s3">not </span><span class="s1">arr</span>
                <span class="s3">or not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">arr</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], (</span><span class="s1">list</span><span class="s4">, </span><span class="s1">tuple</span><span class="s4">))</span>
            <span class="s4">)</span>
        <span class="s4">):</span>
            <span class="s3">if </span><span class="s1">itemproc</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">collection_callable</span><span class="s4">(</span><span class="s1">itemproc</span><span class="s4">(</span><span class="s1">x</span><span class="s4">) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">arr</span><span class="s4">)</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">collection_callable</span><span class="s4">(</span><span class="s1">arr</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">collection_callable</span><span class="s4">(</span>
                <span class="s4">(</span>
                    <span class="s1">self</span><span class="s4">.</span><span class="s1">_apply_item_processor</span><span class="s4">(</span>
                        <span class="s1">x</span><span class="s4">,</span>
                        <span class="s1">itemproc</span><span class="s4">,</span>
                        <span class="s1">dim </span><span class="s4">- </span><span class="s6">1 </span><span class="s3">if </span><span class="s1">dim </span><span class="s3">is not None else None</span><span class="s4">,</span>
                        <span class="s1">collection_callable</span><span class="s4">,</span>
                    <span class="s4">)</span>
                    <span class="s3">if </span><span class="s1">x </span><span class="s3">is not None</span>
                    <span class="s3">else None</span>
                <span class="s4">)</span>
                <span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">arr</span>
            <span class="s4">)</span>


<span class="s3">class </span><span class="s1">TupleType</span><span class="s4">(</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, ...]]):</span>
    <span class="s2">&quot;&quot;&quot;represent the composite type of a Tuple.&quot;&quot;&quot;</span>

    <span class="s1">_is_tuple_type </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">types</span><span class="s4">: </span><span class="s1">List</span><span class="s4">[</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">types</span><span class="s4">: </span><span class="s1">_TypeEngineArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_fully_typed </span><span class="s4">= </span><span class="s1">NULLTYPE </span><span class="s3">not in </span><span class="s1">types</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">types </span><span class="s4">= [</span>
            <span class="s1">item_type</span><span class="s4">() </span><span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">item_type</span><span class="s4">, </span><span class="s1">type</span><span class="s4">) </span><span class="s3">else </span><span class="s1">item_type</span>
            <span class="s3">for </span><span class="s1">item_type </span><span class="s3">in </span><span class="s1">types</span>
        <span class="s4">]</span>

    <span class="s3">def </span><span class="s1">coerce_compared_value</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">op</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">], </span><span class="s1">value</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">value </span><span class="s3">is </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">_NO_VALUE_IN_LIST</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">coerce_compared_value</span><span class="s4">(</span><span class="s1">op</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">TupleType</span><span class="s4">(</span>
                <span class="s4">*[</span>
                    <span class="s1">typ</span><span class="s4">.</span><span class="s1">coerce_compared_value</span><span class="s4">(</span><span class="s1">op</span><span class="s4">, </span><span class="s1">elem</span><span class="s4">)</span>
                    <span class="s3">for </span><span class="s1">typ</span><span class="s4">, </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">types</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>
                <span class="s4">]</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_resolve_values_to_types</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; TupleType</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_fully_typed</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">TupleType</span><span class="s4">(</span>
                <span class="s4">*[</span>
                    <span class="s1">_resolve_value_to_type</span><span class="s4">(</span><span class="s1">elem</span><span class="s4">) </span><span class="s3">if </span><span class="s1">typ </span><span class="s3">is </span><span class="s1">NULLTYPE </span><span class="s3">else </span><span class="s1">typ</span>
                    <span class="s3">for </span><span class="s1">typ</span><span class="s4">, </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">zip</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">types</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>
                <span class="s4">]</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">result_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">(</span>
            <span class="s5">&quot;The tuple type does not support being fetched &quot;</span>
            <span class="s5">&quot;as a column in a result row.&quot;</span>
        <span class="s4">)</span>


<span class="s3">class </span><span class="s1">REAL</span><span class="s4">(</span><span class="s1">Float</span><span class="s4">[</span><span class="s1">_N</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;The SQL REAL type. 
 
    .. seealso:: 
 
        :class:`_types.Float` - documentation for the base type. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;REAL&quot;</span>


<span class="s3">class </span><span class="s1">FLOAT</span><span class="s4">(</span><span class="s1">Float</span><span class="s4">[</span><span class="s1">_N</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;The SQL FLOAT type. 
 
    .. seealso:: 
 
        :class:`_types.Float` - documentation for the base type. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;FLOAT&quot;</span>


<span class="s3">class </span><span class="s1">DOUBLE</span><span class="s4">(</span><span class="s1">Double</span><span class="s4">[</span><span class="s1">_N</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;The SQL DOUBLE type. 
 
    .. versionadded:: 2.0 
 
    .. seealso:: 
 
        :class:`_types.Double` - documentation for the base type. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;DOUBLE&quot;</span>


<span class="s3">class </span><span class="s1">DOUBLE_PRECISION</span><span class="s4">(</span><span class="s1">Double</span><span class="s4">[</span><span class="s1">_N</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;The SQL DOUBLE PRECISION type. 
 
    .. versionadded:: 2.0 
 
    .. seealso:: 
 
        :class:`_types.Double` - documentation for the base type. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;DOUBLE_PRECISION&quot;</span>


<span class="s3">class </span><span class="s1">NUMERIC</span><span class="s4">(</span><span class="s1">Numeric</span><span class="s4">[</span><span class="s1">_N</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;The SQL NUMERIC type. 
 
    .. seealso:: 
 
        :class:`_types.Numeric` - documentation for the base type. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;NUMERIC&quot;</span>


<span class="s3">class </span><span class="s1">DECIMAL</span><span class="s4">(</span><span class="s1">Numeric</span><span class="s4">[</span><span class="s1">_N</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;The SQL DECIMAL type. 
 
    .. seealso:: 
 
        :class:`_types.Numeric` - documentation for the base type. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;DECIMAL&quot;</span>


<span class="s3">class </span><span class="s1">INTEGER</span><span class="s4">(</span><span class="s1">Integer</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The SQL INT or INTEGER type. 
 
    .. seealso:: 
 
        :class:`_types.Integer` - documentation for the base type. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;INTEGER&quot;</span>


<span class="s1">INT </span><span class="s4">= </span><span class="s1">INTEGER</span>


<span class="s3">class </span><span class="s1">SMALLINT</span><span class="s4">(</span><span class="s1">SmallInteger</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The SQL SMALLINT type. 
 
    .. seealso:: 
 
        :class:`_types.SmallInteger` - documentation for the base type. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;SMALLINT&quot;</span>


<span class="s3">class </span><span class="s1">BIGINT</span><span class="s4">(</span><span class="s1">BigInteger</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The SQL BIGINT type. 
 
    .. seealso:: 
 
        :class:`_types.BigInteger` - documentation for the base type. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;BIGINT&quot;</span>


<span class="s3">class </span><span class="s1">TIMESTAMP</span><span class="s4">(</span><span class="s1">DateTime</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The SQL TIMESTAMP type. 
 
    :class:`_types.TIMESTAMP` datatypes have support for timezone 
    storage on some backends, such as PostgreSQL and Oracle.  Use the 
    :paramref:`~types.TIMESTAMP.timezone` argument in order to enable 
    &quot;TIMESTAMP WITH TIMEZONE&quot; for these backends. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;TIMESTAMP&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">timezone</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Construct a new :class:`_types.TIMESTAMP`. 
 
        :param timezone: boolean.  Indicates that the TIMESTAMP type should 
         enable timezone support, if available on the target database. 
         On a per-dialect basis is similar to &quot;TIMESTAMP WITH TIMEZONE&quot;. 
         If the target database does not support timezones, this flag is 
         ignored. 
 
 
        &quot;&quot;&quot;</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">timezone</span><span class="s4">=</span><span class="s1">timezone</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_dbapi_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dbapi</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">dbapi</span><span class="s4">.</span><span class="s1">TIMESTAMP</span>


<span class="s3">class </span><span class="s1">DATETIME</span><span class="s4">(</span><span class="s1">DateTime</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The SQL DATETIME type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;DATETIME&quot;</span>


<span class="s3">class </span><span class="s1">DATE</span><span class="s4">(</span><span class="s1">Date</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The SQL DATE type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;DATE&quot;</span>


<span class="s3">class </span><span class="s1">TIME</span><span class="s4">(</span><span class="s1">Time</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The SQL TIME type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;TIME&quot;</span>


<span class="s3">class </span><span class="s1">TEXT</span><span class="s4">(</span><span class="s1">Text</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The SQL TEXT type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;TEXT&quot;</span>


<span class="s3">class </span><span class="s1">CLOB</span><span class="s4">(</span><span class="s1">Text</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The CLOB type. 
 
    This type is found in Oracle and Informix. 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;CLOB&quot;</span>


<span class="s3">class </span><span class="s1">VARCHAR</span><span class="s4">(</span><span class="s1">String</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The SQL VARCHAR type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;VARCHAR&quot;</span>


<span class="s3">class </span><span class="s1">NVARCHAR</span><span class="s4">(</span><span class="s1">Unicode</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The SQL NVARCHAR type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;NVARCHAR&quot;</span>


<span class="s3">class </span><span class="s1">CHAR</span><span class="s4">(</span><span class="s1">String</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The SQL CHAR type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;CHAR&quot;</span>


<span class="s3">class </span><span class="s1">NCHAR</span><span class="s4">(</span><span class="s1">Unicode</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The SQL NCHAR type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;NCHAR&quot;</span>


<span class="s3">class </span><span class="s1">BLOB</span><span class="s4">(</span><span class="s1">LargeBinary</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The SQL BLOB type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;BLOB&quot;</span>


<span class="s3">class </span><span class="s1">BINARY</span><span class="s4">(</span><span class="s1">_Binary</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The SQL BINARY type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;BINARY&quot;</span>


<span class="s3">class </span><span class="s1">VARBINARY</span><span class="s4">(</span><span class="s1">_Binary</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The SQL VARBINARY type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;VARBINARY&quot;</span>


<span class="s3">class </span><span class="s1">BOOLEAN</span><span class="s4">(</span><span class="s1">Boolean</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;The SQL BOOLEAN type.&quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;BOOLEAN&quot;</span>


<span class="s3">class </span><span class="s1">NullType</span><span class="s4">(</span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s3">None</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;An unknown type. 
 
    :class:`.NullType` is used as a default type for those cases where 
    a type cannot be determined, including: 
 
    * During table reflection, when the type of a column is not recognized 
      by the :class:`.Dialect` 
    * When constructing SQL expressions using plain Python objects of 
      unknown types (e.g. ``somecolumn == my_special_object``) 
    * When a new :class:`_schema.Column` is created, 
      and the given type is passed 
      as ``None`` or is not passed at all. 
 
    The :class:`.NullType` can be used within SQL expression invocation 
    without issue, it just has no behavior either at the expression 
    construction level or at the bind-parameter/result processing level. 
    :class:`.NullType` will result in a :exc:`.CompileError` if the compiler 
    is asked to render the type itself, such as if it is used in a 
    :func:`.cast` operation or within a schema creation operation such as that 
    invoked by :meth:`_schema.MetaData.create_all` or the 
    :class:`.CreateTable` 
    construct. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;null&quot;</span>

    <span class="s1">_isnull </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">literal_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s3">return None</span>

    <span class="s3">class </span><span class="s1">Comparator</span><span class="s4">(</span><span class="s1">TypeEngine</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]):</span>
        <span class="s1">__slots__ </span><span class="s4">= ()</span>

        <span class="s3">def </span><span class="s1">_adapt_expression</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">op</span><span class="s4">: </span><span class="s1">OperatorType</span><span class="s4">,</span>
            <span class="s1">other_comparator</span><span class="s4">: </span><span class="s1">TypeEngine</span><span class="s4">.</span><span class="s1">Comparator</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s4">) </span><span class="s1">-&gt; Tuple</span><span class="s4">[</span><span class="s1">OperatorType</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
            <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span>
                <span class="s1">other_comparator</span><span class="s4">, </span><span class="s1">NullType</span><span class="s4">.</span><span class="s1">Comparator</span>
            <span class="s4">) </span><span class="s3">or not </span><span class="s1">operators</span><span class="s4">.</span><span class="s1">is_commutative</span><span class="s4">(</span><span class="s1">op</span><span class="s4">):</span>
                <span class="s3">return </span><span class="s1">op</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">expr</span><span class="s4">.</span><span class="s1">type</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">other_comparator</span><span class="s4">.</span><span class="s1">_adapt_expression</span><span class="s4">(</span><span class="s1">op</span><span class="s4">, </span><span class="s1">self</span><span class="s4">)</span>

    <span class="s1">comparator_factory </span><span class="s4">= </span><span class="s1">Comparator</span>


<span class="s3">class </span><span class="s1">TableValueType</span><span class="s4">(</span><span class="s1">HasCacheKey</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Refers to a table value type.&quot;&quot;&quot;</span>

    <span class="s1">_is_table_value </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">_traverse_internals </span><span class="s4">= [</span>
        <span class="s4">(</span><span class="s5">&quot;_elements&quot;</span><span class="s4">, </span><span class="s1">InternalTraversal</span><span class="s4">.</span><span class="s1">dp_clauseelement_list</span><span class="s4">),</span>
    <span class="s4">]</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">elements</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_elements </span><span class="s4">= [</span>
            <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">StrAsPlainColumnRole</span><span class="s4">, </span><span class="s1">elem</span><span class="s4">)</span>
            <span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">elements</span>
        <span class="s4">]</span>


<span class="s3">class </span><span class="s1">MatchType</span><span class="s4">(</span><span class="s1">Boolean</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Refers to the return type of the MATCH operator. 
 
    As the :meth:`.ColumnOperators.match` is probably the most open-ended 
    operator in generic SQLAlchemy Core, we can't assume the return type 
    at SQL evaluation time, as MySQL returns a floating point, not a boolean, 
    and other backends might do something different.    So this type 
    acts as a placeholder, currently subclassing :class:`.Boolean`. 
    The type allows dialects to inject result-processing functionality 
    if needed, and on MySQL will return floating-point values. 
 
    &quot;&quot;&quot;</span>


<span class="s1">_UUID_RETURN </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_UUID_RETURN&quot;</span><span class="s4">, </span><span class="s1">str</span><span class="s4">, </span><span class="s1">_python_UUID</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">Uuid</span><span class="s4">(</span><span class="s1">Emulated</span><span class="s4">, </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">_UUID_RETURN</span><span class="s4">]):</span>
    <span class="s2">&quot;&quot;&quot;Represent a database agnostic UUID datatype. 
 
    For backends that have no &quot;native&quot; UUID datatype, the value will 
    make use of ``CHAR(32)`` and store the UUID as a 32-character alphanumeric 
    hex string. 
 
    For backends which are known to support ``UUID`` directly or a similar 
    uuid-storing datatype such as SQL Server's ``UNIQUEIDENTIFIER``, a 
    &quot;native&quot; mode enabled by default allows these types will be used on those 
    backends. 
 
    In its default mode of use, the :class:`_sqltypes.Uuid` datatype expects 
    **Python uuid objects**, from the Python 
    `uuid &lt;https://docs.python.org/3/library/uuid.html&gt;`_ 
    module:: 
 
        import uuid 
 
        from sqlalchemy import Uuid 
        from sqlalchemy import Table, Column, MetaData, String 
 
 
        metadata_obj = MetaData() 
 
        t = Table( 
            &quot;t&quot;, 
            metadata_obj, 
            Column('uuid_data', Uuid, primary_key=True), 
            Column(&quot;other_data&quot;, String) 
        ) 
 
        with engine.begin() as conn: 
            conn.execute( 
                t.insert(), 
                {&quot;uuid_data&quot;: uuid.uuid4(), &quot;other_data&quot;, &quot;some data&quot;} 
            ) 
 
    To have the :class:`_sqltypes.Uuid` datatype work with string-based 
    Uuids (e.g. 32 character hexadecimal strings), pass the 
    :paramref:`_sqltypes.Uuid.as_uuid` parameter with the value ``False``. 
 
    .. versionadded:: 2.0 
 
    .. seealso:: 
 
        :class:`_sqltypes.UUID` - represents exactly the ``UUID`` datatype 
        without any backend-agnostic behaviors. 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;uuid&quot;</span>

    <span class="s1">collation</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">: </span><span class="s1">Uuid</span><span class="s4">[</span><span class="s1">_python_UUID</span><span class="s4">],</span>
        <span class="s1">as_uuid</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">True</span><span class="s4">] = ...,</span>
        <span class="s1">native_uuid</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= ...,</span>
    <span class="s4">): ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">: </span><span class="s1">Uuid</span><span class="s4">[</span><span class="s1">str</span><span class="s4">],</span>
        <span class="s1">as_uuid</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">False</span><span class="s4">] = ...,</span>
        <span class="s1">native_uuid</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= ...,</span>
    <span class="s4">): ...</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">as_uuid</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">, </span><span class="s1">native_uuid</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Construct a :class:`_sqltypes.Uuid` type. 
 
        :param as_uuid=True: if True, values will be interpreted 
         as Python uuid objects, converting to/from string via the 
         DBAPI. 
 
         .. versionchanged: 2.0 ``as_uuid`` now defaults to ``True``. 
 
        :param native_uuid=True: if True, backends that support either the 
         ``UUID`` datatype directly, or a UUID-storing value 
         (such as SQL Server's ``UNIQUEIDENTIFIER`` will be used by those 
         backends.   If False, a ``CHAR(32)`` datatype will be used for 
         all backends regardless of native support. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">as_uuid </span><span class="s4">= </span><span class="s1">as_uuid</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">native_uuid </span><span class="s4">= </span><span class="s1">native_uuid</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">python_type</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">_python_UUID </span><span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">as_uuid </span><span class="s3">else </span><span class="s1">str</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">native</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">native_uuid</span>

    <span class="s3">def </span><span class="s1">coerce_compared_value</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">op</span><span class="s4">, </span><span class="s1">value</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;See :meth:`.TypeEngine.coerce_compared_value` for a description.&quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
            <span class="s3">return </span><span class="s1">self</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">super</span><span class="s4">().</span><span class="s1">coerce_compared_value</span><span class="s4">(</span><span class="s1">op</span><span class="s4">, </span><span class="s1">value</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">bind_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s1">character_based_uuid </span><span class="s4">= (</span>
            <span class="s3">not </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">supports_native_uuid </span><span class="s3">or not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">native_uuid</span>
        <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">character_based_uuid</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">as_uuid</span><span class="s4">:</span>

                <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                    <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span><span class="s4">:</span>
                        <span class="s1">value </span><span class="s4">= </span><span class="s1">value</span><span class="s4">.</span><span class="s1">hex</span>
                    <span class="s3">return </span><span class="s1">value</span>

                <span class="s3">return </span><span class="s1">process</span>
            <span class="s3">else</span><span class="s4">:</span>

                <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                    <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span><span class="s4">:</span>
                        <span class="s1">value </span><span class="s4">= </span><span class="s1">value</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s5">&quot;-&quot;</span><span class="s4">, </span><span class="s5">&quot;&quot;</span><span class="s4">)</span>
                    <span class="s3">return </span><span class="s1">value</span>

                <span class="s3">return </span><span class="s1">process</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">result_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">, </span><span class="s1">coltype</span><span class="s4">):</span>
        <span class="s1">character_based_uuid </span><span class="s4">= (</span>
            <span class="s3">not </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">supports_native_uuid </span><span class="s3">or not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">native_uuid</span>
        <span class="s4">)</span>

        <span class="s3">if </span><span class="s1">character_based_uuid</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">as_uuid</span><span class="s4">:</span>

                <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                    <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span><span class="s4">:</span>
                        <span class="s1">value </span><span class="s4">= </span><span class="s1">_python_UUID</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
                    <span class="s3">return </span><span class="s1">value</span>

                <span class="s3">return </span><span class="s1">process</span>
            <span class="s3">else</span><span class="s4">:</span>

                <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                    <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span><span class="s4">:</span>
                        <span class="s1">value </span><span class="s4">= </span><span class="s1">str</span><span class="s4">(</span><span class="s1">_python_UUID</span><span class="s4">(</span><span class="s1">value</span><span class="s4">))</span>
                    <span class="s3">return </span><span class="s1">value</span>

                <span class="s3">return </span><span class="s1">process</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">as_uuid</span><span class="s4">:</span>

                <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                    <span class="s3">if </span><span class="s1">value </span><span class="s3">is not None</span><span class="s4">:</span>
                        <span class="s1">value </span><span class="s4">= </span><span class="s1">str</span><span class="s4">(</span><span class="s1">value</span><span class="s4">)</span>
                    <span class="s3">return </span><span class="s1">value</span>

                <span class="s3">return </span><span class="s1">process</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">literal_processor</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">dialect</span><span class="s4">):</span>
        <span class="s1">character_based_uuid </span><span class="s4">= (</span>
            <span class="s3">not </span><span class="s1">dialect</span><span class="s4">.</span><span class="s1">supports_native_uuid </span><span class="s3">or not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">native_uuid</span>
        <span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">as_uuid</span><span class="s4">:</span>

            <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                <span class="s3">return </span><span class="s5">f&quot;&quot;&quot;'</span><span class="s3">{</span><span class="s1">value</span><span class="s4">.</span><span class="s1">replace</span><span class="s4">(</span><span class="s5">&quot;-&quot;</span><span class="s4">, </span><span class="s5">&quot;&quot;</span><span class="s4">).</span><span class="s1">replace</span><span class="s4">(</span><span class="s5">&quot;'&quot;</span><span class="s4">, </span><span class="s5">&quot;''&quot;</span><span class="s4">)</span><span class="s3">}</span><span class="s5">'&quot;&quot;&quot;</span>

            <span class="s3">return </span><span class="s1">process</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">if </span><span class="s1">character_based_uuid</span><span class="s4">:</span>

                <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                    <span class="s3">return </span><span class="s5">f&quot;&quot;&quot;'</span><span class="s3">{</span><span class="s1">value</span><span class="s4">.</span><span class="s1">hex</span><span class="s3">}</span><span class="s5">'&quot;&quot;&quot;</span>

                <span class="s3">return </span><span class="s1">process</span>
            <span class="s3">else</span><span class="s4">:</span>

                <span class="s3">def </span><span class="s1">process</span><span class="s4">(</span><span class="s1">value</span><span class="s4">):</span>
                    <span class="s3">return </span><span class="s5">f&quot;&quot;&quot;'</span><span class="s3">{</span><span class="s1">str</span><span class="s4">(</span><span class="s1">value</span><span class="s4">).</span><span class="s1">replace</span><span class="s4">(</span><span class="s5">&quot;'&quot;</span><span class="s4">, </span><span class="s5">&quot;''&quot;</span><span class="s4">)</span><span class="s3">}</span><span class="s5">'&quot;&quot;&quot;</span>

                <span class="s3">return </span><span class="s1">process</span>


<span class="s3">class </span><span class="s1">UUID</span><span class="s4">(</span><span class="s1">Uuid</span><span class="s4">[</span><span class="s1">_UUID_RETURN</span><span class="s4">], </span><span class="s1">type_api</span><span class="s4">.</span><span class="s1">NativeForEmulated</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;Represent the SQL UUID type. 
 
    This is the SQL-native form of the :class:`_types.Uuid` database agnostic 
    datatype, and is backwards compatible with the previous PostgreSQL-only 
    version of ``UUID``. 
 
    The :class:`_sqltypes.UUID` datatype only works on databases that have a 
    SQL datatype named ``UUID``. It will not function for backends which don't 
    have this exact-named type, including SQL Server. For backend-agnostic UUID 
    values with native support, including for SQL Server's ``UNIQUEIDENTIFIER`` 
    datatype, use the :class:`_sqltypes.Uuid` datatype. 
 
    .. versionadded:: 2.0 
 
    .. seealso:: 
 
        :class:`_sqltypes.Uuid` 
 
    &quot;&quot;&quot;</span>

    <span class="s1">__visit_name__ </span><span class="s4">= </span><span class="s5">&quot;UUID&quot;</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">UUID</span><span class="s4">[</span><span class="s1">_python_UUID</span><span class="s4">], </span><span class="s1">as_uuid</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">True</span><span class="s4">] = ...): ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">UUID</span><span class="s4">[</span><span class="s1">str</span><span class="s4">], </span><span class="s1">as_uuid</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">False</span><span class="s4">] = ...): ...</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">as_uuid</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Construct a :class:`_sqltypes.UUID` type. 
 
 
        :param as_uuid=True: if True, values will be interpreted 
         as Python uuid objects, converting to/from string via the 
         DBAPI. 
 
         .. versionchanged: 2.0 ``as_uuid`` now defaults to ``True``. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">as_uuid </span><span class="s4">= </span><span class="s1">as_uuid</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">native_uuid </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s4">@</span><span class="s1">classmethod</span>
    <span class="s3">def </span><span class="s1">adapt_emulated_to_native</span><span class="s4">(</span><span class="s1">cls</span><span class="s4">, </span><span class="s1">impl</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">):</span>
        <span class="s1">kw</span><span class="s4">.</span><span class="s1">setdefault</span><span class="s4">(</span><span class="s5">&quot;as_uuid&quot;</span><span class="s4">, </span><span class="s1">impl</span><span class="s4">.</span><span class="s1">as_uuid</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">cls</span><span class="s4">(**</span><span class="s1">kw</span><span class="s4">)</span>


<span class="s1">NULLTYPE </span><span class="s4">= </span><span class="s1">NullType</span><span class="s4">()</span>
<span class="s1">BOOLEANTYPE </span><span class="s4">= </span><span class="s1">Boolean</span><span class="s4">()</span>
<span class="s1">STRINGTYPE </span><span class="s4">= </span><span class="s1">String</span><span class="s4">()</span>
<span class="s1">INTEGERTYPE </span><span class="s4">= </span><span class="s1">Integer</span><span class="s4">()</span>
<span class="s1">NUMERICTYPE</span><span class="s4">: </span><span class="s1">Numeric</span><span class="s4">[</span><span class="s1">decimal</span><span class="s4">.</span><span class="s1">Decimal</span><span class="s4">] = </span><span class="s1">Numeric</span><span class="s4">()</span>
<span class="s1">MATCHTYPE </span><span class="s4">= </span><span class="s1">MatchType</span><span class="s4">()</span>
<span class="s1">TABLEVALUE </span><span class="s4">= </span><span class="s1">TableValueType</span><span class="s4">()</span>
<span class="s1">DATETIME_TIMEZONE </span><span class="s4">= </span><span class="s1">DateTime</span><span class="s4">(</span><span class="s1">timezone</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
<span class="s1">TIME_TIMEZONE </span><span class="s4">= </span><span class="s1">Time</span><span class="s4">(</span><span class="s1">timezone</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
<span class="s1">_BIGINTEGER </span><span class="s4">= </span><span class="s1">BigInteger</span><span class="s4">()</span>
<span class="s1">_DATETIME </span><span class="s4">= </span><span class="s1">DateTime</span><span class="s4">()</span>
<span class="s1">_TIME </span><span class="s4">= </span><span class="s1">Time</span><span class="s4">()</span>
<span class="s1">_STRING </span><span class="s4">= </span><span class="s1">String</span><span class="s4">()</span>
<span class="s1">_UNICODE </span><span class="s4">= </span><span class="s1">Unicode</span><span class="s4">()</span>

<span class="s1">_type_map</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = {</span>
    <span class="s1">int</span><span class="s4">: </span><span class="s1">Integer</span><span class="s4">(),</span>
    <span class="s1">float</span><span class="s4">: </span><span class="s1">Float</span><span class="s4">(),</span>
    <span class="s1">bool</span><span class="s4">: </span><span class="s1">BOOLEANTYPE</span><span class="s4">,</span>
    <span class="s1">_python_UUID</span><span class="s4">: </span><span class="s1">Uuid</span><span class="s4">(),</span>
    <span class="s1">decimal</span><span class="s4">.</span><span class="s1">Decimal</span><span class="s4">: </span><span class="s1">Numeric</span><span class="s4">(),</span>
    <span class="s1">dt</span><span class="s4">.</span><span class="s1">date</span><span class="s4">: </span><span class="s1">Date</span><span class="s4">(),</span>
    <span class="s1">dt</span><span class="s4">.</span><span class="s1">datetime</span><span class="s4">: </span><span class="s1">_DATETIME</span><span class="s4">,</span>
    <span class="s1">dt</span><span class="s4">.</span><span class="s1">time</span><span class="s4">: </span><span class="s1">_TIME</span><span class="s4">,</span>
    <span class="s1">dt</span><span class="s4">.</span><span class="s1">timedelta</span><span class="s4">: </span><span class="s1">Interval</span><span class="s4">(),</span>
    <span class="s1">type</span><span class="s4">(</span><span class="s3">None</span><span class="s4">): </span><span class="s1">NULLTYPE</span><span class="s4">,</span>
    <span class="s1">bytes</span><span class="s4">: </span><span class="s1">LargeBinary</span><span class="s4">(),</span>
    <span class="s1">str</span><span class="s4">: </span><span class="s1">_STRING</span><span class="s4">,</span>
    <span class="s1">enum</span><span class="s4">.</span><span class="s1">Enum</span><span class="s4">: </span><span class="s1">Enum</span><span class="s4">(</span><span class="s1">enum</span><span class="s4">.</span><span class="s1">Enum</span><span class="s4">),</span>
    <span class="s1">Literal</span><span class="s4">: </span><span class="s1">Enum</span><span class="s4">(</span><span class="s1">enum</span><span class="s4">.</span><span class="s1">Enum</span><span class="s4">),  </span><span class="s0"># type: ignore[dict-item]</span>
<span class="s4">}</span>


<span class="s1">_type_map_get </span><span class="s4">= </span><span class="s1">_type_map</span><span class="s4">.</span><span class="s1">get</span>


<span class="s3">def </span><span class="s1">_resolve_value_to_type</span><span class="s4">(</span><span class="s1">value</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; TypeEngine</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
    <span class="s1">_result_type </span><span class="s4">= </span><span class="s1">_type_map_get</span><span class="s4">(</span><span class="s1">type</span><span class="s4">(</span><span class="s1">value</span><span class="s4">), </span><span class="s3">False</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">_result_type </span><span class="s3">is False</span><span class="s4">:</span>
        <span class="s1">_result_type </span><span class="s4">= </span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s5">&quot;__sa_type_engine__&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">_result_type </span><span class="s3">is False</span><span class="s4">:</span>
        <span class="s0"># use inspect() to detect SQLAlchemy built-in</span>
        <span class="s0"># objects.</span>
        <span class="s1">insp </span><span class="s4">= </span><span class="s1">inspection</span><span class="s4">.</span><span class="s1">inspect</span><span class="s4">(</span><span class="s1">value</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">insp </span><span class="s3">is not None</span>
            <span class="s3">and</span>
            <span class="s0"># foil mock.Mock() and other impostors by ensuring</span>
            <span class="s0"># the inspection target itself self-inspects</span>
            <span class="s1">insp</span><span class="s4">.</span><span class="s1">__class__ </span><span class="s3">in </span><span class="s1">inspection</span><span class="s4">.</span><span class="s1">_registrars</span>
        <span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">exc</span><span class="s4">.</span><span class="s1">ArgumentError</span><span class="s4">(</span>
                <span class="s5">&quot;Object %r is not legal as a SQL literal value&quot; </span><span class="s4">% (</span><span class="s1">value</span><span class="s4">,)</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">NULLTYPE</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">_result_type</span><span class="s4">.</span><span class="s1">_resolve_for_literal</span><span class="s4">(  </span><span class="s0"># type: ignore [union-attr]</span>
            <span class="s1">value</span>
        <span class="s4">)</span>


<span class="s0"># back-assign to type_api</span>
<span class="s1">type_api</span><span class="s4">.</span><span class="s1">BOOLEANTYPE </span><span class="s4">= </span><span class="s1">BOOLEANTYPE</span>
<span class="s1">type_api</span><span class="s4">.</span><span class="s1">STRINGTYPE </span><span class="s4">= </span><span class="s1">STRINGTYPE</span>
<span class="s1">type_api</span><span class="s4">.</span><span class="s1">INTEGERTYPE </span><span class="s4">= </span><span class="s1">INTEGERTYPE</span>
<span class="s1">type_api</span><span class="s4">.</span><span class="s1">NULLTYPE </span><span class="s4">= </span><span class="s1">NULLTYPE</span>
<span class="s1">type_api</span><span class="s4">.</span><span class="s1">NUMERICTYPE </span><span class="s4">= </span><span class="s1">NUMERICTYPE</span>
<span class="s1">type_api</span><span class="s4">.</span><span class="s1">MATCHTYPE </span><span class="s4">= </span><span class="s1">MATCHTYPE</span>
<span class="s1">type_api</span><span class="s4">.</span><span class="s1">INDEXABLE </span><span class="s4">= </span><span class="s1">INDEXABLE </span><span class="s4">= </span><span class="s1">Indexable</span>
<span class="s1">type_api</span><span class="s4">.</span><span class="s1">TABLEVALUE </span><span class="s4">= </span><span class="s1">TABLEVALUE</span>
<span class="s1">type_api</span><span class="s4">.</span><span class="s1">_resolve_value_to_type </span><span class="s4">= </span><span class="s1">_resolve_value_to_type</span>
</pre>
</body>
</html>