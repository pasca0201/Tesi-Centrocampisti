<html>
<head>
<title>_czt.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_czt.py</font>
</center></td></tr></table>
<pre><span class="s0"># This program is public domain</span>
<span class="s0"># Authors: Paul Kienzle, Nadav Horesh</span>
<span class="s2">&quot;&quot;&quot; 
Chirp z-transform. 
 
We provide two interfaces to the chirp z-transform: an object interface 
which precalculates part of the transform and can be applied efficiently 
to many different data sets, and a functional interface which is applied 
only to the given data set. 
 
Transforms 
---------- 
 
CZT : callable (x, axis=-1) -&gt; array 
   Define a chirp z-transform that can be applied to different signals. 
ZoomFFT : callable (x, axis=-1) -&gt; array 
   Define a Fourier transform on a range of frequencies. 
 
Functions 
--------- 
 
czt : array 
   Compute the chirp z-transform for a signal. 
zoom_fft : array 
   Compute the Fourier transform on a range of frequencies. 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">cmath</span>
<span class="s3">import </span><span class="s1">numbers</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">numpy </span><span class="s3">import </span><span class="s1">pi</span><span class="s4">, </span><span class="s1">arange</span>
<span class="s3">from </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">fft </span><span class="s3">import </span><span class="s1">fft</span><span class="s4">, </span><span class="s1">ifft</span><span class="s4">, </span><span class="s1">next_fast_len</span>

<span class="s1">__all__ </span><span class="s4">= [</span><span class="s5">'czt'</span><span class="s4">, </span><span class="s5">'zoom_fft'</span><span class="s4">, </span><span class="s5">'CZT'</span><span class="s4">, </span><span class="s5">'ZoomFFT'</span><span class="s4">, </span><span class="s5">'czt_points'</span><span class="s4">]</span>


<span class="s3">def </span><span class="s1">_validate_sizes</span><span class="s4">(</span><span class="s1">n</span><span class="s4">, </span><span class="s1">m</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">n </span><span class="s4">&lt; </span><span class="s6">1 </span><span class="s3">or not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">n</span><span class="s4">, </span><span class="s1">numbers</span><span class="s4">.</span><span class="s1">Integral</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Invalid number of CZT data '</span>
                         <span class="s5">f'points (</span><span class="s3">{</span><span class="s1">n</span><span class="s3">}</span><span class="s5">) specified. '</span>
                         <span class="s5">'n must be positive and integer type.'</span><span class="s4">)</span>

    <span class="s3">if </span><span class="s1">m </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">m </span><span class="s4">= </span><span class="s1">n</span>
    <span class="s3">elif </span><span class="s1">m </span><span class="s4">&lt; </span><span class="s6">1 </span><span class="s3">or not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">numbers</span><span class="s4">.</span><span class="s1">Integral</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'Invalid number of CZT output '</span>
                         <span class="s5">f'points (</span><span class="s3">{</span><span class="s1">m</span><span class="s3">}</span><span class="s5">) specified. '</span>
                         <span class="s5">'m must be positive and integer type.'</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">m</span>


<span class="s3">def </span><span class="s1">czt_points</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">a</span><span class="s4">=</span><span class="s6">1</span><span class="s4">+</span><span class="s6">0j</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Return the points at which the chirp z-transform is computed. 
 
    Parameters 
    ---------- 
    m : int 
        The number of points desired. 
    w : complex, optional 
        The ratio between points in each step. 
        Defaults to equally spaced points around the entire unit circle. 
    a : complex, optional 
        The starting point in the complex plane.  Default is 1+0j. 
 
    Returns 
    ------- 
    out : ndarray 
        The points in the Z plane at which `CZT` samples the z-transform, 
        when called with arguments `m`, `w`, and `a`, as complex numbers. 
 
    See Also 
    -------- 
    CZT : Class that creates a callable chirp z-transform function. 
    czt : Convenience function for quickly calculating CZT. 
 
    Examples 
    -------- 
    Plot the points of a 16-point FFT: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal import czt_points 
    &gt;&gt;&gt; points = czt_points(16) 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.plot(points.real, points.imag, 'o') 
    &gt;&gt;&gt; plt.gca().add_patch(plt.Circle((0,0), radius=1, fill=False, alpha=.3)) 
    &gt;&gt;&gt; plt.axis('equal') 
    &gt;&gt;&gt; plt.show() 
 
    and a 91-point logarithmic spiral that crosses the unit circle: 
 
    &gt;&gt;&gt; m, w, a = 91, 0.995*np.exp(-1j*np.pi*.05), 0.8*np.exp(1j*np.pi/6) 
    &gt;&gt;&gt; points = czt_points(m, w, a) 
    &gt;&gt;&gt; plt.plot(points.real, points.imag, 'o') 
    &gt;&gt;&gt; plt.gca().add_patch(plt.Circle((0,0), radius=1, fill=False, alpha=.3)) 
    &gt;&gt;&gt; plt.axis('equal') 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">m </span><span class="s4">= </span><span class="s1">_validate_sizes</span><span class="s4">(</span><span class="s6">1</span><span class="s4">, </span><span class="s1">m</span><span class="s4">)</span>

    <span class="s1">k </span><span class="s4">= </span><span class="s1">arange</span><span class="s4">(</span><span class="s1">m</span><span class="s4">)</span>

    <span class="s1">a </span><span class="s4">= </span><span class="s6">1.0 </span><span class="s4">* </span><span class="s1">a  </span><span class="s0"># at least float</span>

    <span class="s3">if </span><span class="s1">w </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s0"># Nothing specified, default to FFT</span>
        <span class="s3">return </span><span class="s1">a </span><span class="s4">* </span><span class="s1">np</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(</span><span class="s6">2j </span><span class="s4">* </span><span class="s1">pi </span><span class="s4">* </span><span class="s1">k </span><span class="s4">/ </span><span class="s1">m</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s0"># w specified</span>
        <span class="s1">w </span><span class="s4">= </span><span class="s6">1.0 </span><span class="s4">* </span><span class="s1">w  </span><span class="s0"># at least float</span>
        <span class="s3">return </span><span class="s1">a </span><span class="s4">* </span><span class="s1">w</span><span class="s4">**-</span><span class="s1">k</span>


<span class="s3">class </span><span class="s1">CZT</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Create a callable chirp z-transform function. 
 
    Transform to compute the frequency response around a spiral. 
    Objects of this class are callables which can compute the 
    chirp z-transform on their inputs.  This object precalculates the constant 
    chirps used in the given transform. 
 
    Parameters 
    ---------- 
    n : int 
        The size of the signal. 
    m : int, optional 
        The number of output points desired.  Default is `n`. 
    w : complex, optional 
        The ratio between points in each step.  This must be precise or the 
        accumulated error will degrade the tail of the output sequence. 
        Defaults to equally spaced points around the entire unit circle. 
    a : complex, optional 
        The starting point in the complex plane.  Default is 1+0j. 
 
    Returns 
    ------- 
    f : CZT 
        Callable object ``f(x, axis=-1)`` for computing the chirp z-transform 
        on `x`. 
 
    See Also 
    -------- 
    czt : Convenience function for quickly calculating CZT. 
    ZoomFFT : Class that creates a callable partial FFT function. 
 
    Notes 
    ----- 
    The defaults are chosen such that ``f(x)`` is equivalent to 
    ``fft.fft(x)`` and, if ``m &gt; len(x)``, that ``f(x, m)`` is equivalent to 
    ``fft.fft(x, m)``. 
 
    If `w` does not lie on the unit circle, then the transform will be 
    around a spiral with exponentially-increasing radius.  Regardless, 
    angle will increase linearly. 
 
    For transforms that do lie on the unit circle, accuracy is better when 
    using `ZoomFFT`, since any numerical error in `w` is 
    accumulated for long data lengths, drifting away from the unit circle. 
 
    The chirp z-transform can be faster than an equivalent FFT with 
    zero padding.  Try it with your own array sizes to see. 
 
    However, the chirp z-transform is considerably less precise than the 
    equivalent zero-padded FFT. 
 
    As this CZT is implemented using the Bluestein algorithm, it can compute 
    large prime-length Fourier transforms in O(N log N) time, rather than the 
    O(N**2) time required by the direct DFT calculation.  (`scipy.fft` also 
    uses Bluestein's algorithm'.) 
 
    (The name &quot;chirp z-transform&quot; comes from the use of a chirp in the 
    Bluestein algorithm.  It does not decompose signals into chirps, like 
    other transforms with &quot;chirp&quot; in the name.) 
 
    References 
    ---------- 
    .. [1] Leo I. Bluestein, &quot;A linear filtering approach to the computation 
           of the discrete Fourier transform,&quot; Northeast Electronics Research 
           and Engineering Meeting Record 10, 218-219 (1968). 
    .. [2] Rabiner, Schafer, and Rader, &quot;The chirp z-transform algorithm and 
           its application,&quot; Bell Syst. Tech. J. 48, 1249-1292 (1969). 
 
    Examples 
    -------- 
    Compute multiple prime-length FFTs: 
 
    &gt;&gt;&gt; from scipy.signal import CZT 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; a = np.random.rand(7) 
    &gt;&gt;&gt; b = np.random.rand(7) 
    &gt;&gt;&gt; c = np.random.rand(7) 
    &gt;&gt;&gt; czt_7 = CZT(n=7) 
    &gt;&gt;&gt; A = czt_7(a) 
    &gt;&gt;&gt; B = czt_7(b) 
    &gt;&gt;&gt; C = czt_7(c) 
 
    Display the points at which the FFT is calculated: 
 
    &gt;&gt;&gt; czt_7.points() 
    array([ 1.00000000+0.j        ,  0.62348980+0.78183148j, 
           -0.22252093+0.97492791j, -0.90096887+0.43388374j, 
           -0.90096887-0.43388374j, -0.22252093-0.97492791j, 
            0.62348980-0.78183148j]) 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.plot(czt_7.points().real, czt_7.points().imag, 'o') 
    &gt;&gt;&gt; plt.gca().add_patch(plt.Circle((0,0), radius=1, fill=False, alpha=.3)) 
    &gt;&gt;&gt; plt.axis('equal') 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">m</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">a</span><span class="s4">=</span><span class="s6">1</span><span class="s4">+</span><span class="s6">0j</span><span class="s4">):</span>
        <span class="s1">m </span><span class="s4">= </span><span class="s1">_validate_sizes</span><span class="s4">(</span><span class="s1">n</span><span class="s4">, </span><span class="s1">m</span><span class="s4">)</span>

        <span class="s1">k </span><span class="s4">= </span><span class="s1">arange</span><span class="s4">(</span><span class="s1">max</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">min_scalar_type</span><span class="s4">(-</span><span class="s1">max</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">)**</span><span class="s6">2</span><span class="s4">))</span>

        <span class="s3">if </span><span class="s1">w </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s0"># Nothing specified, default to FFT-like</span>
            <span class="s1">w </span><span class="s4">= </span><span class="s1">cmath</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(-</span><span class="s6">2j</span><span class="s4">*</span><span class="s1">pi</span><span class="s4">/</span><span class="s1">m</span><span class="s4">)</span>
            <span class="s1">wk2 </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(-(</span><span class="s6">1j </span><span class="s4">* </span><span class="s1">pi </span><span class="s4">* ((</span><span class="s1">k</span><span class="s4">**</span><span class="s6">2</span><span class="s4">) % (</span><span class="s6">2</span><span class="s4">*</span><span class="s1">m</span><span class="s4">))) / </span><span class="s1">m</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s0"># w specified</span>
            <span class="s1">wk2 </span><span class="s4">= </span><span class="s1">w</span><span class="s4">**(</span><span class="s1">k</span><span class="s4">**</span><span class="s6">2</span><span class="s4">/</span><span class="s6">2.</span><span class="s4">)</span>

        <span class="s1">a </span><span class="s4">= </span><span class="s6">1.0 </span><span class="s4">* </span><span class="s1">a  </span><span class="s0"># at least float</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">w</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">a </span><span class="s4">= </span><span class="s1">w</span><span class="s4">, </span><span class="s1">a</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">m</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n </span><span class="s4">= </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span>

        <span class="s1">nfft </span><span class="s4">= </span><span class="s1">next_fast_len</span><span class="s4">(</span><span class="s1">n </span><span class="s4">+ </span><span class="s1">m </span><span class="s4">- </span><span class="s6">1</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_Awk2 </span><span class="s4">= </span><span class="s1">a</span><span class="s4">**-</span><span class="s1">k</span><span class="s4">[:</span><span class="s1">n</span><span class="s4">] * </span><span class="s1">wk2</span><span class="s4">[:</span><span class="s1">n</span><span class="s4">]</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_nfft </span><span class="s4">= </span><span class="s1">nfft</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_Fwk2 </span><span class="s4">= </span><span class="s1">fft</span><span class="s4">(</span><span class="s6">1</span><span class="s4">/</span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">wk2</span><span class="s4">[</span><span class="s1">n</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s6">0</span><span class="s4">:-</span><span class="s6">1</span><span class="s4">], </span><span class="s1">wk2</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">])), </span><span class="s1">nfft</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_wk2 </span><span class="s4">= </span><span class="s1">wk2</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">]</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_yidx </span><span class="s4">= </span><span class="s1">slice</span><span class="s4">(</span><span class="s1">n</span><span class="s4">-</span><span class="s6">1</span><span class="s4">, </span><span class="s1">n</span><span class="s4">+</span><span class="s1">m</span><span class="s4">-</span><span class="s6">1</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">__call__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">x</span><span class="s4">, *, </span><span class="s1">axis</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Calculate the chirp z-transform of a signal. 
 
        Parameters 
        ---------- 
        x : array 
            The signal to transform. 
        axis : int, optional 
            Axis over which to compute the FFT. If not given, the last axis is 
            used. 
 
        Returns 
        ------- 
        out : ndarray 
            An array of the same dimensions as `x`, but with the length of the 
            transformed axis set to `m`. 
        &quot;&quot;&quot;</span>
        <span class="s1">x </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">x</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s1">axis</span><span class="s4">] != </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">f&quot;CZT defined for length </span><span class="s3">{</span><span class="s1">self</span><span class="s4">.</span><span class="s1">n</span><span class="s3">}</span><span class="s5">, not &quot;</span>
                             <span class="s5">f&quot;</span><span class="s3">{</span><span class="s1">x</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s1">axis</span><span class="s4">]</span><span class="s3">}</span><span class="s5">&quot;</span><span class="s4">)</span>
        <span class="s0"># Calculate transpose coordinates, to allow operation on any given axis</span>
        <span class="s1">trnsp </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">arange</span><span class="s4">(</span><span class="s1">x</span><span class="s4">.</span><span class="s1">ndim</span><span class="s4">)</span>
        <span class="s1">trnsp</span><span class="s4">[[</span><span class="s1">axis</span><span class="s4">, -</span><span class="s6">1</span><span class="s4">]] = [-</span><span class="s6">1</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">]</span>
        <span class="s1">x </span><span class="s4">= </span><span class="s1">x</span><span class="s4">.</span><span class="s1">transpose</span><span class="s4">(*</span><span class="s1">trnsp</span><span class="s4">)</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">ifft</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_Fwk2 </span><span class="s4">* </span><span class="s1">fft</span><span class="s4">(</span><span class="s1">x</span><span class="s4">*</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_Awk2</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_nfft</span><span class="s4">))</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">y</span><span class="s4">[..., </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_yidx</span><span class="s4">] * </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_wk2</span>
        <span class="s3">return </span><span class="s1">y</span><span class="s4">.</span><span class="s1">transpose</span><span class="s4">(*</span><span class="s1">trnsp</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">points</span><span class="s4">(</span><span class="s1">self</span><span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the points at which the chirp z-transform is computed. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">czt_points</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">m</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">w</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">a</span><span class="s4">)</span>


<span class="s3">class </span><span class="s1">ZoomFFT</span><span class="s4">(</span><span class="s1">CZT</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Create a callable zoom FFT transform function. 
 
    This is a specialization of the chirp z-transform (`CZT`) for a set of 
    equally-spaced frequencies around the unit circle, used to calculate a 
    section of the FFT more efficiently than calculating the entire FFT and 
    truncating. 
 
    Parameters 
    ---------- 
    n : int 
        The size of the signal. 
    fn : array_like 
        A length-2 sequence [`f1`, `f2`] giving the frequency range, or a 
        scalar, for which the range [0, `fn`] is assumed. 
    m : int, optional 
        The number of points to evaluate.  Default is `n`. 
    fs : float, optional 
        The sampling frequency.  If ``fs=10`` represented 10 kHz, for example, 
        then `f1` and `f2` would also be given in kHz. 
        The default sampling frequency is 2, so `f1` and `f2` should be 
        in the range [0, 1] to keep the transform below the Nyquist 
        frequency. 
    endpoint : bool, optional 
        If True, `f2` is the last sample. Otherwise, it is not included. 
        Default is False. 
 
    Returns 
    ------- 
    f : ZoomFFT 
        Callable object ``f(x, axis=-1)`` for computing the zoom FFT on `x`. 
 
    See Also 
    -------- 
    zoom_fft : Convenience function for calculating a zoom FFT. 
 
    Notes 
    ----- 
    The defaults are chosen such that ``f(x, 2)`` is equivalent to 
    ``fft.fft(x)`` and, if ``m &gt; len(x)``, that ``f(x, 2, m)`` is equivalent to 
    ``fft.fft(x, m)``. 
 
    Sampling frequency is 1/dt, the time step between samples in the 
    signal `x`.  The unit circle corresponds to frequencies from 0 up 
    to the sampling frequency.  The default sampling frequency of 2 
    means that `f1`, `f2` values up to the Nyquist frequency are in the 
    range [0, 1). For `f1`, `f2` values expressed in radians, a sampling 
    frequency of 2*pi should be used. 
 
    Remember that a zoom FFT can only interpolate the points of the existing 
    FFT.  It cannot help to resolve two separate nearby frequencies. 
    Frequency resolution can only be increased by increasing acquisition 
    time. 
 
    These functions are implemented using Bluestein's algorithm (as is 
    `scipy.fft`). [2]_ 
 
    References 
    ---------- 
    .. [1] Steve Alan Shilling, &quot;A study of the chirp z-transform and its 
           applications&quot;, pg 29 (1970) 
           https://krex.k-state.edu/dspace/bitstream/handle/2097/7844/LD2668R41972S43.pdf 
    .. [2] Leo I. Bluestein, &quot;A linear filtering approach to the computation 
           of the discrete Fourier transform,&quot; Northeast Electronics Research 
           and Engineering Meeting Record 10, 218-219 (1968). 
 
    Examples 
    -------- 
    To plot the transform results use something like the following: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal import ZoomFFT 
    &gt;&gt;&gt; t = np.linspace(0, 1, 1021) 
    &gt;&gt;&gt; x = np.cos(2*np.pi*15*t) + np.sin(2*np.pi*17*t) 
    &gt;&gt;&gt; f1, f2 = 5, 27 
    &gt;&gt;&gt; transform = ZoomFFT(len(x), [f1, f2], len(x), fs=1021) 
    &gt;&gt;&gt; X = transform(x) 
    &gt;&gt;&gt; f = np.linspace(f1, f2, len(x)) 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.plot(f, 20*np.log10(np.abs(X))) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">n</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">, </span><span class="s1">m</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, *, </span><span class="s1">fs</span><span class="s4">=</span><span class="s6">2</span><span class="s4">, </span><span class="s1">endpoint</span><span class="s4">=</span><span class="s3">False</span><span class="s4">):</span>
        <span class="s1">m </span><span class="s4">= </span><span class="s1">_validate_sizes</span><span class="s4">(</span><span class="s1">n</span><span class="s4">, </span><span class="s1">m</span><span class="s4">)</span>

        <span class="s1">k </span><span class="s4">= </span><span class="s1">arange</span><span class="s4">(</span><span class="s1">max</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">), </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">min_scalar_type</span><span class="s4">(-</span><span class="s1">max</span><span class="s4">(</span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span><span class="s4">)**</span><span class="s6">2</span><span class="s4">))</span>

        <span class="s3">if </span><span class="s1">np</span><span class="s4">.</span><span class="s1">size</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">) == </span><span class="s6">2</span><span class="s4">:</span>
            <span class="s1">f1</span><span class="s4">, </span><span class="s1">f2 </span><span class="s4">= </span><span class="s1">fn</span>
        <span class="s3">elif </span><span class="s1">np</span><span class="s4">.</span><span class="s1">size</span><span class="s4">(</span><span class="s1">fn</span><span class="s4">) == </span><span class="s6">1</span><span class="s4">:</span>
            <span class="s1">f1</span><span class="s4">, </span><span class="s1">f2 </span><span class="s4">= </span><span class="s6">0.0</span><span class="s4">, </span><span class="s1">fn</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">'fn must be a scalar or 2-length sequence'</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">f1</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">f2</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">fs </span><span class="s4">= </span><span class="s1">f1</span><span class="s4">, </span><span class="s1">f2</span><span class="s4">, </span><span class="s1">fs</span>

        <span class="s3">if </span><span class="s1">endpoint</span><span class="s4">:</span>
            <span class="s1">scale </span><span class="s4">= ((</span><span class="s1">f2 </span><span class="s4">- </span><span class="s1">f1</span><span class="s4">) * </span><span class="s1">m</span><span class="s4">) / (</span><span class="s1">fs </span><span class="s4">* (</span><span class="s1">m </span><span class="s4">- </span><span class="s6">1</span><span class="s4">))</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">scale </span><span class="s4">= (</span><span class="s1">f2 </span><span class="s4">- </span><span class="s1">f1</span><span class="s4">) / </span><span class="s1">fs</span>
        <span class="s1">a </span><span class="s4">= </span><span class="s1">cmath</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(</span><span class="s6">2j </span><span class="s4">* </span><span class="s1">pi </span><span class="s4">* </span><span class="s1">f1</span><span class="s4">/</span><span class="s1">fs</span><span class="s4">)</span>
        <span class="s1">wk2 </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(-(</span><span class="s6">1j </span><span class="s4">* </span><span class="s1">pi </span><span class="s4">* </span><span class="s1">scale </span><span class="s4">* </span><span class="s1">k</span><span class="s4">**</span><span class="s6">2</span><span class="s4">) / </span><span class="s1">m</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">w </span><span class="s4">= </span><span class="s1">cmath</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(-</span><span class="s6">2j</span><span class="s4">*</span><span class="s1">pi</span><span class="s4">/</span><span class="s1">m </span><span class="s4">* </span><span class="s1">scale</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">a </span><span class="s4">= </span><span class="s1">a</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">m</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">n </span><span class="s4">= </span><span class="s1">m</span><span class="s4">, </span><span class="s1">n</span>

        <span class="s1">ak </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">exp</span><span class="s4">(-</span><span class="s6">2j </span><span class="s4">* </span><span class="s1">pi </span><span class="s4">* </span><span class="s1">f1</span><span class="s4">/</span><span class="s1">fs </span><span class="s4">* </span><span class="s1">k</span><span class="s4">[:</span><span class="s1">n</span><span class="s4">])</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_Awk2 </span><span class="s4">= </span><span class="s1">ak </span><span class="s4">* </span><span class="s1">wk2</span><span class="s4">[:</span><span class="s1">n</span><span class="s4">]</span>

        <span class="s1">nfft </span><span class="s4">= </span><span class="s1">next_fast_len</span><span class="s4">(</span><span class="s1">n </span><span class="s4">+ </span><span class="s1">m </span><span class="s4">- </span><span class="s6">1</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_nfft </span><span class="s4">= </span><span class="s1">nfft</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_Fwk2 </span><span class="s4">= </span><span class="s1">fft</span><span class="s4">(</span><span class="s6">1</span><span class="s4">/</span><span class="s1">np</span><span class="s4">.</span><span class="s1">hstack</span><span class="s4">((</span><span class="s1">wk2</span><span class="s4">[</span><span class="s1">n</span><span class="s4">-</span><span class="s6">1</span><span class="s4">:</span><span class="s6">0</span><span class="s4">:-</span><span class="s6">1</span><span class="s4">], </span><span class="s1">wk2</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">])), </span><span class="s1">nfft</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_wk2 </span><span class="s4">= </span><span class="s1">wk2</span><span class="s4">[:</span><span class="s1">m</span><span class="s4">]</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_yidx </span><span class="s4">= </span><span class="s1">slice</span><span class="s4">(</span><span class="s1">n</span><span class="s4">-</span><span class="s6">1</span><span class="s4">, </span><span class="s1">n</span><span class="s4">+</span><span class="s1">m</span><span class="s4">-</span><span class="s6">1</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">czt</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">m</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, </span><span class="s1">a</span><span class="s4">=</span><span class="s6">1</span><span class="s4">+</span><span class="s6">0j</span><span class="s4">, *, </span><span class="s1">axis</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute the frequency response around a spiral in the Z plane. 
 
    Parameters 
    ---------- 
    x : array 
        The signal to transform. 
    m : int, optional 
        The number of output points desired.  Default is the length of the 
        input data. 
    w : complex, optional 
        The ratio between points in each step.  This must be precise or the 
        accumulated error will degrade the tail of the output sequence. 
        Defaults to equally spaced points around the entire unit circle. 
    a : complex, optional 
        The starting point in the complex plane.  Default is 1+0j. 
    axis : int, optional 
        Axis over which to compute the FFT. If not given, the last axis is 
        used. 
 
    Returns 
    ------- 
    out : ndarray 
        An array of the same dimensions as `x`, but with the length of the 
        transformed axis set to `m`. 
 
    See Also 
    -------- 
    CZT : Class that creates a callable chirp z-transform function. 
    zoom_fft : Convenience function for partial FFT calculations. 
 
    Notes 
    ----- 
    The defaults are chosen such that ``signal.czt(x)`` is equivalent to 
    ``fft.fft(x)`` and, if ``m &gt; len(x)``, that ``signal.czt(x, m)`` is 
    equivalent to ``fft.fft(x, m)``. 
 
    If the transform needs to be repeated, use `CZT` to construct a 
    specialized transform function which can be reused without 
    recomputing constants. 
 
    An example application is in system identification, repeatedly evaluating 
    small slices of the z-transform of a system, around where a pole is 
    expected to exist, to refine the estimate of the pole's true location. [1]_ 
 
    References 
    ---------- 
    .. [1] Steve Alan Shilling, &quot;A study of the chirp z-transform and its 
           applications&quot;, pg 20 (1970) 
           https://krex.k-state.edu/dspace/bitstream/handle/2097/7844/LD2668R41972S43.pdf 
 
    Examples 
    -------- 
    Generate a sinusoid: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; f1, f2, fs = 8, 10, 200  # Hz 
    &gt;&gt;&gt; t = np.linspace(0, 1, fs, endpoint=False) 
    &gt;&gt;&gt; x = np.sin(2*np.pi*t*f2) 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.plot(t, x) 
    &gt;&gt;&gt; plt.axis([0, 1, -1.1, 1.1]) 
    &gt;&gt;&gt; plt.show() 
 
    Its discrete Fourier transform has all of its energy in a single frequency 
    bin: 
 
    &gt;&gt;&gt; from scipy.fft import rfft, rfftfreq 
    &gt;&gt;&gt; from scipy.signal import czt, czt_points 
    &gt;&gt;&gt; plt.plot(rfftfreq(fs, 1/fs), abs(rfft(x))) 
    &gt;&gt;&gt; plt.margins(0, 0.1) 
    &gt;&gt;&gt; plt.show() 
 
    However, if the sinusoid is logarithmically-decaying: 
 
    &gt;&gt;&gt; x = np.exp(-t*f1) * np.sin(2*np.pi*t*f2) 
    &gt;&gt;&gt; plt.plot(t, x) 
    &gt;&gt;&gt; plt.axis([0, 1, -1.1, 1.1]) 
    &gt;&gt;&gt; plt.show() 
 
    the DFT will have spectral leakage: 
 
    &gt;&gt;&gt; plt.plot(rfftfreq(fs, 1/fs), abs(rfft(x))) 
    &gt;&gt;&gt; plt.margins(0, 0.1) 
    &gt;&gt;&gt; plt.show() 
 
    While the DFT always samples the z-transform around the unit circle, the 
    chirp z-transform allows us to sample the Z-transform along any 
    logarithmic spiral, such as a circle with radius smaller than unity: 
 
    &gt;&gt;&gt; M = fs // 2  # Just positive frequencies, like rfft 
    &gt;&gt;&gt; a = np.exp(-f1/fs)  # Starting point of the circle, radius &lt; 1 
    &gt;&gt;&gt; w = np.exp(-1j*np.pi/M)  # &quot;Step size&quot; of circle 
    &gt;&gt;&gt; points = czt_points(M + 1, w, a)  # M + 1 to include Nyquist 
    &gt;&gt;&gt; plt.plot(points.real, points.imag, '.') 
    &gt;&gt;&gt; plt.gca().add_patch(plt.Circle((0,0), radius=1, fill=False, alpha=.3)) 
    &gt;&gt;&gt; plt.axis('equal'); plt.axis([-1.05, 1.05, -0.05, 1.05]) 
    &gt;&gt;&gt; plt.show() 
 
    With the correct radius, this transforms the decaying sinusoid (and others 
    with the same decay rate) without spectral leakage: 
 
    &gt;&gt;&gt; z_vals = czt(x, M + 1, w, a)  # Include Nyquist for comparison to rfft 
    &gt;&gt;&gt; freqs = np.angle(points)*fs/(2*np.pi)  # angle = omega, radius = sigma 
    &gt;&gt;&gt; plt.plot(freqs, abs(z_vals)) 
    &gt;&gt;&gt; plt.margins(0, 0.1) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
    <span class="s1">transform </span><span class="s4">= </span><span class="s1">CZT</span><span class="s4">(</span><span class="s1">x</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s1">axis</span><span class="s4">], </span><span class="s1">m</span><span class="s4">=</span><span class="s1">m</span><span class="s4">, </span><span class="s1">w</span><span class="s4">=</span><span class="s1">w</span><span class="s4">, </span><span class="s1">a</span><span class="s4">=</span><span class="s1">a</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">transform</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s1">axis</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">zoom_fft</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">, </span><span class="s1">m</span><span class="s4">=</span><span class="s3">None</span><span class="s4">, *, </span><span class="s1">fs</span><span class="s4">=</span><span class="s6">2</span><span class="s4">, </span><span class="s1">endpoint</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Compute the DFT of `x` only for frequencies in range `fn`. 
 
    Parameters 
    ---------- 
    x : array 
        The signal to transform. 
    fn : array_like 
        A length-2 sequence [`f1`, `f2`] giving the frequency range, or a 
        scalar, for which the range [0, `fn`] is assumed. 
    m : int, optional 
        The number of points to evaluate.  The default is the length of `x`. 
    fs : float, optional 
        The sampling frequency.  If ``fs=10`` represented 10 kHz, for example, 
        then `f1` and `f2` would also be given in kHz. 
        The default sampling frequency is 2, so `f1` and `f2` should be 
        in the range [0, 1] to keep the transform below the Nyquist 
        frequency. 
    endpoint : bool, optional 
        If True, `f2` is the last sample. Otherwise, it is not included. 
        Default is False. 
    axis : int, optional 
        Axis over which to compute the FFT. If not given, the last axis is 
        used. 
 
    Returns 
    ------- 
    out : ndarray 
        The transformed signal.  The Fourier transform will be calculated 
        at the points f1, f1+df, f1+2df, ..., f2, where df=(f2-f1)/m. 
 
    See Also 
    -------- 
    ZoomFFT : Class that creates a callable partial FFT function. 
 
    Notes 
    ----- 
    The defaults are chosen such that ``signal.zoom_fft(x, 2)`` is equivalent 
    to ``fft.fft(x)`` and, if ``m &gt; len(x)``, that ``signal.zoom_fft(x, 2, m)`` 
    is equivalent to ``fft.fft(x, m)``. 
 
    To graph the magnitude of the resulting transform, use:: 
 
        plot(linspace(f1, f2, m, endpoint=False), abs(zoom_fft(x, [f1, f2], m))) 
 
    If the transform needs to be repeated, use `ZoomFFT` to construct 
    a specialized transform function which can be reused without 
    recomputing constants. 
 
    Examples 
    -------- 
    To plot the transform results use something like the following: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.signal import zoom_fft 
    &gt;&gt;&gt; t = np.linspace(0, 1, 1021) 
    &gt;&gt;&gt; x = np.cos(2*np.pi*15*t) + np.sin(2*np.pi*17*t) 
    &gt;&gt;&gt; f1, f2 = 5, 27 
    &gt;&gt;&gt; X = zoom_fft(x, [f1, f2], len(x), fs=1021) 
    &gt;&gt;&gt; f = np.linspace(f1, f2, len(x)) 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.plot(f, 20*np.log10(np.abs(X))) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">x </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">x</span><span class="s4">)</span>
    <span class="s1">transform </span><span class="s4">= </span><span class="s1">ZoomFFT</span><span class="s4">(</span><span class="s1">x</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s1">axis</span><span class="s4">], </span><span class="s1">fn</span><span class="s4">, </span><span class="s1">m</span><span class="s4">=</span><span class="s1">m</span><span class="s4">, </span><span class="s1">fs</span><span class="s4">=</span><span class="s1">fs</span><span class="s4">, </span><span class="s1">endpoint</span><span class="s4">=</span><span class="s1">endpoint</span><span class="s4">)</span>
    <span class="s3">return </span><span class="s1">transform</span><span class="s4">(</span><span class="s1">x</span><span class="s4">, </span><span class="s1">axis</span><span class="s4">=</span><span class="s1">axis</span><span class="s4">)</span>
</pre>
</body>
</html>