<html>
<head>
<title>_array_api.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #7a7e85;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_array_api.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Tools to support array_api.&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">wraps</span>

<span class="s2">import </span><span class="s1">numpy</span>
<span class="s2">import </span><span class="s1">scipy</span><span class="s3">.</span><span class="s1">special </span><span class="s2">as </span><span class="s1">special</span>

<span class="s2">from </span><span class="s3">..</span><span class="s1">_config </span><span class="s2">import </span><span class="s1">get_config</span>
<span class="s2">from </span><span class="s3">.</span><span class="s1">fixes </span><span class="s2">import </span><span class="s1">parse_version</span>

<span class="s1">_NUMPY_NAMESPACE_NAMES </span><span class="s3">= {</span><span class="s4">&quot;numpy&quot;</span><span class="s3">, </span><span class="s4">&quot;array_api_compat.numpy&quot;</span><span class="s3">}</span>


<span class="s2">def </span><span class="s1">yield_namespaces</span><span class="s3">(</span><span class="s1">include_numpy_namespaces</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Yield supported namespace. 
 
    This is meant to be used for testing purposes only. 
 
    Parameters 
    ---------- 
    include_numpy_namespaces : bool, default=True 
        If True, also yield numpy namespaces. 
 
    Returns 
    ------- 
    array_namespace : str 
        The name of the Array API namespace. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">array_namespace </span><span class="s2">in </span><span class="s3">[</span>
        <span class="s5"># The following is used to test the array_api_compat wrapper when</span>
        <span class="s5"># array_api_dispatch is enabled: in particular, the arrays used in the</span>
        <span class="s5"># tests are regular numpy arrays without any &quot;device&quot; attribute.</span>
        <span class="s4">&quot;numpy&quot;</span><span class="s3">,</span>
        <span class="s5"># Stricter NumPy-based Array API implementation. The</span>
        <span class="s5"># array_api_strict.Array instances always have a dummy &quot;device&quot; attribute.</span>
        <span class="s4">&quot;array_api_strict&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;cupy&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;cupy.array_api&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;torch&quot;</span><span class="s3">,</span>
    <span class="s3">]:</span>
        <span class="s2">if not </span><span class="s1">include_numpy_namespaces </span><span class="s2">and </span><span class="s1">array_namespace </span><span class="s2">in </span><span class="s1">_NUMPY_NAMESPACE_NAMES</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s2">yield </span><span class="s1">array_namespace</span>


<span class="s2">def </span><span class="s1">yield_namespace_device_dtype_combinations</span><span class="s3">(</span><span class="s1">include_numpy_namespaces</span><span class="s3">=</span><span class="s2">True</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Yield supported namespace, device, dtype tuples for testing. 
 
    Use this to test that an estimator works with all combinations. 
 
    Parameters 
    ---------- 
    include_numpy_namespaces : bool, default=True 
        If True, also yield numpy namespaces. 
 
    Returns 
    ------- 
    array_namespace : str 
        The name of the Array API namespace. 
 
    device : str 
        The name of the device on which to allocate the arrays. Can be None to 
        indicate that the default value should be used. 
 
    dtype_name : str 
        The name of the data type to use for arrays. Can be None to indicate 
        that the default value should be used. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">array_namespace </span><span class="s2">in </span><span class="s1">yield_namespaces</span><span class="s3">(</span>
        <span class="s1">include_numpy_namespaces</span><span class="s3">=</span><span class="s1">include_numpy_namespaces</span>
    <span class="s3">):</span>
        <span class="s2">if </span><span class="s1">array_namespace </span><span class="s3">== </span><span class="s4">&quot;torch&quot;</span><span class="s3">:</span>
            <span class="s2">for </span><span class="s1">device</span><span class="s3">, </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">itertools</span><span class="s3">.</span><span class="s1">product</span><span class="s3">(</span>
                <span class="s3">(</span><span class="s4">&quot;cpu&quot;</span><span class="s3">, </span><span class="s4">&quot;cuda&quot;</span><span class="s3">), (</span><span class="s4">&quot;float64&quot;</span><span class="s3">, </span><span class="s4">&quot;float32&quot;</span><span class="s3">)</span>
            <span class="s3">):</span>
                <span class="s2">yield </span><span class="s1">array_namespace</span><span class="s3">, </span><span class="s1">device</span><span class="s3">, </span><span class="s1">dtype</span>
            <span class="s2">yield </span><span class="s1">array_namespace</span><span class="s3">, </span><span class="s4">&quot;mps&quot;</span><span class="s3">, </span><span class="s4">&quot;float32&quot;</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">yield </span><span class="s1">array_namespace</span><span class="s3">, </span><span class="s2">None</span><span class="s3">, </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">_check_array_api_dispatch</span><span class="s3">(</span><span class="s1">array_api_dispatch</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Check that array_api_compat is installed and NumPy version is compatible. 
 
    array_api_compat follows NEP29, which has a higher minimum NumPy version than 
    scikit-learn. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">array_api_dispatch</span><span class="s3">:</span>
        <span class="s2">try</span><span class="s3">:</span>
            <span class="s2">import </span><span class="s1">array_api_compat  </span><span class="s5"># noqa</span>
        <span class="s2">except </span><span class="s1">ImportError</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ImportError</span><span class="s3">(</span>
                <span class="s4">&quot;array_api_compat is required to dispatch arrays using the API&quot;</span>
                <span class="s4">&quot; specification&quot;</span>
            <span class="s3">)</span>

        <span class="s1">numpy_version </span><span class="s3">= </span><span class="s1">parse_version</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">__version__</span><span class="s3">)</span>
        <span class="s1">min_numpy_version </span><span class="s3">= </span><span class="s4">&quot;1.21&quot;</span>
        <span class="s2">if </span><span class="s1">numpy_version </span><span class="s3">&lt; </span><span class="s1">parse_version</span><span class="s3">(</span><span class="s1">min_numpy_version</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">ImportError</span><span class="s3">(</span>
                <span class="s4">f&quot;NumPy must be </span><span class="s2">{</span><span class="s1">min_numpy_version</span><span class="s2">} </span><span class="s4">or newer to dispatch array using&quot;</span>
                <span class="s4">&quot; the API specification&quot;</span>
            <span class="s3">)</span>


<span class="s2">def </span><span class="s1">_single_array_device</span><span class="s3">(</span><span class="s1">array</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Hardware device where the array data resides on.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, (</span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">, </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">generic</span><span class="s3">)) </span><span class="s2">or not </span><span class="s1">hasattr</span><span class="s3">(</span>
        <span class="s1">array</span><span class="s3">, </span><span class="s4">&quot;device&quot;</span>
    <span class="s3">):</span>
        <span class="s2">return </span><span class="s4">&quot;cpu&quot;</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">array</span><span class="s3">.</span><span class="s1">device</span>


<span class="s2">def </span><span class="s1">device</span><span class="s3">(*</span><span class="s1">array_list</span><span class="s3">, </span><span class="s1">remove_none</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">remove_types</span><span class="s3">=(</span><span class="s1">str</span><span class="s3">,)):</span>
    <span class="s0">&quot;&quot;&quot;Hardware device where the array data resides on. 
 
    If the hardware device is not the same for all arrays, an error is raised. 
 
    Parameters 
    ---------- 
    *array_list : arrays 
        List of array instances from NumPy or an array API compatible library. 
 
    remove_none : bool, default=True 
        Whether to ignore None objects passed in array_list. 
 
    remove_types : tuple or list, default=(str,) 
        Types to ignore in array_list. 
 
    Returns 
    ------- 
    out : device 
        `device` object (see the &quot;Device Support&quot; section of the array API spec). 
    &quot;&quot;&quot;</span>
    <span class="s1">array_list </span><span class="s3">= </span><span class="s1">_remove_non_arrays</span><span class="s3">(</span>
        <span class="s3">*</span><span class="s1">array_list</span><span class="s3">, </span><span class="s1">remove_none</span><span class="s3">=</span><span class="s1">remove_none</span><span class="s3">, </span><span class="s1">remove_types</span><span class="s3">=</span><span class="s1">remove_types</span>
    <span class="s3">)</span>

    <span class="s5"># Note that _remove_non_arrays ensures that array_list is not empty.</span>
    <span class="s1">device_ </span><span class="s3">= </span><span class="s1">_single_array_device</span><span class="s3">(</span><span class="s1">array_list</span><span class="s3">[</span><span class="s6">0</span><span class="s3">])</span>

    <span class="s5"># Note: here we cannot simply use a Python `set` as it requires</span>
    <span class="s5"># hashable members which is not guaranteed for Array API device</span>
    <span class="s5"># objects. In particular, CuPy devices are not hashable at the</span>
    <span class="s5"># time of writing.</span>
    <span class="s2">for </span><span class="s1">array </span><span class="s2">in </span><span class="s1">array_list</span><span class="s3">[</span><span class="s6">1</span><span class="s3">:]:</span>
        <span class="s1">device_other </span><span class="s3">= </span><span class="s1">_single_array_device</span><span class="s3">(</span><span class="s1">array</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">device_ </span><span class="s3">!= </span><span class="s1">device_other</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">f&quot;Input arrays use different devices: </span><span class="s2">{</span><span class="s1">str</span><span class="s3">(</span><span class="s1">device_</span><span class="s3">)</span><span class="s2">}</span><span class="s4">, &quot;</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">str</span><span class="s3">(</span><span class="s1">device_other</span><span class="s3">)</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>

    <span class="s2">return </span><span class="s1">device_</span>


<span class="s2">def </span><span class="s1">size</span><span class="s3">(</span><span class="s1">x</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return the total number of elements of x. 
 
    Parameters 
    ---------- 
    x : array 
        Array instance from NumPy or an array API compatible library. 
 
    Returns 
    ------- 
    out : int 
        Total number of elements. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">math</span><span class="s3">.</span><span class="s1">prod</span><span class="s3">(</span><span class="s1">x</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_is_numpy_namespace</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return True if xp is backed by NumPy.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s2">in </span><span class="s1">_NUMPY_NAMESPACE_NAMES</span>


<span class="s2">def </span><span class="s1">_union1d</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">_is_numpy_namespace</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">union1d</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">))</span>
    <span class="s2">assert </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s1">b</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s6">1</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">unique_values</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">concat</span><span class="s3">([</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">unique_values</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">unique_values</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)]))</span>


<span class="s2">def </span><span class="s1">isdtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">, *, </span><span class="s1">xp</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Returns a boolean indicating whether a provided dtype is of type &quot;kind&quot;. 
 
    Included in the v2022.12 of the Array API spec. 
    https://data-apis.org/array-api/latest/API_specification/generated/array_api.isdtype.html 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">any</span><span class="s3">(</span><span class="s1">_isdtype_single</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">kind</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">_isdtype_single</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_isdtype_single</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">, *, </span><span class="s1">xp</span><span class="s3">):</span>
    <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">kind</span><span class="s3">, </span><span class="s1">str</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;bool&quot;</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">bool</span>
        <span class="s2">elif </span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;signed integer&quot;</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">dtype </span><span class="s2">in </span><span class="s3">{</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">int8</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">int16</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">int32</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">int64</span><span class="s3">}</span>
        <span class="s2">elif </span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;unsigned integer&quot;</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">dtype </span><span class="s2">in </span><span class="s3">{</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">uint8</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">uint16</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">uint32</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">uint64</span><span class="s3">}</span>
        <span class="s2">elif </span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;integral&quot;</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">any</span><span class="s3">(</span>
                <span class="s1">_isdtype_single</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s3">(</span><span class="s4">&quot;signed integer&quot;</span><span class="s3">, </span><span class="s4">&quot;unsigned integer&quot;</span><span class="s3">)</span>
            <span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;real floating&quot;</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">supported_float_dtypes</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">)</span>
        <span class="s2">elif </span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;complex floating&quot;</span><span class="s3">:</span>
            <span class="s5"># Some name spaces do not have complex, such as cupy.array_api</span>
            <span class="s1">complex_dtypes </span><span class="s3">= </span><span class="s1">set</span><span class="s3">()</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s4">&quot;complex64&quot;</span><span class="s3">):</span>
                <span class="s1">complex_dtypes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">complex64</span><span class="s3">)</span>
            <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s4">&quot;complex128&quot;</span><span class="s3">):</span>
                <span class="s1">complex_dtypes</span><span class="s3">.</span><span class="s1">add</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">complex128</span><span class="s3">)</span>
            <span class="s2">return </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">complex_dtypes</span>
        <span class="s2">elif </span><span class="s1">kind </span><span class="s3">== </span><span class="s4">&quot;numeric&quot;</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">any</span><span class="s3">(</span>
                <span class="s1">_isdtype_single</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">)</span>
                <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s3">(</span><span class="s4">&quot;integral&quot;</span><span class="s3">, </span><span class="s4">&quot;real floating&quot;</span><span class="s3">, </span><span class="s4">&quot;complex floating&quot;</span><span class="s3">)</span>
            <span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;Unrecognized data type kind: </span><span class="s2">{</span><span class="s1">kind</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">dtype </span><span class="s3">== </span><span class="s1">kind</span>


<span class="s2">def </span><span class="s1">supported_float_dtypes</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Supported floating point types for the namespace. 
 
    Note: float16 is not officially part of the Array API spec at the 
    time of writing but scikit-learn estimators and functions can choose 
    to accept it when xp.float16 is defined. 
 
    https://data-apis.org/array-api/latest/API_specification/data_types.html 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">, </span><span class="s4">&quot;float16&quot;</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">float16</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">float64</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">float32</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">ensure_common_namespace_device</span><span class="s3">(</span><span class="s1">reference</span><span class="s3">, *</span><span class="s1">arrays</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Ensure that all arrays use the same namespace and device as reference. 
 
    If neccessary the arrays are moved to the same namespace and device as 
    the reference array. 
 
    Parameters 
    ---------- 
    reference : array 
        Reference array. 
 
    *arrays : array 
        Arrays to check. 
 
    Returns 
    ------- 
    arrays : list 
        Arrays with the same namespace and device as reference. 
    &quot;&quot;&quot;</span>
    <span class="s1">xp</span><span class="s3">, </span><span class="s1">is_array_api </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">reference</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">is_array_api</span><span class="s3">:</span>
        <span class="s1">device_ </span><span class="s3">= </span><span class="s1">device</span><span class="s3">(</span><span class="s1">reference</span><span class="s3">)</span>
        <span class="s5"># Move arrays to the same namespace and device as the reference array.</span>
        <span class="s2">return </span><span class="s3">[</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">device</span><span class="s3">=</span><span class="s1">device_</span><span class="s3">) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">arrays</span>


<span class="s2">class </span><span class="s1">_ArrayAPIWrapper</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;sklearn specific Array API compatibility wrapper 
 
    This wrapper makes it possible for scikit-learn maintainers to 
    deal with discrepancies between different implementations of the 
    Python Array API standard and its evolution over time. 
 
    The Python Array API standard specification: 
    https://data-apis.org/array-api/latest/ 
 
    Documentation of the NumPy implementation: 
    https://numpy.org/neps/nep-0047-array-api-standard.html 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">array_namespace</span><span class="s3">):</span>
        <span class="s1">self</span><span class="s3">.</span><span class="s1">_namespace </span><span class="s3">= </span><span class="s1">array_namespace</span>

    <span class="s2">def </span><span class="s1">__getattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_namespace</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">__eq__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_namespace </span><span class="s3">== </span><span class="s1">other</span><span class="s3">.</span><span class="s1">_namespace</span>

    <span class="s2">def </span><span class="s1">isdtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">isdtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">self</span><span class="s3">.</span><span class="s1">_namespace</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_check_device_cpu</span><span class="s3">(</span><span class="s1">device</span><span class="s3">):  </span><span class="s5"># noqa</span>
    <span class="s2">if </span><span class="s1">device </span><span class="s2">not in </span><span class="s3">{</span><span class="s4">&quot;cpu&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">}:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span><span class="s4">f&quot;Unsupported device for NumPy: </span><span class="s2">{</span><span class="s1">device</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_accept_device_cpu</span><span class="s3">(</span><span class="s1">func</span><span class="s3">):</span>
    <span class="s3">@</span><span class="s1">wraps</span><span class="s3">(</span><span class="s1">func</span><span class="s3">)</span>
    <span class="s2">def </span><span class="s1">wrapped_func</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">):</span>
        <span class="s1">_check_device_cpu</span><span class="s3">(</span><span class="s1">kwargs</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">(</span><span class="s4">&quot;device&quot;</span><span class="s3">, </span><span class="s2">None</span><span class="s3">))</span>
        <span class="s2">return </span><span class="s1">func</span><span class="s3">(*</span><span class="s1">args</span><span class="s3">, **</span><span class="s1">kwargs</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">wrapped_func</span>


<span class="s2">class </span><span class="s1">_NumPyAPIWrapper</span><span class="s3">:</span>
    <span class="s0">&quot;&quot;&quot;Array API compat wrapper for any numpy version 
 
    NumPy &lt; 2 does not implement the namespace. NumPy 2 and later should 
    progressively implement more an more of the latest Array API spec but this 
    is still work in progress at this time. 
 
    This wrapper makes it possible to write code that uses the standard Array 
    API while working with any version of NumPy supported by scikit-learn. 
 
    See the `get_namespace()` public function for more details. 
    &quot;&quot;&quot;</span>

    <span class="s5"># TODO: once scikit-learn drops support for NumPy &lt; 2, this class can be</span>
    <span class="s5"># removed, assuming Array API compliance of NumPy 2 is actually sufficient</span>
    <span class="s5"># for scikit-learn's needs.</span>

    <span class="s5"># Creation functions in spec:</span>
    <span class="s5"># https://data-apis.org/array-api/latest/API_specification/creation_functions.html</span>
    <span class="s1">_CREATION_FUNCS </span><span class="s3">= {</span>
        <span class="s4">&quot;arange&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;empty&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;empty_like&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;eye&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;full&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;full_like&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;linspace&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;ones&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;ones_like&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;zeros&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;zeros_like&quot;</span><span class="s3">,</span>
    <span class="s3">}</span>
    <span class="s5"># Data types in spec</span>
    <span class="s5"># https://data-apis.org/array-api/latest/API_specification/data_types.html</span>
    <span class="s1">_DTYPES </span><span class="s3">= {</span>
        <span class="s4">&quot;int8&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;int16&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;int32&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;int64&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;uint8&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;uint16&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;uint32&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;uint64&quot;</span><span class="s3">,</span>
        <span class="s5"># XXX: float16 is not part of the Array API spec but exposed by</span>
        <span class="s5"># some namespaces.</span>
        <span class="s4">&quot;float16&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;float32&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;float64&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;complex64&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;complex128&quot;</span><span class="s3">,</span>
    <span class="s3">}</span>

    <span class="s2">def </span><span class="s1">__getattr__</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">name</span><span class="s3">):</span>
        <span class="s1">attr </span><span class="s3">= </span><span class="s1">getattr</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">, </span><span class="s1">name</span><span class="s3">)</span>

        <span class="s5"># Support device kwargs and make sure they are on the CPU</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_CREATION_FUNCS</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_accept_device_cpu</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">)</span>

        <span class="s5"># Convert to dtype objects</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self</span><span class="s3">.</span><span class="s1">_DTYPES</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">(</span><span class="s1">attr</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">attr</span>

    <span class="s3">@</span><span class="s1">property</span>
    <span class="s2">def </span><span class="s1">bool</span><span class="s3">(</span><span class="s1">self</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">bool_</span>

    <span class="s2">def </span><span class="s1">astype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, *, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">casting</span><span class="s3">=</span><span class="s4">&quot;unsafe&quot;</span><span class="s3">):</span>
        <span class="s5"># astype is not defined in the top level NumPy namespace</span>
        <span class="s2">return </span><span class="s1">x</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">, </span><span class="s1">casting</span><span class="s3">=</span><span class="s1">casting</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, *, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">device</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):  </span><span class="s5"># noqa</span>
        <span class="s1">_check_device_cpu</span><span class="s3">(</span><span class="s1">device</span><span class="s3">)</span>
        <span class="s5"># Support copy in NumPy namespace</span>
        <span class="s2">if </span><span class="s1">copy </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">unique_inverse</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">return_inverse</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">unique_counts</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">return_counts</span><span class="s3">=</span><span class="s2">True</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">unique_values</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">unique</span><span class="s3">(</span><span class="s1">x</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">concat</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">arrays</span><span class="s3">, *, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">concatenate</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, *, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
        <span class="s0">&quot;&quot;&quot;Gives a new shape to an array without changing its data. 
 
        The Array API specification requires shape to be a tuple. 
        https://data-apis.org/array-api/latest/API_specification/generated/array_api.reshape.html 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">, </span><span class="s1">tuple</span><span class="s3">):</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                <span class="s4">f&quot;shape must be a tuple, got </span><span class="s2">{</span><span class="s1">shape</span><span class="s2">!r} </span><span class="s4">of type </span><span class="s2">{</span><span class="s1">type</span><span class="s3">(</span><span class="s1">shape</span><span class="s3">)</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">copy </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s1">x </span><span class="s3">= </span><span class="s1">x</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
        <span class="s2">return </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">x</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s2">def </span><span class="s1">isdtype</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">isdtype</span><span class="s3">(</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">kind</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">self</span><span class="s3">)</span>


<span class="s1">_NUMPY_API_WRAPPER_INSTANCE </span><span class="s3">= </span><span class="s1">_NumPyAPIWrapper</span><span class="s3">()</span>


<span class="s2">def </span><span class="s1">_remove_non_arrays</span><span class="s3">(*</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">remove_none</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">remove_types</span><span class="s3">=(</span><span class="s1">str</span><span class="s3">,)):</span>
    <span class="s0">&quot;&quot;&quot;Filter arrays to exclude None and/or specific types. 
 
    Raise ValueError if no arrays are left after filtering. 
 
    Parameters 
    ---------- 
    *arrays : array objects 
        Array objects. 
 
    remove_none : bool, default=True 
        Whether to ignore None objects passed in arrays. 
 
    remove_types : tuple or list, default=(str,) 
        Types to ignore in the arrays. 
 
    Returns 
    ------- 
    filtered_arrays : list 
        List of arrays with None and typoe 
    &quot;&quot;&quot;</span>
    <span class="s1">filtered_arrays </span><span class="s3">= []</span>
    <span class="s1">remove_types </span><span class="s3">= </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">remove_types</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">array </span><span class="s2">in </span><span class="s1">arrays</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">remove_none </span><span class="s2">and </span><span class="s1">array </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">remove_types</span><span class="s3">):</span>
            <span class="s2">continue</span>
        <span class="s1">filtered_arrays</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">array</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">filtered_arrays</span><span class="s3">:</span>
        <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
            <span class="s4">f&quot;At least one input array expected after filtering with </span><span class="s2">{</span><span class="s1">remove_none</span><span class="s3">=</span><span class="s2">}</span><span class="s4">, &quot;</span>
            <span class="s4">f&quot;remove_types=[</span><span class="s2">{</span><span class="s4">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">t</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">remove_types</span><span class="s3">)</span><span class="s2">}</span><span class="s4">]. Got none. &quot;</span>
            <span class="s4">f&quot;Original types: [</span><span class="s2">{</span><span class="s4">', '</span><span class="s3">.</span><span class="s1">join</span><span class="s3">(</span><span class="s1">type</span><span class="s3">(</span><span class="s1">a</span><span class="s3">).</span><span class="s1">__name__ </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays</span><span class="s3">)</span><span class="s2">}</span><span class="s4">].&quot;</span>
        <span class="s3">)</span>
    <span class="s2">return </span><span class="s1">filtered_arrays</span>


<span class="s2">def </span><span class="s1">get_namespace</span><span class="s3">(*</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">remove_none</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">remove_types</span><span class="s3">=(</span><span class="s1">str</span><span class="s3">,), </span><span class="s1">xp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Get namespace of arrays. 
 
    Introspect `arrays` arguments and return their common Array API compatible 
    namespace object, if any. 
 
    See: https://numpy.org/neps/nep-0047-array-api-standard.html 
 
    If `arrays` are regular numpy arrays, an instance of the `_NumPyAPIWrapper` 
    compatibility wrapper is returned instead. 
 
    Namespace support is not enabled by default. To enabled it call: 
 
      sklearn.set_config(array_api_dispatch=True) 
 
    or: 
 
      with sklearn.config_context(array_api_dispatch=True): 
          # your code here 
 
    Otherwise an instance of the `_NumPyAPIWrapper` compatibility wrapper is 
    always returned irrespective of the fact that arrays implement the 
    `__array_namespace__` protocol or not. 
 
    Parameters 
    ---------- 
    *arrays : array objects 
        Array objects. 
 
    remove_none : bool, default=True 
        Whether to ignore None objects passed in arrays. 
 
    remove_types : tuple or list, default=(str,) 
        Types to ignore in the arrays. 
 
    xp : module, default=None 
        Precomputed array namespace module. When passed, typically from a caller 
        that has already performed inspection of its own inputs, skips array 
        namespace inspection. 
 
    Returns 
    ------- 
    namespace : module 
        Namespace shared by array objects. If any of the `arrays` are not arrays, 
        the namespace defaults to NumPy. 
 
    is_array_api_compliant : bool 
        True if the arrays are containers that implement the Array API spec. 
        Always False when array_api_dispatch=False. 
    &quot;&quot;&quot;</span>
    <span class="s1">array_api_dispatch </span><span class="s3">= </span><span class="s1">get_config</span><span class="s3">()[</span><span class="s4">&quot;array_api_dispatch&quot;</span><span class="s3">]</span>
    <span class="s2">if not </span><span class="s1">array_api_dispatch</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">xp </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">xp</span><span class="s3">, </span><span class="s2">False</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">_NUMPY_API_WRAPPER_INSTANCE</span><span class="s3">, </span><span class="s2">False</span>

    <span class="s2">if </span><span class="s1">xp </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">xp</span><span class="s3">, </span><span class="s2">True</span>

    <span class="s1">arrays </span><span class="s3">= </span><span class="s1">_remove_non_arrays</span><span class="s3">(</span>
        <span class="s3">*</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">remove_none</span><span class="s3">=</span><span class="s1">remove_none</span><span class="s3">, </span><span class="s1">remove_types</span><span class="s3">=</span><span class="s1">remove_types</span>
    <span class="s3">)</span>

    <span class="s1">_check_array_api_dispatch</span><span class="s3">(</span><span class="s1">array_api_dispatch</span><span class="s3">)</span>

    <span class="s5"># array-api-compat is a required dependency of scikit-learn only when</span>
    <span class="s5"># configuring `array_api_dispatch=True`. Its import should therefore be</span>
    <span class="s5"># protected by _check_array_api_dispatch to display an informative error</span>
    <span class="s5"># message in case it is missing.</span>
    <span class="s2">import </span><span class="s1">array_api_compat</span>

    <span class="s1">namespace</span><span class="s3">, </span><span class="s1">is_array_api_compliant </span><span class="s3">= </span><span class="s1">array_api_compat</span><span class="s3">.</span><span class="s1">get_namespace</span><span class="s3">(*</span><span class="s1">arrays</span><span class="s3">), </span><span class="s2">True</span>

    <span class="s5"># These namespaces need additional wrapping to smooth out small differences</span>
    <span class="s5"># between implementations</span>
    <span class="s2">if </span><span class="s1">namespace</span><span class="s3">.</span><span class="s1">__name__ </span><span class="s2">in </span><span class="s3">{</span><span class="s4">&quot;cupy.array_api&quot;</span><span class="s3">}:</span>
        <span class="s1">namespace </span><span class="s3">= </span><span class="s1">_ArrayAPIWrapper</span><span class="s3">(</span><span class="s1">namespace</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">namespace</span><span class="s3">, </span><span class="s1">is_array_api_compliant</span>


<span class="s2">def </span><span class="s1">get_namespace_and_device</span><span class="s3">(*</span><span class="s1">array_list</span><span class="s3">, </span><span class="s1">remove_none</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">remove_types</span><span class="s3">=(</span><span class="s1">str</span><span class="s3">,)):</span>
    <span class="s0">&quot;&quot;&quot;Combination into one single function of `get_namespace` and `device`.&quot;&quot;&quot;</span>
    <span class="s1">array_list </span><span class="s3">= </span><span class="s1">_remove_non_arrays</span><span class="s3">(</span>
        <span class="s3">*</span><span class="s1">array_list</span><span class="s3">, </span><span class="s1">remove_none</span><span class="s3">=</span><span class="s1">remove_none</span><span class="s3">, </span><span class="s1">remove_types</span><span class="s3">=</span><span class="s1">remove_types</span>
    <span class="s3">)</span>

    <span class="s1">skip_remove_kwargs </span><span class="s3">= </span><span class="s1">dict</span><span class="s3">(</span><span class="s1">remove_none</span><span class="s3">=</span><span class="s2">False</span><span class="s3">, </span><span class="s1">remove_types</span><span class="s3">=[])</span>

    <span class="s1">xp</span><span class="s3">, </span><span class="s1">is_array_api </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(*</span><span class="s1">array_list</span><span class="s3">, **</span><span class="s1">skip_remove_kwargs</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">is_array_api</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s3">(</span>
            <span class="s1">xp</span><span class="s3">,</span>
            <span class="s1">is_array_api</span><span class="s3">,</span>
            <span class="s1">device</span><span class="s3">(*</span><span class="s1">array_list</span><span class="s3">, **</span><span class="s1">skip_remove_kwargs</span><span class="s3">),</span>
        <span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">xp</span><span class="s3">, </span><span class="s2">False</span><span class="s3">, </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">_expit</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s1">xp</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">_is_numpy_namespace</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">special</span><span class="s3">.</span><span class="s1">expit</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)))</span>

    <span class="s2">return </span><span class="s6">1.0 </span><span class="s3">/ (</span><span class="s6">1.0 </span><span class="s3">+ </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">exp</span><span class="s3">(-</span><span class="s1">X</span><span class="s3">))</span>


<span class="s2">def </span><span class="s1">_add_to_diagonal</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">):</span>
    <span class="s5"># Workaround for the lack of support for xp.reshape(a, shape, copy=False) in</span>
    <span class="s5"># numpy.array_api: https://github.com/numpy/numpy/issues/23410</span>
    <span class="s1">value </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">array</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">_is_numpy_namespace</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">):</span>
        <span class="s1">array_np </span><span class="s3">= </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">array</span><span class="s3">)</span>
        <span class="s1">array_np</span><span class="s3">.</span><span class="s1">flat</span><span class="s3">[:: </span><span class="s1">array</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">] + </span><span class="s6">1</span><span class="s3">] += </span><span class="s1">value</span>
        <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">array_np</span><span class="s3">)</span>
    <span class="s2">elif </span><span class="s1">value</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s6">1</span><span class="s3">:</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">array</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]):</span>
            <span class="s1">array</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">i</span><span class="s3">] += </span><span class="s1">value</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s5"># scalar value</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">array</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">]):</span>
            <span class="s1">array</span><span class="s3">[</span><span class="s1">i</span><span class="s3">, </span><span class="s1">i</span><span class="s3">] += </span><span class="s1">value</span>


<span class="s2">def </span><span class="s1">_find_matching_floating_dtype</span><span class="s3">(*</span><span class="s1">arrays</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Find a suitable floating point dtype when computing with arrays. 
 
    If any of the arrays are floating point, return the dtype with the highest 
    precision by following official type promotion rules: 
 
    https://data-apis.org/array-api/latest/API_specification/type_promotion.html 
 
    If there are no floating point input arrays (all integral inputs for 
    instance), return the default floating point dtype for the namespace. 
    &quot;&quot;&quot;</span>
    <span class="s1">dtyped_arrays </span><span class="s3">= [</span><span class="s1">a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">arrays </span><span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s4">&quot;dtype&quot;</span><span class="s3">)]</span>
    <span class="s1">floating_dtypes </span><span class="s3">= [</span>
        <span class="s1">a</span><span class="s3">.</span><span class="s1">dtype </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">dtyped_arrays </span><span class="s2">if </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">isdtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s4">&quot;real floating&quot;</span><span class="s3">)</span>
    <span class="s3">]</span>
    <span class="s2">if </span><span class="s1">floating_dtypes</span><span class="s3">:</span>
        <span class="s5"># Return the floating dtype with the highest precision:</span>
        <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">result_type</span><span class="s3">(*</span><span class="s1">floating_dtypes</span><span class="s3">)</span>

    <span class="s5"># If none of the input arrays have a floating point dtype, they must be all</span>
    <span class="s5"># integer arrays or containers of Python scalars: return the default</span>
    <span class="s5"># floating point dtype for the namespace (implementation specific).</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s6">0.0</span><span class="s3">).</span><span class="s1">dtype</span>


<span class="s2">def </span><span class="s1">_average</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">normalize</span><span class="s3">=</span><span class="s2">True</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Partial port of np.average to support the Array API. 
 
    It does a best effort at mimicking the return dtype rule described at 
    https://numpy.org/doc/stable/reference/generated/numpy.average.html but 
    only for the common cases needed in scikit-learn. 
    &quot;&quot;&quot;</span>
    <span class="s1">xp</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">device_ </span><span class="s3">= </span><span class="s1">get_namespace_and_device</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">_is_numpy_namespace</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">):</span>
        <span class="s2">if </span><span class="s1">normalize</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">average</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">=</span><span class="s1">weights</span><span class="s3">))</span>
        <span class="s2">elif </span><span class="s1">axis </span><span class="s2">is None and </span><span class="s1">weights </span><span class="s2">is not None</span><span class="s3">:</span>
            <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">dot</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">))</span>

    <span class="s1">a </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">device</span><span class="s3">=</span><span class="s1">device_</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">weights </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">weights </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">, </span><span class="s1">device</span><span class="s3">=</span><span class="s1">device_</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">weights </span><span class="s2">is not None and </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape </span><span class="s3">!= </span><span class="s1">weights</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">axis </span><span class="s2">is None</span><span class="s3">:</span>
            <span class="s2">raise </span><span class="s1">TypeError</span><span class="s3">(</span>
                <span class="s4">f&quot;Axis must be specified when the shape of a </span><span class="s2">{</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span><span class="s2">} </span><span class="s4">and &quot;</span>
                <span class="s4">f&quot;weights </span><span class="s2">{</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span><span class="s2">} </span><span class="s4">differ.&quot;</span>
            <span class="s3">)</span>

        <span class="s2">if </span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">) != (</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">],):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span><span class="s3">(</span>
                <span class="s4">f&quot;Shape of weights weights.shape=</span><span class="s2">{</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span><span class="s2">} </span><span class="s4">must be &quot;</span>
                <span class="s4">f&quot;consistent with a.shape=</span><span class="s2">{</span><span class="s1">tuple</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">)</span><span class="s2">} </span><span class="s4">and </span><span class="s2">{</span><span class="s1">axis</span><span class="s3">=</span><span class="s2">}</span><span class="s4">.&quot;</span>
            <span class="s3">)</span>

        <span class="s5"># If weights are 1D, add singleton dimensions for broadcasting</span>
        <span class="s1">shape </span><span class="s3">= [</span><span class="s6">1</span><span class="s3">] * </span><span class="s1">a</span><span class="s3">.</span><span class="s1">ndim</span>
        <span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">] = </span><span class="s1">a</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s1">axis</span><span class="s3">]</span>
        <span class="s1">weights </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">isdtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s4">&quot;complex floating&quot;</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span>
            <span class="s4">&quot;Complex floating point values are not supported by average.&quot;</span>
        <span class="s3">)</span>
    <span class="s2">if </span><span class="s1">weights </span><span class="s2">is not None and </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">isdtype</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">, </span><span class="s4">&quot;complex floating&quot;</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span><span class="s3">(</span>
            <span class="s4">&quot;Complex floating point values are not supported by average.&quot;</span>
        <span class="s3">)</span>

    <span class="s1">output_dtype </span><span class="s3">= </span><span class="s1">_find_matching_floating_dtype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">)</span>
    <span class="s1">a </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">output_dtype</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">weights </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">mean </span><span class="s2">if </span><span class="s1">normalize </span><span class="s2">else </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">)(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s1">weights </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">, </span><span class="s1">output_dtype</span><span class="s3">)</span>

    <span class="s1">sum_ </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">multiply</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>

    <span class="s2">if not </span><span class="s1">normalize</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">sum_</span>

    <span class="s1">scale </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">scale </span><span class="s3">== </span><span class="s6">0.0</span><span class="s3">):</span>
        <span class="s2">raise </span><span class="s1">ZeroDivisionError</span><span class="s3">(</span><span class="s4">&quot;Weights sum to zero, can't be normalized&quot;</span><span class="s3">)</span>

    <span class="s2">return </span><span class="s1">sum_ </span><span class="s3">/ </span><span class="s1">scale</span>


<span class="s2">def </span><span class="s1">_nanmin</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5"># TODO: refactor once nan-aware reductions are standardized:</span>
    <span class="s5"># https://github.com/data-apis/array-api/issues/621</span>
    <span class="s1">xp</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">_is_numpy_namespace</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">nanmin</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">))</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(+</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, </span><span class="s1">device</span><span class="s3">=</span><span class="s1">device</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)), </span><span class="s1">X</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s5"># Replace Infs from all NaN slices with NaN again</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">):</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">), </span><span class="s1">X</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">X</span>


<span class="s2">def </span><span class="s1">_nanmax</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s5"># TODO: refactor once nan-aware reductions are standardized:</span>
    <span class="s5"># https://github.com/data-apis/array-api/issues/621</span>
    <span class="s1">xp</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">_is_numpy_namespace</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">):</span>
        <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">nanmax</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">))</span>

    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">isnan</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)</span>
        <span class="s1">X </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(-</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">inf</span><span class="s3">, </span><span class="s1">device</span><span class="s3">=</span><span class="s1">device</span><span class="s3">(</span><span class="s1">X</span><span class="s3">)), </span><span class="s1">X</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s5"># Replace Infs from all NaN slices with NaN again</span>
        <span class="s1">mask </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">all</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">any</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">):</span>
            <span class="s1">X </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">mask</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">nan</span><span class="s3">), </span><span class="s1">X</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">X</span>


<span class="s2">def </span><span class="s1">_asarray_with_order</span><span class="s3">(</span>
    <span class="s1">array</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, *, </span><span class="s1">xp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">device</span><span class="s3">=</span><span class="s2">None</span>
<span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Helper to support the order kwarg only for NumPy-backed arrays 
 
    Memory layout parameter `order` is not exposed in the Array API standard, 
    however some input validation code in scikit-learn needs to work both 
    for classes and functions that will leverage Array API only operations 
    and for code that inherently relies on NumPy backed data containers with 
    specific memory layout constraints (e.g. our own Cython code). The 
    purpose of this helper is to make it possible to share code for data 
    container validation without memory copies for both downstream use cases: 
    the `order` parameter is only enforced if the input array implementation 
    is NumPy based, otherwise `order` is just silently ignored. 
    &quot;&quot;&quot;</span>
    <span class="s1">xp</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">_is_numpy_namespace</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">):</span>
        <span class="s5"># Use NumPy API to support order</span>
        <span class="s2">if </span><span class="s1">copy </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s1">array </span><span class="s3">= </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>
        <span class="s2">else</span><span class="s3">:</span>
            <span class="s1">array </span><span class="s3">= </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s1">order</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">)</span>

        <span class="s5"># At this point array is a NumPy ndarray. We convert it to an array</span>
        <span class="s5"># container that is consistent with the input's namespace.</span>
        <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">array</span><span class="s3">)</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">dtype</span><span class="s3">, </span><span class="s1">copy</span><span class="s3">=</span><span class="s1">copy</span><span class="s3">, </span><span class="s1">device</span><span class="s3">=</span><span class="s1">device</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_ravel</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Array API compliant version of np.ravel. 
 
    For non numpy namespaces, it just returns a flattened array, that might 
    be or not be a copy. 
    &quot;&quot;&quot;</span>
    <span class="s1">xp</span><span class="s3">, </span><span class="s1">_ </span><span class="s3">= </span><span class="s1">get_namespace</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">=</span><span class="s1">xp</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">_is_numpy_namespace</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">):</span>
        <span class="s1">array </span><span class="s3">= </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">array</span><span class="s3">)</span>
        <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">ravel</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">order</span><span class="s3">=</span><span class="s4">&quot;C&quot;</span><span class="s3">))</span>

    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">=(-</span><span class="s6">1</span><span class="s3">,))</span>


<span class="s2">def </span><span class="s1">_convert_to_numpy</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Convert X into a NumPy ndarray on the CPU.&quot;&quot;&quot;</span>
    <span class="s1">xp_name </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">__name__</span>

    <span class="s2">if </span><span class="s1">xp_name </span><span class="s2">in </span><span class="s3">{</span><span class="s4">&quot;array_api_compat.torch&quot;</span><span class="s3">, </span><span class="s4">&quot;torch&quot;</span><span class="s3">}:</span>
        <span class="s2">return </span><span class="s1">array</span><span class="s3">.</span><span class="s1">cpu</span><span class="s3">().</span><span class="s1">numpy</span><span class="s3">()</span>
    <span class="s2">elif </span><span class="s1">xp_name </span><span class="s3">== </span><span class="s4">&quot;cupy.array_api&quot;</span><span class="s3">:</span>
        <span class="s2">return </span><span class="s1">array</span><span class="s3">.</span><span class="s1">_array</span><span class="s3">.</span><span class="s1">get</span><span class="s3">()</span>
    <span class="s2">elif </span><span class="s1">xp_name </span><span class="s2">in </span><span class="s3">{</span><span class="s4">&quot;array_api_compat.cupy&quot;</span><span class="s3">, </span><span class="s4">&quot;cupy&quot;</span><span class="s3">}:  </span><span class="s5"># pragma: nocover</span>
        <span class="s2">return </span><span class="s1">array</span><span class="s3">.</span><span class="s1">get</span><span class="s3">()</span>

    <span class="s2">return </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">array</span><span class="s3">)</span>


<span class="s2">def </span><span class="s1">_estimator_with_converted_arrays</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">, </span><span class="s1">converter</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Create new estimator which converting all attributes that are arrays. 
 
    The converter is called on all NumPy arrays and arrays that support the 
    `DLPack interface &lt;https://dmlc.github.io/dlpack/latest/&gt;`__. 
 
    Parameters 
    ---------- 
    estimator : Estimator 
        Estimator to convert 
 
    converter : callable 
        Callable that takes an array attribute and returns the converted array. 
 
    Returns 
    ------- 
    new_estimator : Estimator 
        Convert estimator 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">sklearn</span><span class="s3">.</span><span class="s1">base </span><span class="s2">import </span><span class="s1">clone</span>

    <span class="s1">new_estimator </span><span class="s3">= </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">)</span>
    <span class="s2">for </span><span class="s1">key</span><span class="s3">, </span><span class="s1">attribute </span><span class="s2">in </span><span class="s1">vars</span><span class="s3">(</span><span class="s1">estimator</span><span class="s3">).</span><span class="s1">items</span><span class="s3">():</span>
        <span class="s2">if </span><span class="s1">hasattr</span><span class="s3">(</span><span class="s1">attribute</span><span class="s3">, </span><span class="s4">&quot;__dlpack__&quot;</span><span class="s3">) </span><span class="s2">or </span><span class="s1">isinstance</span><span class="s3">(</span><span class="s1">attribute</span><span class="s3">, </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">ndarray</span><span class="s3">):</span>
            <span class="s1">attribute </span><span class="s3">= </span><span class="s1">converter</span><span class="s3">(</span><span class="s1">attribute</span><span class="s3">)</span>
        <span class="s1">setattr</span><span class="s3">(</span><span class="s1">new_estimator</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">attribute</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">new_estimator</span>


<span class="s2">def </span><span class="s1">_atol_for_type</span><span class="s3">(</span><span class="s1">dtype_or_dtype_name</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return the absolute tolerance for a given numpy dtype.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">dtype_or_dtype_name </span><span class="s2">is None</span><span class="s3">:</span>
        <span class="s5"># If no dtype is specified when running tests for a given namespace, we</span>
        <span class="s5"># expect the same floating precision level as NumPy's default floating</span>
        <span class="s5"># point dtype.</span>
        <span class="s1">dtype_or_dtype_name </span><span class="s3">= </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">float64</span>
    <span class="s2">return </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">finfo</span><span class="s3">(</span><span class="s1">dtype_or_dtype_name</span><span class="s3">).</span><span class="s1">eps </span><span class="s3">* </span><span class="s6">100</span>


<span class="s2">def </span><span class="s1">indexing_dtype</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;Return a platform-specific integer dtype suitable for indexing. 
 
    On 32-bit platforms, this will typically return int32 and int64 otherwise. 
 
    Note: using dtype is recommended for indexing transient array 
    datastructures. For long-lived arrays, such as the fitted attributes of 
    estimators, it is instead recommended to use platform-independent int32 if 
    we do not expect to index more 2B elements. Using fixed dtypes simplifies 
    the handling of serialized models, e.g. to deploy a model fit on a 64-bit 
    platform to a target 32-bit platform such as WASM/pyodide. 
    &quot;&quot;&quot;</span>
    <span class="s5"># Currently this is implemented with simple hack that assumes that</span>
    <span class="s5"># following &quot;may be&quot; statements in the Array API spec always hold:</span>
    <span class="s5"># &gt; The default integer data type should be the same across platforms, but</span>
    <span class="s5"># &gt; the default may vary depending on whether Python is 32-bit or 64-bit.</span>
    <span class="s5"># &gt; The default array index data type may be int32 on 32-bit platforms, but</span>
    <span class="s5"># &gt; the default should be int64 otherwise.</span>
    <span class="s5"># https://data-apis.org/array-api/latest/API_specification/data_types.html#default-data-types</span>
    <span class="s5"># TODO: once sufficiently adopted, we might want to instead rely on the</span>
    <span class="s5"># newer inspection API: https://github.com/data-apis/array-api/issues/640</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s6">0</span><span class="s3">).</span><span class="s1">dtype</span>


<span class="s2">def </span><span class="s1">_count_nonzero</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">xp</span><span class="s3">, </span><span class="s1">device</span><span class="s3">, </span><span class="s1">axis</span><span class="s3">=</span><span class="s2">None</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">=</span><span class="s2">None</span><span class="s3">):</span>
    <span class="s0">&quot;&quot;&quot;A variant of `sklearn.utils.sparsefuncs.count_nonzero` for the Array API. 
 
    It only supports 2D arrays. 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">X</span><span class="s3">.</span><span class="s1">ndim </span><span class="s3">== </span><span class="s6">2</span>

    <span class="s1">weights </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">ones_like</span><span class="s3">(</span><span class="s1">X</span><span class="s3">, </span><span class="s1">device</span><span class="s3">=</span><span class="s1">device</span><span class="s3">)</span>
    <span class="s2">if </span><span class="s1">sample_weight </span><span class="s2">is not None</span><span class="s3">:</span>
        <span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s1">sample_weight</span><span class="s3">, </span><span class="s1">device</span><span class="s3">=</span><span class="s1">device</span><span class="s3">)</span>
        <span class="s1">sample_weight </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">reshape</span><span class="s3">(</span><span class="s1">sample_weight</span><span class="s3">, (</span><span class="s1">sample_weight</span><span class="s3">.</span><span class="s1">shape</span><span class="s3">[</span><span class="s6">0</span><span class="s3">], </span><span class="s6">1</span><span class="s3">))</span>
        <span class="s1">weights </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">astype</span><span class="s3">(</span><span class="s1">weights</span><span class="s3">, </span><span class="s1">sample_weight</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">) * </span><span class="s1">sample_weight</span>

    <span class="s1">zero_scalar </span><span class="s3">= </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">asarray</span><span class="s3">(</span><span class="s6">0</span><span class="s3">, </span><span class="s1">device</span><span class="s3">=</span><span class="s1">device</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">=</span><span class="s1">weights</span><span class="s3">.</span><span class="s1">dtype</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">xp</span><span class="s3">.</span><span class="s1">sum</span><span class="s3">(</span><span class="s1">xp</span><span class="s3">.</span><span class="s1">where</span><span class="s3">(</span><span class="s1">X </span><span class="s3">!= </span><span class="s6">0</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">zero_scalar</span><span class="s3">), </span><span class="s1">axis</span><span class="s3">=</span><span class="s1">axis</span><span class="s3">)</span>
</pre>
</body>
</html>