<html>
<head>
<title>interpolatableHelpers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #6aab73;}
.s4 { color: #2aacb8;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
interpolatableHelpers.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">ttLib</span><span class="s2">.</span><span class="s1">ttGlyphSet </span><span class="s0">import </span><span class="s1">LerpGlyphSet</span>
<span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">pens</span><span class="s2">.</span><span class="s1">basePen </span><span class="s0">import </span><span class="s1">AbstractPen</span><span class="s2">, </span><span class="s1">BasePen</span><span class="s2">, </span><span class="s1">DecomposingPen</span>
<span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">pens</span><span class="s2">.</span><span class="s1">pointPen </span><span class="s0">import </span><span class="s1">AbstractPointPen</span><span class="s2">, </span><span class="s1">SegmentToPointPen</span>
<span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">pens</span><span class="s2">.</span><span class="s1">recordingPen </span><span class="s0">import </span><span class="s1">RecordingPen</span><span class="s2">, </span><span class="s1">DecomposingRecordingPen</span>
<span class="s0">from </span><span class="s1">fontTools</span><span class="s2">.</span><span class="s1">misc</span><span class="s2">.</span><span class="s1">transform </span><span class="s0">import </span><span class="s1">Transform</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict</span><span class="s2">, </span><span class="s1">deque</span>
<span class="s0">from </span><span class="s1">math </span><span class="s0">import </span><span class="s1">sqrt</span><span class="s2">, </span><span class="s1">copysign</span><span class="s2">, </span><span class="s1">atan2</span><span class="s2">, </span><span class="s1">pi</span>
<span class="s0">from </span><span class="s1">enum </span><span class="s0">import </span><span class="s1">Enum</span>
<span class="s0">import </span><span class="s1">itertools</span>

<span class="s0">import </span><span class="s1">logging</span>

<span class="s1">log </span><span class="s2">= </span><span class="s1">logging</span><span class="s2">.</span><span class="s1">getLogger</span><span class="s2">(</span><span class="s3">&quot;fontTools.varLib.interpolatable&quot;</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">InterpolatableProblem</span><span class="s2">:</span>
    <span class="s1">NOTHING </span><span class="s2">= </span><span class="s3">&quot;nothing&quot;</span>
    <span class="s1">MISSING </span><span class="s2">= </span><span class="s3">&quot;missing&quot;</span>
    <span class="s1">OPEN_PATH </span><span class="s2">= </span><span class="s3">&quot;open_path&quot;</span>
    <span class="s1">PATH_COUNT </span><span class="s2">= </span><span class="s3">&quot;path_count&quot;</span>
    <span class="s1">NODE_COUNT </span><span class="s2">= </span><span class="s3">&quot;node_count&quot;</span>
    <span class="s1">NODE_INCOMPATIBILITY </span><span class="s2">= </span><span class="s3">&quot;node_incompatibility&quot;</span>
    <span class="s1">CONTOUR_ORDER </span><span class="s2">= </span><span class="s3">&quot;contour_order&quot;</span>
    <span class="s1">WRONG_START_POINT </span><span class="s2">= </span><span class="s3">&quot;wrong_start_point&quot;</span>
    <span class="s1">KINK </span><span class="s2">= </span><span class="s3">&quot;kink&quot;</span>
    <span class="s1">UNDERWEIGHT </span><span class="s2">= </span><span class="s3">&quot;underweight&quot;</span>
    <span class="s1">OVERWEIGHT </span><span class="s2">= </span><span class="s3">&quot;overweight&quot;</span>

    <span class="s1">severity </span><span class="s2">= {</span>
        <span class="s1">MISSING</span><span class="s2">: </span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">OPEN_PATH</span><span class="s2">: </span><span class="s4">2</span><span class="s2">,</span>
        <span class="s1">PATH_COUNT</span><span class="s2">: </span><span class="s4">3</span><span class="s2">,</span>
        <span class="s1">NODE_COUNT</span><span class="s2">: </span><span class="s4">4</span><span class="s2">,</span>
        <span class="s1">NODE_INCOMPATIBILITY</span><span class="s2">: </span><span class="s4">5</span><span class="s2">,</span>
        <span class="s1">CONTOUR_ORDER</span><span class="s2">: </span><span class="s4">6</span><span class="s2">,</span>
        <span class="s1">WRONG_START_POINT</span><span class="s2">: </span><span class="s4">7</span><span class="s2">,</span>
        <span class="s1">KINK</span><span class="s2">: </span><span class="s4">8</span><span class="s2">,</span>
        <span class="s1">UNDERWEIGHT</span><span class="s2">: </span><span class="s4">9</span><span class="s2">,</span>
        <span class="s1">OVERWEIGHT</span><span class="s2">: </span><span class="s4">10</span><span class="s2">,</span>
        <span class="s1">NOTHING</span><span class="s2">: </span><span class="s4">11</span><span class="s2">,</span>
    <span class="s2">}</span>


<span class="s0">def </span><span class="s1">sort_problems</span><span class="s2">(</span><span class="s1">problems</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Sort problems by severity, then by glyph name, then by problem message.&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">dict</span><span class="s2">(</span>
        <span class="s1">sorted</span><span class="s2">(</span>
            <span class="s1">problems</span><span class="s2">.</span><span class="s1">items</span><span class="s2">(),</span>
            <span class="s1">key</span><span class="s2">=</span><span class="s0">lambda </span><span class="s1">_</span><span class="s2">: -</span><span class="s1">min</span><span class="s2">(</span>
                <span class="s2">(</span>
                    <span class="s2">(</span><span class="s1">InterpolatableProblem</span><span class="s2">.</span><span class="s1">severity</span><span class="s2">[</span><span class="s1">p</span><span class="s2">[</span><span class="s3">&quot;type&quot;</span><span class="s2">]] + </span><span class="s1">p</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s3">&quot;tolerance&quot;</span><span class="s2">, </span><span class="s4">0</span><span class="s2">))</span>
                    <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">_</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]</span>
                <span class="s2">),</span>
            <span class="s2">),</span>
            <span class="s1">reverse</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s2">)</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">rot_list</span><span class="s2">(</span><span class="s1">l</span><span class="s2">, </span><span class="s1">k</span><span class="s2">):</span>
    <span class="s5">&quot;&quot;&quot;Rotate list by k items forward.  Ie. item at position 0 will be 
    at position k in returned list.  Negative k is allowed.&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">l</span><span class="s2">[-</span><span class="s1">k</span><span class="s2">:] + </span><span class="s1">l</span><span class="s2">[:-</span><span class="s1">k</span><span class="s2">]</span>


<span class="s0">class </span><span class="s1">PerContourPen</span><span class="s2">(</span><span class="s1">BasePen</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">Pen</span><span class="s2">, </span><span class="s1">glyphset</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s1">BasePen</span><span class="s2">.</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">glyphset</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_glyphset </span><span class="s2">= </span><span class="s1">glyphset</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_Pen </span><span class="s2">= </span><span class="s1">Pen</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_pen </span><span class="s2">= </span><span class="s0">None</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">value </span><span class="s2">= []</span>

    <span class="s0">def </span><span class="s1">_moveTo</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">p0</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_newItem</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_pen</span><span class="s2">.</span><span class="s1">moveTo</span><span class="s2">(</span><span class="s1">p0</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_lineTo</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">p1</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_pen</span><span class="s2">.</span><span class="s1">lineTo</span><span class="s2">(</span><span class="s1">p1</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_qCurveToOne</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">p1</span><span class="s2">, </span><span class="s1">p2</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_pen</span><span class="s2">.</span><span class="s1">qCurveTo</span><span class="s2">(</span><span class="s1">p1</span><span class="s2">, </span><span class="s1">p2</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_curveToOne</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">p1</span><span class="s2">, </span><span class="s1">p2</span><span class="s2">, </span><span class="s1">p3</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_pen</span><span class="s2">.</span><span class="s1">curveTo</span><span class="s2">(</span><span class="s1">p1</span><span class="s2">, </span><span class="s1">p2</span><span class="s2">, </span><span class="s1">p3</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_closePath</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_pen</span><span class="s2">.</span><span class="s1">closePath</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_pen </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_endPath</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_pen</span><span class="s2">.</span><span class="s1">endPath</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_pen </span><span class="s2">= </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">_newItem</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_pen </span><span class="s2">= </span><span class="s1">pen </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_Pen</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">pen</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">PerContourOrComponentPen</span><span class="s2">(</span><span class="s1">PerContourPen</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">addComponent</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">glyphName</span><span class="s2">, </span><span class="s1">transformation</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_newItem</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">value</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">].</span><span class="s1">addComponent</span><span class="s2">(</span><span class="s1">glyphName</span><span class="s2">, </span><span class="s1">transformation</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">SimpleRecordingPointPen</span><span class="s2">(</span><span class="s1">AbstractPointPen</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">value </span><span class="s2">= []</span>

    <span class="s0">def </span><span class="s1">beginPath</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">identifier</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">endPath</span><span class="s2">(</span><span class="s1">self</span><span class="s2">) </span><span class="s1">-&gt; </span><span class="s0">None</span><span class="s2">:</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">addPoint</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">pt</span><span class="s2">, </span><span class="s1">segmentType</span><span class="s2">=</span><span class="s0">None</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">value</span><span class="s2">.</span><span class="s1">append</span><span class="s2">((</span><span class="s1">pt</span><span class="s2">, </span><span class="s0">False if </span><span class="s1">segmentType </span><span class="s0">is None else True</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">vdiff_hypot2</span><span class="s2">(</span><span class="s1">v0</span><span class="s2">, </span><span class="s1">v1</span><span class="s2">):</span>
    <span class="s1">s </span><span class="s2">= </span><span class="s4">0</span>
    <span class="s0">for </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">x1 </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">v0</span><span class="s2">, </span><span class="s1">v1</span><span class="s2">):</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">x1 </span><span class="s2">- </span><span class="s1">x0</span>
        <span class="s1">s </span><span class="s2">+= </span><span class="s1">d </span><span class="s2">* </span><span class="s1">d</span>
    <span class="s0">return </span><span class="s1">s</span>


<span class="s0">def </span><span class="s1">vdiff_hypot2_complex</span><span class="s2">(</span><span class="s1">v0</span><span class="s2">, </span><span class="s1">v1</span><span class="s2">):</span>
    <span class="s1">s </span><span class="s2">= </span><span class="s4">0</span>
    <span class="s0">for </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">x1 </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">v0</span><span class="s2">, </span><span class="s1">v1</span><span class="s2">):</span>
        <span class="s1">d </span><span class="s2">= </span><span class="s1">x1 </span><span class="s2">- </span><span class="s1">x0</span>
        <span class="s1">s </span><span class="s2">+= </span><span class="s1">d</span><span class="s2">.</span><span class="s1">real </span><span class="s2">* </span><span class="s1">d</span><span class="s2">.</span><span class="s1">real </span><span class="s2">+ </span><span class="s1">d</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">* </span><span class="s1">d</span><span class="s2">.</span><span class="s1">imag</span>
        <span class="s6"># This does the same but seems to be slower:</span>
        <span class="s6"># s += (d * d.conjugate()).real</span>
    <span class="s0">return </span><span class="s1">s</span>


<span class="s0">def </span><span class="s1">matching_cost</span><span class="s2">(</span><span class="s1">G</span><span class="s2">, </span><span class="s1">matching</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">G</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s1">j</span><span class="s2">] </span><span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">matching</span><span class="s2">))</span>


<span class="s0">def </span><span class="s1">min_cost_perfect_bipartite_matching_scipy</span><span class="s2">(</span><span class="s1">G</span><span class="s2">):</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">G</span><span class="s2">)</span>
    <span class="s1">rows</span><span class="s2">, </span><span class="s1">cols </span><span class="s2">= </span><span class="s1">linear_sum_assignment</span><span class="s2">(</span><span class="s1">G</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s2">(</span><span class="s1">rows </span><span class="s2">== </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">n</span><span class="s2">))).</span><span class="s1">all</span><span class="s2">()</span>
    <span class="s6"># Convert numpy array and integer to Python types,</span>
    <span class="s6"># to ensure that this is JSON-serializable.</span>
    <span class="s1">cols </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">int</span><span class="s2">(</span><span class="s1">e</span><span class="s2">) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">cols</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">list</span><span class="s2">(</span><span class="s1">cols</span><span class="s2">), </span><span class="s1">matching_cost</span><span class="s2">(</span><span class="s1">G</span><span class="s2">, </span><span class="s1">cols</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">min_cost_perfect_bipartite_matching_munkres</span><span class="s2">(</span><span class="s1">G</span><span class="s2">):</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">G</span><span class="s2">)</span>
    <span class="s1">cols </span><span class="s2">= [</span><span class="s0">None</span><span class="s2">] * </span><span class="s1">n</span>
    <span class="s0">for </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col </span><span class="s0">in </span><span class="s1">Munkres</span><span class="s2">().</span><span class="s1">compute</span><span class="s2">(</span><span class="s1">G</span><span class="s2">):</span>
        <span class="s1">cols</span><span class="s2">[</span><span class="s1">row</span><span class="s2">] = </span><span class="s1">col</span>
    <span class="s0">return </span><span class="s1">cols</span><span class="s2">, </span><span class="s1">matching_cost</span><span class="s2">(</span><span class="s1">G</span><span class="s2">, </span><span class="s1">cols</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">min_cost_perfect_bipartite_matching_bruteforce</span><span class="s2">(</span><span class="s1">G</span><span class="s2">):</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">G</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">n </span><span class="s2">&gt; </span><span class="s4">6</span><span class="s2">:</span>
        <span class="s0">raise </span><span class="s1">Exception</span><span class="s2">(</span><span class="s3">&quot;Install Python module 'munkres' or 'scipy &gt;= 0.17.0'&quot;</span><span class="s2">)</span>

    <span class="s6"># Otherwise just brute-force</span>
    <span class="s1">permutations </span><span class="s2">= </span><span class="s1">itertools</span><span class="s2">.</span><span class="s1">permutations</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">n</span><span class="s2">))</span>
    <span class="s1">best </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">next</span><span class="s2">(</span><span class="s1">permutations</span><span class="s2">))</span>
    <span class="s1">best_cost </span><span class="s2">= </span><span class="s1">matching_cost</span><span class="s2">(</span><span class="s1">G</span><span class="s2">, </span><span class="s1">best</span><span class="s2">)</span>
    <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">permutations</span><span class="s2">:</span>
        <span class="s1">cost </span><span class="s2">= </span><span class="s1">matching_cost</span><span class="s2">(</span><span class="s1">G</span><span class="s2">, </span><span class="s1">p</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">cost </span><span class="s2">&lt; </span><span class="s1">best_cost</span><span class="s2">:</span>
            <span class="s1">best</span><span class="s2">, </span><span class="s1">best_cost </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">p</span><span class="s2">), </span><span class="s1">cost</span>
    <span class="s0">return </span><span class="s1">best</span><span class="s2">, </span><span class="s1">best_cost</span>


<span class="s0">try</span><span class="s2">:</span>
    <span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">optimize </span><span class="s0">import </span><span class="s1">linear_sum_assignment</span>

    <span class="s1">min_cost_perfect_bipartite_matching </span><span class="s2">= </span><span class="s1">min_cost_perfect_bipartite_matching_scipy</span>
<span class="s0">except </span><span class="s1">ImportError</span><span class="s2">:</span>
    <span class="s0">try</span><span class="s2">:</span>
        <span class="s0">from </span><span class="s1">munkres </span><span class="s0">import </span><span class="s1">Munkres</span>

        <span class="s1">min_cost_perfect_bipartite_matching </span><span class="s2">= (</span>
            <span class="s1">min_cost_perfect_bipartite_matching_munkres</span>
        <span class="s2">)</span>
    <span class="s0">except </span><span class="s1">ImportError</span><span class="s2">:</span>
        <span class="s1">min_cost_perfect_bipartite_matching </span><span class="s2">= (</span>
            <span class="s1">min_cost_perfect_bipartite_matching_bruteforce</span>
        <span class="s2">)</span>


<span class="s0">def </span><span class="s1">contour_vector_from_stats</span><span class="s2">(</span><span class="s1">stats</span><span class="s2">):</span>
    <span class="s6"># Don't change the order of items here.</span>
    <span class="s6"># It's okay to add to the end, but otherwise, other</span>
    <span class="s6"># code depends on it. Search for &quot;covariance&quot;.</span>
    <span class="s1">size </span><span class="s2">= </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">stats</span><span class="s2">.</span><span class="s1">area</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s2">(</span>
        <span class="s1">copysign</span><span class="s2">((</span><span class="s1">size</span><span class="s2">), </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">area</span><span class="s2">),</span>
        <span class="s1">stats</span><span class="s2">.</span><span class="s1">meanX</span><span class="s2">,</span>
        <span class="s1">stats</span><span class="s2">.</span><span class="s1">meanY</span><span class="s2">,</span>
        <span class="s1">stats</span><span class="s2">.</span><span class="s1">stddevX </span><span class="s2">* </span><span class="s4">2</span><span class="s2">,</span>
        <span class="s1">stats</span><span class="s2">.</span><span class="s1">stddevY </span><span class="s2">* </span><span class="s4">2</span><span class="s2">,</span>
        <span class="s1">stats</span><span class="s2">.</span><span class="s1">correlation </span><span class="s2">* </span><span class="s1">size</span><span class="s2">,</span>
    <span class="s2">)</span>


<span class="s0">def </span><span class="s1">matching_for_vectors</span><span class="s2">(</span><span class="s1">m0</span><span class="s2">, </span><span class="s1">m1</span><span class="s2">):</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">m0</span><span class="s2">)</span>

    <span class="s1">identity_matching </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">n</span><span class="s2">))</span>

    <span class="s1">costs </span><span class="s2">= [[</span><span class="s1">vdiff_hypot2</span><span class="s2">(</span><span class="s1">v0</span><span class="s2">, </span><span class="s1">v1</span><span class="s2">) </span><span class="s0">for </span><span class="s1">v1 </span><span class="s0">in </span><span class="s1">m1</span><span class="s2">] </span><span class="s0">for </span><span class="s1">v0 </span><span class="s0">in </span><span class="s1">m0</span><span class="s2">]</span>
    <span class="s2">(</span>
        <span class="s1">matching</span><span class="s2">,</span>
        <span class="s1">matching_cost</span><span class="s2">,</span>
    <span class="s2">) = </span><span class="s1">min_cost_perfect_bipartite_matching</span><span class="s2">(</span><span class="s1">costs</span><span class="s2">)</span>
    <span class="s1">identity_cost </span><span class="s2">= </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">costs</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s1">i</span><span class="s2">] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">n</span><span class="s2">))</span>
    <span class="s0">return </span><span class="s1">matching</span><span class="s2">, </span><span class="s1">matching_cost</span><span class="s2">, </span><span class="s1">identity_cost</span>


<span class="s0">def </span><span class="s1">points_characteristic_bits</span><span class="s2">(</span><span class="s1">points</span><span class="s2">):</span>
    <span class="s1">bits </span><span class="s2">= </span><span class="s4">0</span>
    <span class="s0">for </span><span class="s1">pt</span><span class="s2">, </span><span class="s1">b </span><span class="s0">in </span><span class="s1">reversed</span><span class="s2">(</span><span class="s1">points</span><span class="s2">):</span>
        <span class="s1">bits </span><span class="s2">= (</span><span class="s1">bits </span><span class="s2">&lt;&lt; </span><span class="s4">1</span><span class="s2">) | </span><span class="s1">b</span>
    <span class="s0">return </span><span class="s1">bits</span>


<span class="s1">_NUM_ITEMS_PER_POINTS_COMPLEX_VECTOR </span><span class="s2">= </span><span class="s4">4</span>


<span class="s0">def </span><span class="s1">points_complex_vector</span><span class="s2">(</span><span class="s1">points</span><span class="s2">):</span>
    <span class="s1">vector </span><span class="s2">= []</span>
    <span class="s0">if not </span><span class="s1">points</span><span class="s2">:</span>
        <span class="s0">return </span><span class="s1">vector</span>
    <span class="s1">points </span><span class="s2">= [</span><span class="s1">complex</span><span class="s2">(*</span><span class="s1">pt</span><span class="s2">) </span><span class="s0">for </span><span class="s1">pt</span><span class="s2">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">points</span><span class="s2">]</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">_NUM_ITEMS_PER_POINTS_COMPLEX_VECTOR </span><span class="s2">== </span><span class="s4">4</span>
    <span class="s1">points</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">points</span><span class="s2">[: </span><span class="s1">_NUM_ITEMS_PER_POINTS_COMPLEX_VECTOR </span><span class="s2">- </span><span class="s4">1</span><span class="s2">])</span>
    <span class="s0">while </span><span class="s1">len</span><span class="s2">(</span><span class="s1">points</span><span class="s2">) &lt; </span><span class="s1">_NUM_ITEMS_PER_POINTS_COMPLEX_VECTOR</span><span class="s2">:</span>
        <span class="s1">points</span><span class="s2">.</span><span class="s1">extend</span><span class="s2">(</span><span class="s1">points</span><span class="s2">[: </span><span class="s1">_NUM_ITEMS_PER_POINTS_COMPLEX_VECTOR </span><span class="s2">- </span><span class="s4">1</span><span class="s2">])</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">n</span><span class="s2">):</span>
        <span class="s6"># The weights are magic numbers.</span>

        <span class="s6"># The point itself</span>
        <span class="s1">p0 </span><span class="s2">= </span><span class="s1">points</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]</span>
        <span class="s1">vector</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">p0</span><span class="s2">)</span>

        <span class="s6"># The vector to the next point</span>
        <span class="s1">p1 </span><span class="s2">= </span><span class="s1">points</span><span class="s2">[</span><span class="s1">i </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">]</span>
        <span class="s1">d0 </span><span class="s2">= </span><span class="s1">p1 </span><span class="s2">- </span><span class="s1">p0</span>
        <span class="s1">vector</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">d0 </span><span class="s2">* </span><span class="s4">3</span><span class="s2">)</span>

        <span class="s6"># The turn vector</span>
        <span class="s1">p2 </span><span class="s2">= </span><span class="s1">points</span><span class="s2">[</span><span class="s1">i </span><span class="s2">+ </span><span class="s4">2</span><span class="s2">]</span>
        <span class="s1">d1 </span><span class="s2">= </span><span class="s1">p2 </span><span class="s2">- </span><span class="s1">p1</span>
        <span class="s1">vector</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">d1 </span><span class="s2">- </span><span class="s1">d0</span><span class="s2">)</span>

        <span class="s6"># The angle to the next point, as a cross product;</span>
        <span class="s6"># Square root of, to match dimentionality of distance.</span>
        <span class="s1">cross </span><span class="s2">= </span><span class="s1">d0</span><span class="s2">.</span><span class="s1">real </span><span class="s2">* </span><span class="s1">d1</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">- </span><span class="s1">d0</span><span class="s2">.</span><span class="s1">imag </span><span class="s2">* </span><span class="s1">d1</span><span class="s2">.</span><span class="s1">real</span>
        <span class="s1">cross </span><span class="s2">= </span><span class="s1">copysign</span><span class="s2">(</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">cross</span><span class="s2">)), </span><span class="s1">cross</span><span class="s2">)</span>
        <span class="s1">vector</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">cross </span><span class="s2">* </span><span class="s4">4</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">vector</span>


<span class="s0">def </span><span class="s1">add_isomorphisms</span><span class="s2">(</span><span class="s1">points</span><span class="s2">, </span><span class="s1">isomorphisms</span><span class="s2">, </span><span class="s1">reverse</span><span class="s2">):</span>
    <span class="s1">reference_bits </span><span class="s2">= </span><span class="s1">points_characteristic_bits</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

    <span class="s6"># if points[0][0] == points[-1][0]:</span>
    <span class="s6">#   abort</span>

    <span class="s0">if </span><span class="s1">reverse</span><span class="s2">:</span>
        <span class="s1">points </span><span class="s2">= </span><span class="s1">points</span><span class="s2">[::-</span><span class="s4">1</span><span class="s2">]</span>
        <span class="s1">bits </span><span class="s2">= </span><span class="s1">points_characteristic_bits</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">bits </span><span class="s2">= </span><span class="s1">reference_bits</span>

    <span class="s1">vector </span><span class="s2">= </span><span class="s1">points_complex_vector</span><span class="s2">(</span><span class="s1">points</span><span class="s2">)</span>

    <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">vector</span><span class="s2">) % </span><span class="s1">n </span><span class="s2">== </span><span class="s4">0</span>
    <span class="s1">mult </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">vector</span><span class="s2">) // </span><span class="s1">n</span>
    <span class="s1">mask </span><span class="s2">= (</span><span class="s4">1 </span><span class="s2">&lt;&lt; </span><span class="s1">n</span><span class="s2">) - </span><span class="s4">1</span>

    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">n</span><span class="s2">):</span>
        <span class="s1">b </span><span class="s2">= ((</span><span class="s1">bits </span><span class="s2">&lt;&lt; (</span><span class="s1">n </span><span class="s2">- </span><span class="s1">i</span><span class="s2">)) &amp; </span><span class="s1">mask</span><span class="s2">) | (</span><span class="s1">bits </span><span class="s2">&gt;&gt; </span><span class="s1">i</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">b </span><span class="s2">== </span><span class="s1">reference_bits</span><span class="s2">:</span>
            <span class="s1">isomorphisms</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span>
                <span class="s2">(</span><span class="s1">rot_list</span><span class="s2">(</span><span class="s1">vector</span><span class="s2">, -</span><span class="s1">i </span><span class="s2">* </span><span class="s1">mult</span><span class="s2">), </span><span class="s1">n </span><span class="s2">- </span><span class="s4">1 </span><span class="s2">- </span><span class="s1">i </span><span class="s0">if </span><span class="s1">reverse </span><span class="s0">else </span><span class="s1">i</span><span class="s2">, </span><span class="s1">reverse</span><span class="s2">)</span>
            <span class="s2">)</span>


<span class="s0">def </span><span class="s1">find_parents_and_order</span><span class="s2">(</span><span class="s1">glyphsets</span><span class="s2">, </span><span class="s1">locations</span><span class="s2">, *, </span><span class="s1">discrete_axes</span><span class="s2">=</span><span class="s1">set</span><span class="s2">()):</span>
    <span class="s1">parents </span><span class="s2">= [</span><span class="s0">None</span><span class="s2">] + </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">glyphsets</span><span class="s2">) - </span><span class="s4">1</span><span class="s2">))</span>
    <span class="s1">order </span><span class="s2">= </span><span class="s1">list</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">glyphsets</span><span class="s2">)))</span>
    <span class="s0">if </span><span class="s1">locations</span><span class="s2">:</span>
        <span class="s6"># Order base master first</span>
        <span class="s1">bases </span><span class="s2">= [</span>
            <span class="s1">i</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">l </span><span class="s0">in </span><span class="s1">enumerate</span><span class="s2">(</span><span class="s1">locations</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">all</span><span class="s2">(</span><span class="s1">v </span><span class="s2">== </span><span class="s4">0 </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">l</span><span class="s2">.</span><span class="s1">items</span><span class="s2">() </span><span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">discrete_axes</span><span class="s2">)</span>
        <span class="s2">]</span>
        <span class="s0">if </span><span class="s1">bases</span><span class="s2">:</span>
            <span class="s1">logging</span><span class="s2">.</span><span class="s1">info</span><span class="s2">(</span><span class="s3">&quot;Found %s base masters: %s&quot;</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">bases</span><span class="s2">), </span><span class="s1">bases</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">logging</span><span class="s2">.</span><span class="s1">warning</span><span class="s2">(</span><span class="s3">&quot;No base master location found&quot;</span><span class="s2">)</span>

        <span class="s6"># Form a minimum spanning tree of the locations</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">sparse</span><span class="s2">.</span><span class="s1">csgraph </span><span class="s0">import </span><span class="s1">minimum_spanning_tree</span>

            <span class="s1">graph </span><span class="s2">= [[</span><span class="s4">0</span><span class="s2">] * </span><span class="s1">len</span><span class="s2">(</span><span class="s1">locations</span><span class="s2">) </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">locations</span><span class="s2">))]</span>
            <span class="s1">axes </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
            <span class="s0">for </span><span class="s1">l </span><span class="s0">in </span><span class="s1">locations</span><span class="s2">:</span>
                <span class="s1">axes</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(</span><span class="s1">l</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">())</span>
            <span class="s1">axes </span><span class="s2">= </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">axes</span><span class="s2">)</span>
            <span class="s1">vectors </span><span class="s2">= [</span><span class="s1">tuple</span><span class="s2">(</span><span class="s1">l</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s4">0</span><span class="s2">) </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">axes</span><span class="s2">) </span><span class="s0">for </span><span class="s1">l </span><span class="s0">in </span><span class="s1">locations</span><span class="s2">]</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">itertools</span><span class="s2">.</span><span class="s1">combinations</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s1">len</span><span class="s2">(</span><span class="s1">locations</span><span class="s2">)), </span><span class="s4">2</span><span class="s2">):</span>
                <span class="s1">i_discrete_location </span><span class="s2">= {</span>
                    <span class="s1">k</span><span class="s2">: </span><span class="s1">v </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">axes</span><span class="s2">, </span><span class="s1">vectors</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]) </span><span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">discrete_axes</span>
                <span class="s2">}</span>
                <span class="s1">j_discrete_location </span><span class="s2">= {</span>
                    <span class="s1">k</span><span class="s2">: </span><span class="s1">v </span><span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">axes</span><span class="s2">, </span><span class="s1">vectors</span><span class="s2">[</span><span class="s1">j</span><span class="s2">]) </span><span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">discrete_axes</span>
                <span class="s2">}</span>
                <span class="s0">if </span><span class="s1">i_discrete_location </span><span class="s2">!= </span><span class="s1">j_discrete_location</span><span class="s2">:</span>
                    <span class="s0">continue</span>
                <span class="s1">graph</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s1">j</span><span class="s2">] = </span><span class="s1">vdiff_hypot2</span><span class="s2">(</span><span class="s1">vectors</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">vectors</span><span class="s2">[</span><span class="s1">j</span><span class="s2">])</span>

            <span class="s1">tree </span><span class="s2">= </span><span class="s1">minimum_spanning_tree</span><span class="s2">(</span><span class="s1">graph</span><span class="s2">, </span><span class="s1">overwrite</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s1">rows</span><span class="s2">, </span><span class="s1">cols </span><span class="s2">= </span><span class="s1">tree</span><span class="s2">.</span><span class="s1">nonzero</span><span class="s2">()</span>
            <span class="s1">graph </span><span class="s2">= </span><span class="s1">defaultdict</span><span class="s2">(</span><span class="s1">set</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">row</span><span class="s2">, </span><span class="s1">col </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">rows</span><span class="s2">, </span><span class="s1">cols</span><span class="s2">):</span>
                <span class="s1">graph</span><span class="s2">[</span><span class="s1">row</span><span class="s2">].</span><span class="s1">add</span><span class="s2">(</span><span class="s1">col</span><span class="s2">)</span>
                <span class="s1">graph</span><span class="s2">[</span><span class="s1">col</span><span class="s2">].</span><span class="s1">add</span><span class="s2">(</span><span class="s1">row</span><span class="s2">)</span>

            <span class="s6"># Traverse graph from the base and assign parents</span>
            <span class="s1">parents </span><span class="s2">= [</span><span class="s0">None</span><span class="s2">] * </span><span class="s1">len</span><span class="s2">(</span><span class="s1">locations</span><span class="s2">)</span>
            <span class="s1">order </span><span class="s2">= []</span>
            <span class="s1">visited </span><span class="s2">= </span><span class="s1">set</span><span class="s2">()</span>
            <span class="s1">queue </span><span class="s2">= </span><span class="s1">deque</span><span class="s2">(</span><span class="s1">bases</span><span class="s2">)</span>
            <span class="s0">while </span><span class="s1">queue</span><span class="s2">:</span>
                <span class="s1">i </span><span class="s2">= </span><span class="s1">queue</span><span class="s2">.</span><span class="s1">popleft</span><span class="s2">()</span>
                <span class="s1">visited</span><span class="s2">.</span><span class="s1">add</span><span class="s2">(</span><span class="s1">i</span><span class="s2">)</span>
                <span class="s1">order</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">i</span><span class="s2">)</span>
                <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">sorted</span><span class="s2">(</span><span class="s1">graph</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]):</span>
                    <span class="s0">if </span><span class="s1">j </span><span class="s0">not in </span><span class="s1">visited</span><span class="s2">:</span>
                        <span class="s1">parents</span><span class="s2">[</span><span class="s1">j</span><span class="s2">] = </span><span class="s1">i</span>
                        <span class="s1">queue</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">j</span><span class="s2">)</span>
            <span class="s0">assert </span><span class="s1">len</span><span class="s2">(</span><span class="s1">order</span><span class="s2">) == </span><span class="s1">len</span><span class="s2">(</span>
                <span class="s1">parents</span>
            <span class="s2">), </span><span class="s3">&quot;Not all masters are reachable; report an issue&quot;</span>

        <span class="s0">except </span><span class="s1">ImportError</span><span class="s2">:</span>
            <span class="s0">pass</span>

        <span class="s1">log</span><span class="s2">.</span><span class="s1">info</span><span class="s2">(</span><span class="s3">&quot;Parents: %s&quot;</span><span class="s2">, </span><span class="s1">parents</span><span class="s2">)</span>
        <span class="s1">log</span><span class="s2">.</span><span class="s1">info</span><span class="s2">(</span><span class="s3">&quot;Order: %s&quot;</span><span class="s2">, </span><span class="s1">order</span><span class="s2">)</span>
    <span class="s0">return </span><span class="s1">parents</span><span class="s2">, </span><span class="s1">order</span>


<span class="s0">def </span><span class="s1">transform_from_stats</span><span class="s2">(</span><span class="s1">stats</span><span class="s2">, </span><span class="s1">inverse</span><span class="s2">=</span><span class="s0">False</span><span class="s2">):</span>
    <span class="s6"># https://cookierobotics.com/007/</span>
    <span class="s1">a </span><span class="s2">= </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">varianceX</span>
    <span class="s1">b </span><span class="s2">= </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">covariance</span>
    <span class="s1">c </span><span class="s2">= </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">varianceY</span>

    <span class="s1">delta </span><span class="s2">= (((</span><span class="s1">a </span><span class="s2">- </span><span class="s1">c</span><span class="s2">) * </span><span class="s4">0.5</span><span class="s2">) ** </span><span class="s4">2 </span><span class="s2">+ </span><span class="s1">b </span><span class="s2">* </span><span class="s1">b</span><span class="s2">) ** </span><span class="s4">0.5</span>
    <span class="s1">lambda1 </span><span class="s2">= (</span><span class="s1">a </span><span class="s2">+ </span><span class="s1">c</span><span class="s2">) * </span><span class="s4">0.5 </span><span class="s2">+ </span><span class="s1">delta  </span><span class="s6"># Major eigenvalue</span>
    <span class="s1">lambda2 </span><span class="s2">= (</span><span class="s1">a </span><span class="s2">+ </span><span class="s1">c</span><span class="s2">) * </span><span class="s4">0.5 </span><span class="s2">- </span><span class="s1">delta  </span><span class="s6"># Minor eigenvalue</span>
    <span class="s1">theta </span><span class="s2">= </span><span class="s1">atan2</span><span class="s2">(</span><span class="s1">lambda1 </span><span class="s2">- </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">) </span><span class="s0">if </span><span class="s1">b </span><span class="s2">!= </span><span class="s4">0 </span><span class="s0">else </span><span class="s2">(</span><span class="s1">pi </span><span class="s2">* </span><span class="s4">0.5 </span><span class="s0">if </span><span class="s1">a </span><span class="s2">&lt; </span><span class="s1">c </span><span class="s0">else </span><span class="s4">0</span><span class="s2">)</span>
    <span class="s1">trans </span><span class="s2">= </span><span class="s1">Transform</span><span class="s2">()</span>

    <span class="s0">if </span><span class="s1">lambda2 </span><span class="s2">&lt; </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s6"># XXX This is a hack.</span>
        <span class="s6"># The problem is that the covariance matrix is singular.</span>
        <span class="s6"># This happens when the contour is a line, or a circle.</span>
        <span class="s6"># In that case, the covariance matrix is not a good</span>
        <span class="s6"># representation of the contour.</span>
        <span class="s6"># We should probably detect this earlier and avoid</span>
        <span class="s6"># computing the covariance matrix in the first place.</span>
        <span class="s6"># But for now, we just avoid the division by zero.</span>
        <span class="s1">lambda2 </span><span class="s2">= </span><span class="s4">0</span>

    <span class="s0">if </span><span class="s1">inverse</span><span class="s2">:</span>
        <span class="s1">trans </span><span class="s2">= </span><span class="s1">trans</span><span class="s2">.</span><span class="s1">translate</span><span class="s2">(-</span><span class="s1">stats</span><span class="s2">.</span><span class="s1">meanX</span><span class="s2">, -</span><span class="s1">stats</span><span class="s2">.</span><span class="s1">meanY</span><span class="s2">)</span>
        <span class="s1">trans </span><span class="s2">= </span><span class="s1">trans</span><span class="s2">.</span><span class="s1">rotate</span><span class="s2">(-</span><span class="s1">theta</span><span class="s2">)</span>
        <span class="s1">trans </span><span class="s2">= </span><span class="s1">trans</span><span class="s2">.</span><span class="s1">scale</span><span class="s2">(</span><span class="s4">1 </span><span class="s2">/ </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">lambda1</span><span class="s2">), </span><span class="s4">1 </span><span class="s2">/ </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">lambda2</span><span class="s2">))</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">trans </span><span class="s2">= </span><span class="s1">trans</span><span class="s2">.</span><span class="s1">scale</span><span class="s2">(</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">lambda1</span><span class="s2">), </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">lambda2</span><span class="s2">))</span>
        <span class="s1">trans </span><span class="s2">= </span><span class="s1">trans</span><span class="s2">.</span><span class="s1">rotate</span><span class="s2">(</span><span class="s1">theta</span><span class="s2">)</span>
        <span class="s1">trans </span><span class="s2">= </span><span class="s1">trans</span><span class="s2">.</span><span class="s1">translate</span><span class="s2">(</span><span class="s1">stats</span><span class="s2">.</span><span class="s1">meanX</span><span class="s2">, </span><span class="s1">stats</span><span class="s2">.</span><span class="s1">meanY</span><span class="s2">)</span>

    <span class="s0">return </span><span class="s1">trans</span>
</pre>
</body>
</html>