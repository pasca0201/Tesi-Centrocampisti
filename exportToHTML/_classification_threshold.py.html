<html>
<head>
<title>_classification_threshold.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #7a7e85;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_classification_threshold.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">collections</span><span class="s2">.</span><span class="s1">abc </span><span class="s0">import </span><span class="s1">MutableMapping</span>
<span class="s0">from </span><span class="s1">numbers </span><span class="s0">import </span><span class="s1">Integral</span><span class="s2">, </span><span class="s1">Real</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s2">..</span><span class="s1">base </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">BaseEstimator</span><span class="s2">,</span>
    <span class="s1">ClassifierMixin</span><span class="s2">,</span>
    <span class="s1">MetaEstimatorMixin</span><span class="s2">,</span>
    <span class="s1">_fit_context</span><span class="s2">,</span>
    <span class="s1">clone</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">exceptions </span><span class="s0">import </span><span class="s1">NotFittedError</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">metrics </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">check_scoring</span><span class="s2">,</span>
    <span class="s1">get_scorer_names</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">metrics</span><span class="s2">.</span><span class="s1">_scorer </span><span class="s0">import </span><span class="s1">_BaseScorer</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">utils </span><span class="s0">import </span><span class="s1">_safe_indexing</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">utils</span><span class="s2">.</span><span class="s1">_param_validation </span><span class="s0">import </span><span class="s1">HasMethods</span><span class="s2">, </span><span class="s1">Interval</span><span class="s2">, </span><span class="s1">RealNotInt</span><span class="s2">, </span><span class="s1">StrOptions</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">utils</span><span class="s2">.</span><span class="s1">_response </span><span class="s0">import </span><span class="s1">_get_response_values_binary</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">utils</span><span class="s2">.</span><span class="s1">metadata_routing </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">MetadataRouter</span><span class="s2">,</span>
    <span class="s1">MethodMapping</span><span class="s2">,</span>
    <span class="s1">_raise_for_params</span><span class="s2">,</span>
    <span class="s1">process_routing</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">utils</span><span class="s2">.</span><span class="s1">metaestimators </span><span class="s0">import </span><span class="s1">available_if</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">utils</span><span class="s2">.</span><span class="s1">multiclass </span><span class="s0">import </span><span class="s1">type_of_target</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">utils</span><span class="s2">.</span><span class="s1">parallel </span><span class="s0">import </span><span class="s1">Parallel</span><span class="s2">, </span><span class="s1">delayed</span>
<span class="s0">from </span><span class="s2">..</span><span class="s1">utils</span><span class="s2">.</span><span class="s1">validation </span><span class="s0">import </span><span class="s2">(</span>
    <span class="s1">_check_method_params</span><span class="s2">,</span>
    <span class="s1">_num_samples</span><span class="s2">,</span>
    <span class="s1">check_is_fitted</span><span class="s2">,</span>
    <span class="s1">indexable</span><span class="s2">,</span>
<span class="s2">)</span>
<span class="s0">from </span><span class="s2">.</span><span class="s1">_split </span><span class="s0">import </span><span class="s1">StratifiedShuffleSplit</span><span class="s2">, </span><span class="s1">check_cv</span>


<span class="s0">def </span><span class="s1">_estimator_has</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Check if we can delegate a method to the underlying estimator. 
 
    First, we check the fitted estimator if available, otherwise we 
    check the unfitted estimator. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">check</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s4">&quot;estimator_&quot;</span><span class="s2">):</span>
            <span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator_</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">getattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">)</span>
        <span class="s0">return True</span>

    <span class="s0">return </span><span class="s1">check</span>


<span class="s0">def </span><span class="s1">_threshold_scores_to_class_labels</span><span class="s2">(</span><span class="s1">y_score</span><span class="s2">, </span><span class="s1">threshold</span><span class="s2">, </span><span class="s1">classes</span><span class="s2">, </span><span class="s1">pos_label</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Threshold `y_score` and return the associated class labels.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">pos_label </span><span class="s0">is None</span><span class="s2">:</span>
        <span class="s1">map_thresholded_score_to_label </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">])</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s1">pos_label_idx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">flatnonzero</span><span class="s2">(</span><span class="s1">classes </span><span class="s2">== </span><span class="s1">pos_label</span><span class="s2">)[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s1">neg_label_idx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">flatnonzero</span><span class="s2">(</span><span class="s1">classes </span><span class="s2">!= </span><span class="s1">pos_label</span><span class="s2">)[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s1">map_thresholded_score_to_label </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s1">neg_label_idx</span><span class="s2">, </span><span class="s1">pos_label_idx</span><span class="s2">])</span>

    <span class="s0">return </span><span class="s1">classes</span><span class="s2">[</span><span class="s1">map_thresholded_score_to_label</span><span class="s2">[(</span><span class="s1">y_score </span><span class="s2">&gt;= </span><span class="s1">threshold</span><span class="s2">).</span><span class="s1">astype</span><span class="s2">(</span><span class="s1">int</span><span class="s2">)]]</span>


<span class="s0">class </span><span class="s1">BaseThresholdClassifier</span><span class="s2">(</span><span class="s1">ClassifierMixin</span><span class="s2">, </span><span class="s1">MetaEstimatorMixin</span><span class="s2">, </span><span class="s1">BaseEstimator</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Base class for binary classifiers that set a non-default decision threshold. 
 
    In this base class, we define the following interface: 
 
    - the validation of common parameters in `fit`; 
    - the different prediction methods that can be used with the classifier. 
 
    .. versionadded:: 1.5 
 
    Parameters 
    ---------- 
    estimator : estimator instance 
        The binary classifier, fitted or not, for which we want to optimize 
        the decision threshold used during `predict`. 
 
    response_method : {&quot;auto&quot;, &quot;decision_function&quot;, &quot;predict_proba&quot;}, default=&quot;auto&quot; 
        Methods by the classifier `estimator` corresponding to the 
        decision function for which we want to find a threshold. It can be: 
 
        * if `&quot;auto&quot;`, it will try to invoke, for each classifier, 
          `&quot;predict_proba&quot;` or `&quot;decision_function&quot;` in that order. 
        * otherwise, one of `&quot;predict_proba&quot;` or `&quot;decision_function&quot;`. 
          If the method is not implemented by the classifier, it will raise an 
          error. 
    &quot;&quot;&quot;</span>

    <span class="s1">_required_parameters </span><span class="s2">= [</span><span class="s4">&quot;estimator&quot;</span><span class="s2">]</span>
    <span class="s1">_parameter_constraints</span><span class="s2">: </span><span class="s1">dict </span><span class="s2">= {</span>
        <span class="s4">&quot;estimator&quot;</span><span class="s2">: [</span>
            <span class="s1">HasMethods</span><span class="s2">([</span><span class="s4">&quot;fit&quot;</span><span class="s2">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s2">]),</span>
            <span class="s1">HasMethods</span><span class="s2">([</span><span class="s4">&quot;fit&quot;</span><span class="s2">, </span><span class="s4">&quot;decision_function&quot;</span><span class="s2">]),</span>
        <span class="s2">],</span>
        <span class="s4">&quot;response_method&quot;</span><span class="s2">: [</span><span class="s1">StrOptions</span><span class="s2">({</span><span class="s4">&quot;auto&quot;</span><span class="s2">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s2">, </span><span class="s4">&quot;decision_function&quot;</span><span class="s2">})],</span>
    <span class="s2">}</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">estimator</span><span class="s2">, *, </span><span class="s1">response_method</span><span class="s2">=</span><span class="s4">&quot;auto&quot;</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">estimator </span><span class="s2">= </span><span class="s1">estimator</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">response_method </span><span class="s2">= </span><span class="s1">response_method</span>

    <span class="s0">def </span><span class="s1">_get_response_method</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Define the response method.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">response_method </span><span class="s2">== </span><span class="s4">&quot;auto&quot;</span><span class="s2">:</span>
            <span class="s1">response_method </span><span class="s2">= [</span><span class="s4">&quot;predict_proba&quot;</span><span class="s2">, </span><span class="s4">&quot;decision_function&quot;</span><span class="s2">]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">response_method </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">response_method</span>
        <span class="s0">return </span><span class="s1">response_method</span>

    <span class="s2">@</span><span class="s1">_fit_context</span><span class="s2">(</span>
        <span class="s6"># *ThresholdClassifier*.estimator is not validated yet</span>
        <span class="s1">prefer_skip_nested_validation</span><span class="s2">=</span><span class="s0">False</span>
    <span class="s2">)</span>
    <span class="s0">def </span><span class="s1">fit</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, **</span><span class="s1">params</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Fit the classifier. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Training data. 
 
        y : array-like of shape (n_samples,) 
            Target values. 
 
        **params : dict 
            Parameters to pass to the `fit` method of the underlying 
            classifier. 
 
        Returns 
        ------- 
        self : object 
            Returns an instance of self. 
        &quot;&quot;&quot;</span>
        <span class="s1">_raise_for_params</span><span class="s2">(</span><span class="s1">params</span><span class="s2">, </span><span class="s1">self</span><span class="s2">, </span><span class="s0">None</span><span class="s2">)</span>

        <span class="s1">X</span><span class="s2">, </span><span class="s1">y </span><span class="s2">= </span><span class="s1">indexable</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">)</span>

        <span class="s1">y_type </span><span class="s2">= </span><span class="s1">type_of_target</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">input_name</span><span class="s2">=</span><span class="s4">&quot;y&quot;</span><span class="s2">)</span>
        <span class="s0">if </span><span class="s1">y_type </span><span class="s2">!= </span><span class="s4">&quot;binary&quot;</span><span class="s2">:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">f&quot;Only binary classification is supported. Unknown label type: </span><span class="s0">{</span><span class="s1">y_type</span><span class="s0">}</span><span class="s4">&quot;</span>
            <span class="s2">)</span>

        <span class="s1">self</span><span class="s2">.</span><span class="s1">_fit</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, **</span><span class="s1">params</span><span class="s2">)</span>

        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator_</span><span class="s2">, </span><span class="s4">&quot;n_features_in_&quot;</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">n_features_in_ </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator_</span><span class="s2">.</span><span class="s1">n_features_in_</span>
        <span class="s0">if </span><span class="s1">hasattr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator_</span><span class="s2">, </span><span class="s4">&quot;feature_names_in_&quot;</span><span class="s2">):</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">feature_names_in_ </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator_</span><span class="s2">.</span><span class="s1">feature_names_in_</span>

        <span class="s0">return </span><span class="s1">self</span>

    <span class="s2">@</span><span class="s1">property</span>
    <span class="s0">def </span><span class="s1">classes_</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Classes labels.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator_</span><span class="s2">.</span><span class="s1">classes_</span>

    <span class="s2">@</span><span class="s1">available_if</span><span class="s2">(</span><span class="s1">_estimator_has</span><span class="s2">(</span><span class="s4">&quot;predict_proba&quot;</span><span class="s2">))</span>
    <span class="s0">def </span><span class="s1">predict_proba</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Predict class probabilities for `X` using the fitted estimator. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Training vectors, where `n_samples` is the number of samples and 
            `n_features` is the number of features. 
 
        Returns 
        ------- 
        probabilities : ndarray of shape (n_samples, n_classes) 
            The class probabilities of the input samples. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s4">&quot;estimator_&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator_</span><span class="s2">.</span><span class="s1">predict_proba</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">available_if</span><span class="s2">(</span><span class="s1">_estimator_has</span><span class="s2">(</span><span class="s4">&quot;predict_log_proba&quot;</span><span class="s2">))</span>
    <span class="s0">def </span><span class="s1">predict_log_proba</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Predict logarithm class probabilities for `X` using the fitted estimator. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Training vectors, where `n_samples` is the number of samples and 
            `n_features` is the number of features. 
 
        Returns 
        ------- 
        log_probabilities : ndarray of shape (n_samples, n_classes) 
            The logarithm class probabilities of the input samples. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s4">&quot;estimator_&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator_</span><span class="s2">.</span><span class="s1">predict_log_proba</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">available_if</span><span class="s2">(</span><span class="s1">_estimator_has</span><span class="s2">(</span><span class="s4">&quot;decision_function&quot;</span><span class="s2">))</span>
    <span class="s0">def </span><span class="s1">decision_function</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Decision function for samples in `X` using the fitted estimator. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Training vectors, where `n_samples` is the number of samples and 
            `n_features` is the number of features. 
 
        Returns 
        ------- 
        decisions : ndarray of shape (n_samples,) 
            The decision function computed the fitted estimator. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s4">&quot;estimator_&quot;</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator_</span><span class="s2">.</span><span class="s1">decision_function</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">_more_tags</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">{</span>
            <span class="s4">&quot;binary_only&quot;</span><span class="s2">: </span><span class="s0">True</span><span class="s2">,</span>
            <span class="s4">&quot;_xfail_checks&quot;</span><span class="s2">: {</span>
                <span class="s4">&quot;check_classifiers_train&quot;</span><span class="s2">: </span><span class="s4">&quot;Threshold at probability 0.5 does not hold&quot;</span><span class="s2">,</span>
                <span class="s4">&quot;check_sample_weights_invariance&quot;</span><span class="s2">: (</span>
                    <span class="s4">&quot;Due to the cross-validation and sample ordering, removing a sample&quot;</span>
                    <span class="s4">&quot; is not strictly equal to putting is weight to zero. Specific unit&quot;</span>
                    <span class="s4">&quot; tests are added for TunedThresholdClassifierCV specifically.&quot;</span>
                <span class="s2">),</span>
            <span class="s2">},</span>
        <span class="s2">}</span>


<span class="s0">class </span><span class="s1">FixedThresholdClassifier</span><span class="s2">(</span><span class="s1">BaseThresholdClassifier</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Binary classifier that manually sets the decision threshold. 
 
    This classifier allows to change the default decision threshold used for 
    converting posterior probability estimates (i.e. output of `predict_proba`) or 
    decision scores (i.e. output of `decision_function`) into a class label. 
 
    Here, the threshold is not optimized and is set to a constant value. 
 
    Read more in the :ref:`User Guide &lt;FixedThresholdClassifier&gt;`. 
 
    .. versionadded:: 1.5 
 
    Parameters 
    ---------- 
    estimator : estimator instance 
        The binary classifier, fitted or not, for which we want to optimize 
        the decision threshold used during `predict`. 
 
    threshold : {&quot;auto&quot;} or float, default=&quot;auto&quot; 
        The decision threshold to use when converting posterior probability estimates 
        (i.e. output of `predict_proba`) or decision scores (i.e. output of 
        `decision_function`) into a class label. When `&quot;auto&quot;`, the threshold is set 
        to 0.5 if `predict_proba` is used as `response_method`, otherwise it is set to 
        0 (i.e. the default threshold for `decision_function`). 
 
    pos_label : int, float, bool or str, default=None 
        The label of the positive class. Used to process the output of the 
        `response_method` method. When `pos_label=None`, if `y_true` is in `{-1, 1}` or 
        `{0, 1}`, `pos_label` is set to 1, otherwise an error will be raised. 
 
    response_method : {&quot;auto&quot;, &quot;decision_function&quot;, &quot;predict_proba&quot;}, default=&quot;auto&quot; 
        Methods by the classifier `estimator` corresponding to the 
        decision function for which we want to find a threshold. It can be: 
 
        * if `&quot;auto&quot;`, it will try to invoke `&quot;predict_proba&quot;` or `&quot;decision_function&quot;` 
          in that order. 
        * otherwise, one of `&quot;predict_proba&quot;` or `&quot;decision_function&quot;`. 
          If the method is not implemented by the classifier, it will raise an 
          error. 
 
    Attributes 
    ---------- 
    estimator_ : estimator instance 
        The fitted classifier used when predicting. 
 
    classes_ : ndarray of shape (n_classes,) 
        The class labels. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. Only defined if the 
        underlying estimator exposes such an attribute when fit. 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Only defined if the 
        underlying estimator exposes such an attribute when fit. 
 
    See Also 
    -------- 
    sklearn.model_selection.TunedThresholdClassifierCV : Classifier that post-tunes 
        the decision threshold based on some metrics and using cross-validation. 
    sklearn.calibration.CalibratedClassifierCV : Estimator that calibrates 
        probabilities. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.datasets import make_classification 
    &gt;&gt;&gt; from sklearn.linear_model import LogisticRegression 
    &gt;&gt;&gt; from sklearn.metrics import confusion_matrix 
    &gt;&gt;&gt; from sklearn.model_selection import FixedThresholdClassifier, train_test_split 
    &gt;&gt;&gt; X, y = make_classification( 
    ...     n_samples=1_000, weights=[0.9, 0.1], class_sep=0.8, random_state=42 
    ... ) 
    &gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split( 
    ...     X, y, stratify=y, random_state=42 
    ... ) 
    &gt;&gt;&gt; classifier = LogisticRegression(random_state=0).fit(X_train, y_train) 
    &gt;&gt;&gt; print(confusion_matrix(y_test, classifier.predict(X_test))) 
    [[217   7] 
     [ 19   7]] 
    &gt;&gt;&gt; classifier_other_threshold = FixedThresholdClassifier( 
    ...     classifier, threshold=0.1, response_method=&quot;predict_proba&quot; 
    ... ).fit(X_train, y_train) 
    &gt;&gt;&gt; print(confusion_matrix(y_test, classifier_other_threshold.predict(X_test))) 
    [[184  40] 
     [  6  20]] 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s2">: </span><span class="s1">dict </span><span class="s2">= {</span>
        <span class="s2">**</span><span class="s1">BaseThresholdClassifier</span><span class="s2">.</span><span class="s1">_parameter_constraints</span><span class="s2">,</span>
        <span class="s4">&quot;threshold&quot;</span><span class="s2">: [</span><span class="s1">StrOptions</span><span class="s2">({</span><span class="s4">&quot;auto&quot;</span><span class="s2">}), </span><span class="s1">Real</span><span class="s2">],</span>
        <span class="s4">&quot;pos_label&quot;</span><span class="s2">: [</span><span class="s1">Real</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s4">&quot;boolean&quot;</span><span class="s2">, </span><span class="s0">None</span><span class="s2">],</span>
    <span class="s2">}</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">estimator</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">threshold</span><span class="s2">=</span><span class="s4">&quot;auto&quot;</span><span class="s2">,</span>
        <span class="s1">pos_label</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">response_method</span><span class="s2">=</span><span class="s4">&quot;auto&quot;</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">estimator</span><span class="s2">=</span><span class="s1">estimator</span><span class="s2">, </span><span class="s1">response_method</span><span class="s2">=</span><span class="s1">response_method</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">pos_label </span><span class="s2">= </span><span class="s1">pos_label</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">threshold </span><span class="s2">= </span><span class="s1">threshold</span>

    <span class="s0">def </span><span class="s1">_fit</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, **</span><span class="s1">params</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Fit the classifier. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Training data. 
 
        y : array-like of shape (n_samples,) 
            Target values. 
 
        **params : dict 
            Parameters to pass to the `fit` method of the underlying 
            classifier. 
 
        Returns 
        ------- 
        self : object 
            Returns an instance of self. 
        &quot;&quot;&quot;</span>
        <span class="s1">routed_params </span><span class="s2">= </span><span class="s1">process_routing</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s4">&quot;fit&quot;</span><span class="s2">, **</span><span class="s1">params</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">estimator_ </span><span class="s2">= </span><span class="s1">clone</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator</span><span class="s2">).</span><span class="s1">fit</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, **</span><span class="s1">routed_params</span><span class="s2">.</span><span class="s1">estimator</span><span class="s2">.</span><span class="s1">fit</span><span class="s2">)</span>
        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">predict</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Predict the target of new samples. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The samples, as accepted by `estimator.predict`. 
 
        Returns 
        ------- 
        class_labels : ndarray of shape (n_samples,) 
            The predicted class. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s4">&quot;estimator_&quot;</span><span class="s2">)</span>
        <span class="s1">y_score</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">response_method_used </span><span class="s2">= </span><span class="s1">_get_response_values_binary</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">estimator_</span><span class="s2">,</span>
            <span class="s1">X</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_get_response_method</span><span class="s2">(),</span>
            <span class="s1">pos_label</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">pos_label</span><span class="s2">,</span>
            <span class="s1">return_response_method_used</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">threshold </span><span class="s2">== </span><span class="s4">&quot;auto&quot;</span><span class="s2">:</span>
            <span class="s1">decision_threshold </span><span class="s2">= </span><span class="s5">0.5 </span><span class="s0">if </span><span class="s1">response_method_used </span><span class="s2">== </span><span class="s4">&quot;predict_proba&quot; </span><span class="s0">else </span><span class="s5">0.0</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">decision_threshold </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">threshold</span>

        <span class="s0">return </span><span class="s1">_threshold_scores_to_class_labels</span><span class="s2">(</span>
            <span class="s1">y_score</span><span class="s2">, </span><span class="s1">decision_threshold</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">classes_</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">pos_label</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_metadata_routing</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Get metadata routing of this object. 
 
        Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing 
        mechanism works. 
 
        Returns 
        ------- 
        routing : MetadataRouter 
            A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating 
            routing information. 
        &quot;&quot;&quot;</span>
        <span class="s1">router </span><span class="s2">= </span><span class="s1">MetadataRouter</span><span class="s2">(</span><span class="s1">owner</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">).</span><span class="s1">add</span><span class="s2">(</span>
            <span class="s1">estimator</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator</span><span class="s2">,</span>
            <span class="s1">method_mapping</span><span class="s2">=</span><span class="s1">MethodMapping</span><span class="s2">().</span><span class="s1">add</span><span class="s2">(</span><span class="s1">callee</span><span class="s2">=</span><span class="s4">&quot;fit&quot;</span><span class="s2">, </span><span class="s1">caller</span><span class="s2">=</span><span class="s4">&quot;fit&quot;</span><span class="s2">),</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">router</span>


<span class="s0">class </span><span class="s1">_CurveScorer</span><span class="s2">(</span><span class="s1">_BaseScorer</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Scorer taking a continuous response and output a score for each threshold. 
 
    Parameters 
    ---------- 
    score_func : callable 
        The score function to use. It will be called as 
        `score_func(y_true, y_pred, **kwargs)`. 
 
    sign : int 
        Either 1 or -1 to returns the score with `sign * score_func(estimator, X, y)`. 
        Thus, `sign` defined if higher scores are better or worse. 
 
    kwargs : dict 
        Additional parameters to pass to the score function. 
 
    thresholds : int or array-like 
        Related to the number of decision thresholds for which we want to compute the 
        score. If an integer, it will be used to generate `thresholds` thresholds 
        uniformly distributed between the minimum and maximum predicted scores. If an 
        array-like, it will be used as the thresholds. 
 
    response_method : str 
        The method to call on the estimator to get the response values. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">score_func</span><span class="s2">, </span><span class="s1">sign</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">thresholds</span><span class="s2">, </span><span class="s1">response_method</span><span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span>
            <span class="s1">score_func</span><span class="s2">=</span><span class="s1">score_func</span><span class="s2">,</span>
            <span class="s1">sign</span><span class="s2">=</span><span class="s1">sign</span><span class="s2">,</span>
            <span class="s1">kwargs</span><span class="s2">=</span><span class="s1">kwargs</span><span class="s2">,</span>
            <span class="s1">response_method</span><span class="s2">=</span><span class="s1">response_method</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_thresholds </span><span class="s2">= </span><span class="s1">thresholds</span>

    <span class="s2">@</span><span class="s1">classmethod</span>
    <span class="s0">def </span><span class="s1">from_scorer</span><span class="s2">(</span><span class="s1">cls</span><span class="s2">, </span><span class="s1">scorer</span><span class="s2">, </span><span class="s1">response_method</span><span class="s2">, </span><span class="s1">thresholds</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Create a continuous scorer from a normal scorer.&quot;&quot;&quot;</span>
        <span class="s1">instance </span><span class="s2">= </span><span class="s1">cls</span><span class="s2">(</span>
            <span class="s1">score_func</span><span class="s2">=</span><span class="s1">scorer</span><span class="s2">.</span><span class="s1">_score_func</span><span class="s2">,</span>
            <span class="s1">sign</span><span class="s2">=</span><span class="s1">scorer</span><span class="s2">.</span><span class="s1">_sign</span><span class="s2">,</span>
            <span class="s1">response_method</span><span class="s2">=</span><span class="s1">response_method</span><span class="s2">,</span>
            <span class="s1">thresholds</span><span class="s2">=</span><span class="s1">thresholds</span><span class="s2">,</span>
            <span class="s1">kwargs</span><span class="s2">=</span><span class="s1">scorer</span><span class="s2">.</span><span class="s1">_kwargs</span><span class="s2">,</span>
        <span class="s2">)</span>
        <span class="s6"># transfer the metadata request</span>
        <span class="s1">instance</span><span class="s2">.</span><span class="s1">_metadata_request </span><span class="s2">= </span><span class="s1">scorer</span><span class="s2">.</span><span class="s1">_get_metadata_request</span><span class="s2">()</span>
        <span class="s0">return </span><span class="s1">instance</span>

    <span class="s0">def </span><span class="s1">_score</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">method_caller</span><span class="s2">, </span><span class="s1">estimator</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y_true</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Evaluate predicted target values for X relative to y_true. 
 
        Parameters 
        ---------- 
        method_caller : callable 
            Returns predictions given an estimator, method name, and other 
            arguments, potentially caching results. 
 
        estimator : object 
            Trained estimator to use for scoring. 
 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Test data that will be fed to estimator.predict. 
 
        y_true : array-like of shape (n_samples,) 
            Gold standard target values for X. 
 
        **kwargs : dict 
            Other parameters passed to the scorer. Refer to 
            :func:`set_score_request` for more details. 
 
        Returns 
        ------- 
        scores : ndarray of shape (thresholds,) 
            The scores associated to each threshold. 
 
        potential_thresholds : ndarray of shape (thresholds,) 
            The potential thresholds used to compute the scores. 
        &quot;&quot;&quot;</span>
        <span class="s1">pos_label </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_pos_label</span><span class="s2">()</span>
        <span class="s1">y_score </span><span class="s2">= </span><span class="s1">method_caller</span><span class="s2">(</span>
            <span class="s1">estimator</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_response_method</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">pos_label</span><span class="s2">=</span><span class="s1">pos_label</span>
        <span class="s2">)</span>

        <span class="s1">scoring_kwargs </span><span class="s2">= {**</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_kwargs</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">}</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_thresholds</span><span class="s2">, </span><span class="s1">Integral</span><span class="s2">):</span>
            <span class="s1">potential_thresholds </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span>
                <span class="s1">np</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">y_score</span><span class="s2">), </span><span class="s1">np</span><span class="s2">.</span><span class="s1">max</span><span class="s2">(</span><span class="s1">y_score</span><span class="s2">), </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_thresholds</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">potential_thresholds </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_thresholds</span><span class="s2">)</span>
        <span class="s1">score_thresholds </span><span class="s2">= [</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_sign</span>
            <span class="s2">* </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_score_func</span><span class="s2">(</span>
                <span class="s1">y_true</span><span class="s2">,</span>
                <span class="s1">_threshold_scores_to_class_labels</span><span class="s2">(</span>
                    <span class="s1">y_score</span><span class="s2">, </span><span class="s1">th</span><span class="s2">, </span><span class="s1">estimator</span><span class="s2">.</span><span class="s1">classes_</span><span class="s2">, </span><span class="s1">pos_label</span>
                <span class="s2">),</span>
                <span class="s2">**</span><span class="s1">scoring_kwargs</span><span class="s2">,</span>
            <span class="s2">)</span>
            <span class="s0">for </span><span class="s1">th </span><span class="s0">in </span><span class="s1">potential_thresholds</span>
        <span class="s2">]</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">(</span><span class="s1">score_thresholds</span><span class="s2">), </span><span class="s1">potential_thresholds</span>


<span class="s0">def </span><span class="s1">_fit_and_score_over_thresholds</span><span class="s2">(</span>
    <span class="s1">classifier</span><span class="s2">,</span>
    <span class="s1">X</span><span class="s2">,</span>
    <span class="s1">y</span><span class="s2">,</span>
    <span class="s2">*,</span>
    <span class="s1">fit_params</span><span class="s2">,</span>
    <span class="s1">train_idx</span><span class="s2">,</span>
    <span class="s1">val_idx</span><span class="s2">,</span>
    <span class="s1">curve_scorer</span><span class="s2">,</span>
    <span class="s1">score_params</span><span class="s2">,</span>
<span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Fit a classifier and compute the scores for different decision thresholds. 
 
    Parameters 
    ---------- 
    classifier : estimator instance 
        The classifier to fit and use for scoring. If `classifier` is already fitted, 
        it will be used as is. 
 
    X : {array-like, sparse matrix} of shape (n_samples, n_features) 
        The entire dataset. 
 
    y : array-like of shape (n_samples,) 
        The entire target vector. 
 
    fit_params : dict 
        Parameters to pass to the `fit` method of the underlying classifier. 
 
    train_idx : ndarray of shape (n_train_samples,) or None 
        The indices of the training set. If `None`, `classifier` is expected to be 
        already fitted. 
 
    val_idx : ndarray of shape (n_val_samples,) 
        The indices of the validation set used to score `classifier`. If `train_idx`, 
        the entire set will be used. 
 
    curve_scorer : scorer instance 
        The scorer taking `classifier` and the validation set as input and outputting 
        decision thresholds and scores as a curve. Note that this is different from 
        the usual scorer that output a single score value: 
 
        * when `score_method` is one of the four constraint metrics, the curve scorer 
          will output a curve of two scores parametrized by the decision threshold, e.g. 
          TPR/TNR or precision/recall curves for each threshold; 
        * otherwise, the curve scorer will output a single score value for each 
          threshold. 
 
    score_params : dict 
        Parameters to pass to the `score` method of the underlying scorer. 
 
    Returns 
    ------- 
    scores : ndarray of shape (thresholds,) or tuple of such arrays 
        The scores computed for each decision threshold. When TPR/TNR or precision/ 
        recall are computed, `scores` is a tuple of two arrays. 
 
    potential_thresholds : ndarray of shape (thresholds,) 
        The decision thresholds used to compute the scores. They are returned in 
        ascending order. 
    &quot;&quot;&quot;</span>

    <span class="s0">if </span><span class="s1">train_idx </span><span class="s0">is not None</span><span class="s2">:</span>
        <span class="s1">X_train</span><span class="s2">, </span><span class="s1">X_val </span><span class="s2">= </span><span class="s1">_safe_indexing</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">train_idx</span><span class="s2">), </span><span class="s1">_safe_indexing</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">val_idx</span><span class="s2">)</span>
        <span class="s1">y_train</span><span class="s2">, </span><span class="s1">y_val </span><span class="s2">= </span><span class="s1">_safe_indexing</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">train_idx</span><span class="s2">), </span><span class="s1">_safe_indexing</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">val_idx</span><span class="s2">)</span>
        <span class="s1">fit_params_train </span><span class="s2">= </span><span class="s1">_check_method_params</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">fit_params</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">=</span><span class="s1">train_idx</span><span class="s2">)</span>
        <span class="s1">score_params_val </span><span class="s2">= </span><span class="s1">_check_method_params</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">score_params</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">=</span><span class="s1">val_idx</span><span class="s2">)</span>
        <span class="s1">classifier</span><span class="s2">.</span><span class="s1">fit</span><span class="s2">(</span><span class="s1">X_train</span><span class="s2">, </span><span class="s1">y_train</span><span class="s2">, **</span><span class="s1">fit_params_train</span><span class="s2">)</span>
    <span class="s0">else</span><span class="s2">:  </span><span class="s6"># prefit estimator, only a validation set is provided</span>
        <span class="s1">X_val</span><span class="s2">, </span><span class="s1">y_val</span><span class="s2">, </span><span class="s1">score_params_val </span><span class="s2">= </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">score_params</span>

    <span class="s0">return </span><span class="s1">curve_scorer</span><span class="s2">(</span><span class="s1">classifier</span><span class="s2">, </span><span class="s1">X_val</span><span class="s2">, </span><span class="s1">y_val</span><span class="s2">, **</span><span class="s1">score_params_val</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">_mean_interpolated_score</span><span class="s2">(</span><span class="s1">target_thresholds</span><span class="s2">, </span><span class="s1">cv_thresholds</span><span class="s2">, </span><span class="s1">cv_scores</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Compute the mean interpolated score across folds by defining common thresholds. 
 
    Parameters 
    ---------- 
    target_thresholds : ndarray of shape (thresholds,) 
        The thresholds to use to compute the mean score. 
 
    cv_thresholds : ndarray of shape (n_folds, thresholds_fold) 
        The thresholds used to compute the scores for each fold. 
 
    cv_scores : ndarray of shape (n_folds, thresholds_fold) 
        The scores computed for each threshold for each fold. 
 
    Returns 
    ------- 
    mean_score : ndarray of shape (thresholds,) 
        The mean score across all folds for each target threshold. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">mean</span><span class="s2">(</span>
        <span class="s2">[</span>
            <span class="s1">np</span><span class="s2">.</span><span class="s1">interp</span><span class="s2">(</span><span class="s1">target_thresholds</span><span class="s2">, </span><span class="s1">split_thresholds</span><span class="s2">, </span><span class="s1">split_score</span><span class="s2">)</span>
            <span class="s0">for </span><span class="s1">split_thresholds</span><span class="s2">, </span><span class="s1">split_score </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">cv_thresholds</span><span class="s2">, </span><span class="s1">cv_scores</span><span class="s2">)</span>
        <span class="s2">],</span>
        <span class="s1">axis</span><span class="s2">=</span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">)</span>


<span class="s0">class </span><span class="s1">TunedThresholdClassifierCV</span><span class="s2">(</span><span class="s1">BaseThresholdClassifier</span><span class="s2">):</span>
    <span class="s3">&quot;&quot;&quot;Classifier that post-tunes the decision threshold using cross-validation. 
 
    This estimator post-tunes the decision threshold (cut-off point) that is 
    used for converting posterior probability estimates (i.e. output of 
    `predict_proba`) or decision scores (i.e. output of `decision_function`) 
    into a class label. The tuning is done by optimizing a binary metric, 
    potentially constrained by a another metric. 
 
    Read more in the :ref:`User Guide &lt;TunedThresholdClassifierCV&gt;`. 
 
    .. versionadded:: 1.5 
 
    Parameters 
    ---------- 
    estimator : estimator instance 
        The classifier, fitted or not, for which we want to optimize 
        the decision threshold used during `predict`. 
 
    scoring : str or callable, default=&quot;balanced_accuracy&quot; 
        The objective metric to be optimized. Can be one of: 
 
        * a string associated to a scoring function for binary classification 
          (see model evaluation documentation); 
        * a scorer callable object created with :func:`~sklearn.metrics.make_scorer`; 
 
    response_method : {&quot;auto&quot;, &quot;decision_function&quot;, &quot;predict_proba&quot;}, default=&quot;auto&quot; 
        Methods by the classifier `estimator` corresponding to the 
        decision function for which we want to find a threshold. It can be: 
 
        * if `&quot;auto&quot;`, it will try to invoke, for each classifier, 
          `&quot;predict_proba&quot;` or `&quot;decision_function&quot;` in that order. 
        * otherwise, one of `&quot;predict_proba&quot;` or `&quot;decision_function&quot;`. 
          If the method is not implemented by the classifier, it will raise an 
          error. 
 
    thresholds : int or array-like, default=100 
        The number of decision threshold to use when discretizing the output of the 
        classifier `method`. Pass an array-like to manually specify the thresholds 
        to use. 
 
    cv : int, float, cross-validation generator, iterable or &quot;prefit&quot;, default=None 
        Determines the cross-validation splitting strategy to train classifier. 
        Possible inputs for cv are: 
 
        * `None`, to use the default 5-fold stratified K-fold cross validation; 
        * An integer number, to specify the number of folds in a stratified k-fold; 
        * A float number, to specify a single shuffle split. The floating number should 
          be in (0, 1) and represent the size of the validation set; 
        * An object to be used as a cross-validation generator; 
        * An iterable yielding train, test splits; 
        * `&quot;prefit&quot;`, to bypass the cross-validation. 
 
        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various 
        cross-validation strategies that can be used here. 
 
        .. warning:: 
            Using `cv=&quot;prefit&quot;` and passing the same dataset for fitting `estimator` 
            and tuning the cut-off point is subject to undesired overfitting. You can 
            refer to :ref:`TunedThresholdClassifierCV_no_cv` for an example. 
 
            This option should only be used when the set used to fit `estimator` is 
            different from the one used to tune the cut-off point (by calling 
            :meth:`TunedThresholdClassifierCV.fit`). 
 
    refit : bool, default=True 
        Whether or not to refit the classifier on the entire training set once 
        the decision threshold has been found. 
        Note that forcing `refit=False` on cross-validation having more 
        than a single split will raise an error. Similarly, `refit=True` in 
        conjunction with `cv=&quot;prefit&quot;` will raise an error. 
 
    n_jobs : int, default=None 
        The number of jobs to run in parallel. When `cv` represents a 
        cross-validation strategy, the fitting and scoring on each data split 
        is done in parallel. ``None`` means 1 unless in a 
        :obj:`joblib.parallel_backend` context. ``-1`` means using all 
        processors. See :term:`Glossary &lt;n_jobs&gt;` for more details. 
 
    random_state : int, RandomState instance or None, default=None 
        Controls the randomness of cross-validation when `cv` is a float. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    store_cv_results : bool, default=False 
        Whether to store all scores and thresholds computed during the cross-validation 
        process. 
 
    Attributes 
    ---------- 
    estimator_ : estimator instance 
        The fitted classifier used when predicting. 
 
    best_threshold_ : float 
        The new decision threshold. 
 
    best_score_ : float or None 
        The optimal score of the objective metric, evaluated at `best_threshold_`. 
 
    cv_results_ : dict or None 
        A dictionary containing the scores and thresholds computed during the 
        cross-validation process. Only exist if `store_cv_results=True`. The 
        keys are `&quot;thresholds&quot;` and `&quot;scores&quot;`. 
 
    classes_ : ndarray of shape (n_classes,) 
        The class labels. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. Only defined if the 
        underlying estimator exposes such an attribute when fit. 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Only defined if the 
        underlying estimator exposes such an attribute when fit. 
 
    See Also 
    -------- 
    sklearn.model_selection.FixedThresholdClassifier : Classifier that uses a 
        constant threshold. 
    sklearn.calibration.CalibratedClassifierCV : Estimator that calibrates 
        probabilities. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.datasets import make_classification 
    &gt;&gt;&gt; from sklearn.ensemble import RandomForestClassifier 
    &gt;&gt;&gt; from sklearn.metrics import classification_report 
    &gt;&gt;&gt; from sklearn.model_selection import TunedThresholdClassifierCV, train_test_split 
    &gt;&gt;&gt; X, y = make_classification( 
    ...     n_samples=1_000, weights=[0.9, 0.1], class_sep=0.8, random_state=42 
    ... ) 
    &gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split( 
    ...     X, y, stratify=y, random_state=42 
    ... ) 
    &gt;&gt;&gt; classifier = RandomForestClassifier(random_state=0).fit(X_train, y_train) 
    &gt;&gt;&gt; print(classification_report(y_test, classifier.predict(X_test))) 
                  precision    recall  f1-score   support 
    &lt;BLANKLINE&gt; 
               0       0.94      0.99      0.96       224 
               1       0.80      0.46      0.59        26 
    &lt;BLANKLINE&gt; 
        accuracy                           0.93       250 
       macro avg       0.87      0.72      0.77       250 
    weighted avg       0.93      0.93      0.92       250 
    &lt;BLANKLINE&gt; 
    &gt;&gt;&gt; classifier_tuned = TunedThresholdClassifierCV( 
    ...     classifier, scoring=&quot;balanced_accuracy&quot; 
    ... ).fit(X_train, y_train) 
    &gt;&gt;&gt; print( 
    ...     f&quot;Cut-off point found at {classifier_tuned.best_threshold_:.3f}&quot; 
    ... ) 
    Cut-off point found at 0.342 
    &gt;&gt;&gt; print(classification_report(y_test, classifier_tuned.predict(X_test))) 
                  precision    recall  f1-score   support 
    &lt;BLANKLINE&gt; 
               0       0.96      0.95      0.96       224 
               1       0.61      0.65      0.63        26 
    &lt;BLANKLINE&gt; 
        accuracy                           0.92       250 
       macro avg       0.78      0.80      0.79       250 
    weighted avg       0.92      0.92      0.92       250 
    &lt;BLANKLINE&gt; 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints</span><span class="s2">: </span><span class="s1">dict </span><span class="s2">= {</span>
        <span class="s2">**</span><span class="s1">BaseThresholdClassifier</span><span class="s2">.</span><span class="s1">_parameter_constraints</span><span class="s2">,</span>
        <span class="s4">&quot;scoring&quot;</span><span class="s2">: [</span>
            <span class="s1">StrOptions</span><span class="s2">(</span><span class="s1">set</span><span class="s2">(</span><span class="s1">get_scorer_names</span><span class="s2">())),</span>
            <span class="s1">callable</span><span class="s2">,</span>
            <span class="s1">MutableMapping</span><span class="s2">,</span>
        <span class="s2">],</span>
        <span class="s4">&quot;thresholds&quot;</span><span class="s2">: [</span><span class="s1">Interval</span><span class="s2">(</span><span class="s1">Integral</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s0">None</span><span class="s2">, </span><span class="s1">closed</span><span class="s2">=</span><span class="s4">&quot;left&quot;</span><span class="s2">), </span><span class="s4">&quot;array-like&quot;</span><span class="s2">],</span>
        <span class="s4">&quot;cv&quot;</span><span class="s2">: [</span>
            <span class="s4">&quot;cv_object&quot;</span><span class="s2">,</span>
            <span class="s1">StrOptions</span><span class="s2">({</span><span class="s4">&quot;prefit&quot;</span><span class="s2">}),</span>
            <span class="s1">Interval</span><span class="s2">(</span><span class="s1">RealNotInt</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">closed</span><span class="s2">=</span><span class="s4">&quot;neither&quot;</span><span class="s2">),</span>
        <span class="s2">],</span>
        <span class="s4">&quot;refit&quot;</span><span class="s2">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s2">],</span>
        <span class="s4">&quot;n_jobs&quot;</span><span class="s2">: [</span><span class="s1">Integral</span><span class="s2">, </span><span class="s0">None</span><span class="s2">],</span>
        <span class="s4">&quot;random_state&quot;</span><span class="s2">: [</span><span class="s4">&quot;random_state&quot;</span><span class="s2">],</span>
        <span class="s4">&quot;store_cv_results&quot;</span><span class="s2">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s2">],</span>
    <span class="s2">}</span>

    <span class="s0">def </span><span class="s1">__init__</span><span class="s2">(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">estimator</span><span class="s2">,</span>
        <span class="s2">*,</span>
        <span class="s1">scoring</span><span class="s2">=</span><span class="s4">&quot;balanced_accuracy&quot;</span><span class="s2">,</span>
        <span class="s1">response_method</span><span class="s2">=</span><span class="s4">&quot;auto&quot;</span><span class="s2">,</span>
        <span class="s1">thresholds</span><span class="s2">=</span><span class="s5">100</span><span class="s2">,</span>
        <span class="s1">cv</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">refit</span><span class="s2">=</span><span class="s0">True</span><span class="s2">,</span>
        <span class="s1">n_jobs</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">random_state</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
        <span class="s1">store_cv_results</span><span class="s2">=</span><span class="s0">False</span><span class="s2">,</span>
    <span class="s2">):</span>
        <span class="s1">super</span><span class="s2">().</span><span class="s1">__init__</span><span class="s2">(</span><span class="s1">estimator</span><span class="s2">=</span><span class="s1">estimator</span><span class="s2">, </span><span class="s1">response_method</span><span class="s2">=</span><span class="s1">response_method</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">scoring </span><span class="s2">= </span><span class="s1">scoring</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">thresholds </span><span class="s2">= </span><span class="s1">thresholds</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">cv </span><span class="s2">= </span><span class="s1">cv</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">refit </span><span class="s2">= </span><span class="s1">refit</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">n_jobs </span><span class="s2">= </span><span class="s1">n_jobs</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">random_state </span><span class="s2">= </span><span class="s1">random_state</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">store_cv_results </span><span class="s2">= </span><span class="s1">store_cv_results</span>

    <span class="s0">def </span><span class="s1">_fit</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, **</span><span class="s1">params</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Fit the classifier and post-tune the decision threshold. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            Training data. 
 
        y : array-like of shape (n_samples,) 
            Target values. 
 
        **params : dict 
            Parameters to pass to the `fit` method of the underlying 
            classifier and to the `scoring` scorer. 
 
        Returns 
        ------- 
        self : object 
            Returns an instance of self. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cv</span><span class="s2">, </span><span class="s1">Real</span><span class="s2">) </span><span class="s0">and </span><span class="s5">0 </span><span class="s2">&lt; </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cv </span><span class="s2">&lt; </span><span class="s5">1</span><span class="s2">:</span>
            <span class="s1">cv </span><span class="s2">= </span><span class="s1">StratifiedShuffleSplit</span><span class="s2">(</span>
                <span class="s1">n_splits</span><span class="s2">=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">test_size</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cv</span><span class="s2">, </span><span class="s1">random_state</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">random_state</span>
            <span class="s2">)</span>
        <span class="s0">elif </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cv </span><span class="s2">== </span><span class="s4">&quot;prefit&quot;</span><span class="s2">:</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refit </span><span class="s0">is True</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;When cv='prefit', refit cannot be True.&quot;</span><span class="s2">)</span>
            <span class="s0">try</span><span class="s2">:</span>
                <span class="s1">check_is_fitted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator</span><span class="s2">, </span><span class="s4">&quot;classes_&quot;</span><span class="s2">)</span>
            <span class="s0">except </span><span class="s1">NotFittedError </span><span class="s0">as </span><span class="s1">exc</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">NotFittedError</span><span class="s2">(</span>
                    <span class="s4">&quot;&quot;&quot;When cv='prefit', `estimator` must be fitted.&quot;&quot;&quot;</span>
                <span class="s2">) </span><span class="s0">from </span><span class="s1">exc</span>
            <span class="s1">cv </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">cv</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">cv </span><span class="s2">= </span><span class="s1">check_cv</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cv</span><span class="s2">, </span><span class="s1">y</span><span class="s2">=</span><span class="s1">y</span><span class="s2">, </span><span class="s1">classifier</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refit </span><span class="s0">is False and </span><span class="s1">cv</span><span class="s2">.</span><span class="s1">get_n_splits</span><span class="s2">() &gt; </span><span class="s5">1</span><span class="s2">:</span>
                <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span><span class="s4">&quot;When cv has several folds, refit cannot be False.&quot;</span><span class="s2">)</span>

        <span class="s1">routed_params </span><span class="s2">= </span><span class="s1">process_routing</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s4">&quot;fit&quot;</span><span class="s2">, **</span><span class="s1">params</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">_curve_scorer </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_curve_scorer</span><span class="s2">()</span>

        <span class="s6"># in the following block, we:</span>
        <span class="s6"># - define the final classifier `self.estimator_` and train it if necessary</span>
        <span class="s6"># - define `classifier` to be used to post-tune the decision threshold</span>
        <span class="s6"># - define `split` to be used to fit/score `classifier`</span>
        <span class="s0">if </span><span class="s1">cv </span><span class="s2">== </span><span class="s4">&quot;prefit&quot;</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">estimator_ </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator</span>
            <span class="s1">classifier </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator_</span>
            <span class="s1">splits </span><span class="s2">= [(</span><span class="s0">None</span><span class="s2">, </span><span class="s1">range</span><span class="s2">(</span><span class="s1">_num_samples</span><span class="s2">(</span><span class="s1">X</span><span class="s2">)))]</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">estimator_ </span><span class="s2">= </span><span class="s1">clone</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator</span><span class="s2">)</span>
            <span class="s1">classifier </span><span class="s2">= </span><span class="s1">clone</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator</span><span class="s2">)</span>
            <span class="s1">splits </span><span class="s2">= </span><span class="s1">cv</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, **</span><span class="s1">routed_params</span><span class="s2">.</span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">split</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">refit</span><span class="s2">:</span>
                <span class="s6"># train on the whole dataset</span>
                <span class="s1">X_train</span><span class="s2">, </span><span class="s1">y_train</span><span class="s2">, </span><span class="s1">fit_params_train </span><span class="s2">= </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">routed_params</span><span class="s2">.</span><span class="s1">estimator</span><span class="s2">.</span><span class="s1">fit</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s6"># single split cross-validation</span>
                <span class="s1">train_idx</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">next</span><span class="s2">(</span><span class="s1">cv</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, **</span><span class="s1">routed_params</span><span class="s2">.</span><span class="s1">splitter</span><span class="s2">.</span><span class="s1">split</span><span class="s2">))</span>
                <span class="s1">X_train </span><span class="s2">= </span><span class="s1">_safe_indexing</span><span class="s2">(</span><span class="s1">X</span><span class="s2">, </span><span class="s1">train_idx</span><span class="s2">)</span>
                <span class="s1">y_train </span><span class="s2">= </span><span class="s1">_safe_indexing</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, </span><span class="s1">train_idx</span><span class="s2">)</span>
                <span class="s1">fit_params_train </span><span class="s2">= </span><span class="s1">_check_method_params</span><span class="s2">(</span>
                    <span class="s1">X</span><span class="s2">, </span><span class="s1">routed_params</span><span class="s2">.</span><span class="s1">estimator</span><span class="s2">.</span><span class="s1">fit</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">=</span><span class="s1">train_idx</span>
                <span class="s2">)</span>

            <span class="s1">self</span><span class="s2">.</span><span class="s1">estimator_</span><span class="s2">.</span><span class="s1">fit</span><span class="s2">(</span><span class="s1">X_train</span><span class="s2">, </span><span class="s1">y_train</span><span class="s2">, **</span><span class="s1">fit_params_train</span><span class="s2">)</span>

        <span class="s1">cv_scores</span><span class="s2">, </span><span class="s1">cv_thresholds </span><span class="s2">= </span><span class="s1">zip</span><span class="s2">(</span>
            <span class="s2">*</span><span class="s1">Parallel</span><span class="s2">(</span><span class="s1">n_jobs</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">n_jobs</span><span class="s2">)(</span>
                <span class="s1">delayed</span><span class="s2">(</span><span class="s1">_fit_and_score_over_thresholds</span><span class="s2">)(</span>
                    <span class="s1">clone</span><span class="s2">(</span><span class="s1">classifier</span><span class="s2">) </span><span class="s0">if </span><span class="s1">cv </span><span class="s2">!= </span><span class="s4">&quot;prefit&quot; </span><span class="s0">else </span><span class="s1">classifier</span><span class="s2">,</span>
                    <span class="s1">X</span><span class="s2">,</span>
                    <span class="s1">y</span><span class="s2">,</span>
                    <span class="s1">fit_params</span><span class="s2">=</span><span class="s1">routed_params</span><span class="s2">.</span><span class="s1">estimator</span><span class="s2">.</span><span class="s1">fit</span><span class="s2">,</span>
                    <span class="s1">train_idx</span><span class="s2">=</span><span class="s1">train_idx</span><span class="s2">,</span>
                    <span class="s1">val_idx</span><span class="s2">=</span><span class="s1">val_idx</span><span class="s2">,</span>
                    <span class="s1">curve_scorer</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_curve_scorer</span><span class="s2">,</span>
                    <span class="s1">score_params</span><span class="s2">=</span><span class="s1">routed_params</span><span class="s2">.</span><span class="s1">scorer</span><span class="s2">.</span><span class="s1">score</span><span class="s2">,</span>
                <span class="s2">)</span>
                <span class="s0">for </span><span class="s1">train_idx</span><span class="s2">, </span><span class="s1">val_idx </span><span class="s0">in </span><span class="s1">splits</span>
            <span class="s2">)</span>
        <span class="s2">)</span>

        <span class="s0">if </span><span class="s1">any</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">isclose</span><span class="s2">(</span><span class="s1">th</span><span class="s2">[</span><span class="s5">0</span><span class="s2">], </span><span class="s1">th</span><span class="s2">[-</span><span class="s5">1</span><span class="s2">]) </span><span class="s0">for </span><span class="s1">th </span><span class="s0">in </span><span class="s1">cv_thresholds</span><span class="s2">):</span>
            <span class="s0">raise </span><span class="s1">ValueError</span><span class="s2">(</span>
                <span class="s4">&quot;The provided estimator makes constant predictions. Therefore, it is &quot;</span>
                <span class="s4">&quot;impossible to optimize the decision threshold.&quot;</span>
            <span class="s2">)</span>

        <span class="s6"># find the global min and max thresholds across all folds</span>
        <span class="s1">min_threshold </span><span class="s2">= </span><span class="s1">min</span><span class="s2">(</span>
            <span class="s1">split_thresholds</span><span class="s2">.</span><span class="s1">min</span><span class="s2">() </span><span class="s0">for </span><span class="s1">split_thresholds </span><span class="s0">in </span><span class="s1">cv_thresholds</span>
        <span class="s2">)</span>
        <span class="s1">max_threshold </span><span class="s2">= </span><span class="s1">max</span><span class="s2">(</span>
            <span class="s1">split_thresholds</span><span class="s2">.</span><span class="s1">max</span><span class="s2">() </span><span class="s0">for </span><span class="s1">split_thresholds </span><span class="s0">in </span><span class="s1">cv_thresholds</span>
        <span class="s2">)</span>
        <span class="s0">if </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">thresholds</span><span class="s2">, </span><span class="s1">Integral</span><span class="s2">):</span>
            <span class="s1">decision_thresholds </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">linspace</span><span class="s2">(</span>
                <span class="s1">min_threshold</span><span class="s2">, </span><span class="s1">max_threshold</span><span class="s2">, </span><span class="s1">num</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">thresholds</span>
            <span class="s2">)</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">decision_thresholds </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">asarray</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">thresholds</span><span class="s2">)</span>

        <span class="s1">objective_scores </span><span class="s2">= </span><span class="s1">_mean_interpolated_score</span><span class="s2">(</span>
            <span class="s1">decision_thresholds</span><span class="s2">, </span><span class="s1">cv_thresholds</span><span class="s2">, </span><span class="s1">cv_scores</span>
        <span class="s2">)</span>
        <span class="s1">best_idx </span><span class="s2">= </span><span class="s1">objective_scores</span><span class="s2">.</span><span class="s1">argmax</span><span class="s2">()</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">best_score_ </span><span class="s2">= </span><span class="s1">objective_scores</span><span class="s2">[</span><span class="s1">best_idx</span><span class="s2">]</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">best_threshold_ </span><span class="s2">= </span><span class="s1">decision_thresholds</span><span class="s2">[</span><span class="s1">best_idx</span><span class="s2">]</span>
        <span class="s0">if </span><span class="s1">self</span><span class="s2">.</span><span class="s1">store_cv_results</span><span class="s2">:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">cv_results_ </span><span class="s2">= {</span>
                <span class="s4">&quot;thresholds&quot;</span><span class="s2">: </span><span class="s1">decision_thresholds</span><span class="s2">,</span>
                <span class="s4">&quot;scores&quot;</span><span class="s2">: </span><span class="s1">objective_scores</span><span class="s2">,</span>
            <span class="s2">}</span>

        <span class="s0">return </span><span class="s1">self</span>

    <span class="s0">def </span><span class="s1">predict</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Predict the target of new samples. 
 
        Parameters 
        ---------- 
        X : {array-like, sparse matrix} of shape (n_samples, n_features) 
            The samples, as accepted by `estimator.predict`. 
 
        Returns 
        ------- 
        class_labels : ndarray of shape (n_samples,) 
            The predicted class. 
        &quot;&quot;&quot;</span>
        <span class="s1">check_is_fitted</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s4">&quot;estimator_&quot;</span><span class="s2">)</span>
        <span class="s1">pos_label </span><span class="s2">= </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_curve_scorer</span><span class="s2">.</span><span class="s1">_get_pos_label</span><span class="s2">()</span>
        <span class="s1">y_score</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">= </span><span class="s1">_get_response_values_binary</span><span class="s2">(</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">estimator_</span><span class="s2">,</span>
            <span class="s1">X</span><span class="s2">,</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">_get_response_method</span><span class="s2">(),</span>
            <span class="s1">pos_label</span><span class="s2">=</span><span class="s1">pos_label</span><span class="s2">,</span>
        <span class="s2">)</span>

        <span class="s0">return </span><span class="s1">_threshold_scores_to_class_labels</span><span class="s2">(</span>
            <span class="s1">y_score</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">best_threshold_</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">classes_</span><span class="s2">, </span><span class="s1">pos_label</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">get_metadata_routing</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Get metadata routing of this object. 
 
        Please check :ref:`User Guide &lt;metadata_routing&gt;` on how the routing 
        mechanism works. 
 
        Returns 
        ------- 
        routing : MetadataRouter 
            A :class:`~sklearn.utils.metadata_routing.MetadataRouter` encapsulating 
            routing information. 
        &quot;&quot;&quot;</span>
        <span class="s1">router </span><span class="s2">= (</span>
            <span class="s1">MetadataRouter</span><span class="s2">(</span><span class="s1">owner</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">__class__</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">)</span>
            <span class="s2">.</span><span class="s1">add</span><span class="s2">(</span>
                <span class="s1">estimator</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator</span><span class="s2">,</span>
                <span class="s1">method_mapping</span><span class="s2">=</span><span class="s1">MethodMapping</span><span class="s2">().</span><span class="s1">add</span><span class="s2">(</span><span class="s1">callee</span><span class="s2">=</span><span class="s4">&quot;fit&quot;</span><span class="s2">, </span><span class="s1">caller</span><span class="s2">=</span><span class="s4">&quot;fit&quot;</span><span class="s2">),</span>
            <span class="s2">)</span>
            <span class="s2">.</span><span class="s1">add</span><span class="s2">(</span>
                <span class="s1">splitter</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">cv</span><span class="s2">,</span>
                <span class="s1">method_mapping</span><span class="s2">=</span><span class="s1">MethodMapping</span><span class="s2">().</span><span class="s1">add</span><span class="s2">(</span><span class="s1">callee</span><span class="s2">=</span><span class="s4">&quot;split&quot;</span><span class="s2">, </span><span class="s1">caller</span><span class="s2">=</span><span class="s4">&quot;fit&quot;</span><span class="s2">),</span>
            <span class="s2">)</span>
            <span class="s2">.</span><span class="s1">add</span><span class="s2">(</span>
                <span class="s1">scorer</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_curve_scorer</span><span class="s2">(),</span>
                <span class="s1">method_mapping</span><span class="s2">=</span><span class="s1">MethodMapping</span><span class="s2">().</span><span class="s1">add</span><span class="s2">(</span><span class="s1">callee</span><span class="s2">=</span><span class="s4">&quot;score&quot;</span><span class="s2">, </span><span class="s1">caller</span><span class="s2">=</span><span class="s4">&quot;fit&quot;</span><span class="s2">),</span>
            <span class="s2">)</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">router</span>

    <span class="s0">def </span><span class="s1">_get_curve_scorer</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3">&quot;&quot;&quot;Get the curve scorer based on the objective metric used.&quot;&quot;&quot;</span>
        <span class="s1">scoring </span><span class="s2">= </span><span class="s1">check_scoring</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">estimator</span><span class="s2">, </span><span class="s1">scoring</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">scoring</span><span class="s2">)</span>
        <span class="s1">curve_scorer </span><span class="s2">= </span><span class="s1">_CurveScorer</span><span class="s2">.</span><span class="s1">from_scorer</span><span class="s2">(</span>
            <span class="s1">scoring</span><span class="s2">, </span><span class="s1">self</span><span class="s2">.</span><span class="s1">_get_response_method</span><span class="s2">(), </span><span class="s1">self</span><span class="s2">.</span><span class="s1">thresholds</span>
        <span class="s2">)</span>
        <span class="s0">return </span><span class="s1">curve_scorer</span>
</pre>
</body>
</html>