<html>
<head>
<title>_svmlight_format_io.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #7a7e85;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
.s7 { color: #a5c261;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_svmlight_format_io.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;This module implements a loader and dumper for the svmlight format 
 
This format is a text-based format, with one sample per line. It does 
not store zero valued features hence is suitable for sparse dataset. 
 
The first element of each line can be used to store a target variable to 
predict. 
 
This format is used as the default format for both svmlight and the 
libsvm command line programs. 
&quot;&quot;&quot;</span>

<span class="s2"># Authors: Mathieu Blondel &lt;mathieu@mblondel.org&gt;</span>
<span class="s2">#          Lars Buitinck</span>
<span class="s2">#          Olivier Grisel &lt;olivier.grisel@ensta.org&gt;</span>
<span class="s2"># License: BSD 3 clause</span>

<span class="s3">import </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span>
<span class="s3">from </span><span class="s1">contextlib </span><span class="s3">import </span><span class="s1">closing</span>
<span class="s3">from </span><span class="s1">numbers </span><span class="s3">import </span><span class="s1">Integral</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">scipy</span><span class="s4">.</span><span class="s1">sparse </span><span class="s3">as </span><span class="s1">sp</span>

<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">__version__</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils </span><span class="s3">import </span><span class="s1">check_array</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">_param_validation </span><span class="s3">import </span><span class="s1">HasMethods</span><span class="s4">, </span><span class="s1">Interval</span><span class="s4">, </span><span class="s1">StrOptions</span><span class="s4">, </span><span class="s1">validate_params</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">utils</span><span class="s4">.</span><span class="s1">fixes </span><span class="s3">import </span><span class="s1">_IS_PYPY</span>

<span class="s3">if not </span><span class="s1">_IS_PYPY</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_svmlight_format_fast </span><span class="s3">import </span><span class="s4">(</span>
        <span class="s1">_dump_svmlight_file</span><span class="s4">,</span>
        <span class="s1">_load_svmlight_file</span><span class="s4">,</span>
    <span class="s4">)</span>
<span class="s3">else</span><span class="s4">:</span>

    <span class="s3">def </span><span class="s1">_load_svmlight_file</span><span class="s4">(*</span><span class="s1">args</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span><span class="s4">(</span>
            <span class="s5">&quot;load_svmlight_file is currently not &quot;</span>
            <span class="s5">&quot;compatible with PyPy (see &quot;</span>
            <span class="s5">&quot;https://github.com/scikit-learn/scikit-learn/issues/11543 &quot;</span>
            <span class="s5">&quot;for the status updates).&quot;</span>
        <span class="s4">)</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;f&quot;</span><span class="s4">: [</span>
            <span class="s1">str</span><span class="s4">,</span>
            <span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">),</span>
            <span class="s1">os</span><span class="s4">.</span><span class="s1">PathLike</span><span class="s4">,</span>
            <span class="s1">HasMethods</span><span class="s4">(</span><span class="s5">&quot;read&quot;</span><span class="s4">),</span>
        <span class="s4">],</span>
        <span class="s5">&quot;n_features&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">), </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;dtype&quot;</span><span class="s4">: </span><span class="s5">&quot;no_validation&quot;</span><span class="s4">,  </span><span class="s2"># delegate validation to numpy</span>
        <span class="s5">&quot;multilabel&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;zero_based&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">, </span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;auto&quot;</span><span class="s4">})],</span>
        <span class="s5">&quot;query_id&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;offset&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;length&quot;</span><span class="s4">: [</span><span class="s1">Integral</span><span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">load_svmlight_file</span><span class="s4">(</span>
    <span class="s1">f</span><span class="s4">,</span>
    <span class="s4">*,</span>
    <span class="s1">n_features</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">,</span>
    <span class="s1">multilabel</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s1">zero_based</span><span class="s4">=</span><span class="s5">&quot;auto&quot;</span><span class="s4">,</span>
    <span class="s1">query_id</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s1">offset</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
    <span class="s1">length</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Load datasets in the svmlight / libsvm format into sparse CSR matrix. 
 
    This format is a text-based format, with one sample per line. It does 
    not store zero valued features hence is suitable for sparse dataset. 
 
    The first element of each line can be used to store a target variable 
    to predict. 
 
    This format is used as the default format for both svmlight and the 
    libsvm command line programs. 
 
    Parsing a text based source can be expensive. When repeatedly 
    working on the same dataset, it is recommended to wrap this 
    loader with joblib.Memory.cache to store a memmapped backup of the 
    CSR results of the first call and benefit from the near instantaneous 
    loading of memmapped structures for the subsequent calls. 
 
    In case the file contains a pairwise preference constraint (known 
    as &quot;qid&quot; in the svmlight format) these are ignored unless the 
    query_id parameter is set to True. These pairwise preference 
    constraints can be used to constraint the combination of samples 
    when using pairwise loss functions (as is the case in some 
    learning to rank problems) so that only pairs with the same 
    query_id value are considered. 
 
    This implementation is written in Cython and is reasonably fast. 
    However, a faster API-compatible loader is also available at: 
 
      https://github.com/mblondel/svmlight-loader 
 
    Parameters 
    ---------- 
    f : str, path-like, file-like or int 
        (Path to) a file to load. If a path ends in &quot;.gz&quot; or &quot;.bz2&quot;, it will 
        be uncompressed on the fly. If an integer is passed, it is assumed to 
        be a file descriptor. A file-like or file descriptor will not be closed 
        by this function. A file-like object must be opened in binary mode. 
 
        .. versionchanged:: 1.2 
           Path-like objects are now accepted. 
 
    n_features : int, default=None 
        The number of features to use. If None, it will be inferred. This 
        argument is useful to load several files that are subsets of a 
        bigger sliced dataset: each subset might not have examples of 
        every feature, hence the inferred shape might vary from one 
        slice to another. 
        n_features is only required if ``offset`` or ``length`` are passed a 
        non-default value. 
 
    dtype : numpy data type, default=np.float64 
        Data type of dataset to be loaded. This will be the data type of the 
        output numpy arrays ``X`` and ``y``. 
 
    multilabel : bool, default=False 
        Samples may have several labels each (see 
        https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/multilabel.html). 
 
    zero_based : bool or &quot;auto&quot;, default=&quot;auto&quot; 
        Whether column indices in f are zero-based (True) or one-based 
        (False). If column indices are one-based, they are transformed to 
        zero-based to match Python/NumPy conventions. 
        If set to &quot;auto&quot;, a heuristic check is applied to determine this from 
        the file contents. Both kinds of files occur &quot;in the wild&quot;, but they 
        are unfortunately not self-identifying. Using &quot;auto&quot; or True should 
        always be safe when no ``offset`` or ``length`` is passed. 
        If ``offset`` or ``length`` are passed, the &quot;auto&quot; mode falls back 
        to ``zero_based=True`` to avoid having the heuristic check yield 
        inconsistent results on different segments of the file. 
 
    query_id : bool, default=False 
        If True, will return the query_id array for each file. 
 
    offset : int, default=0 
        Ignore the offset first bytes by seeking forward, then 
        discarding the following bytes up until the next new line 
        character. 
 
    length : int, default=-1 
        If strictly positive, stop reading any new line of data once the 
        position in the file has reached the (offset + length) bytes threshold. 
 
    Returns 
    ------- 
    X : scipy.sparse matrix of shape (n_samples, n_features) 
        The data matrix. 
 
    y : ndarray of shape (n_samples,), or a list of tuples of length n_samples 
        The target. It is a list of tuples when ``multilabel=True``, else a 
        ndarray. 
 
    query_id : array of shape (n_samples,) 
       The query_id for each sample. Only returned when query_id is set to 
       True. 
 
    See Also 
    -------- 
    load_svmlight_files : Similar function for loading multiple files in this 
        format, enforcing the same number of features/columns on all of them. 
 
    Examples 
    -------- 
    To use joblib.Memory to cache the svmlight file:: 
 
        from joblib import Memory 
        from sklearn.datasets import load_svmlight_file 
        mem = Memory(&quot;./mycache&quot;) 
 
        @mem.cache 
        def get_data(): 
            data = load_svmlight_file(&quot;mysvmlightfile&quot;) 
            return data[0], data[1] 
 
        X, y = get_data() 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">tuple</span><span class="s4">(</span>
        <span class="s1">load_svmlight_files</span><span class="s4">(</span>
            <span class="s4">[</span><span class="s1">f</span><span class="s4">],</span>
            <span class="s1">n_features</span><span class="s4">=</span><span class="s1">n_features</span><span class="s4">,</span>
            <span class="s1">dtype</span><span class="s4">=</span><span class="s1">dtype</span><span class="s4">,</span>
            <span class="s1">multilabel</span><span class="s4">=</span><span class="s1">multilabel</span><span class="s4">,</span>
            <span class="s1">zero_based</span><span class="s4">=</span><span class="s1">zero_based</span><span class="s4">,</span>
            <span class="s1">query_id</span><span class="s4">=</span><span class="s1">query_id</span><span class="s4">,</span>
            <span class="s1">offset</span><span class="s4">=</span><span class="s1">offset</span><span class="s4">,</span>
            <span class="s1">length</span><span class="s4">=</span><span class="s1">length</span><span class="s4">,</span>
        <span class="s4">)</span>
    <span class="s4">)</span>


<span class="s3">def </span><span class="s1">_gen_open</span><span class="s4">(</span><span class="s1">f</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">int</span><span class="s4">):  </span><span class="s2"># file descriptor</span>
        <span class="s3">return </span><span class="s1">open</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s5">&quot;rb&quot;</span><span class="s4">, </span><span class="s1">closefd</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">os</span><span class="s4">.</span><span class="s1">PathLike</span><span class="s4">):</span>
        <span class="s1">f </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">fspath</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
    <span class="s3">elif not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">str</span><span class="s4">):</span>
        <span class="s3">raise </span><span class="s1">TypeError</span><span class="s4">(</span><span class="s5">&quot;expected {str, int, path-like, file-like}, got %s&quot; </span><span class="s4">% </span><span class="s1">type</span><span class="s4">(</span><span class="s1">f</span><span class="s4">))</span>

    <span class="s1">_</span><span class="s4">, </span><span class="s1">ext </span><span class="s4">= </span><span class="s1">os</span><span class="s4">.</span><span class="s1">path</span><span class="s4">.</span><span class="s1">splitext</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">ext </span><span class="s4">== </span><span class="s5">&quot;.gz&quot;</span><span class="s4">:</span>
        <span class="s3">import </span><span class="s1">gzip</span>

        <span class="s3">return </span><span class="s1">gzip</span><span class="s4">.</span><span class="s1">open</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s5">&quot;rb&quot;</span><span class="s4">)</span>
    <span class="s3">elif </span><span class="s1">ext </span><span class="s4">== </span><span class="s5">&quot;.bz2&quot;</span><span class="s4">:</span>
        <span class="s3">from </span><span class="s1">bz2 </span><span class="s3">import </span><span class="s1">BZ2File</span>

        <span class="s3">return </span><span class="s1">BZ2File</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s5">&quot;rb&quot;</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">open</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s5">&quot;rb&quot;</span><span class="s4">)</span>


<span class="s3">def </span><span class="s1">_open_and_load</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">multilabel</span><span class="s4">, </span><span class="s1">zero_based</span><span class="s4">, </span><span class="s1">query_id</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">=</span><span class="s6">0</span><span class="s4">, </span><span class="s1">length</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s5">&quot;read&quot;</span><span class="s4">):</span>
        <span class="s1">actual_dtype</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">ind</span><span class="s4">, </span><span class="s1">indptr</span><span class="s4">, </span><span class="s1">labels</span><span class="s4">, </span><span class="s1">query </span><span class="s4">= </span><span class="s1">_load_svmlight_file</span><span class="s4">(</span>
            <span class="s1">f</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">multilabel</span><span class="s4">, </span><span class="s1">zero_based</span><span class="s4">, </span><span class="s1">query_id</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">, </span><span class="s1">length</span>
        <span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">with </span><span class="s1">closing</span><span class="s4">(</span><span class="s1">_gen_open</span><span class="s4">(</span><span class="s1">f</span><span class="s4">)) </span><span class="s3">as </span><span class="s1">f</span><span class="s4">:</span>
            <span class="s1">actual_dtype</span><span class="s4">, </span><span class="s1">data</span><span class="s4">, </span><span class="s1">ind</span><span class="s4">, </span><span class="s1">indptr</span><span class="s4">, </span><span class="s1">labels</span><span class="s4">, </span><span class="s1">query </span><span class="s4">= </span><span class="s1">_load_svmlight_file</span><span class="s4">(</span>
                <span class="s1">f</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">, </span><span class="s1">multilabel</span><span class="s4">, </span><span class="s1">zero_based</span><span class="s4">, </span><span class="s1">query_id</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">, </span><span class="s1">length</span>
            <span class="s4">)</span>

    <span class="s2"># convert from array.array, give data the right dtype</span>
    <span class="s3">if not </span><span class="s1">multilabel</span><span class="s4">:</span>
        <span class="s1">labels </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">frombuffer</span><span class="s4">(</span><span class="s1">labels</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">)</span>
    <span class="s1">data </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">frombuffer</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">actual_dtype</span><span class="s4">)</span>
    <span class="s1">indices </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">frombuffer</span><span class="s4">(</span><span class="s1">ind</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">longlong</span><span class="s4">)</span>
    <span class="s1">indptr </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">frombuffer</span><span class="s4">(</span><span class="s1">indptr</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">longlong</span><span class="s4">)  </span><span class="s2"># never empty</span>
    <span class="s1">query </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">frombuffer</span><span class="s4">(</span><span class="s1">query</span><span class="s4">, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">int64</span><span class="s4">)</span>

    <span class="s1">data </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">data</span><span class="s4">, </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">dtype</span><span class="s4">)  </span><span class="s2"># no-op for float{32,64}</span>
    <span class="s3">return </span><span class="s1">data</span><span class="s4">, </span><span class="s1">indices</span><span class="s4">, </span><span class="s1">indptr</span><span class="s4">, </span><span class="s1">labels</span><span class="s4">, </span><span class="s1">query</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;files&quot;</span><span class="s4">: [</span>
            <span class="s5">&quot;array-like&quot;</span><span class="s4">,</span>
            <span class="s1">str</span><span class="s4">,</span>
            <span class="s1">os</span><span class="s4">.</span><span class="s1">PathLike</span><span class="s4">,</span>
            <span class="s1">HasMethods</span><span class="s4">(</span><span class="s5">&quot;read&quot;</span><span class="s4">),</span>
            <span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">),</span>
        <span class="s4">],</span>
        <span class="s5">&quot;n_features&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s6">1</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">), </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;dtype&quot;</span><span class="s4">: </span><span class="s5">&quot;no_validation&quot;</span><span class="s4">,  </span><span class="s2"># delegate validation to numpy</span>
        <span class="s5">&quot;multilabel&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;zero_based&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">, </span><span class="s1">StrOptions</span><span class="s4">({</span><span class="s5">&quot;auto&quot;</span><span class="s4">})],</span>
        <span class="s5">&quot;query_id&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;offset&quot;</span><span class="s4">: [</span><span class="s1">Interval</span><span class="s4">(</span><span class="s1">Integral</span><span class="s4">, </span><span class="s6">0</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">closed</span><span class="s4">=</span><span class="s5">&quot;left&quot;</span><span class="s4">)],</span>
        <span class="s5">&quot;length&quot;</span><span class="s4">: [</span><span class="s1">Integral</span><span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">load_svmlight_files</span><span class="s4">(</span>
    <span class="s1">files</span><span class="s4">,</span>
    <span class="s4">*,</span>
    <span class="s1">n_features</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">float64</span><span class="s4">,</span>
    <span class="s1">multilabel</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s1">zero_based</span><span class="s4">=</span><span class="s5">&quot;auto&quot;</span><span class="s4">,</span>
    <span class="s1">query_id</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
    <span class="s1">offset</span><span class="s4">=</span><span class="s6">0</span><span class="s4">,</span>
    <span class="s1">length</span><span class="s4">=-</span><span class="s6">1</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Load dataset from multiple files in SVMlight format. 
 
    This function is equivalent to mapping load_svmlight_file over a list of 
    files, except that the results are concatenated into a single, flat list 
    and the samples vectors are constrained to all have the same number of 
    features. 
 
    In case the file contains a pairwise preference constraint (known 
    as &quot;qid&quot; in the svmlight format) these are ignored unless the 
    query_id parameter is set to True. These pairwise preference 
    constraints can be used to constraint the combination of samples 
    when using pairwise loss functions (as is the case in some 
    learning to rank problems) so that only pairs with the same 
    query_id value are considered. 
 
    Parameters 
    ---------- 
    files : array-like, dtype=str, path-like, file-like or int 
        (Paths of) files to load. If a path ends in &quot;.gz&quot; or &quot;.bz2&quot;, it will 
        be uncompressed on the fly. If an integer is passed, it is assumed to 
        be a file descriptor. File-likes and file descriptors will not be 
        closed by this function. File-like objects must be opened in binary 
        mode. 
 
        .. versionchanged:: 1.2 
           Path-like objects are now accepted. 
 
    n_features : int, default=None 
        The number of features to use. If None, it will be inferred from the 
        maximum column index occurring in any of the files. 
 
        This can be set to a higher value than the actual number of features 
        in any of the input files, but setting it to a lower value will cause 
        an exception to be raised. 
 
    dtype : numpy data type, default=np.float64 
        Data type of dataset to be loaded. This will be the data type of the 
        output numpy arrays ``X`` and ``y``. 
 
    multilabel : bool, default=False 
        Samples may have several labels each (see 
        https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/multilabel.html). 
 
    zero_based : bool or &quot;auto&quot;, default=&quot;auto&quot; 
        Whether column indices in f are zero-based (True) or one-based 
        (False). If column indices are one-based, they are transformed to 
        zero-based to match Python/NumPy conventions. 
        If set to &quot;auto&quot;, a heuristic check is applied to determine this from 
        the file contents. Both kinds of files occur &quot;in the wild&quot;, but they 
        are unfortunately not self-identifying. Using &quot;auto&quot; or True should 
        always be safe when no offset or length is passed. 
        If offset or length are passed, the &quot;auto&quot; mode falls back 
        to zero_based=True to avoid having the heuristic check yield 
        inconsistent results on different segments of the file. 
 
    query_id : bool, default=False 
        If True, will return the query_id array for each file. 
 
    offset : int, default=0 
        Ignore the offset first bytes by seeking forward, then 
        discarding the following bytes up until the next new line 
        character. 
 
    length : int, default=-1 
        If strictly positive, stop reading any new line of data once the 
        position in the file has reached the (offset + length) bytes threshold. 
 
    Returns 
    ------- 
    [X1, y1, ..., Xn, yn] or [X1, y1, q1, ..., Xn, yn, qn]: list of arrays 
        Each (Xi, yi) pair is the result from load_svmlight_file(files[i]). 
        If query_id is set to True, this will return instead (Xi, yi, qi) 
        triplets. 
 
    See Also 
    -------- 
    load_svmlight_file: Similar function for loading a single file in this 
        format. 
 
    Notes 
    ----- 
    When fitting a model to a matrix X_train and evaluating it against a 
    matrix X_test, it is essential that X_train and X_test have the same 
    number of features (X_train.shape[1] == X_test.shape[1]). This may not 
    be the case if you load the files individually with load_svmlight_file. 
 
    Examples 
    -------- 
    To use joblib.Memory to cache the svmlight file:: 
 
        from joblib import Memory 
        from sklearn.datasets import load_svmlight_file 
        mem = Memory(&quot;./mycache&quot;) 
 
        @mem.cache 
        def get_data(): 
            data_train, target_train, data_test, target_test = load_svmlight_files( 
                [&quot;svmlight_file_train&quot;, &quot;svmlight_file_test&quot;] 
            ) 
            return data_train, target_train, data_test, target_test 
 
        X_train, y_train, X_test, y_test = get_data() 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s4">(</span><span class="s1">offset </span><span class="s4">!= </span><span class="s6">0 </span><span class="s3">or </span><span class="s1">length </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">) </span><span class="s3">and </span><span class="s1">zero_based </span><span class="s4">== </span><span class="s5">&quot;auto&quot;</span><span class="s4">:</span>
        <span class="s2"># disable heuristic search to avoid getting inconsistent results on</span>
        <span class="s2"># different segments of the file</span>
        <span class="s1">zero_based </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s3">if </span><span class="s4">(</span><span class="s1">offset </span><span class="s4">!= </span><span class="s6">0 </span><span class="s3">or </span><span class="s1">length </span><span class="s4">&gt; </span><span class="s6">0</span><span class="s4">) </span><span class="s3">and </span><span class="s1">n_features </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;n_features is required when offset or length is specified.&quot;</span><span class="s4">)</span>

    <span class="s1">r </span><span class="s4">= [</span>
        <span class="s1">_open_and_load</span><span class="s4">(</span>
            <span class="s1">f</span><span class="s4">,</span>
            <span class="s1">dtype</span><span class="s4">,</span>
            <span class="s1">multilabel</span><span class="s4">,</span>
            <span class="s1">bool</span><span class="s4">(</span><span class="s1">zero_based</span><span class="s4">),</span>
            <span class="s1">bool</span><span class="s4">(</span><span class="s1">query_id</span><span class="s4">),</span>
            <span class="s1">offset</span><span class="s4">=</span><span class="s1">offset</span><span class="s4">,</span>
            <span class="s1">length</span><span class="s4">=</span><span class="s1">length</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">files</span>
    <span class="s4">]</span>

    <span class="s3">if </span><span class="s4">(</span>
        <span class="s1">zero_based </span><span class="s3">is False</span>
        <span class="s3">or </span><span class="s1">zero_based </span><span class="s4">== </span><span class="s5">&quot;auto&quot;</span>
        <span class="s3">and </span><span class="s1">all</span><span class="s4">(</span><span class="s1">len</span><span class="s4">(</span><span class="s1">tmp</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]) </span><span class="s3">and </span><span class="s1">np</span><span class="s4">.</span><span class="s1">min</span><span class="s4">(</span><span class="s1">tmp</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]) &gt; </span><span class="s6">0 </span><span class="s3">for </span><span class="s1">tmp </span><span class="s3">in </span><span class="s1">r</span><span class="s4">)</span>
    <span class="s4">):</span>
        <span class="s3">for </span><span class="s1">_</span><span class="s4">, </span><span class="s1">indices</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_</span><span class="s4">, </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">r</span><span class="s4">:</span>
            <span class="s1">indices </span><span class="s4">-= </span><span class="s6">1</span>

    <span class="s1">n_f </span><span class="s4">= </span><span class="s1">max</span><span class="s4">(</span><span class="s1">ind</span><span class="s4">[</span><span class="s6">1</span><span class="s4">].</span><span class="s1">max</span><span class="s4">() </span><span class="s3">if </span><span class="s1">len</span><span class="s4">(</span><span class="s1">ind</span><span class="s4">[</span><span class="s6">1</span><span class="s4">]) </span><span class="s3">else </span><span class="s6">0 </span><span class="s3">for </span><span class="s1">ind </span><span class="s3">in </span><span class="s1">r</span><span class="s4">) + </span><span class="s6">1</span>

    <span class="s3">if </span><span class="s1">n_features </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s1">n_features </span><span class="s4">= </span><span class="s1">n_f</span>
    <span class="s3">elif </span><span class="s1">n_features </span><span class="s4">&lt; </span><span class="s1">n_f</span><span class="s4">:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
            <span class="s5">&quot;n_features was set to {}, but input file contains {} features&quot;</span><span class="s4">.</span><span class="s1">format</span><span class="s4">(</span>
                <span class="s1">n_features</span><span class="s4">, </span><span class="s1">n_f</span>
            <span class="s4">)</span>
        <span class="s4">)</span>

    <span class="s1">result </span><span class="s4">= []</span>
    <span class="s3">for </span><span class="s1">data</span><span class="s4">, </span><span class="s1">indices</span><span class="s4">, </span><span class="s1">indptr</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">query_values </span><span class="s3">in </span><span class="s1">r</span><span class="s4">:</span>
        <span class="s1">shape </span><span class="s4">= (</span><span class="s1">indptr</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] - </span><span class="s6">1</span><span class="s4">, </span><span class="s1">n_features</span><span class="s4">)</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">sp</span><span class="s4">.</span><span class="s1">csr_matrix</span><span class="s4">((</span><span class="s1">data</span><span class="s4">, </span><span class="s1">indices</span><span class="s4">, </span><span class="s1">indptr</span><span class="s4">), </span><span class="s1">shape</span><span class="s4">)</span>
        <span class="s1">X</span><span class="s4">.</span><span class="s1">sort_indices</span><span class="s4">()</span>
        <span class="s1">result </span><span class="s4">+= </span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span>
        <span class="s3">if </span><span class="s1">query_id</span><span class="s4">:</span>
            <span class="s1">result</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span><span class="s1">query_values</span><span class="s4">)</span>

    <span class="s3">return </span><span class="s1">result</span>


<span class="s3">def </span><span class="s1">_dump_svmlight</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">multilabel</span><span class="s4">, </span><span class="s1">one_based</span><span class="s4">, </span><span class="s1">comment</span><span class="s4">, </span><span class="s1">query_id</span><span class="s4">):</span>
    <span class="s3">if </span><span class="s1">comment</span><span class="s4">:</span>
        <span class="s1">f</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span>
            <span class="s4">(</span>
                <span class="s5">&quot;# Generated by dump_svmlight_file from scikit-learn %s</span><span class="s3">\n</span><span class="s5">&quot; </span><span class="s4">% </span><span class="s1">__version__</span>
            <span class="s4">).</span><span class="s1">encode</span><span class="s4">()</span>
        <span class="s4">)</span>
        <span class="s1">f</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span>
            <span class="s4">(</span><span class="s5">&quot;# Column indices are %s-based</span><span class="s3">\n</span><span class="s5">&quot; </span><span class="s4">% [</span><span class="s5">&quot;zero&quot;</span><span class="s4">, </span><span class="s5">&quot;one&quot;</span><span class="s4">][</span><span class="s1">one_based</span><span class="s4">]).</span><span class="s1">encode</span><span class="s4">()</span>
        <span class="s4">)</span>

        <span class="s1">f</span><span class="s4">.</span><span class="s1">write</span><span class="s4">(</span><span class="s7">b&quot;#</span><span class="s3">\n</span><span class="s7">&quot;</span><span class="s4">)</span>
        <span class="s1">f</span><span class="s4">.</span><span class="s1">writelines</span><span class="s4">(</span><span class="s7">b&quot;# %s</span><span class="s3">\n</span><span class="s7">&quot; </span><span class="s4">% </span><span class="s1">line </span><span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">comment</span><span class="s4">.</span><span class="s1">splitlines</span><span class="s4">())</span>
    <span class="s1">X_is_sp </span><span class="s4">= </span><span class="s1">sp</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">X</span><span class="s4">)</span>
    <span class="s1">y_is_sp </span><span class="s4">= </span><span class="s1">sp</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">y</span><span class="s4">)</span>
    <span class="s3">if not </span><span class="s1">multilabel </span><span class="s3">and not </span><span class="s1">y_is_sp</span><span class="s4">:</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">y</span><span class="s4">[:, </span><span class="s1">np</span><span class="s4">.</span><span class="s1">newaxis</span><span class="s4">]</span>
    <span class="s1">_dump_svmlight_file</span><span class="s4">(</span>
        <span class="s1">X</span><span class="s4">,</span>
        <span class="s1">y</span><span class="s4">,</span>
        <span class="s1">f</span><span class="s4">,</span>
        <span class="s1">multilabel</span><span class="s4">,</span>
        <span class="s1">one_based</span><span class="s4">,</span>
        <span class="s1">query_id</span><span class="s4">,</span>
        <span class="s1">X_is_sp</span><span class="s4">,</span>
        <span class="s1">y_is_sp</span><span class="s4">,</span>
    <span class="s4">)</span>


<span class="s4">@</span><span class="s1">validate_params</span><span class="s4">(</span>
    <span class="s4">{</span>
        <span class="s5">&quot;X&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;y&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s5">&quot;sparse matrix&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;f&quot;</span><span class="s4">: [</span><span class="s1">str</span><span class="s4">, </span><span class="s1">HasMethods</span><span class="s4">([</span><span class="s5">&quot;write&quot;</span><span class="s4">])],</span>
        <span class="s5">&quot;zero_based&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
        <span class="s5">&quot;comment&quot;</span><span class="s4">: [</span><span class="s1">str</span><span class="s4">, </span><span class="s1">bytes</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;query_id&quot;</span><span class="s4">: [</span><span class="s5">&quot;array-like&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">],</span>
        <span class="s5">&quot;multilabel&quot;</span><span class="s4">: [</span><span class="s5">&quot;boolean&quot;</span><span class="s4">],</span>
    <span class="s4">},</span>
    <span class="s1">prefer_skip_nested_validation</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
<span class="s4">)</span>
<span class="s3">def </span><span class="s1">dump_svmlight_file</span><span class="s4">(</span>
    <span class="s1">X</span><span class="s4">,</span>
    <span class="s1">y</span><span class="s4">,</span>
    <span class="s1">f</span><span class="s4">,</span>
    <span class="s4">*,</span>
    <span class="s1">zero_based</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
    <span class="s1">comment</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">query_id</span><span class="s4">=</span><span class="s3">None</span><span class="s4">,</span>
    <span class="s1">multilabel</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,</span>
<span class="s4">):</span>
    <span class="s0">&quot;&quot;&quot;Dump the dataset in svmlight / libsvm file format. 
 
    This format is a text-based format, with one sample per line. It does 
    not store zero valued features hence is suitable for sparse dataset. 
 
    The first element of each line can be used to store a target variable 
    to predict. 
 
    Parameters 
    ---------- 
    X : {array-like, sparse matrix} of shape (n_samples, n_features) 
        Training vectors, where `n_samples` is the number of samples and 
        `n_features` is the number of features. 
 
    y : {array-like, sparse matrix}, shape = (n_samples,) or (n_samples, n_labels) 
        Target values. Class labels must be an 
        integer or float, or array-like objects of integer or float for 
        multilabel classifications. 
 
    f : str or file-like in binary mode 
        If string, specifies the path that will contain the data. 
        If file-like, data will be written to f. f should be opened in binary 
        mode. 
 
    zero_based : bool, default=True 
        Whether column indices should be written zero-based (True) or one-based 
        (False). 
 
    comment : str or bytes, default=None 
        Comment to insert at the top of the file. This should be either a 
        Unicode string, which will be encoded as UTF-8, or an ASCII byte 
        string. 
        If a comment is given, then it will be preceded by one that identifies 
        the file as having been dumped by scikit-learn. Note that not all 
        tools grok comments in SVMlight files. 
 
    query_id : array-like of shape (n_samples,), default=None 
        Array containing pairwise preference constraints (qid in svmlight 
        format). 
 
    multilabel : bool, default=False 
        Samples may have several labels each (see 
        https://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/multilabel.html). 
 
        .. versionadded:: 0.17 
           parameter `multilabel` to support multilabel datasets. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.datasets import dump_svmlight_file, make_classification 
    &gt;&gt;&gt; X, y = make_classification(random_state=0) 
    &gt;&gt;&gt; output_file = &quot;my_dataset.svmlight&quot; 
    &gt;&gt;&gt; dump_svmlight_file(X, y, output_file)  # doctest: +SKIP 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">comment </span><span class="s3">is not None</span><span class="s4">:</span>
        <span class="s2"># Convert comment string to list of lines in UTF-8.</span>
        <span class="s2"># If a byte string is passed, then check whether it's ASCII;</span>
        <span class="s2"># if a user wants to get fancy, they'll have to decode themselves.</span>
        <span class="s3">if </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">comment</span><span class="s4">, </span><span class="s1">bytes</span><span class="s4">):</span>
            <span class="s1">comment</span><span class="s4">.</span><span class="s1">decode</span><span class="s4">(</span><span class="s5">&quot;ascii&quot;</span><span class="s4">)  </span><span class="s2"># just for the exception</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">comment </span><span class="s4">= </span><span class="s1">comment</span><span class="s4">.</span><span class="s1">encode</span><span class="s4">(</span><span class="s5">&quot;utf-8&quot;</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s7">b&quot;</span><span class="s3">\0</span><span class="s7">&quot; </span><span class="s3">in </span><span class="s1">comment</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;comment string contains NUL byte&quot;</span><span class="s4">)</span>

    <span class="s1">yval </span><span class="s4">= </span><span class="s1">check_array</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s1">accept_sparse</span><span class="s4">=</span><span class="s5">&quot;csr&quot;</span><span class="s4">, </span><span class="s1">ensure_2d</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">sp</span><span class="s4">.</span><span class="s1">issparse</span><span class="s4">(</span><span class="s1">yval</span><span class="s4">):</span>
        <span class="s3">if </span><span class="s1">yval</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">1</span><span class="s4">] != </span><span class="s6">1 </span><span class="s3">and not </span><span class="s1">multilabel</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;expected y of shape (n_samples, 1), got %r&quot; </span><span class="s4">% (</span><span class="s1">yval</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">,)</span>
            <span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">if </span><span class="s1">yval</span><span class="s4">.</span><span class="s1">ndim </span><span class="s4">!= </span><span class="s6">1 </span><span class="s3">and not </span><span class="s1">multilabel</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span><span class="s5">&quot;expected y of shape (n_samples,), got %r&quot; </span><span class="s4">% (</span><span class="s1">yval</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">,))</span>

    <span class="s1">Xval </span><span class="s4">= </span><span class="s1">check_array</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">accept_sparse</span><span class="s4">=</span><span class="s5">&quot;csr&quot;</span><span class="s4">)</span>
    <span class="s3">if </span><span class="s1">Xval</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] != </span><span class="s1">yval</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
        <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
            <span class="s5">&quot;X.shape[0] and y.shape[0] should be the same, got %r and %r instead.&quot;</span>
            <span class="s4">% (</span><span class="s1">Xval</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">], </span><span class="s1">yval</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">])</span>
        <span class="s4">)</span>

    <span class="s2"># We had some issues with CSR matrices with unsorted indices (e.g. #1501),</span>
    <span class="s2"># so sort them here, but first make sure we don't modify the user's X.</span>
    <span class="s2"># TODO We can do this cheaper; sorted_indices copies the whole matrix.</span>
    <span class="s3">if </span><span class="s1">yval </span><span class="s3">is </span><span class="s1">y </span><span class="s3">and </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">yval</span><span class="s4">, </span><span class="s5">&quot;sorted_indices&quot;</span><span class="s4">):</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">yval</span><span class="s4">.</span><span class="s1">sorted_indices</span><span class="s4">()</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">y </span><span class="s4">= </span><span class="s1">yval</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">y</span><span class="s4">, </span><span class="s5">&quot;sort_indices&quot;</span><span class="s4">):</span>
            <span class="s1">y</span><span class="s4">.</span><span class="s1">sort_indices</span><span class="s4">()</span>

    <span class="s3">if </span><span class="s1">Xval </span><span class="s3">is </span><span class="s1">X </span><span class="s3">and </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">Xval</span><span class="s4">, </span><span class="s5">&quot;sorted_indices&quot;</span><span class="s4">):</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">Xval</span><span class="s4">.</span><span class="s1">sorted_indices</span><span class="s4">()</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">X </span><span class="s4">= </span><span class="s1">Xval</span>
        <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s5">&quot;sort_indices&quot;</span><span class="s4">):</span>
            <span class="s1">X</span><span class="s4">.</span><span class="s1">sort_indices</span><span class="s4">()</span>

    <span class="s3">if </span><span class="s1">query_id </span><span class="s3">is None</span><span class="s4">:</span>
        <span class="s2"># NOTE: query_id is passed to Cython functions using a fused type on query_id.</span>
        <span class="s2"># Yet as of Cython&gt;=3.0, memory views can't be None otherwise the runtime</span>
        <span class="s2"># would not known which concrete implementation to dispatch the Python call to.</span>
        <span class="s2"># TODO: simplify interfaces and implementations in _svmlight_format_fast.pyx.</span>
        <span class="s1">query_id </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">array</span><span class="s4">([], </span><span class="s1">dtype</span><span class="s4">=</span><span class="s1">np</span><span class="s4">.</span><span class="s1">int32</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s1">query_id </span><span class="s4">= </span><span class="s1">np</span><span class="s4">.</span><span class="s1">asarray</span><span class="s4">(</span><span class="s1">query_id</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">query_id</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] != </span><span class="s1">y</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError</span><span class="s4">(</span>
                <span class="s5">&quot;expected query_id of shape (n_samples,), got %r&quot; </span><span class="s4">% (</span><span class="s1">query_id</span><span class="s4">.</span><span class="s1">shape</span><span class="s4">,)</span>
            <span class="s4">)</span>

    <span class="s1">one_based </span><span class="s4">= </span><span class="s3">not </span><span class="s1">zero_based</span>

    <span class="s3">if </span><span class="s1">hasattr</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s5">&quot;write&quot;</span><span class="s4">):</span>
        <span class="s1">_dump_svmlight</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">multilabel</span><span class="s4">, </span><span class="s1">one_based</span><span class="s4">, </span><span class="s1">comment</span><span class="s4">, </span><span class="s1">query_id</span><span class="s4">)</span>
    <span class="s3">else</span><span class="s4">:</span>
        <span class="s3">with </span><span class="s1">open</span><span class="s4">(</span><span class="s1">f</span><span class="s4">, </span><span class="s5">&quot;wb&quot;</span><span class="s4">) </span><span class="s3">as </span><span class="s1">f</span><span class="s4">:</span>
            <span class="s1">_dump_svmlight</span><span class="s4">(</span><span class="s1">X</span><span class="s4">, </span><span class="s1">y</span><span class="s4">, </span><span class="s1">f</span><span class="s4">, </span><span class="s1">multilabel</span><span class="s4">, </span><span class="s1">one_based</span><span class="s4">, </span><span class="s1">comment</span><span class="s4">, </span><span class="s1">query_id</span><span class="s4">)</span>
</pre>
</body>
</html>