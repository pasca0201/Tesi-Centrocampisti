<html>
<head>
<title>test_zeros.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cf8e6d;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #7a7e85;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.s6 { color: #5f826b; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_zeros.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">lru_cache</span>

<span class="s0">from </span><span class="s1">numpy</span><span class="s2">.</span><span class="s1">testing </span><span class="s0">import </span><span class="s2">(</span><span class="s1">assert_warns</span><span class="s2">, </span><span class="s1">assert_</span><span class="s2">,</span>
                           <span class="s1">assert_allclose</span><span class="s2">,</span>
                           <span class="s1">assert_equal</span><span class="s2">,</span>
                           <span class="s1">assert_array_equal</span><span class="s2">,</span>
                           <span class="s1">suppress_warnings</span><span class="s2">)</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy </span><span class="s0">import </span><span class="s1">finfo</span><span class="s2">, </span><span class="s1">power</span><span class="s2">, </span><span class="s1">nan</span><span class="s2">, </span><span class="s1">isclose</span><span class="s2">, </span><span class="s1">sqrt</span><span class="s2">, </span><span class="s1">exp</span><span class="s2">, </span><span class="s1">sin</span><span class="s2">, </span><span class="s1">cos</span>

<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">optimize</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">optimize </span><span class="s0">import </span><span class="s2">(</span><span class="s1">_zeros_py </span><span class="s0">as </span><span class="s1">zeros</span><span class="s2">, </span><span class="s1">newton</span><span class="s2">, </span><span class="s1">root_scalar</span><span class="s2">,</span>
                            <span class="s1">OptimizeResult</span><span class="s2">)</span>

<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">_lib</span><span class="s2">.</span><span class="s1">_util </span><span class="s0">import </span><span class="s1">getfullargspec_no_self </span><span class="s0">as </span><span class="s1">_getfullargspec</span>

<span class="s3"># Import testing parameters</span>
<span class="s0">from </span><span class="s1">scipy</span><span class="s2">.</span><span class="s1">optimize</span><span class="s2">.</span><span class="s1">_tstutils </span><span class="s0">import </span><span class="s1">get_tests</span><span class="s2">, </span><span class="s1">functions </span><span class="s0">as </span><span class="s1">tstutils_functions</span>

<span class="s1">TOL </span><span class="s2">= </span><span class="s4">4</span><span class="s2">*</span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">float</span><span class="s2">).</span><span class="s1">eps  </span><span class="s3"># tolerance</span>

<span class="s1">_FLOAT_EPS </span><span class="s2">= </span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">float</span><span class="s2">).</span><span class="s1">eps</span>

<span class="s1">bracket_methods </span><span class="s2">= [</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">bisect</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">ridder</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">brentq</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">brenth</span><span class="s2">,</span>
                   <span class="s1">zeros</span><span class="s2">.</span><span class="s1">toms748</span><span class="s2">]</span>
<span class="s1">gradient_methods </span><span class="s2">= [</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">]</span>
<span class="s1">all_methods </span><span class="s2">= </span><span class="s1">bracket_methods </span><span class="s2">+ </span><span class="s1">gradient_methods</span>

<span class="s3"># A few test functions used frequently:</span>
<span class="s3"># # A simple quadratic, (x-1)^2 - 1</span>
<span class="s0">def </span><span class="s1">f1</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">x </span><span class="s2">** </span><span class="s4">2 </span><span class="s2">- </span><span class="s4">2 </span><span class="s2">* </span><span class="s1">x </span><span class="s2">- </span><span class="s4">1</span>


<span class="s0">def </span><span class="s1">f1_1</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s4">2 </span><span class="s2">* </span><span class="s1">x </span><span class="s2">- </span><span class="s4">2</span>


<span class="s0">def </span><span class="s1">f1_2</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s4">2.0 </span><span class="s2">+ </span><span class="s4">0 </span><span class="s2">* </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">f1_and_p_and_pp</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">f1</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s1">f1_1</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s1">f1_2</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>


<span class="s3"># Simple transcendental function</span>
<span class="s0">def </span><span class="s1">f2</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">exp</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) - </span><span class="s1">cos</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">f2_1</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">exp</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) + </span><span class="s1">sin</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">f2_2</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">exp</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) + </span><span class="s1">cos</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>


<span class="s3"># lru cached function</span>
<span class="s2">@</span><span class="s1">lru_cache</span>
<span class="s0">def </span><span class="s1">f_lrucached</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
    <span class="s0">return </span><span class="s1">x</span>


<span class="s0">class </span><span class="s1">TestScalarRootFinders</span><span class="s2">:</span>
    <span class="s3"># Basic tests for all scalar root finders</span>

    <span class="s1">xtol </span><span class="s2">= </span><span class="s4">4 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">float</span><span class="s2">).</span><span class="s1">eps</span>
    <span class="s1">rtol </span><span class="s2">= </span><span class="s4">4 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">float</span><span class="s2">).</span><span class="s1">eps</span>

    <span class="s0">def </span><span class="s1">_run_one_test</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">tc</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">sig_args_keys</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                      <span class="s1">sig_kwargs_keys</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s1">method_args </span><span class="s2">= []</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">sig_args_keys </span><span class="s0">or </span><span class="s2">[]:</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">tc</span><span class="s2">:</span>
                <span class="s3"># If a,b not present use x0, x1. Similarly for f and func</span>
                <span class="s1">k </span><span class="s2">= {</span><span class="s5">'a'</span><span class="s2">: </span><span class="s5">'x0'</span><span class="s2">, </span><span class="s5">'b'</span><span class="s2">: </span><span class="s5">'x1'</span><span class="s2">, </span><span class="s5">'func'</span><span class="s2">: </span><span class="s5">'f'</span><span class="s2">}.</span><span class="s1">get</span><span class="s2">(</span><span class="s1">k</span><span class="s2">, </span><span class="s1">k</span><span class="s2">)</span>
            <span class="s1">method_args</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s1">tc</span><span class="s2">[</span><span class="s1">k</span><span class="s2">])</span>

        <span class="s1">method_kwargs </span><span class="s2">= </span><span class="s1">dict</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">method_kwargs</span><span class="s2">.</span><span class="s1">update</span><span class="s2">({</span><span class="s5">'full_output'</span><span class="s2">: </span><span class="s0">True</span><span class="s2">, </span><span class="s5">'disp'</span><span class="s2">: </span><span class="s0">False</span><span class="s2">})</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">sig_kwargs_keys </span><span class="s0">or </span><span class="s2">[]:</span>
            <span class="s1">method_kwargs</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">tc</span><span class="s2">[</span><span class="s1">k</span><span class="s2">]</span>

        <span class="s1">root </span><span class="s2">= </span><span class="s1">tc</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s5">'root'</span><span class="s2">)</span>
        <span class="s1">func_args </span><span class="s2">= </span><span class="s1">tc</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s5">'args'</span><span class="s2">, ())</span>

        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">r</span><span class="s2">, </span><span class="s1">rr </span><span class="s2">= </span><span class="s1">method</span><span class="s2">(*</span><span class="s1">method_args</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">func_args</span><span class="s2">, **</span><span class="s1">method_kwargs</span><span class="s2">)</span>
            <span class="s0">return </span><span class="s1">root</span><span class="s2">, </span><span class="s1">rr</span><span class="s2">, </span><span class="s1">tc</span>
        <span class="s0">except </span><span class="s1">Exception</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">root</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">RootResults</span><span class="s2">(</span><span class="s1">nan</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">_EVALUEERR</span><span class="s2">, </span><span class="s1">method</span><span class="s2">), </span><span class="s1">tc</span>

    <span class="s0">def </span><span class="s1">run_tests</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">tests</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">known_fail</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s6">r&quot;&quot;&quot;Run test-cases using the specified method and the supplied signature. 
 
        Extract the arguments for the method call from the test case 
        dictionary using the supplied keys for the method's signature.&quot;&quot;&quot;</span>
        <span class="s3"># The methods have one of two base signatures:</span>
        <span class="s3"># (f, a, b, **kwargs)  # newton</span>
        <span class="s3"># (func, x0, **kwargs)  # bisect/brentq/...</span>

        <span class="s3"># FullArgSpec with args, varargs, varkw, defaults, ...</span>
        <span class="s1">sig </span><span class="s2">= </span><span class="s1">_getfullargspec</span><span class="s2">(</span><span class="s1">method</span><span class="s2">)</span>
        <span class="s1">assert_</span><span class="s2">(</span><span class="s0">not </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">kwonlyargs</span><span class="s2">)</span>
        <span class="s1">nDefaults </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">defaults</span><span class="s2">)</span>
        <span class="s1">nRequired </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">) - </span><span class="s1">nDefaults</span>
        <span class="s1">sig_args_keys </span><span class="s2">= </span><span class="s1">sig</span><span class="s2">.</span><span class="s1">args</span><span class="s2">[:</span><span class="s1">nRequired</span><span class="s2">]</span>
        <span class="s1">sig_kwargs_keys </span><span class="s2">= []</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s2">[</span><span class="s5">'secant'</span><span class="s2">, </span><span class="s5">'newton'</span><span class="s2">, </span><span class="s5">'halley'</span><span class="s2">]:</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s2">[</span><span class="s5">'newton'</span><span class="s2">, </span><span class="s5">'halley'</span><span class="s2">]:</span>
                <span class="s1">sig_kwargs_keys</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">'fprime'</span><span class="s2">)</span>
                <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s2">[</span><span class="s5">'halley'</span><span class="s2">]:</span>
                    <span class="s1">sig_kwargs_keys</span><span class="s2">.</span><span class="s1">append</span><span class="s2">(</span><span class="s5">'fprime2'</span><span class="s2">)</span>
            <span class="s1">kwargs</span><span class="s2">[</span><span class="s5">'tol'</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">xtol</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s1">kwargs</span><span class="s2">[</span><span class="s5">'xtol'</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">xtol</span>
            <span class="s1">kwargs</span><span class="s2">[</span><span class="s5">'rtol'</span><span class="s2">] = </span><span class="s1">self</span><span class="s2">.</span><span class="s1">rtol</span>

        <span class="s1">results </span><span class="s2">= [</span><span class="s1">list</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">_run_one_test</span><span class="s2">(</span>
            <span class="s1">tc</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">sig_args_keys</span><span class="s2">=</span><span class="s1">sig_args_keys</span><span class="s2">,</span>
            <span class="s1">sig_kwargs_keys</span><span class="s2">=</span><span class="s1">sig_kwargs_keys</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)) </span><span class="s0">for </span><span class="s1">tc </span><span class="s0">in </span><span class="s1">tests</span><span class="s2">]</span>
        <span class="s3"># results= [[true root, full output, tc], ...]</span>

        <span class="s1">known_fail </span><span class="s2">= </span><span class="s1">known_fail </span><span class="s0">or </span><span class="s2">[]</span>
        <span class="s1">notcvgd </span><span class="s2">= [</span><span class="s1">elt </span><span class="s0">for </span><span class="s1">elt </span><span class="s0">in </span><span class="s1">results </span><span class="s0">if not </span><span class="s1">elt</span><span class="s2">[</span><span class="s4">1</span><span class="s2">].</span><span class="s1">converged</span><span class="s2">]</span>
        <span class="s1">notcvgd </span><span class="s2">= [</span><span class="s1">elt </span><span class="s0">for </span><span class="s1">elt </span><span class="s0">in </span><span class="s1">notcvgd </span><span class="s0">if </span><span class="s1">elt</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">][</span><span class="s5">'ID'</span><span class="s2">] </span><span class="s0">not in </span><span class="s1">known_fail</span><span class="s2">]</span>
        <span class="s1">notcvged_IDS </span><span class="s2">= [</span><span class="s1">elt</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">][</span><span class="s5">'ID'</span><span class="s2">] </span><span class="s0">for </span><span class="s1">elt </span><span class="s0">in </span><span class="s1">notcvgd</span><span class="s2">]</span>
        <span class="s1">assert_equal</span><span class="s2">([</span><span class="s1">len</span><span class="s2">(</span><span class="s1">notcvged_IDS</span><span class="s2">), </span><span class="s1">notcvged_IDS</span><span class="s2">], [</span><span class="s4">0</span><span class="s2">, []])</span>

        <span class="s3"># The usable xtol and rtol depend on the test</span>
        <span class="s1">tols </span><span class="s2">= {</span><span class="s5">'xtol'</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">xtol</span><span class="s2">, </span><span class="s5">'rtol'</span><span class="s2">: </span><span class="s1">self</span><span class="s2">.</span><span class="s1">rtol</span><span class="s2">}</span>
        <span class="s1">tols</span><span class="s2">.</span><span class="s1">update</span><span class="s2">(**</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s1">rtol </span><span class="s2">= </span><span class="s1">tols</span><span class="s2">[</span><span class="s5">'rtol'</span><span class="s2">]</span>
        <span class="s1">atol </span><span class="s2">= </span><span class="s1">tols</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s5">'tol'</span><span class="s2">, </span><span class="s1">tols</span><span class="s2">[</span><span class="s5">'xtol'</span><span class="s2">])</span>

        <span class="s1">cvgd </span><span class="s2">= [</span><span class="s1">elt </span><span class="s0">for </span><span class="s1">elt </span><span class="s0">in </span><span class="s1">results </span><span class="s0">if </span><span class="s1">elt</span><span class="s2">[</span><span class="s4">1</span><span class="s2">].</span><span class="s1">converged</span><span class="s2">]</span>
        <span class="s1">approx </span><span class="s2">= [</span><span class="s1">elt</span><span class="s2">[</span><span class="s4">1</span><span class="s2">].</span><span class="s1">root </span><span class="s0">for </span><span class="s1">elt </span><span class="s0">in </span><span class="s1">cvgd</span><span class="s2">]</span>
        <span class="s1">correct </span><span class="s2">= [</span><span class="s1">elt</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] </span><span class="s0">for </span><span class="s1">elt </span><span class="s0">in </span><span class="s1">cvgd</span><span class="s2">]</span>
        <span class="s3"># See if the root matches the reference value</span>
        <span class="s1">notclose </span><span class="s2">= [[</span><span class="s1">a</span><span class="s2">] + </span><span class="s1">elt </span><span class="s0">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">elt </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">approx</span><span class="s2">, </span><span class="s1">correct</span><span class="s2">, </span><span class="s1">cvgd</span><span class="s2">) </span><span class="s0">if</span>
                    <span class="s0">not </span><span class="s1">isclose</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">rtol</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">atol</span><span class="s2">)</span>
                    <span class="s0">and </span><span class="s1">elt</span><span class="s2">[-</span><span class="s4">1</span><span class="s2">][</span><span class="s5">'ID'</span><span class="s2">] </span><span class="s0">not in </span><span class="s1">known_fail</span><span class="s2">]</span>
        <span class="s3"># If not, evaluate the function and see if is 0 at the purported root</span>
        <span class="s1">fvs </span><span class="s2">= [</span><span class="s1">tc</span><span class="s2">[</span><span class="s5">'f'</span><span class="s2">](</span><span class="s1">aroot</span><span class="s2">, *</span><span class="s1">tc</span><span class="s2">.</span><span class="s1">get</span><span class="s2">(</span><span class="s5">'args'</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">()))</span>
               <span class="s0">for </span><span class="s1">aroot</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">fullout</span><span class="s2">, </span><span class="s1">tc </span><span class="s0">in </span><span class="s1">notclose</span><span class="s2">]</span>
        <span class="s1">notclose </span><span class="s2">= [[</span><span class="s1">fv</span><span class="s2">] + </span><span class="s1">elt </span><span class="s0">for </span><span class="s1">fv</span><span class="s2">, </span><span class="s1">elt </span><span class="s0">in </span><span class="s1">zip</span><span class="s2">(</span><span class="s1">fvs</span><span class="s2">, </span><span class="s1">notclose</span><span class="s2">) </span><span class="s0">if </span><span class="s1">fv </span><span class="s2">!= </span><span class="s4">0</span><span class="s2">]</span>
        <span class="s1">assert_equal</span><span class="s2">([</span><span class="s1">notclose</span><span class="s2">, </span><span class="s1">len</span><span class="s2">(</span><span class="s1">notclose</span><span class="s2">)], [[], </span><span class="s4">0</span><span class="s2">])</span>
        <span class="s1">method_from_result </span><span class="s2">= [</span><span class="s1">result</span><span class="s2">[</span><span class="s4">1</span><span class="s2">].</span><span class="s1">method </span><span class="s0">for </span><span class="s1">result </span><span class="s0">in </span><span class="s1">results</span><span class="s2">]</span>
        <span class="s1">expected_method </span><span class="s2">= [</span><span class="s1">name </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">results</span><span class="s2">]</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">method_from_result</span><span class="s2">, </span><span class="s1">expected_method</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">run_collection</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">collection</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">smoothness</span><span class="s2">=</span><span class="s0">None</span><span class="s2">,</span>
                       <span class="s1">known_fail</span><span class="s2">=</span><span class="s0">None</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s6">r&quot;&quot;&quot;Run a collection of tests using the specified method. 
 
        The name is used to determine some optional arguments.&quot;&quot;&quot;</span>
        <span class="s1">tests </span><span class="s2">= </span><span class="s1">get_tests</span><span class="s2">(</span><span class="s1">collection</span><span class="s2">, </span><span class="s1">smoothness</span><span class="s2">=</span><span class="s1">smoothness</span><span class="s2">)</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">run_tests</span><span class="s2">(</span><span class="s1">tests</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">known_fail</span><span class="s2">=</span><span class="s1">known_fail</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestBracketMethods</span><span class="s2">(</span><span class="s1">TestScalarRootFinders</span><span class="s2">):</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'method'</span><span class="s2">, </span><span class="s1">bracket_methods</span><span class="s2">)</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'function'</span><span class="s2">, </span><span class="s1">tstutils_functions</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_basic_root_scalar</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">function</span><span class="s2">):</span>
        <span class="s3"># Tests bracketing root finders called via `root_scalar` on a small</span>
        <span class="s3"># set of simple problems, each of which has a root at `x=1`. Checks for</span>
        <span class="s3"># converged status and that the root was found.</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">= </span><span class="s4">.5</span><span class="s2">, </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s4">3</span><span class="s2">)</span>

        <span class="s1">r </span><span class="s2">= </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">function</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s1">method</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, </span><span class="s1">bracket</span><span class="s2">=[</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">], </span><span class="s1">x0</span><span class="s2">=</span><span class="s1">a</span><span class="s2">,</span>
                        <span class="s1">xtol</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">rtol</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">r</span><span class="s2">.</span><span class="s1">converged</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">root</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">rtol</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">r</span><span class="s2">.</span><span class="s1">method </span><span class="s2">== </span><span class="s1">method</span><span class="s2">.</span><span class="s1">__name__</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'method'</span><span class="s2">, </span><span class="s1">bracket_methods</span><span class="s2">)</span>
    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'function'</span><span class="s2">, </span><span class="s1">tstutils_functions</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_basic_individual</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">function</span><span class="s2">):</span>
        <span class="s3"># Tests individual bracketing root finders on a small set of simple</span>
        <span class="s3"># problems, each of which has a root at `x=1`. Checks for converged</span>
        <span class="s3"># status and that the root was found.</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">= </span><span class="s4">.5</span><span class="s2">, </span><span class="s1">sqrt</span><span class="s2">(</span><span class="s4">3</span><span class="s2">)</span>
        <span class="s1">root</span><span class="s2">, </span><span class="s1">r </span><span class="s2">= </span><span class="s1">method</span><span class="s2">(</span><span class="s1">function</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">rtol</span><span class="s2">,</span>
                         <span class="s1">full_output</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

        <span class="s0">assert </span><span class="s1">r</span><span class="s2">.</span><span class="s1">converged</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">root</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">self</span><span class="s2">.</span><span class="s1">rtol</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'method'</span><span class="s2">, </span><span class="s1">bracket_methods</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_aps_collection</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">method</span><span class="s2">):</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">run_collection</span><span class="s2">(</span><span class="s5">'aps'</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">method</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">, </span><span class="s1">smoothness</span><span class="s2">=</span><span class="s4">1</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'method'</span><span class="s2">, [</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">bisect</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">ridder</span><span class="s2">,</span>
                                        <span class="s1">zeros</span><span class="s2">.</span><span class="s1">toms748</span><span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_chandrupatla_collection</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">method</span><span class="s2">):</span>
        <span class="s1">known_fail </span><span class="s2">= {</span><span class="s5">'fun7.4'</span><span class="s2">} </span><span class="s0">if </span><span class="s1">method </span><span class="s2">== </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">ridder </span><span class="s0">else </span><span class="s2">{}</span>
        <span class="s1">self</span><span class="s2">.</span><span class="s1">run_collection</span><span class="s2">(</span><span class="s5">'chandrupatla'</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">method</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">,</span>
                            <span class="s1">known_fail</span><span class="s2">=</span><span class="s1">known_fail</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'method'</span><span class="s2">, </span><span class="s1">bracket_methods</span><span class="s2">)</span>
    <span class="s0">def </span><span class="s1">test_lru_cached_individual</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">method</span><span class="s2">):</span>
        <span class="s3"># check that https://github.com/scipy/scipy/issues/10846 is fixed</span>
        <span class="s3"># (`root_scalar` failed when passed a function that was `@lru_cache`d)</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b </span><span class="s2">= -</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">root</span><span class="s2">, </span><span class="s1">r </span><span class="s2">= </span><span class="s1">method</span><span class="s2">(</span><span class="s1">f_lrucached</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">r</span><span class="s2">.</span><span class="s1">converged</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">root</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestNewton</span><span class="s2">(</span><span class="s1">TestScalarRootFinders</span><span class="s2">):</span>
    <span class="s0">def </span><span class="s1">test_newton_collections</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">known_fail </span><span class="s2">= [</span><span class="s5">'aps.13.00'</span><span class="s2">]</span>
        <span class="s1">known_fail </span><span class="s2">+= [</span><span class="s5">'aps.12.05'</span><span class="s2">, </span><span class="s5">'aps.12.17'</span><span class="s2">]  </span><span class="s3"># fails under Windows Py27</span>
        <span class="s0">for </span><span class="s1">collection </span><span class="s0">in </span><span class="s2">[</span><span class="s5">'aps'</span><span class="s2">, </span><span class="s5">'complex'</span><span class="s2">]:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">run_collection</span><span class="s2">(</span><span class="s1">collection</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">, </span><span class="s5">'newton'</span><span class="s2">,</span>
                                <span class="s1">smoothness</span><span class="s2">=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">known_fail</span><span class="s2">=</span><span class="s1">known_fail</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_halley_collections</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">known_fail </span><span class="s2">= [</span><span class="s5">'aps.12.06'</span><span class="s2">, </span><span class="s5">'aps.12.07'</span><span class="s2">, </span><span class="s5">'aps.12.08'</span><span class="s2">, </span><span class="s5">'aps.12.09'</span><span class="s2">,</span>
                      <span class="s5">'aps.12.10'</span><span class="s2">, </span><span class="s5">'aps.12.11'</span><span class="s2">, </span><span class="s5">'aps.12.12'</span><span class="s2">, </span><span class="s5">'aps.12.13'</span><span class="s2">,</span>
                      <span class="s5">'aps.12.14'</span><span class="s2">, </span><span class="s5">'aps.12.15'</span><span class="s2">, </span><span class="s5">'aps.12.16'</span><span class="s2">, </span><span class="s5">'aps.12.17'</span><span class="s2">,</span>
                      <span class="s5">'aps.12.18'</span><span class="s2">, </span><span class="s5">'aps.13.00'</span><span class="s2">]</span>
        <span class="s0">for </span><span class="s1">collection </span><span class="s0">in </span><span class="s2">[</span><span class="s5">'aps'</span><span class="s2">, </span><span class="s5">'complex'</span><span class="s2">]:</span>
            <span class="s1">self</span><span class="s2">.</span><span class="s1">run_collection</span><span class="s2">(</span><span class="s1">collection</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">, </span><span class="s5">'halley'</span><span class="s2">,</span>
                                <span class="s1">smoothness</span><span class="s2">=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">known_fail</span><span class="s2">=</span><span class="s1">known_fail</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_newton</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">for </span><span class="s1">f</span><span class="s2">, </span><span class="s1">f_1</span><span class="s2">, </span><span class="s1">f_2 </span><span class="s0">in </span><span class="s2">[(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">f1_1</span><span class="s2">, </span><span class="s1">f1_2</span><span class="s2">), (</span><span class="s1">f2</span><span class="s2">, </span><span class="s1">f2_1</span><span class="s2">, </span><span class="s1">f2_2</span><span class="s2">)]:</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)  </span><span class="s3"># secant, x0 and x1</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">f_1</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)   </span><span class="s3"># newton</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
            <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">f_1</span><span class="s2">, </span><span class="s1">fprime2</span><span class="s2">=</span><span class="s1">f_2</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)  </span><span class="s3"># halley</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_newton_by_name</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">r&quot;&quot;&quot;Invoke newton through root_scalar()&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">f</span><span class="s2">, </span><span class="s1">f_1</span><span class="s2">, </span><span class="s1">f_2 </span><span class="s0">in </span><span class="s2">[(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">f1_1</span><span class="s2">, </span><span class="s1">f1_2</span><span class="s2">), (</span><span class="s1">f2</span><span class="s2">, </span><span class="s1">f2_1</span><span class="s2">, </span><span class="s1">f2_2</span><span class="s2">)]:</span>
            <span class="s1">r </span><span class="s2">= </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s5">'newton'</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">f_1</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">root</span><span class="s2">), </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">f</span><span class="s2">, </span><span class="s1">f_1</span><span class="s2">, </span><span class="s1">f_2 </span><span class="s0">in </span><span class="s2">[(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">f1_1</span><span class="s2">, </span><span class="s1">f1_2</span><span class="s2">), (</span><span class="s1">f2</span><span class="s2">, </span><span class="s1">f2_1</span><span class="s2">, </span><span class="s1">f2_2</span><span class="s2">)]:</span>
            <span class="s1">r </span><span class="s2">= </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s5">'newton'</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)  </span><span class="s3"># without f'</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">root</span><span class="s2">), </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_secant_by_name</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">r&quot;&quot;&quot;Invoke secant through root_scalar()&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">f</span><span class="s2">, </span><span class="s1">f_1</span><span class="s2">, </span><span class="s1">f_2 </span><span class="s0">in </span><span class="s2">[(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">f1_1</span><span class="s2">, </span><span class="s1">f1_2</span><span class="s2">), (</span><span class="s1">f2</span><span class="s2">, </span><span class="s1">f2_1</span><span class="s2">, </span><span class="s1">f2_2</span><span class="s2">)]:</span>
            <span class="s1">r </span><span class="s2">= </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s5">'secant'</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">root</span><span class="s2">), </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
            <span class="s1">r </span><span class="s2">= </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s5">'secant'</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">root</span><span class="s2">), </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">f</span><span class="s2">, </span><span class="s1">f_1</span><span class="s2">, </span><span class="s1">f_2 </span><span class="s0">in </span><span class="s2">[(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">f1_1</span><span class="s2">, </span><span class="s1">f1_2</span><span class="s2">), (</span><span class="s1">f2</span><span class="s2">, </span><span class="s1">f2_1</span><span class="s2">, </span><span class="s1">f2_2</span><span class="s2">)]:</span>
            <span class="s1">r </span><span class="s2">= </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s5">'secant'</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)  </span><span class="s3"># without x1</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">root</span><span class="s2">), </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_halley_by_name</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">r&quot;&quot;&quot;Invoke halley through root_scalar()&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">f</span><span class="s2">, </span><span class="s1">f_1</span><span class="s2">, </span><span class="s1">f_2 </span><span class="s0">in </span><span class="s2">[(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">f1_1</span><span class="s2">, </span><span class="s1">f1_2</span><span class="s2">), (</span><span class="s1">f2</span><span class="s2">, </span><span class="s1">f2_1</span><span class="s2">, </span><span class="s1">f2_2</span><span class="s2">)]:</span>
            <span class="s1">r </span><span class="s2">= </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s5">'halley'</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">3</span><span class="s2">,</span>
                            <span class="s1">fprime</span><span class="s2">=</span><span class="s1">f_1</span><span class="s2">, </span><span class="s1">fprime2</span><span class="s2">=</span><span class="s1">f_2</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">root</span><span class="s2">), </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_root_scalar_fail</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">message </span><span class="s2">= </span><span class="s5">'fprime2 must be specified for halley'</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s1">message</span><span class="s2">):</span>
            <span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s5">'halley'</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">f1_1</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)  </span><span class="s3"># no fprime2</span>
        <span class="s1">message </span><span class="s2">= </span><span class="s5">'fprime must be specified for halley'</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s1">message</span><span class="s2">):</span>
            <span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s5">'halley'</span><span class="s2">, </span><span class="s1">fprime2</span><span class="s2">=</span><span class="s1">f1_2</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)  </span><span class="s3"># no fprime</span>

    <span class="s0">def </span><span class="s1">test_array_newton</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;test newton with array&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">f1</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">a</span><span class="s2">):</span>
            <span class="s1">b </span><span class="s2">= </span><span class="s1">a</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] + </span><span class="s1">x </span><span class="s2">* </span><span class="s1">a</span><span class="s2">[</span><span class="s4">3</span><span class="s2">]</span>
            <span class="s0">return </span><span class="s1">a</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] - </span><span class="s1">a</span><span class="s2">[</span><span class="s4">2</span><span class="s2">] * (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">exp</span><span class="s2">(</span><span class="s1">b </span><span class="s2">/ </span><span class="s1">a</span><span class="s2">[</span><span class="s4">5</span><span class="s2">]) - </span><span class="s4">1.0</span><span class="s2">) - </span><span class="s1">b </span><span class="s2">/ </span><span class="s1">a</span><span class="s2">[</span><span class="s4">4</span><span class="s2">] - </span><span class="s1">x</span>

        <span class="s0">def </span><span class="s1">f1_1</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">a</span><span class="s2">):</span>
            <span class="s1">b </span><span class="s2">= </span><span class="s1">a</span><span class="s2">[</span><span class="s4">3</span><span class="s2">] / </span><span class="s1">a</span><span class="s2">[</span><span class="s4">5</span><span class="s2">]</span>
            <span class="s0">return </span><span class="s2">-</span><span class="s1">a</span><span class="s2">[</span><span class="s4">2</span><span class="s2">] * </span><span class="s1">np</span><span class="s2">.</span><span class="s1">exp</span><span class="s2">(</span><span class="s1">a</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] / </span><span class="s1">a</span><span class="s2">[</span><span class="s4">5</span><span class="s2">] + </span><span class="s1">x </span><span class="s2">* </span><span class="s1">b</span><span class="s2">) * </span><span class="s1">b </span><span class="s2">- </span><span class="s1">a</span><span class="s2">[</span><span class="s4">3</span><span class="s2">] / </span><span class="s1">a</span><span class="s2">[</span><span class="s4">4</span><span class="s2">] - </span><span class="s4">1</span>

        <span class="s0">def </span><span class="s1">f1_2</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">a</span><span class="s2">):</span>
            <span class="s1">b </span><span class="s2">= </span><span class="s1">a</span><span class="s2">[</span><span class="s4">3</span><span class="s2">] / </span><span class="s1">a</span><span class="s2">[</span><span class="s4">5</span><span class="s2">]</span>
            <span class="s0">return </span><span class="s2">-</span><span class="s1">a</span><span class="s2">[</span><span class="s4">2</span><span class="s2">] * </span><span class="s1">np</span><span class="s2">.</span><span class="s1">exp</span><span class="s2">(</span><span class="s1">a</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] / </span><span class="s1">a</span><span class="s2">[</span><span class="s4">5</span><span class="s2">] + </span><span class="s1">x </span><span class="s2">* </span><span class="s1">b</span><span class="s2">) * </span><span class="s1">b</span><span class="s2">**</span><span class="s4">2</span>

        <span class="s1">a0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span>
            <span class="s4">5.32725221</span><span class="s2">, </span><span class="s4">5.48673747</span><span class="s2">, </span><span class="s4">5.49539973</span><span class="s2">,</span>
            <span class="s4">5.36387202</span><span class="s2">, </span><span class="s4">4.80237316</span><span class="s2">, </span><span class="s4">1.43764452</span><span class="s2">,</span>
            <span class="s4">5.23063958</span><span class="s2">, </span><span class="s4">5.46094772</span><span class="s2">, </span><span class="s4">5.50512718</span><span class="s2">,</span>
            <span class="s4">5.42046290</span>
        <span class="s2">])</span>
        <span class="s1">a1 </span><span class="s2">= (</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">(</span><span class="s1">range</span><span class="s2">(</span><span class="s4">10</span><span class="s2">)) + </span><span class="s4">1.0</span><span class="s2">) * </span><span class="s4">7.0</span>
        <span class="s1">args </span><span class="s2">= (</span><span class="s1">a0</span><span class="s2">, </span><span class="s1">a1</span><span class="s2">, </span><span class="s4">1e-09</span><span class="s2">, </span><span class="s4">0.004</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.27456</span><span class="s2">)</span>
        <span class="s1">x0 </span><span class="s2">= [</span><span class="s4">7.0</span><span class="s2">] * </span><span class="s4">10</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">f1_1</span><span class="s2">, </span><span class="s1">args</span><span class="s2">)</span>
        <span class="s1">x_expected </span><span class="s2">= (</span>
            <span class="s4">6.17264965</span><span class="s2">, </span><span class="s4">11.7702805</span><span class="s2">, </span><span class="s4">12.2219954</span><span class="s2">,</span>
            <span class="s4">7.11017681</span><span class="s2">, </span><span class="s4">1.18151293</span><span class="s2">, </span><span class="s4">0.143707955</span><span class="s2">,</span>
            <span class="s4">4.31928228</span><span class="s2">, </span><span class="s4">10.5419107</span><span class="s2">, </span><span class="s4">12.7552490</span><span class="s2">,</span>
            <span class="s4">8.91225749</span>
        <span class="s2">)</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">x_expected</span><span class="s2">)</span>
        <span class="s3"># test halley's</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">f1_1</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">fprime2</span><span class="s2">=</span><span class="s1">f1_2</span><span class="s2">)</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">x_expected</span><span class="s2">)</span>
        <span class="s3"># test secant</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">args</span><span class="s2">)</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">x_expected</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_array_newton_complex</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">x </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">+</span><span class="s4">1j</span>

        <span class="s0">def </span><span class="s1">fprime</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s4">1.0</span>

        <span class="s1">t </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full</span><span class="s2">(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">1j</span><span class="s2">)</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">fprime</span><span class="s2">)</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s4">0.</span><span class="s2">)</span>

        <span class="s3"># should work even if x0 is not complex</span>
        <span class="s1">t </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">ones</span><span class="s2">(</span><span class="s4">4</span><span class="s2">)</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">fprime</span><span class="s2">)</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s4">0.</span><span class="s2">)</span>

        <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">t</span><span class="s2">)</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s4">0.</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_array_secant_active_zero_der</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s6">&quot;&quot;&quot;test secant doesn't continue to iterate zero derivatives&quot;&quot;&quot;</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">x</span><span class="s2">, *</span><span class="s1">a</span><span class="s2">: </span><span class="s1">x</span><span class="s2">*</span><span class="s1">x </span><span class="s2">- </span><span class="s1">a</span><span class="s2">[</span><span class="s4">0</span><span class="s2">], </span><span class="s1">x0</span><span class="s2">=[</span><span class="s4">4.123</span><span class="s2">, </span><span class="s4">5</span><span class="s2">],</span>
                         <span class="s1">args</span><span class="s2">=[</span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s4">17</span><span class="s2">, </span><span class="s4">25</span><span class="s2">])])</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, (</span><span class="s4">4.123105625617661</span><span class="s2">, </span><span class="s4">5.0</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">test_array_newton_integers</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3"># test secant with float</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">: </span><span class="s1">z </span><span class="s2">- </span><span class="s1">y </span><span class="s2">** </span><span class="s4">2</span><span class="s2">, [</span><span class="s4">4.0</span><span class="s2">] * </span><span class="s4">2</span><span class="s2">,</span>
                         <span class="s1">args</span><span class="s2">=([</span><span class="s4">15.0</span><span class="s2">, </span><span class="s4">17.0</span><span class="s2">],))</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, (</span><span class="s4">3.872983346207417</span><span class="s2">, </span><span class="s4">4.123105625617661</span><span class="s2">))</span>
        <span class="s3"># test integer becomes float</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">y</span><span class="s2">, </span><span class="s1">z</span><span class="s2">: </span><span class="s1">z </span><span class="s2">- </span><span class="s1">y </span><span class="s2">** </span><span class="s4">2</span><span class="s2">, [</span><span class="s4">4</span><span class="s2">] * </span><span class="s4">2</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=([</span><span class="s4">15</span><span class="s2">, </span><span class="s4">17</span><span class="s2">],))</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, (</span><span class="s4">3.872983346207417</span><span class="s2">, </span><span class="s4">4.123105625617661</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">test_array_newton_zero_der_failures</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3"># test derivative zero warning</span>
        <span class="s1">assert_warns</span><span class="s2">(</span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">,</span>
                     <span class="s0">lambda </span><span class="s1">y</span><span class="s2">: </span><span class="s1">y</span><span class="s2">**</span><span class="s4">2 </span><span class="s2">- </span><span class="s4">2</span><span class="s2">, [</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">], </span><span class="s0">lambda </span><span class="s1">y</span><span class="s2">: </span><span class="s4">2 </span><span class="s2">* </span><span class="s1">y</span><span class="s2">)</span>
        <span class="s3"># test failures and zero_der</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">warns</span><span class="s2">(</span><span class="s1">RuntimeWarning</span><span class="s2">):</span>
            <span class="s1">results </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">y</span><span class="s2">: </span><span class="s1">y</span><span class="s2">**</span><span class="s4">2 </span><span class="s2">- </span><span class="s4">2</span><span class="s2">, [</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">],</span>
                                   <span class="s0">lambda </span><span class="s1">y</span><span class="s2">: </span><span class="s4">2</span><span class="s2">*</span><span class="s1">y</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">results</span><span class="s2">.</span><span class="s1">root</span><span class="s2">, </span><span class="s4">0</span><span class="s2">)</span>
            <span class="s0">assert </span><span class="s1">results</span><span class="s2">.</span><span class="s1">zero_der</span><span class="s2">.</span><span class="s1">all</span><span class="s2">()</span>
            <span class="s0">assert not </span><span class="s1">results</span><span class="s2">.</span><span class="s1">converged</span><span class="s2">.</span><span class="s1">any</span><span class="s2">()</span>

    <span class="s0">def </span><span class="s1">test_newton_combined</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">f1</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">x </span><span class="s2">** </span><span class="s4">2 </span><span class="s2">- </span><span class="s4">2 </span><span class="s2">* </span><span class="s1">x </span><span class="s2">- </span><span class="s4">1</span>
        <span class="s0">def </span><span class="s1">f1_1</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s4">2 </span><span class="s2">* </span><span class="s1">x </span><span class="s2">- </span><span class="s4">2</span>
        <span class="s0">def </span><span class="s1">f1_2</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s4">2.0 </span><span class="s2">+ </span><span class="s4">0 </span><span class="s2">* </span><span class="s1">x</span>

        <span class="s0">def </span><span class="s1">f1_and_p_and_pp</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">x</span><span class="s2">**</span><span class="s4">2 </span><span class="s2">- </span><span class="s4">2</span><span class="s2">*</span><span class="s1">x</span><span class="s2">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">*</span><span class="s1">x</span><span class="s2">-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2.0</span>

        <span class="s1">sol0 </span><span class="s2">= </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s5">'newton'</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">f1_1</span><span class="s2">)</span>
        <span class="s1">sol </span><span class="s2">= </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f1_and_p_and_pp</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s5">'newton'</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">sol0</span><span class="s2">.</span><span class="s1">root</span><span class="s2">, </span><span class="s1">sol</span><span class="s2">.</span><span class="s1">root</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-8</span><span class="s2">)</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s4">2</span><span class="s2">*</span><span class="s1">sol</span><span class="s2">.</span><span class="s1">function_calls</span><span class="s2">, </span><span class="s1">sol0</span><span class="s2">.</span><span class="s1">function_calls</span><span class="s2">)</span>

        <span class="s1">sol0 </span><span class="s2">= </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s5">'halley'</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">f1_1</span><span class="s2">, </span><span class="s1">fprime2</span><span class="s2">=</span><span class="s1">f1_2</span><span class="s2">)</span>
        <span class="s1">sol </span><span class="s2">= </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f1_and_p_and_pp</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s5">'halley'</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">fprime2</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">sol0</span><span class="s2">.</span><span class="s1">root</span><span class="s2">, </span><span class="s1">sol</span><span class="s2">.</span><span class="s1">root</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-8</span><span class="s2">)</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s4">3</span><span class="s2">*</span><span class="s1">sol</span><span class="s2">.</span><span class="s1">function_calls</span><span class="s2">, </span><span class="s1">sol0</span><span class="s2">.</span><span class="s1">function_calls</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_newton_full_output</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">capsys</span><span class="s2">):</span>
        <span class="s3"># Test the full_output capability, both when converging and not.</span>
        <span class="s3"># Use simple polynomials, to avoid hitting platform dependencies</span>
        <span class="s3"># (e.g., exp &amp; trig) in number of iterations</span>

        <span class="s1">x0 </span><span class="s2">= </span><span class="s4">3</span>
        <span class="s1">expected_counts </span><span class="s2">= [(</span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">), (</span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s2">), (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">9</span><span class="s2">)]</span>

        <span class="s0">for </span><span class="s1">derivs </span><span class="s0">in </span><span class="s1">range</span><span class="s2">(</span><span class="s4">3</span><span class="s2">):</span>
            <span class="s1">kwargs </span><span class="s2">= {</span><span class="s5">'tol'</span><span class="s2">: </span><span class="s4">1e-6</span><span class="s2">, </span><span class="s5">'full_output'</span><span class="s2">: </span><span class="s0">True</span><span class="s2">, }</span>
            <span class="s0">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s0">in </span><span class="s2">[[</span><span class="s5">'fprime'</span><span class="s2">, </span><span class="s1">f1_1</span><span class="s2">], [</span><span class="s5">'fprime2'</span><span class="s2">, </span><span class="s1">f1_2</span><span class="s2">]][:</span><span class="s1">derivs</span><span class="s2">]:</span>
                <span class="s1">kwargs</span><span class="s2">[</span><span class="s1">k</span><span class="s2">] = </span><span class="s1">v</span>

            <span class="s1">x</span><span class="s2">, </span><span class="s1">r </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s1">assert_</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">converged</span><span class="s2">)</span>
            <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">r</span><span class="s2">.</span><span class="s1">root</span><span class="s2">)</span>
            <span class="s1">assert_equal</span><span class="s2">((</span><span class="s1">r</span><span class="s2">.</span><span class="s1">iterations</span><span class="s2">, </span><span class="s1">r</span><span class="s2">.</span><span class="s1">function_calls</span><span class="s2">), </span><span class="s1">expected_counts</span><span class="s2">[</span><span class="s1">derivs</span><span class="s2">])</span>
            <span class="s0">if </span><span class="s1">derivs </span><span class="s2">== </span><span class="s4">0</span><span class="s2">:</span>
                <span class="s0">assert </span><span class="s1">r</span><span class="s2">.</span><span class="s1">function_calls </span><span class="s2">&lt;= </span><span class="s1">r</span><span class="s2">.</span><span class="s1">iterations </span><span class="s2">+ </span><span class="s4">1</span>
            <span class="s0">else</span><span class="s2">:</span>
                <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">function_calls</span><span class="s2">, (</span><span class="s1">derivs </span><span class="s2">+ </span><span class="s4">1</span><span class="s2">) * </span><span class="s1">r</span><span class="s2">.</span><span class="s1">iterations</span><span class="s2">)</span>

            <span class="s3"># Now repeat, allowing one fewer iteration to force convergence failure</span>
            <span class="s1">iters </span><span class="s2">= </span><span class="s1">r</span><span class="s2">.</span><span class="s1">iterations </span><span class="s2">- </span><span class="s4">1</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">r </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s1">iters</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>
            <span class="s1">assert_</span><span class="s2">(</span><span class="s0">not </span><span class="s1">r</span><span class="s2">.</span><span class="s1">converged</span><span class="s2">)</span>
            <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">r</span><span class="s2">.</span><span class="s1">root</span><span class="s2">)</span>
            <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">iterations</span><span class="s2">, </span><span class="s1">iters</span><span class="s2">)</span>

            <span class="s0">if </span><span class="s1">derivs </span><span class="s2">== </span><span class="s4">1</span><span class="s2">:</span>
                <span class="s3"># Check that the correct Exception is raised and</span>
                <span class="s3"># validate the start of the message.</span>
                <span class="s1">msg </span><span class="s2">= </span><span class="s5">'Failed to converge after %d iterations, value is .*' </span><span class="s2">% (</span><span class="s1">iters</span><span class="s2">)</span>
                <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s1">msg</span><span class="s2">):</span>
                    <span class="s1">x</span><span class="s2">, </span><span class="s1">r </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s1">iters</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_deriv_zero_warning</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">func</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s1">x </span><span class="s2">** </span><span class="s4">2 </span><span class="s2">- </span><span class="s4">2.0</span>
        <span class="s0">def </span><span class="s1">dfunc</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s0">return </span><span class="s4">2 </span><span class="s2">* </span><span class="s1">x</span>
        <span class="s1">assert_warns</span><span class="s2">(</span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">dfunc</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
        <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">'Derivative was zero'</span><span class="s2">):</span>
            <span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">func</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">dfunc</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_newton_does_not_modify_x0</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3"># https://github.com/scipy/scipy/issues/9964</span>
        <span class="s1">x0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">])</span>
        <span class="s1">x0_copy </span><span class="s2">= </span><span class="s1">x0</span><span class="s2">.</span><span class="s1">copy</span><span class="s2">()  </span><span class="s3"># Copy to test for equality.</span>
        <span class="s1">newton</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">sin</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">np</span><span class="s2">.</span><span class="s1">cos</span><span class="s2">)</span>
        <span class="s1">assert_array_equal</span><span class="s2">(</span><span class="s1">x0</span><span class="s2">, </span><span class="s1">x0_copy</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_gh17570_defaults</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s3"># Previously, when fprime was not specified, root_scalar would default</span>
        <span class="s3"># to secant. When x1 was not specified, secant failed.</span>
        <span class="s3"># Check that without fprime, the default is secant if x1 is specified</span>
        <span class="s3"># and newton otherwise.</span>
        <span class="s1">res_newton_default </span><span class="s2">= </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s5">'newton'</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
        <span class="s1">res_secant_default </span><span class="s2">= </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s5">'secant'</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">=</span><span class="s4">2</span><span class="s2">,</span>
                                         <span class="s1">xtol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
        <span class="s3"># `newton` uses the secant method when `x1` and `x2` are specified</span>
        <span class="s1">res_secant </span><span class="s2">= </span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)[</span><span class="s4">1</span><span class="s2">]</span>

        <span class="s3"># all three found a root</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">(</span><span class="s1">res_newton_default</span><span class="s2">.</span><span class="s1">root</span><span class="s2">), </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">res_newton_default</span><span class="s2">.</span><span class="s1">root</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">tuple</span><span class="s2">()</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">(</span><span class="s1">res_secant_default</span><span class="s2">.</span><span class="s1">root</span><span class="s2">), </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">res_secant_default</span><span class="s2">.</span><span class="s1">root</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">tuple</span><span class="s2">()</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">(</span><span class="s1">res_secant</span><span class="s2">.</span><span class="s1">root</span><span class="s2">), </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">res_secant</span><span class="s2">.</span><span class="s1">root</span><span class="s2">.</span><span class="s1">shape </span><span class="s2">== </span><span class="s1">tuple</span><span class="s2">()</span>

        <span class="s3"># Defaults are correct</span>
        <span class="s0">assert </span><span class="s2">(</span><span class="s1">res_secant_default</span><span class="s2">.</span><span class="s1">root</span>
                <span class="s2">== </span><span class="s1">res_secant</span><span class="s2">.</span><span class="s1">root</span>
                <span class="s2">!= </span><span class="s1">res_newton_default</span><span class="s2">.</span><span class="s1">iterations</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s2">(</span><span class="s1">res_secant_default</span><span class="s2">.</span><span class="s1">iterations</span>
                <span class="s2">== </span><span class="s1">res_secant_default</span><span class="s2">.</span><span class="s1">function_calls </span><span class="s2">- </span><span class="s4">1  </span><span class="s3"># true for secant</span>
                <span class="s2">== </span><span class="s1">res_secant</span><span class="s2">.</span><span class="s1">iterations</span>
                <span class="s2">!= </span><span class="s1">res_newton_default</span><span class="s2">.</span><span class="s1">iterations</span>
                <span class="s2">== </span><span class="s1">res_newton_default</span><span class="s2">.</span><span class="s1">function_calls</span><span class="s2">/</span><span class="s4">2</span><span class="s2">)  </span><span class="s3"># newton 2-point diff</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'kwargs'</span><span class="s2">, [</span><span class="s1">dict</span><span class="s2">(), {</span><span class="s5">'method'</span><span class="s2">: </span><span class="s5">'newton'</span><span class="s2">}])</span>
    <span class="s0">def </span><span class="s1">test_args_gh19090</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">):</span>
        <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">):</span>
            <span class="s0">assert </span><span class="s1">a </span><span class="s2">== </span><span class="s4">3</span>
            <span class="s0">assert </span><span class="s1">b </span><span class="s2">== </span><span class="s4">1</span>
            <span class="s0">return </span><span class="s2">(</span><span class="s1">x </span><span class="s2">** </span><span class="s1">a </span><span class="s2">- </span><span class="s1">b</span><span class="s2">)</span>

        <span class="s1">res </span><span class="s2">= </span><span class="s1">optimize</span><span class="s2">.</span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">), **</span><span class="s1">kwargs</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">res</span><span class="s2">.</span><span class="s1">converged</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">res</span><span class="s2">.</span><span class="s1">root</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>

    <span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'method'</span><span class="s2">, [</span><span class="s5">'secant'</span><span class="s2">, </span><span class="s5">'newton'</span><span class="s2">])</span>
    <span class="s0">def </span><span class="s1">test_int_x0_gh19280</span><span class="s2">(</span><span class="s1">self</span><span class="s2">, </span><span class="s1">method</span><span class="s2">):</span>
        <span class="s3"># Originally, `newton` ensured that only floats were passed to the</span>
        <span class="s3"># callable. This was indadvertently changed by gh-17669. Check that</span>
        <span class="s3"># it has been changed back.</span>
        <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
            <span class="s3"># an integer raised to a negative integer power would fail</span>
            <span class="s0">return </span><span class="s1">x</span><span class="s2">**-</span><span class="s4">2 </span><span class="s2">- </span><span class="s4">2</span>

        <span class="s1">res </span><span class="s2">= </span><span class="s1">optimize</span><span class="s2">.</span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s1">method</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">res</span><span class="s2">.</span><span class="s1">converged</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">abs</span><span class="s2">(</span><span class="s1">res</span><span class="s2">.</span><span class="s1">root</span><span class="s2">), </span><span class="s4">2</span><span class="s2">**-</span><span class="s4">0.5</span><span class="s2">)</span>
        <span class="s0">assert </span><span class="s1">res</span><span class="s2">.</span><span class="s1">root</span><span class="s2">.</span><span class="s1">dtype </span><span class="s2">== </span><span class="s1">np</span><span class="s2">.</span><span class="s1">dtype</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float64</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_gh_5555</span><span class="s2">():</span>
    <span class="s1">root </span><span class="s2">= </span><span class="s4">0.1</span>

    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">x </span><span class="s2">- </span><span class="s1">root</span>

    <span class="s1">methods </span><span class="s2">= [</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">bisect</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">ridder</span><span class="s2">]</span>
    <span class="s1">xtol </span><span class="s2">= </span><span class="s1">rtol </span><span class="s2">= </span><span class="s1">TOL</span>
    <span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s1">methods</span><span class="s2">:</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">method</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, -</span><span class="s4">1e8</span><span class="s2">, </span><span class="s4">1e7</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s1">xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">rtol</span><span class="s2">)</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">root</span><span class="s2">, </span><span class="s1">res</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">rtol</span><span class="s2">,</span>
                        <span class="s1">err_msg</span><span class="s2">=</span><span class="s5">'method %s' </span><span class="s2">% </span><span class="s1">method</span><span class="s2">.</span><span class="s1">__name__</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_gh_5557</span><span class="s2">():</span>
    <span class="s3"># Show that without the changes in 5557 brentq and brenth might</span>
    <span class="s3"># only achieve a tolerance of 2*(xtol + rtol*|res|).</span>

    <span class="s3"># f linearly interpolates (0, -0.1), (0.5, -0.1), and (1,</span>
    <span class="s3"># 0.4). The important parts are that |f(0)| &lt; |f(1)| (so that</span>
    <span class="s3"># brent takes 0 as the initial guess), |f(0)| &lt; atol (so that</span>
    <span class="s3"># brent accepts 0 as the root), and that the exact root of f lies</span>
    <span class="s3"># more than atol away from 0 (so that brent doesn't achieve the</span>
    <span class="s3"># desired tolerance).</span>
    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">if </span><span class="s1">x </span><span class="s2">&lt; </span><span class="s4">0.5</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">-</span><span class="s4">0.1</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">x </span><span class="s2">- </span><span class="s4">0.6</span>

    <span class="s1">atol </span><span class="s2">= </span><span class="s4">0.51</span>
    <span class="s1">rtol </span><span class="s2">= </span><span class="s4">4 </span><span class="s2">* </span><span class="s1">_FLOAT_EPS</span>
    <span class="s1">methods </span><span class="s2">= [</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">brentq</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">brenth</span><span class="s2">]</span>
    <span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s1">methods</span><span class="s2">:</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">method</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s1">atol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">rtol</span><span class="s2">)</span>
        <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s4">0.6</span><span class="s2">, </span><span class="s1">res</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">atol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">rtol</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_brent_underflow_in_root_bracketing</span><span class="s2">():</span>
    <span class="s3"># Testing if an interval [a,b] brackets a zero of a function</span>
    <span class="s3"># by checking f(a)*f(b) &lt; 0 is not reliable when the product</span>
    <span class="s3"># underflows/overflows. (reported in issue# 13737)</span>

    <span class="s1">underflow_scenario </span><span class="s2">= (-</span><span class="s4">450.0</span><span class="s2">, -</span><span class="s4">350.0</span><span class="s2">, -</span><span class="s4">400.0</span><span class="s2">)</span>
    <span class="s1">overflow_scenario </span><span class="s2">= (</span><span class="s4">350.0</span><span class="s2">, </span><span class="s4">450.0</span><span class="s2">, </span><span class="s4">400.0</span><span class="s2">)</span>

    <span class="s0">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">root </span><span class="s0">in </span><span class="s2">[</span><span class="s1">underflow_scenario</span><span class="s2">, </span><span class="s1">overflow_scenario</span><span class="s2">]:</span>
        <span class="s1">c </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">exp</span><span class="s2">(</span><span class="s1">root</span><span class="s2">)</span>
        <span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s2">[</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">brenth</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">brentq</span><span class="s2">]:</span>
            <span class="s1">res </span><span class="s2">= </span><span class="s1">method</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">x</span><span class="s2">: </span><span class="s1">np</span><span class="s2">.</span><span class="s1">exp</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)-</span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)</span>
            <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">root</span><span class="s2">, </span><span class="s1">res</span><span class="s2">)</span>


<span class="s0">class </span><span class="s1">TestRootResults</span><span class="s2">:</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">RootResults</span><span class="s2">(</span><span class="s1">root</span><span class="s2">=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">iterations</span><span class="s2">=</span><span class="s4">44</span><span class="s2">, </span><span class="s1">function_calls</span><span class="s2">=</span><span class="s4">46</span><span class="s2">, </span><span class="s1">flag</span><span class="s2">=</span><span class="s4">0</span><span class="s2">,</span>
                          <span class="s1">method</span><span class="s2">=</span><span class="s5">&quot;newton&quot;</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_repr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s1">expected_repr </span><span class="s2">= (</span><span class="s5">&quot;      converged: True</span><span class="s0">\n           </span><span class="s5">flag: converged&quot;</span>
                         <span class="s5">&quot;</span><span class="s0">\n </span><span class="s5">function_calls: 46</span><span class="s0">\n     </span><span class="s5">iterations: 44</span><span class="s0">\n</span><span class="s5">&quot;</span>
                         <span class="s5">&quot;           root: 1.0</span><span class="s0">\n         </span><span class="s5">method: newton&quot;</span><span class="s2">)</span>
        <span class="s1">assert_equal</span><span class="s2">(</span><span class="s1">repr</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">r</span><span class="s2">), </span><span class="s1">expected_repr</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">test_type</span><span class="s2">(</span><span class="s1">self</span><span class="s2">):</span>
        <span class="s0">assert </span><span class="s1">isinstance</span><span class="s2">(</span><span class="s1">self</span><span class="s2">.</span><span class="s1">r</span><span class="s2">, </span><span class="s1">OptimizeResult</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_complex_halley</span><span class="s2">():</span>
    <span class="s6">&quot;&quot;&quot;Test Halley's works with complex roots&quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">a</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">a</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] * </span><span class="s1">x</span><span class="s2">**</span><span class="s4">2 </span><span class="s2">+ </span><span class="s1">a</span><span class="s2">[</span><span class="s4">1</span><span class="s2">] * </span><span class="s1">x </span><span class="s2">+ </span><span class="s1">a</span><span class="s2">[</span><span class="s4">2</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">f_1</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">a</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s4">2 </span><span class="s2">* </span><span class="s1">a</span><span class="s2">[</span><span class="s4">0</span><span class="s2">] * </span><span class="s1">x </span><span class="s2">+ </span><span class="s1">a</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]</span>

    <span class="s0">def </span><span class="s1">f_2</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, *</span><span class="s1">a</span><span class="s2">):</span>
        <span class="s1">retval </span><span class="s2">= </span><span class="s4">2 </span><span class="s2">* </span><span class="s1">a</span><span class="s2">[</span><span class="s4">0</span><span class="s2">]</span>
        <span class="s0">try</span><span class="s2">:</span>
            <span class="s1">size </span><span class="s2">= </span><span class="s1">len</span><span class="s2">(</span><span class="s1">x</span><span class="s2">)</span>
        <span class="s0">except </span><span class="s1">TypeError</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s1">retval</span>
        <span class="s0">else</span><span class="s2">:</span>
            <span class="s0">return </span><span class="s2">[</span><span class="s1">retval</span><span class="s2">] * </span><span class="s1">size</span>

    <span class="s1">z </span><span class="s2">= </span><span class="s1">complex</span><span class="s2">(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">)</span>
    <span class="s1">coeffs </span><span class="s2">= (</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">)</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">coeffs</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">f_1</span><span class="s2">, </span><span class="s1">fprime2</span><span class="s2">=</span><span class="s1">f_2</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
    <span class="s3"># (-0.75000000000000078+1.1989578808281789j)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, *</span><span class="s1">coeffs</span><span class="s2">), </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
    <span class="s1">z </span><span class="s2">= [</span><span class="s1">z</span><span class="s2">] * </span><span class="s4">10</span>
    <span class="s1">coeffs </span><span class="s2">= (</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">)</span>
    <span class="s1">y </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">z</span><span class="s2">, </span><span class="s1">args</span><span class="s2">=</span><span class="s1">coeffs</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">f_1</span><span class="s2">, </span><span class="s1">fprime2</span><span class="s2">=</span><span class="s1">f_2</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">f</span><span class="s2">(</span><span class="s1">y</span><span class="s2">, *</span><span class="s1">coeffs</span><span class="s2">), </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-6</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_zero_der_nz_dp</span><span class="s2">(</span><span class="s1">capsys</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot;Test secant method with a non-zero dp, but an infinite newton step&quot;&quot;&quot;</span>
    <span class="s3"># pick a symmetrical functions and choose a point on the side that with dx</span>
    <span class="s3"># makes a secant that is a flat line with zero slope, EG: f = (x - 100)**2,</span>
    <span class="s3"># which has a root at x = 100 and is symmetrical around the line x = 100</span>
    <span class="s3"># we have to pick a really big number so that it is consistently true</span>
    <span class="s3"># now find a point on each side so that the secant has a zero slope</span>
    <span class="s1">dx </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">float</span><span class="s2">).</span><span class="s1">eps </span><span class="s2">** </span><span class="s4">0.33</span>
    <span class="s3"># 100 - p0 = p1 - 100 = p0 * (1 + dx) + dx - 100</span>
    <span class="s3"># -&gt; 200 = p0 * (2 + dx) + dx</span>
    <span class="s1">p0 </span><span class="s2">= (</span><span class="s4">200.0 </span><span class="s2">- </span><span class="s1">dx</span><span class="s2">) / (</span><span class="s4">2.0 </span><span class="s2">+ </span><span class="s1">dx</span><span class="s2">)</span>
    <span class="s0">with </span><span class="s1">suppress_warnings</span><span class="s2">() </span><span class="s0">as </span><span class="s1">sup</span><span class="s2">:</span>
        <span class="s1">sup</span><span class="s2">.</span><span class="s1">filter</span><span class="s2">(</span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s5">&quot;RMS of&quot;</span><span class="s2">)</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">y</span><span class="s2">: (</span><span class="s1">y </span><span class="s2">- </span><span class="s4">100.0</span><span class="s2">)**</span><span class="s4">2</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=[</span><span class="s1">p0</span><span class="s2">] * </span><span class="s4">10</span><span class="s2">)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, [</span><span class="s4">100</span><span class="s2">] * </span><span class="s4">10</span><span class="s2">)</span>
    <span class="s3"># test scalar cases too</span>
    <span class="s1">p0 </span><span class="s2">= (</span><span class="s4">2.0 </span><span class="s2">- </span><span class="s4">1e-4</span><span class="s2">) / (</span><span class="s4">2.0 </span><span class="s2">+ </span><span class="s4">1e-4</span><span class="s2">)</span>
    <span class="s0">with </span><span class="s1">suppress_warnings</span><span class="s2">() </span><span class="s0">as </span><span class="s1">sup</span><span class="s2">:</span>
        <span class="s1">sup</span><span class="s2">.</span><span class="s1">filter</span><span class="s2">(</span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s5">&quot;Tolerance of&quot;</span><span class="s2">)</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">y</span><span class="s2">: (</span><span class="s1">y </span><span class="s2">- </span><span class="s4">1.0</span><span class="s2">) ** </span><span class="s4">2</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s1">p0</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">'Tolerance of'</span><span class="s2">):</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">y</span><span class="s2">: (</span><span class="s1">y </span><span class="s2">- </span><span class="s4">1.0</span><span class="s2">) ** </span><span class="s4">2</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s1">p0</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s1">p0 </span><span class="s2">= (-</span><span class="s4">2.0 </span><span class="s2">+ </span><span class="s4">1e-4</span><span class="s2">) / (</span><span class="s4">2.0 </span><span class="s2">+ </span><span class="s4">1e-4</span><span class="s2">)</span>
    <span class="s0">with </span><span class="s1">suppress_warnings</span><span class="s2">() </span><span class="s0">as </span><span class="s1">sup</span><span class="s2">:</span>
        <span class="s1">sup</span><span class="s2">.</span><span class="s1">filter</span><span class="s2">(</span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s5">&quot;Tolerance of&quot;</span><span class="s2">)</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">y</span><span class="s2">: (</span><span class="s1">y </span><span class="s2">+ </span><span class="s4">1.0</span><span class="s2">) ** </span><span class="s4">2</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s1">p0</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, -</span><span class="s4">1</span><span class="s2">)</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">'Tolerance of'</span><span class="s2">):</span>
        <span class="s1">x </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s0">lambda </span><span class="s1">y</span><span class="s2">: (</span><span class="s1">y </span><span class="s2">+ </span><span class="s4">1.0</span><span class="s2">) ** </span><span class="s4">2</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s1">p0</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_array_newton_failures</span><span class="s2">():</span>
    <span class="s6">&quot;&quot;&quot;Test that array newton fails as expected&quot;&quot;&quot;</span>
    <span class="s3"># p = 0.68  # [MPa]</span>
    <span class="s3"># dp = -0.068 * 1e6  # [Pa]</span>
    <span class="s3"># T = 323  # [K]</span>
    <span class="s1">diameter </span><span class="s2">= </span><span class="s4">0.10  </span><span class="s3"># [m]</span>
    <span class="s3"># L = 100  # [m]</span>
    <span class="s1">roughness </span><span class="s2">= </span><span class="s4">0.00015  </span><span class="s3"># [m]</span>
    <span class="s1">rho </span><span class="s2">= </span><span class="s4">988.1  </span><span class="s3"># [kg/m**3]</span>
    <span class="s1">mu </span><span class="s2">= </span><span class="s4">5.4790e-04  </span><span class="s3"># [Pa*s]</span>
    <span class="s1">u </span><span class="s2">= </span><span class="s4">2.488  </span><span class="s3"># [m/s]</span>
    <span class="s1">reynolds_number </span><span class="s2">= </span><span class="s1">rho </span><span class="s2">* </span><span class="s1">u </span><span class="s2">* </span><span class="s1">diameter </span><span class="s2">/ </span><span class="s1">mu  </span><span class="s3"># Reynolds number</span>

    <span class="s0">def </span><span class="s1">colebrook_eqn</span><span class="s2">(</span><span class="s1">darcy_friction</span><span class="s2">, </span><span class="s1">re</span><span class="s2">, </span><span class="s1">dia</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s2">(</span><span class="s4">1 </span><span class="s2">/ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">darcy_friction</span><span class="s2">) +</span>
                <span class="s4">2 </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">log10</span><span class="s2">(</span><span class="s1">roughness </span><span class="s2">/ </span><span class="s4">3.7 </span><span class="s2">/ </span><span class="s1">dia </span><span class="s2">+</span>
                             <span class="s4">2.51 </span><span class="s2">/ </span><span class="s1">re </span><span class="s2">/ </span><span class="s1">np</span><span class="s2">.</span><span class="s1">sqrt</span><span class="s2">(</span><span class="s1">darcy_friction</span><span class="s2">)))</span>

    <span class="s3"># only some failures</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">warns</span><span class="s2">(</span><span class="s1">RuntimeWarning</span><span class="s2">):</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span>
            <span class="s1">colebrook_eqn</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=[</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.02223</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">], </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s4">2</span><span class="s2">,</span>
            <span class="s1">args</span><span class="s2">=[</span><span class="s1">reynolds_number</span><span class="s2">, </span><span class="s1">diameter</span><span class="s2">], </span><span class="s1">full_output</span><span class="s2">=</span><span class="s0">True</span>
        <span class="s2">)</span>
        <span class="s0">assert not </span><span class="s1">result</span><span class="s2">.</span><span class="s1">converged</span><span class="s2">.</span><span class="s1">all</span><span class="s2">()</span>
    <span class="s3"># they all fail</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">RuntimeError</span><span class="s2">):</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span>
            <span class="s1">colebrook_eqn</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=[</span><span class="s4">0.01</span><span class="s2">] * </span><span class="s4">2</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s4">2</span><span class="s2">,</span>
            <span class="s1">args</span><span class="s2">=[</span><span class="s1">reynolds_number</span><span class="s2">, </span><span class="s1">diameter</span><span class="s2">], </span><span class="s1">full_output</span><span class="s2">=</span><span class="s0">True</span>
        <span class="s2">)</span>


<span class="s3"># this test should **not** raise a RuntimeWarning</span>
<span class="s0">def </span><span class="s1">test_gh8904_zeroder_at_root_fails</span><span class="s2">():</span>
    <span class="s6">&quot;&quot;&quot;Test that Newton or Halley don't warn if zero derivative at root&quot;&quot;&quot;</span>

    <span class="s3"># a function that has a zero derivative at it's root</span>
    <span class="s0">def </span><span class="s1">f_zeroder_root</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">x</span><span class="s2">**</span><span class="s4">3 </span><span class="s2">- </span><span class="s1">x</span><span class="s2">**</span><span class="s4">2</span>

    <span class="s3"># should work with secant</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f_zeroder_root</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">0</span><span class="s2">)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">_xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">_rtol</span><span class="s2">)</span>
    <span class="s3"># test again with array</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f_zeroder_root</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=[</span><span class="s4">0</span><span class="s2">]*</span><span class="s4">10</span><span class="s2">)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">_xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">_rtol</span><span class="s2">)</span>

    <span class="s3"># 1st derivative</span>
    <span class="s0">def </span><span class="s1">fder</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s4">3 </span><span class="s2">* </span><span class="s1">x</span><span class="s2">**</span><span class="s4">2 </span><span class="s2">- </span><span class="s4">2 </span><span class="s2">* </span><span class="s1">x</span>

    <span class="s3"># 2nd derivative</span>
    <span class="s0">def </span><span class="s1">fder2</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s4">6</span><span class="s2">*</span><span class="s1">x </span><span class="s2">- </span><span class="s4">2</span>

    <span class="s3"># should work with newton and halley</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f_zeroder_root</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">fder</span><span class="s2">)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">_xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">_rtol</span><span class="s2">)</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f_zeroder_root</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">fder</span><span class="s2">,</span>
                     <span class="s1">fprime2</span><span class="s2">=</span><span class="s1">fder2</span><span class="s2">)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">_xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">_rtol</span><span class="s2">)</span>
    <span class="s3"># test again with array</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f_zeroder_root</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=[</span><span class="s4">0</span><span class="s2">]*</span><span class="s4">10</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">fder</span><span class="s2">)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">_xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">_rtol</span><span class="s2">)</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f_zeroder_root</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=[</span><span class="s4">0</span><span class="s2">]*</span><span class="s4">10</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">fder</span><span class="s2">,</span>
                     <span class="s1">fprime2</span><span class="s2">=</span><span class="s1">fder2</span><span class="s2">)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">_xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">_rtol</span><span class="s2">)</span>

    <span class="s3"># also test that if a root is found we do not raise RuntimeWarning even if</span>
    <span class="s3"># the derivative is zero, EG: at x = 0.5, then fval = -0.125 and</span>
    <span class="s3"># fder = -0.25 so the next guess is 0.5 - (-0.125/-0.5) = 0 which is the</span>
    <span class="s3"># root, but if the solver continued with that guess, then it will calculate</span>
    <span class="s3"># a zero derivative, so it should return the root w/o RuntimeWarning</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f_zeroder_root</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">fder</span><span class="s2">)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">_xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">_rtol</span><span class="s2">)</span>
    <span class="s3"># test again with array</span>
    <span class="s1">r </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f_zeroder_root</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=[</span><span class="s4">0.5</span><span class="s2">]*</span><span class="s4">10</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">fder</span><span class="s2">)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">r</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">_xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">_rtol</span><span class="s2">)</span>
    <span class="s3"># doesn't apply to halley</span>


<span class="s0">def </span><span class="s1">test_gh_8881</span><span class="s2">():</span>
    <span class="s6">r&quot;&quot;&quot;Test that Halley's method realizes that the 2nd order adjustment 
    is too big and drops off to the 1st order adjustment.&quot;&quot;&quot;</span>
    <span class="s1">n </span><span class="s2">= </span><span class="s4">9</span>

    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">power</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">/</span><span class="s1">n</span><span class="s2">) - </span><span class="s1">power</span><span class="s2">(</span><span class="s1">n</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">/</span><span class="s1">n</span><span class="s2">)</span>

    <span class="s0">def </span><span class="s1">fp</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">power</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, (</span><span class="s4">1.0</span><span class="s2">-</span><span class="s1">n</span><span class="s2">)/</span><span class="s1">n</span><span class="s2">)/</span><span class="s1">n</span>

    <span class="s0">def </span><span class="s1">fpp</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">power</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, (</span><span class="s4">1.0</span><span class="s2">-</span><span class="s4">2</span><span class="s2">*</span><span class="s1">n</span><span class="s2">)/</span><span class="s1">n</span><span class="s2">) * (</span><span class="s4">1.0</span><span class="s2">/</span><span class="s1">n</span><span class="s2">) * (</span><span class="s4">1.0</span><span class="s2">-</span><span class="s1">n</span><span class="s2">)/</span><span class="s1">n</span>

    <span class="s1">x0 </span><span class="s2">= </span><span class="s4">0.1</span>
    <span class="s3"># The root is at x=9.</span>
    <span class="s3"># The function has positive slope, x0 &lt; root.</span>
    <span class="s3"># Newton succeeds in 8 iterations</span>
    <span class="s1">rt</span><span class="s2">, </span><span class="s1">r </span><span class="s2">= </span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">fp</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">r</span><span class="s2">.</span><span class="s1">converged</span>
    <span class="s3"># Before the Issue 8881/PR 8882, halley would send x in the wrong direction.</span>
    <span class="s3"># Check that it now succeeds.</span>
    <span class="s1">rt</span><span class="s2">, </span><span class="s1">r </span><span class="s2">= </span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">fp</span><span class="s2">, </span><span class="s1">fprime2</span><span class="s2">=</span><span class="s1">fpp</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">r</span><span class="s2">.</span><span class="s1">converged</span>


<span class="s0">def </span><span class="s1">test_gh_9608_preserve_array_shape</span><span class="s2">():</span>
    <span class="s6">&quot;&quot;&quot; 
    Test that shape is preserved for array inputs even if fprime or fprime2 is 
    scalar 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">x</span><span class="s2">**</span><span class="s4">2</span>

    <span class="s0">def </span><span class="s1">fp</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s4">2 </span><span class="s2">* </span><span class="s1">x</span>

    <span class="s0">def </span><span class="s1">fpp</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s4">2</span>

    <span class="s1">x0 </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([-</span><span class="s4">2</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">)</span>
    <span class="s1">rt</span><span class="s2">, </span><span class="s1">r </span><span class="s2">= </span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">fp</span><span class="s2">, </span><span class="s1">fprime2</span><span class="s2">=</span><span class="s1">fpp</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">r</span><span class="s2">.</span><span class="s1">converged</span>

    <span class="s1">x0_array </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">array</span><span class="s2">([-</span><span class="s4">2</span><span class="s2">, -</span><span class="s4">3</span><span class="s2">], </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">)</span>
    <span class="s3"># This next invocation should fail</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">IndexError</span><span class="s2">):</span>
        <span class="s1">result </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span>
            <span class="s1">f</span><span class="s2">, </span><span class="s1">x0_array</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">fp</span><span class="s2">, </span><span class="s1">fprime2</span><span class="s2">=</span><span class="s1">fpp</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s0">True</span>
        <span class="s2">)</span>

    <span class="s0">def </span><span class="s1">fpp_array</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">full</span><span class="s2">(</span><span class="s1">np</span><span class="s2">.</span><span class="s1">shape</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s4">2</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">=</span><span class="s1">np</span><span class="s2">.</span><span class="s1">float32</span><span class="s2">)</span>

    <span class="s1">result </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span>
        <span class="s1">f</span><span class="s2">, </span><span class="s1">x0_array</span><span class="s2">, </span><span class="s1">fprime</span><span class="s2">=</span><span class="s1">fp</span><span class="s2">, </span><span class="s1">fprime2</span><span class="s2">=</span><span class="s1">fpp_array</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s0">True</span>
    <span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">result</span><span class="s2">.</span><span class="s1">converged</span><span class="s2">.</span><span class="s1">all</span><span class="s2">()</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span>
    <span class="s5">&quot;maximum_iterations,flag_expected&quot;</span><span class="s2">,</span>
    <span class="s2">[(</span><span class="s4">10</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">CONVERR</span><span class="s2">), (</span><span class="s4">100</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">CONVERGED</span><span class="s2">)])</span>
<span class="s0">def </span><span class="s1">test_gh9254_flag_if_maxiter_exceeded</span><span class="s2">(</span><span class="s1">maximum_iterations</span><span class="s2">, </span><span class="s1">flag_expected</span><span class="s2">):</span>
    <span class="s6">&quot;&quot;&quot; 
    Test that if the maximum iterations is exceeded that the flag is not 
    converged. 
    &quot;&quot;&quot;</span>
    <span class="s1">result </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">brentq</span><span class="s2">(</span>
        <span class="s0">lambda </span><span class="s1">x</span><span class="s2">: ((</span><span class="s4">1.2</span><span class="s2">*</span><span class="s1">x </span><span class="s2">- </span><span class="s4">2.3</span><span class="s2">)*</span><span class="s1">x </span><span class="s2">+ </span><span class="s4">3.4</span><span class="s2">)*</span><span class="s1">x </span><span class="s2">- </span><span class="s4">4.5</span><span class="s2">,</span>
        <span class="s2">-</span><span class="s4">30</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, (), </span><span class="s4">1e-6</span><span class="s2">, </span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">maximum_iterations</span><span class="s2">,</span>
        <span class="s1">full_output</span><span class="s2">=</span><span class="s0">True</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">result</span><span class="s2">[</span><span class="s4">1</span><span class="s2">].</span><span class="s1">flag </span><span class="s2">== </span><span class="s1">flag_expected</span>
    <span class="s0">if </span><span class="s1">flag_expected </span><span class="s2">== </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">CONVERR</span><span class="s2">:</span>
        <span class="s3"># didn't converge because exceeded maximum iterations</span>
        <span class="s0">assert </span><span class="s1">result</span><span class="s2">[</span><span class="s4">1</span><span class="s2">].</span><span class="s1">iterations </span><span class="s2">== </span><span class="s1">maximum_iterations</span>
    <span class="s0">elif </span><span class="s1">flag_expected </span><span class="s2">== </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">CONVERGED</span><span class="s2">:</span>
        <span class="s3"># converged before maximum iterations</span>
        <span class="s0">assert </span><span class="s1">result</span><span class="s2">[</span><span class="s4">1</span><span class="s2">].</span><span class="s1">iterations </span><span class="s2">&lt; </span><span class="s1">maximum_iterations</span>


<span class="s0">def </span><span class="s1">test_gh9551_raise_error_if_disp_true</span><span class="s2">():</span>
    <span class="s6">&quot;&quot;&quot;Test that if disp is true then zero derivative raises RuntimeError&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">x</span><span class="s2">*</span><span class="s1">x </span><span class="s2">+ </span><span class="s4">1</span>

    <span class="s0">def </span><span class="s1">f_p</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s4">2</span><span class="s2">*</span><span class="s1">x</span>

    <span class="s1">assert_warns</span><span class="s2">(</span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">f_p</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">False</span><span class="s2">)</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span>
            <span class="s1">RuntimeError</span><span class="s2">,</span>
            <span class="s1">match</span><span class="s2">=</span><span class="s5">r'^Derivative was zero\. Failed to converge after \d+ iterations, '</span>
                  <span class="s5">r'value is [+-]?\d*\.\d+\.$'</span><span class="s2">):</span>
        <span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">f_p</span><span class="s2">)</span>
    <span class="s1">root </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">complex</span><span class="s2">(</span><span class="s4">10.0</span><span class="s2">, </span><span class="s4">10.0</span><span class="s2">), </span><span class="s1">f_p</span><span class="s2">)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">root</span><span class="s2">, </span><span class="s1">complex</span><span class="s2">(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">))</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'solver_name'</span><span class="s2">,</span>
                         <span class="s2">[</span><span class="s5">'brentq'</span><span class="s2">, </span><span class="s5">'brenth'</span><span class="s2">, </span><span class="s5">'bisect'</span><span class="s2">, </span><span class="s5">'ridder'</span><span class="s2">, </span><span class="s5">'toms748'</span><span class="s2">])</span>
<span class="s0">def </span><span class="s1">test_gh3089_8394</span><span class="s2">(</span><span class="s1">solver_name</span><span class="s2">):</span>
    <span class="s3"># gh-3089 and gh-8394 reported that bracketing solvers returned incorrect</span>
    <span class="s3"># results when they encountered NaNs. Check that this is resolved.</span>
    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span>

    <span class="s1">solver </span><span class="s2">= </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">zeros</span><span class="s2">, </span><span class="s1">solver_name</span><span class="s2">)</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">&quot;The function value at x...&quot;</span><span class="s2">):</span>
        <span class="s1">solver</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'method'</span><span class="s2">,</span>
                         <span class="s2">[</span><span class="s5">'brentq'</span><span class="s2">, </span><span class="s5">'brenth'</span><span class="s2">, </span><span class="s5">'bisect'</span><span class="s2">, </span><span class="s5">'ridder'</span><span class="s2">, </span><span class="s5">'toms748'</span><span class="s2">])</span>
<span class="s0">def </span><span class="s1">test_gh18171</span><span class="s2">(</span><span class="s1">method</span><span class="s2">):</span>
    <span class="s3"># gh-3089 and gh-8394 reported that bracketing solvers returned incorrect</span>
    <span class="s3"># results when they encountered NaNs. Check that `root_scalar` returns</span>
    <span class="s3"># normally but indicates that convergence was unsuccessful. See gh-18171.</span>
    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s1">f</span><span class="s2">.</span><span class="s1">_count </span><span class="s2">+= </span><span class="s4">1</span>
        <span class="s0">return </span><span class="s1">np</span><span class="s2">.</span><span class="s1">nan</span>
    <span class="s1">f</span><span class="s2">.</span><span class="s1">_count </span><span class="s2">= </span><span class="s4">0</span>

    <span class="s1">res </span><span class="s2">= </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">bracket</span><span class="s2">=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">), </span><span class="s1">method</span><span class="s2">=</span><span class="s1">method</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">res</span><span class="s2">.</span><span class="s1">converged </span><span class="s0">is False</span>
    <span class="s0">assert </span><span class="s1">res</span><span class="s2">.</span><span class="s1">flag</span><span class="s2">.</span><span class="s1">startswith</span><span class="s2">(</span><span class="s5">&quot;The function value at x&quot;</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">res</span><span class="s2">.</span><span class="s1">function_calls </span><span class="s2">== </span><span class="s1">f</span><span class="s2">.</span><span class="s1">_count</span>
    <span class="s0">assert </span><span class="s1">str</span><span class="s2">(</span><span class="s1">res</span><span class="s2">.</span><span class="s1">root</span><span class="s2">) </span><span class="s0">in </span><span class="s1">res</span><span class="s2">.</span><span class="s1">flag</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'solver_name'</span><span class="s2">,</span>
                         <span class="s2">[</span><span class="s5">'brentq'</span><span class="s2">, </span><span class="s5">'brenth'</span><span class="s2">, </span><span class="s5">'bisect'</span><span class="s2">, </span><span class="s5">'ridder'</span><span class="s2">, </span><span class="s5">'toms748'</span><span class="s2">])</span>
<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'rs_interface'</span><span class="s2">, [</span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">])</span>
<span class="s0">def </span><span class="s1">test_function_calls</span><span class="s2">(</span><span class="s1">solver_name</span><span class="s2">, </span><span class="s1">rs_interface</span><span class="s2">):</span>
    <span class="s3"># There do not appear to be checks that the bracketing solvers report the</span>
    <span class="s3"># correct number of function evaluations. Check that this is the case.</span>
    <span class="s1">solver </span><span class="s2">= ((</span><span class="s0">lambda </span><span class="s1">f</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">: </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">bracket</span><span class="s2">=(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)))</span>
              <span class="s0">if </span><span class="s1">rs_interface </span><span class="s0">else </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">zeros</span><span class="s2">, </span><span class="s1">solver_name</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s1">f</span><span class="s2">.</span><span class="s1">calls </span><span class="s2">+= </span><span class="s4">1</span>
        <span class="s0">return </span><span class="s1">x</span><span class="s2">**</span><span class="s4">2 </span><span class="s2">- </span><span class="s4">1</span>
    <span class="s1">f</span><span class="s2">.</span><span class="s1">calls </span><span class="s2">= </span><span class="s4">0</span>

    <span class="s1">res </span><span class="s2">= </span><span class="s1">solver</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

    <span class="s0">if </span><span class="s1">rs_interface</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">res</span><span class="s2">.</span><span class="s1">function_calls </span><span class="s2">== </span><span class="s1">f</span><span class="s2">.</span><span class="s1">calls</span>
    <span class="s0">else</span><span class="s2">:</span>
        <span class="s0">assert </span><span class="s1">res</span><span class="s2">[</span><span class="s4">1</span><span class="s2">].</span><span class="s1">function_calls </span><span class="s2">== </span><span class="s1">f</span><span class="s2">.</span><span class="s1">calls</span>


<span class="s0">def </span><span class="s1">test_gh_14486_converged_false</span><span class="s2">():</span>
    <span class="s6">&quot;&quot;&quot;Test that zero slope with secant method results in a converged=False&quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">lhs</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">x </span><span class="s2">* </span><span class="s1">np</span><span class="s2">.</span><span class="s1">exp</span><span class="s2">(-</span><span class="s1">x</span><span class="s2">*</span><span class="s1">x</span><span class="s2">) - </span><span class="s4">0.07</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">warns</span><span class="s2">(</span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">'Tolerance of'</span><span class="s2">):</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s5">'secant'</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=-</span><span class="s4">0.15</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">=</span><span class="s4">1.0</span><span class="s2">)</span>
    <span class="s0">assert not </span><span class="s1">res</span><span class="s2">.</span><span class="s1">converged</span>
    <span class="s0">assert </span><span class="s1">res</span><span class="s2">.</span><span class="s1">flag </span><span class="s2">== </span><span class="s5">'convergence error'</span>

    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">warns</span><span class="s2">(</span><span class="s1">RuntimeWarning</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">'Tolerance of'</span><span class="s2">):</span>
        <span class="s1">res </span><span class="s2">= </span><span class="s1">newton</span><span class="s2">(</span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=-</span><span class="s4">0.15</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">disp</span><span class="s2">=</span><span class="s0">False</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)[</span><span class="s4">1</span><span class="s2">]</span>
    <span class="s0">assert not </span><span class="s1">res</span><span class="s2">.</span><span class="s1">converged</span>
    <span class="s0">assert </span><span class="s1">res</span><span class="s2">.</span><span class="s1">flag </span><span class="s2">== </span><span class="s5">'convergence error'</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'solver_name'</span><span class="s2">,</span>
                         <span class="s2">[</span><span class="s5">'brentq'</span><span class="s2">, </span><span class="s5">'brenth'</span><span class="s2">, </span><span class="s5">'bisect'</span><span class="s2">, </span><span class="s5">'ridder'</span><span class="s2">, </span><span class="s5">'toms748'</span><span class="s2">])</span>
<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'rs_interface'</span><span class="s2">, [</span><span class="s0">True</span><span class="s2">, </span><span class="s0">False</span><span class="s2">])</span>
<span class="s0">def </span><span class="s1">test_gh5584</span><span class="s2">(</span><span class="s1">solver_name</span><span class="s2">, </span><span class="s1">rs_interface</span><span class="s2">):</span>
    <span class="s3"># gh-5584 reported that an underflow can cause sign checks in the algorithm</span>
    <span class="s3"># to fail. Check that this is resolved.</span>
    <span class="s1">solver </span><span class="s2">= ((</span><span class="s0">lambda </span><span class="s1">f</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, **</span><span class="s1">kwargs</span><span class="s2">: </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">bracket</span><span class="s2">=(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">)))</span>
              <span class="s0">if </span><span class="s1">rs_interface </span><span class="s0">else </span><span class="s1">getattr</span><span class="s2">(</span><span class="s1">zeros</span><span class="s2">, </span><span class="s1">solver_name</span><span class="s2">))</span>

    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s4">1e-200</span><span class="s2">*</span><span class="s1">x</span>

    <span class="s3"># Report failure when signs are the same</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s5">'...must have different signs'</span><span class="s2">):</span>
        <span class="s1">solver</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, -</span><span class="s4">0.5</span><span class="s2">, -</span><span class="s4">0.4</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>

    <span class="s3"># Solve successfully when signs are different</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">solver</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, -</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.4</span><span class="s2">, </span><span class="s1">full_output</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">res </span><span class="s0">if </span><span class="s1">rs_interface </span><span class="s0">else </span><span class="s1">res</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]</span>
    <span class="s0">assert </span><span class="s1">res</span><span class="s2">.</span><span class="s1">converged</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">res</span><span class="s2">.</span><span class="s1">root</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-8</span><span class="s2">)</span>

    <span class="s3"># Solve successfully when one side is negative zero</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">solver</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, -</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">float</span><span class="s2">(</span><span class="s5">'-0.0'</span><span class="s2">), </span><span class="s1">full_output</span><span class="s2">=</span><span class="s0">True</span><span class="s2">)</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">res </span><span class="s0">if </span><span class="s1">rs_interface </span><span class="s0">else </span><span class="s1">res</span><span class="s2">[</span><span class="s4">1</span><span class="s2">]</span>
    <span class="s0">assert </span><span class="s1">res</span><span class="s2">.</span><span class="s1">converged</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">res</span><span class="s2">.</span><span class="s1">root</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-8</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_gh13407</span><span class="s2">():</span>
    <span class="s3"># gh-13407 reported that the message produced by `scipy.optimize.toms748`</span>
    <span class="s3"># when `rtol &lt; eps` is incorrect, and also that toms748 is unusual in</span>
    <span class="s3"># accepting `rtol` as low as eps while other solvers raise at 4*eps. Check</span>
    <span class="s3"># that the error message has been corrected and that `rtol=eps` can produce</span>
    <span class="s3"># a lower function value than `rtol=4*eps`.</span>
    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">x</span><span class="s2">**</span><span class="s4">3 </span><span class="s2">- </span><span class="s4">2</span><span class="s2">*</span><span class="s1">x </span><span class="s2">- </span><span class="s4">5</span>

    <span class="s1">xtol </span><span class="s2">= </span><span class="s4">1e-300</span>
    <span class="s1">eps </span><span class="s2">= </span><span class="s1">np</span><span class="s2">.</span><span class="s1">finfo</span><span class="s2">(</span><span class="s1">float</span><span class="s2">).</span><span class="s1">eps</span>
    <span class="s1">x1 </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">toms748</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s4">1e-10</span><span class="s2">, </span><span class="s4">1e10</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s1">xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s4">1</span><span class="s2">*</span><span class="s1">eps</span><span class="s2">)</span>
    <span class="s1">f1 </span><span class="s2">= </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x1</span><span class="s2">)</span>
    <span class="s1">x4 </span><span class="s2">= </span><span class="s1">zeros</span><span class="s2">.</span><span class="s1">toms748</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s4">1e-10</span><span class="s2">, </span><span class="s4">1e10</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s1">xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s4">4</span><span class="s2">*</span><span class="s1">eps</span><span class="s2">)</span>
    <span class="s1">f4 </span><span class="s2">= </span><span class="s1">f</span><span class="s2">(</span><span class="s1">x4</span><span class="s2">)</span>
    <span class="s0">assert </span><span class="s1">f1 </span><span class="s2">&lt; </span><span class="s1">f4</span>

    <span class="s3"># using old-style syntax to get exactly the same message</span>
    <span class="s1">message </span><span class="s2">= </span><span class="s5">fr&quot;rtol too small \(</span><span class="s0">{</span><span class="s1">eps</span><span class="s2">/</span><span class="s4">2</span><span class="s0">:</span><span class="s5">g</span><span class="s0">} </span><span class="s5">&lt; </span><span class="s0">{</span><span class="s1">eps</span><span class="s0">:</span><span class="s5">g</span><span class="s0">}</span><span class="s5">\)&quot;</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s1">message</span><span class="s2">):</span>
        <span class="s1">zeros</span><span class="s2">.</span><span class="s1">toms748</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s4">1e-10</span><span class="s2">, </span><span class="s4">1e10</span><span class="s2">, </span><span class="s1">xtol</span><span class="s2">=</span><span class="s1">xtol</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">=</span><span class="s1">eps</span><span class="s2">/</span><span class="s4">2</span><span class="s2">)</span>


<span class="s0">def </span><span class="s1">test_newton_complex_gh10103</span><span class="s2">():</span>
    <span class="s3"># gh-10103 reported a problem when `newton` is pass a Python complex x0,</span>
    <span class="s3"># no `fprime` (secant method), and no `x1` (`x1` must be constructed).</span>
    <span class="s3"># Check that this is resolved.</span>
    <span class="s0">def </span><span class="s1">f</span><span class="s2">(</span><span class="s1">z</span><span class="s2">):</span>
        <span class="s0">return </span><span class="s1">z </span><span class="s2">- </span><span class="s4">1</span>
    <span class="s1">res </span><span class="s2">= </span><span class="s1">newton</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s4">1</span><span class="s2">+</span><span class="s4">1j</span><span class="s2">)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">res</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-12</span><span class="s2">)</span>

    <span class="s1">res </span><span class="s2">= </span><span class="s1">root_scalar</span><span class="s2">(</span><span class="s1">f</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">=</span><span class="s4">1</span><span class="s2">+</span><span class="s4">1j</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">=</span><span class="s4">2</span><span class="s2">+</span><span class="s4">1.5j</span><span class="s2">, </span><span class="s1">method</span><span class="s2">=</span><span class="s5">'secant'</span><span class="s2">)</span>
    <span class="s1">assert_allclose</span><span class="s2">(</span><span class="s1">res</span><span class="s2">.</span><span class="s1">root</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">=</span><span class="s4">1e-12</span><span class="s2">)</span>


<span class="s2">@</span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">mark</span><span class="s2">.</span><span class="s1">parametrize</span><span class="s2">(</span><span class="s5">'method'</span><span class="s2">, </span><span class="s1">all_methods</span><span class="s2">)</span>
<span class="s0">def </span><span class="s1">test_maxiter_int_check_gh10236</span><span class="s2">(</span><span class="s1">method</span><span class="s2">):</span>
    <span class="s3"># gh-10236 reported that the error message when `maxiter` is not an integer</span>
    <span class="s3"># was difficult to interpret. Check that this was resolved (by gh-10907).</span>
    <span class="s1">message </span><span class="s2">= </span><span class="s5">&quot;'float' object cannot be interpreted as an integer&quot;</span>
    <span class="s0">with </span><span class="s1">pytest</span><span class="s2">.</span><span class="s1">raises</span><span class="s2">(</span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">match</span><span class="s2">=</span><span class="s1">message</span><span class="s2">):</span>
        <span class="s1">method</span><span class="s2">(</span><span class="s1">f1</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">=</span><span class="s4">72.45</span><span class="s2">)</span>
</pre>
</body>
</html>