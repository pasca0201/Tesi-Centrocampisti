<html>
<head>
<title>query.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #5f826b; font-style: italic;}
.s3 { color: #cf8e6d;}
.s4 { color: #bcbec4;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
query.py</font>
</center></td></tr></table>
<pre><span class="s0"># orm/query.py</span>
<span class="s0"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="s0"># &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of SQLAlchemy and is released under</span>
<span class="s0"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">&quot;&quot;&quot;The Query class and support. 
 
Defines the :class:`_query.Query` class, the central 
construct used by the ORM to construct database queries. 
 
The :class:`_query.Query` class should not be confused with the 
:class:`_expression.Select` class, which defines database 
SELECT operations at the SQL (non-ORM) level.  ``Query`` differs from 
``Select`` in that it returns ORM-mapped objects and interacts with an 
ORM session, whereas the ``Select`` construct interacts directly with the 
database to return iterable result sets. 
 
&quot;&quot;&quot;</span>
<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">import </span><span class="s1">collections</span><span class="s4">.</span><span class="s1">abc </span><span class="s3">as </span><span class="s1">collections_abc</span>
<span class="s3">import </span><span class="s1">operator</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Callable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Dict</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Generic</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterable</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Iterator</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">List</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Mapping</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Optional</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">overload</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Sequence</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Tuple</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Type</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TypeVar</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Union</span>

<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">attributes</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">interfaces</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">loading</span>
<span class="s3">from </span><span class="s4">. </span><span class="s3">import </span><span class="s1">util </span><span class="s3">as </span><span class="s1">orm_util</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_O</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_assertions</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">context </span><span class="s3">import </span><span class="s1">_column_descriptions</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">context </span><span class="s3">import </span><span class="s1">_determine_last_joined_entity</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">context </span><span class="s3">import </span><span class="s1">_legacy_filter_by_entity_zero</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">context </span><span class="s3">import </span><span class="s1">FromStatement</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">context </span><span class="s3">import </span><span class="s1">ORMCompileState</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">context </span><span class="s3">import </span><span class="s1">QueryContext</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">ORMColumnDescription</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">ORMColumnsClauseRole</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">util </span><span class="s3">import </span><span class="s1">AliasedClass</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">util </span><span class="s3">import </span><span class="s1">object_mapper</span>
<span class="s3">from </span><span class="s4">.</span><span class="s1">util </span><span class="s3">import </span><span class="s1">with_parent</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">exc </span><span class="s3">as </span><span class="s1">sa_exc</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">inspect</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">inspection</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">log</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">sql</span>
<span class="s3">from </span><span class="s4">.. </span><span class="s3">import </span><span class="s1">util</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">Result</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">engine </span><span class="s3">import </span><span class="s1">Row</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">event </span><span class="s3">import </span><span class="s1">dispatcher</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">event </span><span class="s3">import </span><span class="s1">EventTarget</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">coercions</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">expression</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">roles</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">Select</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">util </span><span class="s3">as </span><span class="s1">sql_util</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql </span><span class="s3">import </span><span class="s1">visitors</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_FromClauseArgument</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_TP</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">annotation </span><span class="s3">import </span><span class="s1">SupportsCloneAnnotations</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_entity_namespace_key</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_generative</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">_NoArg</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">Executable</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">Generative</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">BooleanClauseList</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">expression </span><span class="s3">import </span><span class="s1">Exists</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">_MemoizedSelectEntities</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">_SelectFromElements</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">ForUpdateArg</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">HasHints</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">HasPrefixes</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">HasSuffixes</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">LABEL_STYLE_TABLENAME_PLUS_COL</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">SelectLabelStyle</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Literal</span>
<span class="s3">from </span><span class="s4">..</span><span class="s1">util</span><span class="s4">.</span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Self</span>


<span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_EntityType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_ExternalEntityType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_InternalEntityType</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">SynchronizeSessionArgument</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">mapper </span><span class="s3">import </span><span class="s1">Mapper</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">path_registry </span><span class="s3">import </span><span class="s1">PathRegistry</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">session </span><span class="s3">import </span><span class="s1">_PKIdentityArgument</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">session </span><span class="s3">import </span><span class="s1">Session</span>
    <span class="s3">from </span><span class="s4">.</span><span class="s1">state </span><span class="s3">import </span><span class="s1">InstanceState</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">cursor </span><span class="s3">import </span><span class="s1">CursorResult</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">_ImmutableExecuteOptions</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">CompiledCacheType</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">IsolationLevel</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">interfaces </span><span class="s3">import </span><span class="s1">SchemaTranslateMapType</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">result </span><span class="s3">import </span><span class="s1">FrozenResult</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">engine</span><span class="s4">.</span><span class="s1">result </span><span class="s3">import </span><span class="s1">ScalarResult</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_ColumnExpressionArgument</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_ColumnExpressionOrStrLabelArgument</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_ColumnsClauseArgument</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_DMLColumnArgument</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_JoinTargetArgument</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_LimitOffsetType</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_MAYBE_ENTITY</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_no_kw</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_NOT_ENTITY</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_OnClauseArgument</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_PropagateAttrsType</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T0</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T1</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T2</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T3</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T4</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T5</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T6</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_T7</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">_typing </span><span class="s3">import </span><span class="s1">_TypedColumnClauseArgument </span><span class="s3">as </span><span class="s1">_TCCA</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">CacheableOptions</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">base </span><span class="s3">import </span><span class="s1">ExecutableOption</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">ColumnElement</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">elements </span><span class="s3">import </span><span class="s1">Label</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">_ForUpdateOfArgument</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">_JoinTargetElement</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">_SetupJoinsElement</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">Alias</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">CTE</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">ExecutableReturnsRows</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">FromClause</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">ScalarSelect</span>
    <span class="s3">from </span><span class="s4">..</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">selectable </span><span class="s3">import </span><span class="s1">Subquery</span>


<span class="s1">__all__ </span><span class="s4">= [</span><span class="s5">&quot;Query&quot;</span><span class="s4">, </span><span class="s5">&quot;QueryContext&quot;</span><span class="s4">]</span>

<span class="s1">_T </span><span class="s4">= </span><span class="s1">TypeVar</span><span class="s4">(</span><span class="s5">&quot;_T&quot;</span><span class="s4">, </span><span class="s1">bound</span><span class="s4">=</span><span class="s1">Any</span><span class="s4">)</span>


<span class="s4">@</span><span class="s1">inspection</span><span class="s4">.</span><span class="s1">_self_inspects</span>
<span class="s4">@</span><span class="s1">log</span><span class="s4">.</span><span class="s1">class_logger</span>
<span class="s3">class </span><span class="s1">Query</span><span class="s4">(</span>
    <span class="s1">_SelectFromElements</span><span class="s4">,</span>
    <span class="s1">SupportsCloneAnnotations</span><span class="s4">,</span>
    <span class="s1">HasPrefixes</span><span class="s4">,</span>
    <span class="s1">HasSuffixes</span><span class="s4">,</span>
    <span class="s1">HasHints</span><span class="s4">,</span>
    <span class="s1">EventTarget</span><span class="s4">,</span>
    <span class="s1">log</span><span class="s4">.</span><span class="s1">Identified</span><span class="s4">,</span>
    <span class="s1">Generative</span><span class="s4">,</span>
    <span class="s1">Executable</span><span class="s4">,</span>
    <span class="s1">Generic</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
<span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;ORM-level SQL construction object. 
 
    .. legacy:: The ORM :class:`.Query` object is a legacy construct 
       as of SQLAlchemy 2.0.   See the notes at the top of 
       :ref:`query_api_toplevel` for an overview, including links to migration 
       documentation. 
 
    :class:`_query.Query` objects are normally initially generated using the 
    :meth:`~.Session.query` method of :class:`.Session`, and in 
    less common cases by instantiating the :class:`_query.Query` directly and 
    associating with a :class:`.Session` using the 
    :meth:`_query.Query.with_session` 
    method. 
 
    &quot;&quot;&quot;</span>

    <span class="s0"># elements that are in Core and can be cached in the same way</span>
    <span class="s1">_where_criteria</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], ...] = ()</span>
    <span class="s1">_having_criteria</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], ...] = ()</span>

    <span class="s1">_order_by_clauses</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], ...] = ()</span>
    <span class="s1">_group_by_clauses</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], ...] = ()</span>
    <span class="s1">_limit_clause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span>
    <span class="s1">_offset_clause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span>

    <span class="s1">_distinct</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span>
    <span class="s1">_distinct_on</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], ...] = ()</span>

    <span class="s1">_for_update_arg</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ForUpdateArg</span><span class="s4">] = </span><span class="s3">None</span>
    <span class="s1">_correlate</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">, ...] = ()</span>
    <span class="s1">_auto_correlate</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s1">_from_obj</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">FromClause</span><span class="s4">, ...] = ()</span>
    <span class="s1">_setup_joins</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_SetupJoinsElement</span><span class="s4">, ...] = ()</span>

    <span class="s1">_label_style</span><span class="s4">: </span><span class="s1">SelectLabelStyle </span><span class="s4">= </span><span class="s1">SelectLabelStyle</span><span class="s4">.</span><span class="s1">LABEL_STYLE_LEGACY_ORM</span>

    <span class="s1">_memoized_select_entities </span><span class="s4">= ()</span>

    <span class="s1">_compile_options</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Type</span><span class="s4">[</span><span class="s1">CacheableOptions</span><span class="s4">], </span><span class="s1">CacheableOptions</span><span class="s4">] = (</span>
        <span class="s1">ORMCompileState</span><span class="s4">.</span><span class="s1">default_compile_options</span>
    <span class="s4">)</span>

    <span class="s1">_with_options</span><span class="s4">: </span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">ExecutableOption</span><span class="s4">, ...]</span>
    <span class="s1">load_options </span><span class="s4">= </span><span class="s1">QueryContext</span><span class="s4">.</span><span class="s1">default_load_options </span><span class="s4">+ {</span>
        <span class="s5">&quot;_legacy_uniquing&quot;</span><span class="s4">: </span><span class="s3">True</span>
    <span class="s4">}</span>

    <span class="s1">_params</span><span class="s4">: </span><span class="s1">util</span><span class="s4">.</span><span class="s1">immutabledict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">] = </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span>

    <span class="s0"># local Query builder state, not needed for</span>
    <span class="s0"># compilation or execution</span>
    <span class="s1">_enable_assertions </span><span class="s4">= </span><span class="s3">True</span>

    <span class="s1">_statement</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">ExecutableReturnsRows</span><span class="s4">] = </span><span class="s3">None</span>

    <span class="s1">session</span><span class="s4">: </span><span class="s1">Session</span>

    <span class="s1">dispatch</span><span class="s4">: </span><span class="s1">dispatcher</span><span class="s4">[</span><span class="s1">Query</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]</span>

    <span class="s0"># mirrors that of ClauseElement, used to propagate the &quot;orm&quot;</span>
    <span class="s0"># plugin as well as the &quot;subject&quot; of the plugin, e.g. the mapper</span>
    <span class="s0"># we are querying against.</span>
    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_propagate_attrs</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _PropagateAttrsType</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">util</span><span class="s4">.</span><span class="s1">EMPTY_DICT</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">entities</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
            <span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>
        <span class="s4">],</span>
        <span class="s1">session</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Session</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">):</span>
        <span class="s2">&quot;&quot;&quot;Construct a :class:`_query.Query` directly. 
 
        E.g.:: 
 
            q = Query([User, Address], session=some_session) 
 
        The above is equivalent to:: 
 
            q = some_session.query(User, Address) 
 
        :param entities: a sequence of entities and/or SQL expressions. 
 
        :param session: a :class:`.Session` with which the 
         :class:`_query.Query` 
         will be associated.   Optional; a :class:`_query.Query` 
         can be associated 
         with a :class:`.Session` generatively via the 
         :meth:`_query.Query.with_session` method as well. 
 
        .. seealso:: 
 
            :meth:`.Session.query` 
 
            :meth:`_query.Query.with_session` 
 
        &quot;&quot;&quot;</span>

        <span class="s0"># session is usually present.  There's one case in subqueryloader</span>
        <span class="s0"># where it stores a Query without a Session and also there are tests</span>
        <span class="s0"># for the query(Entity).with_session(session) API which is likely in</span>
        <span class="s0"># some old recipes, however these are legacy as select() can now be</span>
        <span class="s0"># used.</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">session </span><span class="s4">= </span><span class="s1">session  </span><span class="s0"># type: ignore</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_set_entities</span><span class="s4">(</span><span class="s1">entities</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_set_propagate_attrs</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">values</span><span class="s4">: </span><span class="s1">Mapping</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_propagate_attrs </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">immutabledict</span><span class="s4">(</span><span class="s1">values</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_set_entities</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">entities</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
            <span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>
        <span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns </span><span class="s4">= [</span>
            <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                <span class="s1">roles</span><span class="s4">.</span><span class="s1">ColumnsClauseRole</span><span class="s4">,</span>
                <span class="s1">ent</span><span class="s4">,</span>
                <span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">,</span>
                <span class="s1">post_inspect</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">ent </span><span class="s3">in </span><span class="s1">util</span><span class="s4">.</span><span class="s1">to_list</span><span class="s4">(</span><span class="s1">entities</span><span class="s4">)</span>
        <span class="s4">]</span>

    <span class="s3">def </span><span class="s1">tuples</span><span class="s4">(</span><span class="s1">self</span><span class="s4">: </span><span class="s1">Query</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">]) </span><span class="s1">-&gt; Query</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;return a tuple-typed form of this :class:`.Query`. 
 
        This method invokes the :meth:`.Query.only_return_tuples` 
        method with a value of ``True``, which by itself ensures that this 
        :class:`.Query` will always return :class:`.Row` objects, even 
        if the query is made against a single entity.  It then also 
        at the typing level will return a &quot;typed&quot; query, if possible, 
        that will type result rows as ``Tuple`` objects with typed 
        elements. 
 
        This method can be compared to the :meth:`.Result.tuples` method, 
        which returns &quot;self&quot;, but from a typing perspective returns an object 
        that will yield typed ``Tuple`` objects for results.   Typing 
        takes effect only if this :class:`.Query` object is a typed 
        query object already. 
 
        .. versionadded:: 2.0 
 
        .. seealso:: 
 
            :meth:`.Result.tuples` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">only_return_tuples</span><span class="s4">(</span><span class="s3">True</span><span class="s4">)  </span><span class="s0"># type: ignore</span>

    <span class="s3">def </span><span class="s1">_entity_from_pre_ent_zero</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">_InternalEntityType</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">:</span>
            <span class="s3">return None</span>

        <span class="s1">ent </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

        <span class="s3">if </span><span class="s5">&quot;parententity&quot; </span><span class="s3">in </span><span class="s1">ent</span><span class="s4">.</span><span class="s1">_annotations</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">ent</span><span class="s4">.</span><span class="s1">_annotations</span><span class="s4">[</span><span class="s5">&quot;parententity&quot;</span><span class="s4">]  </span><span class="s0"># type: ignore</span>
        <span class="s3">elif </span><span class="s5">&quot;bundle&quot; </span><span class="s3">in </span><span class="s1">ent</span><span class="s4">.</span><span class="s1">_annotations</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">ent</span><span class="s4">.</span><span class="s1">_annotations</span><span class="s4">[</span><span class="s5">&quot;bundle&quot;</span><span class="s4">]  </span><span class="s0"># type: ignore</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s0"># label, other SQL expression</span>
            <span class="s3">for </span><span class="s1">element </span><span class="s3">in </span><span class="s1">visitors</span><span class="s4">.</span><span class="s1">iterate</span><span class="s4">(</span><span class="s1">ent</span><span class="s4">):</span>
                <span class="s3">if </span><span class="s5">&quot;parententity&quot; </span><span class="s3">in </span><span class="s1">element</span><span class="s4">.</span><span class="s1">_annotations</span><span class="s4">:</span>
                    <span class="s3">return </span><span class="s1">element</span><span class="s4">.</span><span class="s1">_annotations</span><span class="s4">[</span><span class="s5">&quot;parententity&quot;</span><span class="s4">]  </span><span class="s0"># type: ignore  # noqa: E501</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">_only_full_mapper_zero</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">methname</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; Mapper</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">) != </span><span class="s6">1</span>
            <span class="s3">or </span><span class="s5">&quot;parententity&quot; </span><span class="s3">not in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">_annotations</span>
            <span class="s3">or not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">is_selectable</span>
        <span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;%s() can only be used against &quot;</span>
                <span class="s5">&quot;a single mapped class.&quot; </span><span class="s4">% </span><span class="s1">methname</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">_annotations</span><span class="s4">[</span><span class="s5">&quot;parententity&quot;</span><span class="s4">]  </span><span class="s0"># type: ignore  # noqa: E501</span>

    <span class="s3">def </span><span class="s1">_set_select_from</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">obj</span><span class="s4">: </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">_FromClauseArgument</span><span class="s4">], </span><span class="s1">set_base_alias</span><span class="s4">: </span><span class="s1">bool</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">fa </span><span class="s4">= [</span>
            <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                <span class="s1">roles</span><span class="s4">.</span><span class="s1">StrictFromClauseRole</span><span class="s4">,</span>
                <span class="s1">elem</span><span class="s4">,</span>
                <span class="s1">allow_select</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
                <span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">elem </span><span class="s3">in </span><span class="s1">obj</span>
        <span class="s4">]</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_options </span><span class="s4">+= {</span><span class="s5">&quot;_set_base_alias&quot;</span><span class="s4">: </span><span class="s1">set_base_alias</span><span class="s4">}</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_from_obj </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">fa</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">_set_lazyload_from</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">state</span><span class="s4">: </span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">load_options </span><span class="s4">+= {</span><span class="s5">&quot;_lazy_loaded_from&quot;</span><span class="s4">: </span><span class="s1">state</span><span class="s4">}</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_get_condition</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;used by legacy BakedQuery&quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_no_criterion_condition</span><span class="s4">(</span><span class="s5">&quot;get&quot;</span><span class="s4">, </span><span class="s1">order_by</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">distinct</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_get_existing_condition</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_no_criterion_assertion</span><span class="s4">(</span><span class="s5">&quot;get&quot;</span><span class="s4">, </span><span class="s1">order_by</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">distinct</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_no_criterion_assertion</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">meth</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">order_by</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">, </span><span class="s1">distinct</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_enable_assertions</span><span class="s4">:</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_where_criteria</span>
            <span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_statement </span><span class="s3">is not None</span>
            <span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_from_obj</span>
            <span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_setup_joins</span>
            <span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_limit_clause </span><span class="s3">is not None</span>
            <span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_offset_clause </span><span class="s3">is not None</span>
            <span class="s3">or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_group_by_clauses</span>
            <span class="s3">or </span><span class="s4">(</span><span class="s1">order_by </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_order_by_clauses</span><span class="s4">)</span>
            <span class="s3">or </span><span class="s4">(</span><span class="s1">distinct </span><span class="s3">and </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_distinct</span><span class="s4">)</span>
        <span class="s4">):</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;Query.%s() being called on a &quot;</span>
                <span class="s5">&quot;Query with existing criterion. &quot; </span><span class="s4">% </span><span class="s1">meth</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_no_criterion_condition</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">meth</span><span class="s4">: </span><span class="s1">str</span><span class="s4">, </span><span class="s1">order_by</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">, </span><span class="s1">distinct</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_no_criterion_assertion</span><span class="s4">(</span><span class="s1">meth</span><span class="s4">, </span><span class="s1">order_by</span><span class="s4">, </span><span class="s1">distinct</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_from_obj </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_setup_joins </span><span class="s4">= ()</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_statement </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_options </span><span class="s4">+= {</span><span class="s5">&quot;_statement&quot;</span><span class="s4">: </span><span class="s3">None</span><span class="s4">}</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_where_criteria </span><span class="s4">= ()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_distinct </span><span class="s4">= </span><span class="s3">False</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_order_by_clauses </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_group_by_clauses </span><span class="s4">= ()</span>

    <span class="s3">def </span><span class="s1">_no_clauseelement_condition</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">meth</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_enable_assertions</span><span class="s4">:</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_order_by_clauses</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;Query.%s() being called on a &quot;</span>
                <span class="s5">&quot;Query with existing criterion. &quot; </span><span class="s4">% </span><span class="s1">meth</span>
            <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_no_criterion_condition</span><span class="s4">(</span><span class="s1">meth</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_no_statement_condition</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">meth</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_enable_assertions</span><span class="s4">:</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_statement </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s4">(</span>
                    <span class="s5">&quot;Query.%s() being called on a Query with an existing full &quot;</span>
                    <span class="s5">&quot;statement - can't apply criterion.&quot;</span>
                <span class="s4">)</span>
                <span class="s4">% </span><span class="s1">meth</span>
            <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_no_limit_offset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">meth</span><span class="s4">: </span><span class="s1">str</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_enable_assertions</span><span class="s4">:</span>
            <span class="s3">return</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_limit_clause </span><span class="s3">is not None or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_offset_clause </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;Query.%s() being called on a Query which already has LIMIT &quot;</span>
                <span class="s5">&quot;or OFFSET applied.  Call %s() before limit() or offset() &quot;</span>
                <span class="s5">&quot;are applied.&quot; </span><span class="s4">% (</span><span class="s1">meth</span><span class="s4">, </span><span class="s1">meth</span><span class="s4">)</span>
            <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_has_row_limiting_clause</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_limit_clause </span><span class="s3">is not None or </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_offset_clause </span><span class="s3">is not None</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_get_options</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">populate_existing</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">version_check</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">only_load_props</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">refresh_state</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">identity_token</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s1">load_options</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">] = {}</span>
        <span class="s1">compile_options</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">] = {}</span>

        <span class="s3">if </span><span class="s1">version_check</span><span class="s4">:</span>
            <span class="s1">load_options</span><span class="s4">[</span><span class="s5">&quot;_version_check&quot;</span><span class="s4">] = </span><span class="s1">version_check</span>
        <span class="s3">if </span><span class="s1">populate_existing</span><span class="s4">:</span>
            <span class="s1">load_options</span><span class="s4">[</span><span class="s5">&quot;_populate_existing&quot;</span><span class="s4">] = </span><span class="s1">populate_existing</span>
        <span class="s3">if </span><span class="s1">refresh_state</span><span class="s4">:</span>
            <span class="s1">load_options</span><span class="s4">[</span><span class="s5">&quot;_refresh_state&quot;</span><span class="s4">] = </span><span class="s1">refresh_state</span>
            <span class="s1">compile_options</span><span class="s4">[</span><span class="s5">&quot;_for_refresh_state&quot;</span><span class="s4">] = </span><span class="s3">True</span>
        <span class="s3">if </span><span class="s1">only_load_props</span><span class="s4">:</span>
            <span class="s1">compile_options</span><span class="s4">[</span><span class="s5">&quot;_only_load_props&quot;</span><span class="s4">] = </span><span class="s1">frozenset</span><span class="s4">(</span><span class="s1">only_load_props</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">identity_token</span><span class="s4">:</span>
            <span class="s1">load_options</span><span class="s4">[</span><span class="s5">&quot;_identity_token&quot;</span><span class="s4">] = </span><span class="s1">identity_token</span>

        <span class="s3">if </span><span class="s1">load_options</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">load_options </span><span class="s4">+= </span><span class="s1">load_options</span>
        <span class="s3">if </span><span class="s1">compile_options</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_options </span><span class="s4">+= </span><span class="s1">compile_options</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_clone</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_generate</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_get_select_statement_only</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_statement </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                <span class="s5">&quot;Can't call this method on a Query that uses from_statement()&quot;</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">cast</span><span class="s4">(</span><span class="s5">&quot;Select[_T]&quot;</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">statement</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">Select</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">], </span><span class="s1">FromStatement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;The full SELECT statement represented by this Query. 
 
        The statement by default will not have disambiguating labels 
        applied to the construct unless with_labels(True) is called 
        first. 
 
        &quot;&quot;&quot;</span>

        <span class="s0"># .statement can return the direct future.Select() construct here, as</span>
        <span class="s0"># long as we are not using subsequent adaption features that</span>
        <span class="s0"># are made against raw entities, e.g. from_self(), with_polymorphic(),</span>
        <span class="s0"># select_entity_from().  If these features are being used, then</span>
        <span class="s0"># the Select() we return will not have the correct .selected_columns</span>
        <span class="s0"># collection and will not embed in subsequent queries correctly.</span>
        <span class="s0"># We could find a way to make this collection &quot;correct&quot;, however</span>
        <span class="s0"># this would not be too different from doing the full compile as</span>
        <span class="s0"># we are doing in any case, the Select() would still not have the</span>
        <span class="s0"># proper state for other attributes like whereclause, order_by,</span>
        <span class="s0"># and these features are all deprecated in any case.</span>
        <span class="s0">#</span>
        <span class="s0"># for these reasons, Query is not a Select, it remains an ORM</span>
        <span class="s0"># object for which __clause_element__() must be called in order for</span>
        <span class="s0"># it to provide a real expression object.</span>
        <span class="s0">#</span>
        <span class="s0"># from there, it starts to look much like Query itself won't be</span>
        <span class="s0"># passed into the execute process and won't generate its own cache</span>
        <span class="s0"># key; this will all occur in terms of the ORM-enabled Select.</span>
        <span class="s3">if not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_options</span><span class="s4">.</span><span class="s1">_set_base_alias</span><span class="s4">:</span>
            <span class="s0"># if we don't have legacy top level aliasing features in use</span>
            <span class="s0"># then convert to a future select() directly</span>
            <span class="s1">stmt </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_statement_20</span><span class="s4">(</span><span class="s1">for_statement</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">stmt </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_state</span><span class="s4">(</span><span class="s1">for_statement</span><span class="s4">=</span><span class="s3">True</span><span class="s4">).</span><span class="s1">statement</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_params</span><span class="s4">:</span>
            <span class="s1">stmt </span><span class="s4">= </span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">params</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_params</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">stmt</span>

    <span class="s3">def </span><span class="s1">_final_statement</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">legacy_query_style</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">) </span><span class="s1">-&gt; Select</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the 'final' SELECT statement for this :class:`.Query`. 
 
        This is used by the testing suite only and is fairly inefficient. 
 
        This is the Core-only select() that will be rendered by a complete 
        compilation of this query, and is what .statement used to return 
        in 1.3. 
 
 
        &quot;&quot;&quot;</span>

        <span class="s1">q </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_clone</span><span class="s4">()</span>

        <span class="s3">return </span><span class="s1">q</span><span class="s4">.</span><span class="s1">_compile_state</span><span class="s4">(</span>
            <span class="s1">use_legacy_query_style</span><span class="s4">=</span><span class="s1">legacy_query_style</span>
        <span class="s4">).</span><span class="s1">statement  </span><span class="s0"># type: ignore</span>

    <span class="s3">def </span><span class="s1">_statement_20</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">for_statement</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">, </span><span class="s1">use_legacy_query_style</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">Select</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">], </span><span class="s1">FromStatement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
        <span class="s0"># TODO: this event needs to be deprecated, as it currently applies</span>
        <span class="s0"># only to ORM query and occurs at this spot that is now more</span>
        <span class="s0"># or less an artificial spot</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">before_compile</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">before_compile</span><span class="s4">:</span>
                <span class="s1">new_query </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">new_query </span><span class="s3">is not None and </span><span class="s1">new_query </span><span class="s3">is not </span><span class="s1">self</span><span class="s4">:</span>
                    <span class="s1">self </span><span class="s4">= </span><span class="s1">new_query</span>
                    <span class="s3">if not </span><span class="s1">fn</span><span class="s4">.</span><span class="s1">_bake_ok</span><span class="s4">:  </span><span class="s0"># type: ignore</span>
                        <span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_options </span><span class="s4">+= {</span><span class="s5">&quot;_bake_ok&quot;</span><span class="s4">: </span><span class="s3">False</span><span class="s4">}</span>

        <span class="s1">compile_options </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_options</span>
        <span class="s1">compile_options </span><span class="s4">+= {</span>
            <span class="s5">&quot;_for_statement&quot;</span><span class="s4">: </span><span class="s1">for_statement</span><span class="s4">,</span>
            <span class="s5">&quot;_use_legacy_query_style&quot;</span><span class="s4">: </span><span class="s1">use_legacy_query_style</span><span class="s4">,</span>
        <span class="s4">}</span>

        <span class="s1">stmt</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Select</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">], </span><span class="s1">FromStatement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_statement </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">stmt </span><span class="s4">= </span><span class="s1">FromStatement</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_statement</span><span class="s4">)</span>
            <span class="s1">stmt</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span>
                <span class="s1">_with_options</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_with_options</span><span class="s4">,</span>
                <span class="s1">_with_context_options</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_with_context_options</span><span class="s4">,</span>
                <span class="s1">_compile_options</span><span class="s4">=</span><span class="s1">compile_options</span><span class="s4">,</span>
                <span class="s1">_execution_options</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_execution_options</span><span class="s4">,</span>
                <span class="s1">_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_propagate_attrs</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s0"># Query / select() internal attributes are 99% cross-compatible</span>
            <span class="s1">stmt </span><span class="s4">= </span><span class="s1">Select</span><span class="s4">.</span><span class="s1">_create_raw_select</span><span class="s4">(**</span><span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">)</span>
            <span class="s1">stmt</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span>
                <span class="s1">_label_style</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_style</span><span class="s4">,</span>
                <span class="s1">_compile_options</span><span class="s4">=</span><span class="s1">compile_options</span><span class="s4">,</span>
                <span class="s1">_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_propagate_attrs</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s1">stmt</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;session&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>

        <span class="s0"># ensure the ORM context is used to compile the statement, even</span>
        <span class="s0"># if it has no ORM entities.  This is so ORM-only things like</span>
        <span class="s0"># _legacy_joins are picked up that wouldn't be picked up by the</span>
        <span class="s0"># Core statement context</span>
        <span class="s3">if </span><span class="s5">&quot;compile_state_plugin&quot; </span><span class="s3">not in </span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">_propagate_attrs</span><span class="s4">:</span>
            <span class="s1">stmt</span><span class="s4">.</span><span class="s1">_propagate_attrs </span><span class="s4">= </span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">_propagate_attrs</span><span class="s4">.</span><span class="s1">union</span><span class="s4">(</span>
                <span class="s4">{</span><span class="s5">&quot;compile_state_plugin&quot;</span><span class="s4">: </span><span class="s5">&quot;orm&quot;</span><span class="s4">, </span><span class="s5">&quot;plugin_subject&quot;</span><span class="s4">: </span><span class="s3">None</span><span class="s4">}</span>
            <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">stmt</span>

    <span class="s3">def </span><span class="s1">subquery</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">with_labels</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">reduce_columns</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Subquery</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return the full SELECT statement represented by 
        this :class:`_query.Query`, embedded within an 
        :class:`_expression.Alias`. 
 
        Eager JOIN generation within the query is disabled. 
 
        .. seealso:: 
 
            :meth:`_sql.Select.subquery` - v2 comparable method. 
 
        :param name: string name to be assigned as the alias; 
            this is passed through to :meth:`_expression.FromClause.alias`. 
            If ``None``, a name will be deterministically generated 
            at compile time. 
 
        :param with_labels: if True, :meth:`.with_labels` will be called 
         on the :class:`_query.Query` first to apply table-qualified labels 
         to all columns. 
 
        :param reduce_columns: if True, 
         :meth:`_expression.Select.reduce_columns` will 
         be called on the resulting :func:`_expression.select` construct, 
         to remove same-named columns where one also refers to the other 
         via foreign key or WHERE clause equivalence. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">q </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">enable_eagerloads</span><span class="s4">(</span><span class="s3">False</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">with_labels</span><span class="s4">:</span>
            <span class="s1">q </span><span class="s4">= </span><span class="s1">q</span><span class="s4">.</span><span class="s1">set_label_style</span><span class="s4">(</span><span class="s1">LABEL_STYLE_TABLENAME_PLUS_COL</span><span class="s4">)</span>

        <span class="s1">stmt </span><span class="s4">= </span><span class="s1">q</span><span class="s4">.</span><span class="s1">_get_select_statement_only</span><span class="s4">()</span>

        <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>
            <span class="s3">assert </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">stmt</span><span class="s4">, </span><span class="s1">Select</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">reduce_columns</span><span class="s4">:</span>
            <span class="s1">stmt </span><span class="s4">= </span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">reduce_columns</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">subquery</span><span class="s4">(</span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">cte</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">recursive</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">nesting</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; CTE</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return the full SELECT statement represented by this 
        :class:`_query.Query` represented as a common table expression (CTE). 
 
        Parameters and usage are the same as those of the 
        :meth:`_expression.SelectBase.cte` method; see that method for 
        further details. 
 
        Here is the `PostgreSQL WITH 
        RECURSIVE example 
        &lt;https://www.postgresql.org/docs/current/static/queries-with.html&gt;`_. 
        Note that, in this example, the ``included_parts`` cte and the 
        ``incl_alias`` alias of it are Core selectables, which 
        means the columns are accessed via the ``.c.`` attribute.  The 
        ``parts_alias`` object is an :func:`_orm.aliased` instance of the 
        ``Part`` entity, so column-mapped attributes are available 
        directly:: 
 
            from sqlalchemy.orm import aliased 
 
            class Part(Base): 
                __tablename__ = 'part' 
                part = Column(String, primary_key=True) 
                sub_part = Column(String, primary_key=True) 
                quantity = Column(Integer) 
 
            included_parts = session.query( 
                            Part.sub_part, 
                            Part.part, 
                            Part.quantity).\ 
                                filter(Part.part==&quot;our part&quot;).\ 
                                cte(name=&quot;included_parts&quot;, recursive=True) 
 
            incl_alias = aliased(included_parts, name=&quot;pr&quot;) 
            parts_alias = aliased(Part, name=&quot;p&quot;) 
            included_parts = included_parts.union_all( 
                session.query( 
                    parts_alias.sub_part, 
                    parts_alias.part, 
                    parts_alias.quantity).\ 
                        filter(parts_alias.part==incl_alias.c.sub_part) 
                ) 
 
            q = session.query( 
                    included_parts.c.sub_part, 
                    func.sum(included_parts.c.quantity). 
                        label('total_quantity') 
                ).\ 
                group_by(included_parts.c.sub_part) 
 
        .. seealso:: 
 
            :meth:`_sql.Select.cte` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">enable_eagerloads</span><span class="s4">(</span><span class="s3">False</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">_get_select_statement_only</span><span class="s4">()</span>
            <span class="s4">.</span><span class="s1">cte</span><span class="s4">(</span><span class="s1">name</span><span class="s4">=</span><span class="s1">name</span><span class="s4">, </span><span class="s1">recursive</span><span class="s4">=</span><span class="s1">recursive</span><span class="s4">, </span><span class="s1">nesting</span><span class="s4">=</span><span class="s1">nesting</span><span class="s4">)</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">label</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">name</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">str</span><span class="s4">]) </span><span class="s1">-&gt; Label</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the full SELECT statement represented by this 
        :class:`_query.Query`, converted 
        to a scalar subquery with a label of the given name. 
 
        .. seealso:: 
 
            :meth:`_sql.Select.label` - v2 comparable method. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">enable_eagerloads</span><span class="s4">(</span><span class="s3">False</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">_get_select_statement_only</span><span class="s4">()</span>
            <span class="s4">.</span><span class="s1">label</span><span class="s4">(</span><span class="s1">name</span><span class="s4">)</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">as_scalar</span><span class="s4">(  </span><span class="s0"># type: ignore[overload-overlap]</span>
        <span class="s1">self</span><span class="s4">: </span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_MAYBE_ENTITY</span><span class="s4">]],</span>
    <span class="s4">) </span><span class="s1">-&gt; ScalarSelect</span><span class="s4">[</span><span class="s1">_MAYBE_ENTITY</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">as_scalar</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">: </span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_NOT_ENTITY</span><span class="s4">]],</span>
    <span class="s4">) </span><span class="s1">-&gt; ScalarSelect</span><span class="s4">[</span><span class="s1">_NOT_ENTITY</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">as_scalar</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ScalarSelect</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">deprecated</span><span class="s4">(</span>
        <span class="s5">&quot;1.4&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;The :meth:`_query.Query.as_scalar` method is deprecated and will be &quot;</span>
        <span class="s5">&quot;removed in a future release.  Please refer to &quot;</span>
        <span class="s5">&quot;:meth:`_query.Query.scalar_subquery`.&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">as_scalar</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ScalarSelect</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the full SELECT statement represented by this 
        :class:`_query.Query`, converted to a scalar subquery. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">scalar_subquery</span><span class="s4">()</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">scalar_subquery</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">: </span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_MAYBE_ENTITY</span><span class="s4">]],</span>
    <span class="s4">) </span><span class="s1">-&gt; ScalarSelect</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">scalar_subquery</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">: </span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_NOT_ENTITY</span><span class="s4">]],</span>
    <span class="s4">) </span><span class="s1">-&gt; ScalarSelect</span><span class="s4">[</span><span class="s1">_NOT_ENTITY</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">scalar_subquery</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ScalarSelect</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s3">def </span><span class="s1">scalar_subquery</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; ScalarSelect</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the full SELECT statement represented by this 
        :class:`_query.Query`, converted to a scalar subquery. 
 
        Analogous to 
        :meth:`sqlalchemy.sql.expression.SelectBase.scalar_subquery`. 
 
        .. versionchanged:: 1.4 The :meth:`_query.Query.scalar_subquery` 
           method replaces the :meth:`_query.Query.as_scalar` method. 
 
        .. seealso:: 
 
            :meth:`_sql.Select.scalar_subquery` - v2 comparable method. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">enable_eagerloads</span><span class="s4">(</span><span class="s3">False</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">_get_select_statement_only</span><span class="s4">()</span>
            <span class="s4">.</span><span class="s1">scalar_subquery</span><span class="s4">()</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">selectable</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">Select</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">], </span><span class="s1">FromStatement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;Return the :class:`_expression.Select` object emitted by this 
        :class:`_query.Query`. 
 
        Used for :func:`_sa.inspect` compatibility, this is equivalent to:: 
 
            query.enable_eagerloads(False).with_labels().statement 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">__clause_element__</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">__clause_element__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">Select</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">], </span><span class="s1">FromStatement</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_with_compile_options</span><span class="s4">(</span>
                <span class="s1">_enable_eagerloads</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">_render_for_subquery</span><span class="s4">=</span><span class="s3">True</span>
            <span class="s4">)</span>
            <span class="s4">.</span><span class="s1">set_label_style</span><span class="s4">(</span><span class="s1">LABEL_STYLE_TABLENAME_PLUS_COL</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">statement</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">only_return_tuples</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">: </span><span class="s1">Query</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">], </span><span class="s1">value</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">True</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">only_return_tuples</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">: </span><span class="s1">Query</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">], </span><span class="s1">value</span><span class="s4">: </span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">False</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; Query</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">only_return_tuples</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">) </span><span class="s1">-&gt; Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;When set to True, the query results will always be a 
        :class:`.Row` object. 
 
        This can change a query that normally returns a single entity 
        as a scalar to return a :class:`.Row` result in all cases. 
 
        .. seealso:: 
 
            :meth:`.Query.tuples` - returns tuples, but also at the typing 
            level will type results as ``Tuple``. 
 
            :meth:`_query.Query.is_single_entity` 
 
            :meth:`_engine.Result.tuples` - v2 comparable method. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">load_options </span><span class="s4">+= </span><span class="s1">dict</span><span class="s4">(</span><span class="s1">_only_return_tuples</span><span class="s4">=</span><span class="s1">value</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">is_single_entity</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; bool</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Indicates if this :class:`_query.Query` 
        returns tuples or single entities. 
 
        Returns True if this query returns a single entity for each instance 
        in its result list, and False if this query returns a tuple of entities 
        for each result. 
 
        .. versionadded:: 1.3.11 
 
        .. seealso:: 
 
            :meth:`_query.Query.only_return_tuples` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s4">(</span>
            <span class="s3">not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">load_options</span><span class="s4">.</span><span class="s1">_only_return_tuples</span>
            <span class="s3">and </span><span class="s1">len</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">) == </span><span class="s6">1</span>
            <span class="s3">and </span><span class="s5">&quot;parententity&quot; </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">_annotations</span>
            <span class="s3">and </span><span class="s1">isinstance</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">[</span><span class="s6">0</span><span class="s4">].</span><span class="s1">_annotations</span><span class="s4">[</span><span class="s5">&quot;parententity&quot;</span><span class="s4">],</span>
                <span class="s1">ORMColumnsClauseRole</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">enable_eagerloads</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Control whether or not eager joins and subqueries are 
        rendered. 
 
        When set to False, the returned Query will not render 
        eager joins regardless of :func:`~sqlalchemy.orm.joinedload`, 
        :func:`~sqlalchemy.orm.subqueryload` options 
        or mapper-level ``lazy='joined'``/``lazy='subquery'`` 
        configurations. 
 
        This is used primarily when nesting the Query's 
        statement into a subquery or other 
        selectable, or when using :meth:`_query.Query.yield_per`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_options </span><span class="s4">+= {</span><span class="s5">&quot;_enable_eagerloads&quot;</span><span class="s4">: </span><span class="s1">value</span><span class="s4">}</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">_with_compile_options</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">opt</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_options </span><span class="s4">+= </span><span class="s1">opt</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">became_legacy_20</span><span class="s4">(</span>
        <span class="s5">&quot;:meth:`_orm.Query.with_labels` and :meth:`_orm.Query.apply_labels`&quot;</span><span class="s4">,</span>
        <span class="s1">alternative</span><span class="s4">=</span><span class="s5">&quot;Use set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL) &quot;</span>
        <span class="s5">&quot;instead.&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">with_labels</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">set_label_style</span><span class="s4">(</span>
            <span class="s1">SelectLabelStyle</span><span class="s4">.</span><span class="s1">LABEL_STYLE_TABLENAME_PLUS_COL</span>
        <span class="s4">)</span>

    <span class="s1">apply_labels </span><span class="s4">= </span><span class="s1">with_labels</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">get_label_style</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; SelectLabelStyle</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot; 
        Retrieve the current label style. 
 
        .. versionadded:: 1.4 
 
        .. seealso:: 
 
            :meth:`_sql.Select.get_label_style` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_style</span>

    <span class="s3">def </span><span class="s1">set_label_style</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">style</span><span class="s4">: </span><span class="s1">SelectLabelStyle</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s5">&quot;&quot;&quot;Apply column labels to the return value of Query.statement. 
 
        Indicates that this Query's `statement` accessor should return 
        a SELECT statement that applies labels to all columns in the 
        form &lt;tablename&gt;_&lt;columnname&gt;; this is commonly used to 
        disambiguate columns from multiple tables which have the same 
        name. 
 
        When the `Query` actually issues SQL to load rows, it always 
        uses column labeling. 
 
        .. note:: The :meth:`_query.Query.set_label_style` method *only* applies 
           the output of :attr:`_query.Query.statement`, and *not* to any of 
           the result-row invoking systems of :class:`_query.Query` itself, 
           e.g. 
           :meth:`_query.Query.first`, :meth:`_query.Query.all`, etc. 
           To execute 
           a query using :meth:`_query.Query.set_label_style`, invoke the 
           :attr:`_query.Query.statement` using :meth:`.Session.execute`:: 
 
                result = session.execute( 
                    query 
                    .set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL) 
                    .statement 
                ) 
 
        .. versionadded:: 1.4 
 
 
        .. seealso:: 
 
            :meth:`_sql.Select.set_label_style` - v2 equivalent method. 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_label_style </span><span class="s3">is not </span><span class="s1">style</span><span class="s4">:</span>
            <span class="s1">self </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_generate</span><span class="s4">()</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_label_style </span><span class="s4">= </span><span class="s1">style</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">enable_assertions</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Control whether assertions are generated. 
 
        When set to False, the returned Query will 
        not assert its state before certain operations, 
        including that LIMIT/OFFSET has not been applied 
        when filter() is called, no criterion exists 
        when get() is called, and no &quot;from_statement()&quot; 
        exists when filter()/order_by()/group_by() etc. 
        is called.  This more permissive mode is used by 
        custom Query subclasses to specify criterion or 
        other modifiers outside of the usual usage patterns. 
 
        Care should be taken to ensure that the usage 
        pattern is even possible.  A statement applied 
        by from_statement() will override any criterion 
        set by filter() or order_by(), for example. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_enable_assertions </span><span class="s4">= </span><span class="s1">value</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">whereclause</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">ColumnElement</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;A readonly attribute which returns the current WHERE criterion for 
        this Query. 
 
        This returned value is a SQL expression construct, or ``None`` if no 
        criterion has been established. 
 
        .. seealso:: 
 
            :attr:`_sql.Select.whereclause` - v2 equivalent property. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">BooleanClauseList</span><span class="s4">.</span><span class="s1">_construct_for_whereclause</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_where_criteria</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">_with_current_path</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">path</span><span class="s4">: </span><span class="s1">PathRegistry</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;indicate that this query applies to objects loaded 
        within a certain path. 
 
        Used by deferred loaders (see strategies.py) which transfer 
        query options from an originating query to a newly generated 
        query intended for the deferred load. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_options </span><span class="s4">+= {</span><span class="s5">&quot;_current_path&quot;</span><span class="s4">: </span><span class="s1">path</span><span class="s4">}</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">yield_per</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">count</span><span class="s4">: </span><span class="s1">int</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Yield only ``count`` rows at a time. 
 
        The purpose of this method is when fetching very large result sets 
        (&gt; 10K rows), to batch results in sub-collections and yield them 
        out partially, so that the Python interpreter doesn't need to declare 
        very large areas of memory which is both time consuming and leads 
        to excessive memory use.   The performance from fetching hundreds of 
        thousands of rows can often double when a suitable yield-per setting 
        (e.g. approximately 1000) is used, even with DBAPIs that buffer 
        rows (which are most). 
 
        As of SQLAlchemy 1.4, the :meth:`_orm.Query.yield_per` method is 
        equivalent to using the ``yield_per`` execution option at the ORM 
        level. See the section :ref:`orm_queryguide_yield_per` for further 
        background on this option. 
 
        .. seealso:: 
 
            :ref:`orm_queryguide_yield_per` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">load_options </span><span class="s4">+= {</span><span class="s5">&quot;_yield_per&quot;</span><span class="s4">: </span><span class="s1">count</span><span class="s4">}</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">became_legacy_20</span><span class="s4">(</span>
        <span class="s5">&quot;:meth:`_orm.Query.get`&quot;</span><span class="s4">,</span>
        <span class="s1">alternative</span><span class="s4">=</span><span class="s5">&quot;The method is now available as :meth:`_orm.Session.get`&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">get</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">ident</span><span class="s4">: </span><span class="s1">_PKIdentityArgument</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return an instance based on the given primary key identifier, 
        or ``None`` if not found. 
 
        E.g.:: 
 
            my_user = session.query(User).get(5) 
 
            some_object = session.query(VersionedFoo).get((5, 10)) 
 
            some_object = session.query(VersionedFoo).get( 
                {&quot;id&quot;: 5, &quot;version_id&quot;: 10}) 
 
        :meth:`_query.Query.get` is special in that it provides direct 
        access to the identity map of the owning :class:`.Session`. 
        If the given primary key identifier is present 
        in the local identity map, the object is returned 
        directly from this collection and no SQL is emitted, 
        unless the object has been marked fully expired. 
        If not present, 
        a SELECT is performed in order to locate the object. 
 
        :meth:`_query.Query.get` also will perform a check if 
        the object is present in the identity map and 
        marked as expired - a SELECT 
        is emitted to refresh the object as well as to 
        ensure that the row is still present. 
        If not, :class:`~sqlalchemy.orm.exc.ObjectDeletedError` is raised. 
 
        :meth:`_query.Query.get` is only used to return a single 
        mapped instance, not multiple instances or 
        individual column constructs, and strictly 
        on a single primary key value.  The originating 
        :class:`_query.Query` must be constructed in this way, 
        i.e. against a single mapped entity, 
        with no additional filtering criterion.  Loading 
        options via :meth:`_query.Query.options` may be applied 
        however, and will be used if the object is not 
        yet locally present. 
 
        :param ident: A scalar, tuple, or dictionary representing the 
         primary key.  For a composite (e.g. multiple column) primary key, 
         a tuple or dictionary should be passed. 
 
         For a single-column primary key, the scalar calling form is typically 
         the most expedient.  If the primary key of a row is the value &quot;5&quot;, 
         the call looks like:: 
 
            my_object = query.get(5) 
 
         The tuple form contains primary key values typically in 
         the order in which they correspond to the mapped 
         :class:`_schema.Table` 
         object's primary key columns, or if the 
         :paramref:`_orm.Mapper.primary_key` configuration parameter were 
         used, in 
         the order used for that parameter. For example, if the primary key 
         of a row is represented by the integer 
         digits &quot;5, 10&quot; the call would look like:: 
 
             my_object = query.get((5, 10)) 
 
         The dictionary form should include as keys the mapped attribute names 
         corresponding to each element of the primary key.  If the mapped class 
         has the attributes ``id``, ``version_id`` as the attributes which 
         store the object's primary key value, the call would look like:: 
 
            my_object = query.get({&quot;id&quot;: 5, &quot;version_id&quot;: 10}) 
 
         .. versionadded:: 1.3 the :meth:`_query.Query.get` 
            method now optionally 
            accepts a dictionary of attribute names to values in order to 
            indicate a primary key identifier. 
 
 
        :return: The object instance, or ``None``. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_no_criterion_assertion</span><span class="s4">(</span><span class="s5">&quot;get&quot;</span><span class="s4">, </span><span class="s1">order_by</span><span class="s4">=</span><span class="s3">False</span><span class="s4">, </span><span class="s1">distinct</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

        <span class="s0"># we still implement _get_impl() so that baked query can override</span>
        <span class="s0"># it</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_get_impl</span><span class="s4">(</span><span class="s1">ident</span><span class="s4">, </span><span class="s1">loading</span><span class="s4">.</span><span class="s1">load_on_pk_identity</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_get_impl</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">primary_key_identity</span><span class="s4">: </span><span class="s1">_PKIdentityArgument</span><span class="s4">,</span>
        <span class="s1">db_load_fn</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[..., </span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">identity_token</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s1">mapper </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_only_full_mapper_zero</span><span class="s4">(</span><span class="s5">&quot;get&quot;</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">_get_impl</span><span class="s4">(</span>
            <span class="s1">mapper</span><span class="s4">,</span>
            <span class="s1">primary_key_identity</span><span class="s4">,</span>
            <span class="s1">db_load_fn</span><span class="s4">,</span>
            <span class="s1">populate_existing</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">load_options</span><span class="s4">.</span><span class="s1">_populate_existing</span><span class="s4">,</span>
            <span class="s1">with_for_update</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_for_update_arg</span><span class="s4">,</span>
            <span class="s1">options</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_with_options</span><span class="s4">,</span>
            <span class="s1">identity_token</span><span class="s4">=</span><span class="s1">identity_token</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_execution_options</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">lazy_loaded_from</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">InstanceState</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;An :class:`.InstanceState` that is using this :class:`_query.Query` 
        for a lazy load operation. 
 
        .. deprecated:: 1.4  This attribute should be viewed via the 
           :attr:`.ORMExecuteState.lazy_loaded_from` attribute, within 
           the context of the :meth:`.SessionEvents.do_orm_execute` 
           event. 
 
        .. seealso:: 
 
            :attr:`.ORMExecuteState.lazy_loaded_from` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">load_options</span><span class="s4">.</span><span class="s1">_lazy_loaded_from  </span><span class="s0"># type: ignore</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">_current_path</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; PathRegistry</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_options</span><span class="s4">.</span><span class="s1">_current_path  </span><span class="s0"># type: ignore</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">correlate</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">fromclauses</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Literal</span><span class="s4">[</span><span class="s3">None</span><span class="s4">, </span><span class="s3">False</span><span class="s4">], </span><span class="s1">_FromClauseArgument</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a :class:`.Query` construct which will correlate the given 
        FROM clauses to that of an enclosing :class:`.Query` or 
        :func:`~.expression.select`. 
 
        The method here accepts mapped classes, :func:`.aliased` constructs, 
        and :class:`_orm.Mapper` constructs as arguments, which are resolved 
        into expression constructs, in addition to appropriate expression 
        constructs. 
 
        The correlation arguments are ultimately passed to 
        :meth:`_expression.Select.correlate` 
        after coercion to expression constructs. 
 
        The correlation arguments take effect in such cases 
        as when :meth:`_query.Query.from_self` is used, or when 
        a subquery as returned by :meth:`_query.Query.subquery` is 
        embedded in another :func:`_expression.select` construct. 
 
        .. seealso:: 
 
            :meth:`_sql.Select.correlate` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_auto_correlate </span><span class="s4">= </span><span class="s3">False</span>
        <span class="s3">if </span><span class="s1">fromclauses </span><span class="s3">and </span><span class="s1">fromclauses</span><span class="s4">[</span><span class="s6">0</span><span class="s4">] </span><span class="s3">in </span><span class="s4">{</span><span class="s3">None</span><span class="s4">, </span><span class="s3">False</span><span class="s4">}:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_correlate </span><span class="s4">= ()</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_correlate </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_correlate </span><span class="s4">+ </span><span class="s1">tuple</span><span class="s4">(</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">FromClauseRole</span><span class="s4">, </span><span class="s1">f</span><span class="s4">) </span><span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">fromclauses</span>
            <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">autoflush</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">setting</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a Query with a specific 'autoflush' setting. 
 
        As of SQLAlchemy 1.4, the :meth:`_orm.Query.autoflush` method 
        is equivalent to using the ``autoflush`` execution option at the 
        ORM level. See the section :ref:`orm_queryguide_autoflush` for 
        further background on this option. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">load_options </span><span class="s4">+= {</span><span class="s5">&quot;_autoflush&quot;</span><span class="s4">: </span><span class="s1">setting</span><span class="s4">}</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">populate_existing</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a :class:`_query.Query` 
        that will expire and refresh all instances 
        as they are loaded, or reused from the current :class:`.Session`. 
 
        As of SQLAlchemy 1.4, the :meth:`_orm.Query.populate_existing` method 
        is equivalent to using the ``populate_existing`` execution option at 
        the ORM level. See the section :ref:`orm_queryguide_populate_existing` 
        for further background on this option. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">load_options </span><span class="s4">+= {</span><span class="s5">&quot;_populate_existing&quot;</span><span class="s4">: </span><span class="s3">True</span><span class="s4">}</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">_with_invoke_all_eagers</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">value</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Set the 'invoke all eagers' flag which causes joined- and 
        subquery loaders to traverse into already-loaded related objects 
        and collections. 
 
        Default is that of :attr:`_query.Query._invoke_all_eagers`. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">load_options </span><span class="s4">+= {</span><span class="s5">&quot;_invoke_all_eagers&quot;</span><span class="s4">: </span><span class="s1">value</span><span class="s4">}</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">became_legacy_20</span><span class="s4">(</span>
        <span class="s5">&quot;:meth:`_orm.Query.with_parent`&quot;</span><span class="s4">,</span>
        <span class="s1">alternative</span><span class="s4">=</span><span class="s5">&quot;Use the :func:`_orm.with_parent` standalone construct.&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">preload_module</span><span class="s4">(</span><span class="s5">&quot;sqlalchemy.orm.relationships&quot;</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">with_parent</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">instance</span><span class="s4">: </span><span class="s1">object</span><span class="s4">,</span>
        <span class="s1">property</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[  </span><span class="s0"># noqa: A002</span>
            <span class="s1">attributes</span><span class="s4">.</span><span class="s1">QueryableAttribute</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
        <span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">from_entity</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_ExternalEntityType</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Add filtering criterion that relates the given instance 
        to a child object or collection, using its attribute state 
        as well as an established :func:`_orm.relationship()` 
        configuration. 
 
        The method uses the :func:`.with_parent` function to generate 
        the clause, the result of which is passed to 
        :meth:`_query.Query.filter`. 
 
        Parameters are the same as :func:`.with_parent`, with the exception 
        that the given property can be None, in which case a search is 
        performed against this :class:`_query.Query` object's target mapper. 
 
        :param instance: 
          An instance which has some :func:`_orm.relationship`. 
 
        :param property: 
          Class bound attribute which indicates 
          what relationship from the instance should be used to reconcile the 
          parent/child relationship. 
 
        :param from_entity: 
          Entity in which to consider as the left side.  This defaults to the 
          &quot;zero&quot; entity of the :class:`_query.Query` itself. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">relationships </span><span class="s4">= </span><span class="s1">util</span><span class="s4">.</span><span class="s1">preloaded</span><span class="s4">.</span><span class="s1">orm_relationships</span>

        <span class="s3">if </span><span class="s1">from_entity</span><span class="s4">:</span>
            <span class="s1">entity_zero </span><span class="s4">= </span><span class="s1">inspect</span><span class="s4">(</span><span class="s1">from_entity</span><span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">entity_zero </span><span class="s4">= </span><span class="s1">_legacy_filter_by_entity_zero</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">property </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s0"># TODO: deprecate, property has to be supplied</span>
            <span class="s1">mapper </span><span class="s4">= </span><span class="s1">object_mapper</span><span class="s4">(</span><span class="s1">instance</span><span class="s4">)</span>

            <span class="s3">for </span><span class="s1">prop </span><span class="s3">in </span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">iterate_properties</span><span class="s4">:</span>
                <span class="s3">if </span><span class="s4">(</span>
                    <span class="s1">isinstance</span><span class="s4">(</span><span class="s1">prop</span><span class="s4">, </span><span class="s1">relationships</span><span class="s4">.</span><span class="s1">RelationshipProperty</span><span class="s4">)</span>
                    <span class="s3">and </span><span class="s1">prop</span><span class="s4">.</span><span class="s1">mapper </span><span class="s3">is </span><span class="s1">entity_zero</span><span class="s4">.</span><span class="s1">mapper  </span><span class="s0"># type: ignore</span>
                <span class="s4">):</span>
                    <span class="s1">property </span><span class="s4">= </span><span class="s1">prop  </span><span class="s0"># type: ignore  # noqa: A001</span>
                    <span class="s3">break</span>
            <span class="s3">else</span><span class="s4">:</span>
                <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                    <span class="s5">&quot;Could not locate a property which relates instances &quot;</span>
                    <span class="s5">&quot;of class '%s' to instances of class '%s'&quot;</span>
                    <span class="s4">% (</span>
                        <span class="s1">entity_zero</span><span class="s4">.</span><span class="s1">mapper</span><span class="s4">.</span><span class="s1">class_</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">,  </span><span class="s0"># type: ignore</span>
                        <span class="s1">instance</span><span class="s4">.</span><span class="s1">__class__</span><span class="s4">.</span><span class="s1">__name__</span><span class="s4">,</span>
                    <span class="s4">)</span>
                <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">filter</span><span class="s4">(</span>
            <span class="s1">with_parent</span><span class="s4">(</span>
                <span class="s1">instance</span><span class="s4">,</span>
                <span class="s1">property</span><span class="s4">,  </span><span class="s0"># type: ignore</span>
                <span class="s1">entity_zero</span><span class="s4">.</span><span class="s1">entity</span><span class="s4">,  </span><span class="s0"># type: ignore</span>
            <span class="s4">)</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">add_entity</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">entity</span><span class="s4">: </span><span class="s1">_EntityType</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">alias</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Alias</span><span class="s4">, </span><span class="s1">Subquery</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;add a mapped entity to the list of result columns 
        to be returned. 
 
        .. seealso:: 
 
            :meth:`_sql.Select.add_columns` - v2 comparable method. 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">alias </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s0"># TODO: deprecate</span>
            <span class="s1">entity </span><span class="s4">= </span><span class="s1">AliasedClass</span><span class="s4">(</span><span class="s1">entity</span><span class="s4">, </span><span class="s1">alias</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">.</span><span class="s1">append</span><span class="s4">(</span>
            <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                <span class="s1">roles</span><span class="s4">.</span><span class="s1">ColumnsClauseRole</span><span class="s4">, </span><span class="s1">entity</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
            <span class="s4">)</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">with_session</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">session</span><span class="s4">: </span><span class="s1">Session</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a :class:`_query.Query` that will use the given 
        :class:`.Session`. 
 
        While the :class:`_query.Query` 
        object is normally instantiated using the 
        :meth:`.Session.query` method, it is legal to build the 
        :class:`_query.Query` 
        directly without necessarily using a :class:`.Session`.  Such a 
        :class:`_query.Query` object, or any :class:`_query.Query` 
        already associated 
        with a different :class:`.Session`, can produce a new 
        :class:`_query.Query` 
        object associated with a target session using this method:: 
 
            from sqlalchemy.orm import Query 
 
            query = Query([MyClass]).filter(MyClass.id == 5) 
 
            result = query.with_session(my_session).one() 
 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">session </span><span class="s4">= </span><span class="s1">session</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_legacy_from_self</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *</span><span class="s1">entities</span><span class="s4">: </span><span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s0"># used for query.count() as well as for the same</span>
        <span class="s0"># function in BakedQuery, as well as some old tests in test_baked.py.</span>

        <span class="s1">fromclause </span><span class="s4">= (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">set_label_style</span><span class="s4">(</span><span class="s1">LABEL_STYLE_TABLENAME_PLUS_COL</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">correlate</span><span class="s4">(</span><span class="s3">None</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">subquery</span><span class="s4">()</span>
            <span class="s4">.</span><span class="s1">_anonymous_fromclause</span><span class="s4">()</span>
        <span class="s4">)</span>

        <span class="s1">q </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_from_selectable</span><span class="s4">(</span><span class="s1">fromclause</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">entities</span><span class="s4">:</span>
            <span class="s1">q</span><span class="s4">.</span><span class="s1">_set_entities</span><span class="s4">(</span><span class="s1">entities</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">q</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">_set_enable_single_crit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">val</span><span class="s4">: </span><span class="s1">bool</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_options </span><span class="s4">+= {</span><span class="s5">&quot;_enable_single_crit&quot;</span><span class="s4">: </span><span class="s1">val</span><span class="s4">}</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">_from_selectable</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">fromclause</span><span class="s4">: </span><span class="s1">FromClause</span><span class="s4">, </span><span class="s1">set_entity_from</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">attr </span><span class="s3">in </span><span class="s4">(</span>
            <span class="s5">&quot;_where_criteria&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_order_by_clauses&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_group_by_clauses&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_limit_clause&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_offset_clause&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_last_joined_entity&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_setup_joins&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_memoized_select_entities&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_distinct&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_distinct_on&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_having_criteria&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_prefixes&quot;</span><span class="s4">,</span>
            <span class="s5">&quot;_suffixes&quot;</span><span class="s4">,</span>
        <span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s1">attr</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_set_select_from</span><span class="s4">([</span><span class="s1">fromclause</span><span class="s4">], </span><span class="s1">set_entity_from</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_options </span><span class="s4">+= {</span>
            <span class="s5">&quot;_enable_single_crit&quot;</span><span class="s4">: </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">}</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">deprecated</span><span class="s4">(</span>
        <span class="s5">&quot;1.4&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;:meth:`_query.Query.values` &quot;</span>
        <span class="s5">&quot;is deprecated and will be removed in a &quot;</span>
        <span class="s5">&quot;future release.  Please use :meth:`_query.Query.with_entities`&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">values</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">columns</span><span class="s4">: </span><span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return an iterator yielding result tuples corresponding 
        to the given list of columns 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_values_no_warn</span><span class="s4">(*</span><span class="s1">columns</span><span class="s4">)</span>

    <span class="s1">_values </span><span class="s4">= </span><span class="s1">values</span>

    <span class="s3">def </span><span class="s1">_values_no_warn</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *</span><span class="s1">columns</span><span class="s4">: </span><span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; Iterable</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s3">if not </span><span class="s1">columns</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">iter</span><span class="s4">(())</span>
        <span class="s1">q </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_clone</span><span class="s4">().</span><span class="s1">enable_eagerloads</span><span class="s4">(</span><span class="s3">False</span><span class="s4">)</span>
        <span class="s1">q</span><span class="s4">.</span><span class="s1">_set_entities</span><span class="s4">(</span><span class="s1">columns</span><span class="s4">)</span>
        <span class="s3">if not </span><span class="s1">q</span><span class="s4">.</span><span class="s1">load_options</span><span class="s4">.</span><span class="s1">_yield_per</span><span class="s4">:</span>
            <span class="s1">q</span><span class="s4">.</span><span class="s1">load_options </span><span class="s4">+= {</span><span class="s5">&quot;_yield_per&quot;</span><span class="s4">: </span><span class="s6">10</span><span class="s4">}</span>
        <span class="s3">return </span><span class="s1">iter</span><span class="s4">(</span><span class="s1">q</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">deprecated</span><span class="s4">(</span>
        <span class="s5">&quot;1.4&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;:meth:`_query.Query.value` &quot;</span>
        <span class="s5">&quot;is deprecated and will be removed in a &quot;</span>
        <span class="s5">&quot;future release.  Please use :meth:`_query.Query.with_entities` &quot;</span>
        <span class="s5">&quot;in combination with :meth:`_query.Query.scalar`&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">value</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a scalar result corresponding to the given 
        column expression. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">next</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_values_no_warn</span><span class="s4">(</span><span class="s1">column</span><span class="s4">))[</span><span class="s6">0</span><span class="s4">]  </span><span class="s0"># type: ignore</span>
        <span class="s3">except </span><span class="s1">StopIteration</span><span class="s4">:</span>
            <span class="s3">return None</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_entities</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">_entity</span><span class="s4">: </span><span class="s1">_EntityType</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">]) </span><span class="s1">-&gt; Query</span><span class="s4">[</span><span class="s1">_O</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_entities</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">_colexpr</span><span class="s4">: </span><span class="s1">roles</span><span class="s4">.</span><span class="s1">TypedColumnsClauseRole</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]: ...</span>

    <span class="s0"># START OVERLOADED FUNCTIONS self.with_entities RowReturningQuery 2-8</span>

    <span class="s0"># code within this block is **programmatically,</span>
    <span class="s0"># statically generated** by tools/generate_tuple_map_overloads.py</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_entities</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">], </span><span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_entities</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">], </span><span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">], </span><span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_entities</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">],</span>
        <span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">],</span>
        <span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">],</span>
        <span class="s1">__ent3</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T3</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">, </span><span class="s1">_T3</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_entities</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">],</span>
        <span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">],</span>
        <span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">],</span>
        <span class="s1">__ent3</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T3</span><span class="s4">],</span>
        <span class="s1">__ent4</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T4</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">, </span><span class="s1">_T3</span><span class="s4">, </span><span class="s1">_T4</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_entities</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">],</span>
        <span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">],</span>
        <span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">],</span>
        <span class="s1">__ent3</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T3</span><span class="s4">],</span>
        <span class="s1">__ent4</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T4</span><span class="s4">],</span>
        <span class="s1">__ent5</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T5</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">, </span><span class="s1">_T3</span><span class="s4">, </span><span class="s1">_T4</span><span class="s4">, </span><span class="s1">_T5</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_entities</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">],</span>
        <span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">],</span>
        <span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">],</span>
        <span class="s1">__ent3</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T3</span><span class="s4">],</span>
        <span class="s1">__ent4</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T4</span><span class="s4">],</span>
        <span class="s1">__ent5</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T5</span><span class="s4">],</span>
        <span class="s1">__ent6</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T6</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">, </span><span class="s1">_T3</span><span class="s4">, </span><span class="s1">_T4</span><span class="s4">, </span><span class="s1">_T5</span><span class="s4">, </span><span class="s1">_T6</span><span class="s4">]]: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_entities</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__ent0</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">],</span>
        <span class="s1">__ent1</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T1</span><span class="s4">],</span>
        <span class="s1">__ent2</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T2</span><span class="s4">],</span>
        <span class="s1">__ent3</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T3</span><span class="s4">],</span>
        <span class="s1">__ent4</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T4</span><span class="s4">],</span>
        <span class="s1">__ent5</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T5</span><span class="s4">],</span>
        <span class="s1">__ent6</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T6</span><span class="s4">],</span>
        <span class="s1">__ent7</span><span class="s4">: </span><span class="s1">_TCCA</span><span class="s4">[</span><span class="s1">_T7</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; RowReturningQuery</span><span class="s4">[</span><span class="s1">Tuple</span><span class="s4">[</span><span class="s1">_T0</span><span class="s4">, </span><span class="s1">_T1</span><span class="s4">, </span><span class="s1">_T2</span><span class="s4">, </span><span class="s1">_T3</span><span class="s4">, </span><span class="s1">_T4</span><span class="s4">, </span><span class="s1">_T5</span><span class="s4">, </span><span class="s1">_T6</span><span class="s4">, </span><span class="s1">_T7</span><span class="s4">]]: ...</span>

    <span class="s0"># END OVERLOADED FUNCTIONS self.with_entities</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">with_entities</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *</span><span class="s1">entities</span><span class="s4">: </span><span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]: ...</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">with_entities</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *</span><span class="s1">entities</span><span class="s4">: </span><span class="s1">_ColumnsClauseArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], **</span><span class="s1">__kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">r&quot;&quot;&quot;Return a new :class:`_query.Query` 
        replacing the SELECT list with the 
        given entities. 
 
        e.g.:: 
 
            # Users, filtered on some arbitrary criterion 
            # and then ordered by related email address 
            q = session.query(User).\ 
                        join(User.address).\ 
                        filter(User.name.like('%ed%')).\ 
                        order_by(Address.email) 
 
            # given *only* User.id==5, Address.email, and 'q', what 
            # would the *next* User in the result be ? 
            subq = q.with_entities(Address.email).\ 
                        order_by(None).\ 
                        filter(User.id==5).\ 
                        subquery() 
            q = q.join((subq, subq.c.email &lt; Address.email)).\ 
                        limit(1) 
 
        .. seealso:: 
 
            :meth:`_sql.Select.with_only_columns` - v2 comparable method. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">__kw</span><span class="s4">:</span>
            <span class="s3">raise </span><span class="s1">_no_kw</span><span class="s4">()</span>

        <span class="s0"># Query has all the same fields as Select for this operation</span>
        <span class="s0"># this could in theory be based on a protocol but not sure if it's</span>
        <span class="s0"># worth it</span>
        <span class="s1">_MemoizedSelectEntities</span><span class="s4">.</span><span class="s1">_generate_for_statement</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)  </span><span class="s0"># type: ignore</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_set_entities</span><span class="s4">(</span><span class="s1">entities</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">add_columns</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, *</span><span class="s1">column</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]</span>
    <span class="s4">) </span><span class="s1">-&gt; Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Add one or more column expressions to the list 
        of result columns to be returned. 
 
        .. seealso:: 
 
            :meth:`_sql.Select.add_columns` - v2 comparable method. 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns </span><span class="s4">= </span><span class="s1">list</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">.</span><span class="s1">extend</span><span class="s4">(</span>
            <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                <span class="s1">roles</span><span class="s4">.</span><span class="s1">ColumnsClauseRole</span><span class="s4">,</span>
                <span class="s1">c</span><span class="s4">,</span>
                <span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">,</span>
                <span class="s1">post_inspect</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s3">for </span><span class="s1">c </span><span class="s3">in </span><span class="s1">column</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">deprecated</span><span class="s4">(</span>
        <span class="s5">&quot;1.4&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;:meth:`_query.Query.add_column` &quot;</span>
        <span class="s5">&quot;is deprecated and will be removed in a &quot;</span>
        <span class="s5">&quot;future release.  Please use :meth:`_query.Query.add_columns`&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">add_column</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">column</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Add a column expression to the list of result columns to be 
        returned. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">add_columns</span><span class="s4">(</span><span class="s1">column</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">options</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">args</span><span class="s4">: </span><span class="s1">ExecutableOption</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new :class:`_query.Query` object, 
        applying the given list of 
        mapper options. 
 
        Most supplied options regard changing how column- and 
        relationship-mapped attributes are loaded. 
 
        .. seealso:: 
 
            :ref:`loading_columns` 
 
            :ref:`relationship_loader_options` 
 
        &quot;&quot;&quot;</span>

        <span class="s1">opts </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span><span class="s1">util</span><span class="s4">.</span><span class="s1">flatten_iterator</span><span class="s4">(</span><span class="s1">args</span><span class="s4">))</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_options</span><span class="s4">.</span><span class="s1">_current_path</span><span class="s4">:</span>
            <span class="s0"># opting for lower method overhead for the checks</span>
            <span class="s3">for </span><span class="s1">opt </span><span class="s3">in </span><span class="s1">opts</span><span class="s4">:</span>
                <span class="s3">if not </span><span class="s1">opt</span><span class="s4">.</span><span class="s1">_is_core </span><span class="s3">and </span><span class="s1">opt</span><span class="s4">.</span><span class="s1">_is_legacy_option</span><span class="s4">:  </span><span class="s0"># type: ignore</span>
                    <span class="s1">opt</span><span class="s4">.</span><span class="s1">process_query_conditionally</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)  </span><span class="s0"># type: ignore</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">opt </span><span class="s3">in </span><span class="s1">opts</span><span class="s4">:</span>
                <span class="s3">if not </span><span class="s1">opt</span><span class="s4">.</span><span class="s1">_is_core </span><span class="s3">and </span><span class="s1">opt</span><span class="s4">.</span><span class="s1">_is_legacy_option</span><span class="s4">:  </span><span class="s0"># type: ignore</span>
                    <span class="s1">opt</span><span class="s4">.</span><span class="s1">process_query</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)  </span><span class="s0"># type: ignore</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_with_options </span><span class="s4">+= </span><span class="s1">opts</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">with_transformation</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">: </span><span class="s1">Callable</span><span class="s4">[[</span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]], </span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]</span>
    <span class="s4">) </span><span class="s1">-&gt; Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return a new :class:`_query.Query` object transformed by 
        the given function. 
 
        E.g.:: 
 
            def filter_something(criterion): 
                def transform(q): 
                    return q.filter(criterion) 
                return transform 
 
            q = q.with_transformation(filter_something(x==5)) 
 
        This allows ad-hoc recipes to be created for :class:`_query.Query` 
        objects. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">fn</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">get_execution_options</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _ImmutableExecuteOptions</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Get the non-SQL options which will take effect during execution. 
 
        .. versionadded:: 1.3 
 
        .. seealso:: 
 
            :meth:`_query.Query.execution_options` 
 
            :meth:`_sql.Select.get_execution_options` - v2 comparable method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_execution_options</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">execution_options</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">compiled_cache</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">CompiledCacheType</span><span class="s4">] = ...,</span>
        <span class="s1">logging_token</span><span class="s4">: </span><span class="s1">str </span><span class="s4">= ...,</span>
        <span class="s1">isolation_level</span><span class="s4">: </span><span class="s1">IsolationLevel </span><span class="s4">= ...,</span>
        <span class="s1">no_parameters</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">stream_results</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">max_row_buffer</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= ...,</span>
        <span class="s1">yield_per</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= ...,</span>
        <span class="s1">insertmanyvalues_page_size</span><span class="s4">: </span><span class="s1">int </span><span class="s4">= ...,</span>
        <span class="s1">schema_translate_map</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">SchemaTranslateMapType</span><span class="s4">] = ...,</span>
        <span class="s1">populate_existing</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">autoflush</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">preserve_rowcount</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s4">**</span><span class="s1">opt</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">: ...</span>

    <span class="s4">@</span><span class="s1">overload</span>
    <span class="s3">def </span><span class="s1">execution_options</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">opt</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">: ...</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">execution_options</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Set non-SQL options which take effect during execution. 
 
        Options allowed here include all of those accepted by 
        :meth:`_engine.Connection.execution_options`, as well as a series 
        of ORM specific options: 
 
        ``populate_existing=True`` - equivalent to using 
        :meth:`_orm.Query.populate_existing` 
 
        ``autoflush=True|False`` - equivalent to using 
        :meth:`_orm.Query.autoflush` 
 
        ``yield_per=&lt;value&gt;`` - equivalent to using 
        :meth:`_orm.Query.yield_per` 
 
        Note that the ``stream_results`` execution option is enabled 
        automatically if the :meth:`~sqlalchemy.orm.query.Query.yield_per()` 
        method or execution option is used. 
 
        .. versionadded:: 1.4 - added ORM options to 
           :meth:`_orm.Query.execution_options` 
 
        The execution options may also be specified on a per execution basis 
        when using :term:`2.0 style` queries via the 
        :paramref:`_orm.Session.execution_options` parameter. 
 
        .. warning:: The 
           :paramref:`_engine.Connection.execution_options.stream_results` 
           parameter should not be used at the level of individual ORM 
           statement executions, as the :class:`_orm.Session` will not track 
           objects from different schema translate maps within a single 
           session.  For multiple schema translate maps within the scope of a 
           single :class:`_orm.Session`, see :ref:`examples_sharding`. 
 
 
        .. seealso:: 
 
            :ref:`engine_stream_results` 
 
            :meth:`_query.Query.get_execution_options` 
 
            :meth:`_sql.Select.execution_options` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_execution_options </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_execution_options</span><span class="s4">.</span><span class="s1">union</span><span class="s4">(</span><span class="s1">kwargs</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">with_for_update</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">nowait</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">read</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">of</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_ForUpdateOfArgument</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s1">skip_locked</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">key_share</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s5">&quot;&quot;&quot;return a new :class:`_query.Query` 
        with the specified options for the 
        ``FOR UPDATE`` clause. 
 
        The behavior of this method is identical to that of 
        :meth:`_expression.GenerativeSelect.with_for_update`. 
        When called with no arguments, 
        the resulting ``SELECT`` statement will have a ``FOR UPDATE`` clause 
        appended.  When additional arguments are specified, backend-specific 
        options such as ``FOR UPDATE NOWAIT`` or ``LOCK IN SHARE MODE`` 
        can take effect. 
 
        E.g.:: 
 
            q = sess.query(User).populate_existing().with_for_update(nowait=True, of=User) 
 
        The above query on a PostgreSQL backend will render like:: 
 
            SELECT users.id AS users_id FROM users FOR UPDATE OF users NOWAIT 
 
        .. warning:: 
 
            Using ``with_for_update`` in the context of eager loading 
            relationships is not officially supported or recommended by 
            SQLAlchemy and may not work with certain queries on various 
            database backends.  When ``with_for_update`` is successfully used 
            with a query that involves :func:`_orm.joinedload`, SQLAlchemy will 
            attempt to emit SQL that locks all involved tables. 
 
        .. note::  It is generally a good idea to combine the use of the 
           :meth:`_orm.Query.populate_existing` method when using the 
           :meth:`_orm.Query.with_for_update` method.   The purpose of 
           :meth:`_orm.Query.populate_existing` is to force all the data read 
           from the SELECT to be populated into the ORM objects returned, 
           even if these objects are already in the :term:`identity map`. 
 
        .. seealso:: 
 
            :meth:`_expression.GenerativeSelect.with_for_update` 
            - Core level method with 
            full argument and behavioral description. 
 
            :meth:`_orm.Query.populate_existing` - overwrites attributes of 
            objects already loaded in the identity map. 
 
        &quot;&quot;&quot;  </span><span class="s0"># noqa: E501</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_for_update_arg </span><span class="s4">= </span><span class="s1">ForUpdateArg</span><span class="s4">(</span>
            <span class="s1">read</span><span class="s4">=</span><span class="s1">read</span><span class="s4">,</span>
            <span class="s1">nowait</span><span class="s4">=</span><span class="s1">nowait</span><span class="s4">,</span>
            <span class="s1">of</span><span class="s4">=</span><span class="s1">of</span><span class="s4">,</span>
            <span class="s1">skip_locked</span><span class="s4">=</span><span class="s1">skip_locked</span><span class="s4">,</span>
            <span class="s1">key_share</span><span class="s4">=</span><span class="s1">key_share</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">params</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">__params</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">str</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Add values for bind parameters which may have been 
        specified in filter(). 
 
        Parameters may be specified using \**kwargs, or optionally a single 
        dictionary as the first positional argument. The reason for both is 
        that \**kwargs is convenient, however some parameter dictionaries 
        contain unicode keys in which case \**kwargs cannot be used. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">__params</span><span class="s4">:</span>
            <span class="s1">kw</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(</span><span class="s1">__params</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_params </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_params</span><span class="s4">.</span><span class="s1">union</span><span class="s4">(</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">where</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">criterion</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;A synonym for :meth:`.Query.filter`. 
 
        .. versionadded:: 1.4 
 
        .. seealso:: 
 
            :meth:`_sql.Select.where` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">filter</span><span class="s4">(*</span><span class="s1">criterion</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s4">@</span><span class="s1">_assertions</span><span class="s4">(</span><span class="s1">_no_statement_condition</span><span class="s4">, </span><span class="s1">_no_limit_offset</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">filter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">criterion</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Apply the given filtering criterion to a copy 
        of this :class:`_query.Query`, using SQL expressions. 
 
        e.g.:: 
 
            session.query(MyClass).filter(MyClass.name == 'some name') 
 
        Multiple criteria may be specified as comma separated; the effect 
        is that they will be joined together using the :func:`.and_` 
        function:: 
 
            session.query(MyClass).\ 
                filter(MyClass.name == 'some name', MyClass.id &gt; 5) 
 
        The criterion is any SQL expression object applicable to the 
        WHERE clause of a select.   String expressions are coerced 
        into SQL expression constructs via the :func:`_expression.text` 
        construct. 
 
        .. seealso:: 
 
            :meth:`_query.Query.filter_by` - filter on keyword expressions. 
 
            :meth:`_sql.Select.where` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">crit </span><span class="s3">in </span><span class="s1">list</span><span class="s4">(</span><span class="s1">criterion</span><span class="s4">):</span>
            <span class="s1">crit </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                <span class="s1">roles</span><span class="s4">.</span><span class="s1">WhereHavingRole</span><span class="s4">, </span><span class="s1">crit</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
            <span class="s4">)</span>

            <span class="s1">self</span><span class="s4">.</span><span class="s1">_where_criteria </span><span class="s4">+= (</span><span class="s1">crit</span><span class="s4">,)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">memoized_property</span>
    <span class="s3">def </span><span class="s1">_last_joined_entity</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">Union</span><span class="s4">[</span><span class="s1">_InternalEntityType</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">_JoinTargetElement</span><span class="s4">]]:</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_setup_joins</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">_determine_last_joined_entity</span><span class="s4">(</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_setup_joins</span><span class="s4">,</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">_filter_by_zero</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;for the filter_by() method, return the target entity for which 
        we will attempt to derive an expression from based on string name. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_setup_joins</span><span class="s4">:</span>
            <span class="s1">_last_joined_entity </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_last_joined_entity</span>
            <span class="s3">if </span><span class="s1">_last_joined_entity </span><span class="s3">is not None</span><span class="s4">:</span>
                <span class="s3">return </span><span class="s1">_last_joined_entity</span>

        <span class="s0"># discussion related to #7239</span>
        <span class="s0"># special check determines if we should try to derive attributes</span>
        <span class="s0"># for filter_by() from the &quot;from object&quot;, i.e., if the user</span>
        <span class="s0"># called query.select_from(some selectable).filter_by(some_attr=value).</span>
        <span class="s0"># We don't want to do that in the case that methods like</span>
        <span class="s0"># from_self(), select_entity_from(), or a set op like union() were</span>
        <span class="s0"># called; while these methods also place a</span>
        <span class="s0"># selectable in the _from_obj collection, they also set up</span>
        <span class="s0"># the _set_base_alias boolean which turns on the whole &quot;adapt the</span>
        <span class="s0"># entity to this selectable&quot; thing, meaning the query still continues</span>
        <span class="s0"># to construct itself in terms of the lead entity that was passed</span>
        <span class="s0"># to query(), e.g. query(User).from_self() is still in terms of User,</span>
        <span class="s0"># and not the subquery that from_self() created.   This feature of</span>
        <span class="s0"># &quot;implicitly adapt all occurrences of entity X to some arbitrary</span>
        <span class="s0"># subquery&quot; is the main thing I am trying to do away with in 2.0 as</span>
        <span class="s0"># users should now used aliased() for that, but I can't entirely get</span>
        <span class="s0"># rid of it due to query.union() and other set ops relying upon it.</span>
        <span class="s0">#</span>
        <span class="s0"># compare this to the base Select()._filter_by_zero() which can</span>
        <span class="s0"># just return self._from_obj[0] if present, because there is no</span>
        <span class="s0"># &quot;_set_base_alias&quot; feature.</span>
        <span class="s0">#</span>
        <span class="s0"># IOW, this conditional essentially detects if</span>
        <span class="s0"># &quot;select_from(some_selectable)&quot; has been called, as opposed to</span>
        <span class="s0"># &quot;select_entity_from()&quot;, &quot;from_self()&quot;</span>
        <span class="s0"># or &quot;union() / some_set_op()&quot;.</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_from_obj </span><span class="s3">and not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_options</span><span class="s4">.</span><span class="s1">_set_base_alias</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_from_obj</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>

    <span class="s3">def </span><span class="s1">filter_by</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, **</span><span class="s1">kwargs</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Apply the given filtering criterion to a copy 
        of this :class:`_query.Query`, using keyword expressions. 
 
        e.g.:: 
 
            session.query(MyClass).filter_by(name = 'some name') 
 
        Multiple criteria may be specified as comma separated; the effect 
        is that they will be joined together using the :func:`.and_` 
        function:: 
 
            session.query(MyClass).\ 
                filter_by(name = 'some name', id = 5) 
 
        The keyword expressions are extracted from the primary 
        entity of the query, or the last entity that was the 
        target of a call to :meth:`_query.Query.join`. 
 
        .. seealso:: 
 
            :meth:`_query.Query.filter` - filter on SQL expressions. 
 
            :meth:`_sql.Select.filter_by` - v2 comparable method. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">from_entity </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_filter_by_zero</span><span class="s4">()</span>

        <span class="s1">clauses </span><span class="s4">= [</span>
            <span class="s1">_entity_namespace_key</span><span class="s4">(</span><span class="s1">from_entity</span><span class="s4">, </span><span class="s1">key</span><span class="s4">) == </span><span class="s1">value</span>
            <span class="s3">for </span><span class="s1">key</span><span class="s4">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">kwargs</span><span class="s4">.</span><span class="s1">items</span><span class="s4">()</span>
        <span class="s4">]</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">filter</span><span class="s4">(*</span><span class="s1">clauses</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">order_by</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__first</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
            <span class="s1">Literal</span><span class="s4">[</span><span class="s3">None</span><span class="s4">, </span><span class="s3">False</span><span class="s4">, </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">],</span>
            <span class="s1">_ColumnExpressionOrStrLabelArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s4">] = </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">clauses</span><span class="s4">: </span><span class="s1">_ColumnExpressionOrStrLabelArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Apply one or more ORDER BY criteria to the query and return 
        the newly resulting :class:`_query.Query`. 
 
        e.g.:: 
 
            q = session.query(Entity).order_by(Entity.id, Entity.name) 
 
        Calling this method multiple times is equivalent to calling it once 
        with all the clauses concatenated. All existing ORDER BY criteria may 
        be cancelled by passing ``None`` by itself.  New ORDER BY criteria may 
        then be added by invoking :meth:`_orm.Query.order_by` again, e.g.:: 
 
            # will erase all ORDER BY and ORDER BY new_col alone 
            q = q.order_by(None).order_by(new_col) 
 
        .. seealso:: 
 
            These sections describe ORDER BY in terms of :term:`2.0 style` 
            invocation but apply to :class:`_orm.Query` as well: 
 
            :ref:`tutorial_order_by` - in the :ref:`unified_tutorial` 
 
            :ref:`tutorial_order_by_label` - in the :ref:`unified_tutorial` 
 
            :meth:`_sql.Select.order_by` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">for </span><span class="s1">assertion </span><span class="s3">in </span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_no_statement_condition</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_no_limit_offset</span><span class="s4">):</span>
            <span class="s1">assertion</span><span class="s4">(</span><span class="s5">&quot;order_by&quot;</span><span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">clauses </span><span class="s3">and </span><span class="s4">(</span><span class="s1">__first </span><span class="s3">is None or </span><span class="s1">__first </span><span class="s3">is False</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_order_by_clauses </span><span class="s4">= ()</span>
        <span class="s3">elif </span><span class="s1">__first </span><span class="s3">is not </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">:</span>
            <span class="s1">criterion </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">OrderByRole</span><span class="s4">, </span><span class="s1">clause</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">clause </span><span class="s3">in </span><span class="s4">(</span><span class="s1">__first</span><span class="s4">,) + </span><span class="s1">clauses</span>
            <span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_order_by_clauses </span><span class="s4">+= </span><span class="s1">criterion</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s3">def </span><span class="s1">group_by</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">__first</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
            <span class="s1">Literal</span><span class="s4">[</span><span class="s3">None</span><span class="s4">, </span><span class="s3">False</span><span class="s4">, </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">],</span>
            <span class="s1">_ColumnExpressionOrStrLabelArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s4">] = </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">,</span>
        <span class="s4">*</span><span class="s1">clauses</span><span class="s4">: </span><span class="s1">_ColumnExpressionOrStrLabelArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Apply one or more GROUP BY criterion to the query and return 
        the newly resulting :class:`_query.Query`. 
 
        All existing GROUP BY settings can be suppressed by 
        passing ``None`` - this will suppress any GROUP BY configured 
        on mappers as well. 
 
        .. seealso:: 
 
            These sections describe GROUP BY in terms of :term:`2.0 style` 
            invocation but apply to :class:`_orm.Query` as well: 
 
            :ref:`tutorial_group_by_w_aggregates` - in the 
            :ref:`unified_tutorial` 
 
            :ref:`tutorial_order_by_label` - in the :ref:`unified_tutorial` 
 
            :meth:`_sql.Select.group_by` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">for </span><span class="s1">assertion </span><span class="s3">in </span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_no_statement_condition</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_no_limit_offset</span><span class="s4">):</span>
            <span class="s1">assertion</span><span class="s4">(</span><span class="s5">&quot;group_by&quot;</span><span class="s4">)</span>

        <span class="s3">if not </span><span class="s1">clauses </span><span class="s3">and </span><span class="s4">(</span><span class="s1">__first </span><span class="s3">is None or </span><span class="s1">__first </span><span class="s3">is False</span><span class="s4">):</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_group_by_clauses </span><span class="s4">= ()</span>
        <span class="s3">elif </span><span class="s1">__first </span><span class="s3">is not </span><span class="s1">_NoArg</span><span class="s4">.</span><span class="s1">NO_ARG</span><span class="s4">:</span>
            <span class="s1">criterion </span><span class="s4">= </span><span class="s1">tuple</span><span class="s4">(</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">GroupByRole</span><span class="s4">, </span><span class="s1">clause</span><span class="s4">)</span>
                <span class="s3">for </span><span class="s1">clause </span><span class="s3">in </span><span class="s4">(</span><span class="s1">__first</span><span class="s4">,) + </span><span class="s1">clauses</span>
            <span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_group_by_clauses </span><span class="s4">+= </span><span class="s1">criterion</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s4">@</span><span class="s1">_assertions</span><span class="s4">(</span><span class="s1">_no_statement_condition</span><span class="s4">, </span><span class="s1">_no_limit_offset</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">having</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">having</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">bool</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Apply a HAVING criterion to the query and return the 
        newly resulting :class:`_query.Query`. 
 
        :meth:`_query.Query.having` is used in conjunction with 
        :meth:`_query.Query.group_by`. 
 
        HAVING criterion makes it possible to use filters on aggregate 
        functions like COUNT, SUM, AVG, MAX, and MIN, eg.:: 
 
            q = session.query(User.id).\ 
                        join(User.addresses).\ 
                        group_by(User.id).\ 
                        having(func.count(Address.id) &gt; 2) 
 
        .. seealso:: 
 
            :meth:`_sql.Select.having` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">for </span><span class="s1">criterion </span><span class="s3">in </span><span class="s1">having</span><span class="s4">:</span>
            <span class="s1">having_criteria </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                <span class="s1">roles</span><span class="s4">.</span><span class="s1">WhereHavingRole</span><span class="s4">, </span><span class="s1">criterion</span>
            <span class="s4">)</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_having_criteria </span><span class="s4">+= (</span><span class="s1">having_criteria</span><span class="s4">,)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_set_op</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">expr_fn</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, *</span><span class="s1">q</span><span class="s4">: </span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s1">list_of_queries </span><span class="s4">= (</span><span class="s1">self</span><span class="s4">,) + </span><span class="s1">q</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_from_selectable</span><span class="s4">(</span><span class="s1">expr_fn</span><span class="s4">(*(</span><span class="s1">list_of_queries</span><span class="s4">)).</span><span class="s1">subquery</span><span class="s4">())</span>

    <span class="s3">def </span><span class="s1">union</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">q</span><span class="s4">: </span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Produce a UNION of this Query against one or more queries. 
 
        e.g.:: 
 
            q1 = sess.query(SomeClass).filter(SomeClass.foo=='bar') 
            q2 = sess.query(SomeClass).filter(SomeClass.bar=='foo') 
 
            q3 = q1.union(q2) 
 
        The method accepts multiple Query objects so as to control 
        the level of nesting.  A series of ``union()`` calls such as:: 
 
            x.union(y).union(z).all() 
 
        will nest on each ``union()``, and produces:: 
 
            SELECT * FROM (SELECT * FROM (SELECT * FROM X UNION 
                            SELECT * FROM y) UNION SELECT * FROM Z) 
 
        Whereas:: 
 
            x.union(y, z).all() 
 
        produces:: 
 
            SELECT * FROM (SELECT * FROM X UNION SELECT * FROM y UNION 
                            SELECT * FROM Z) 
 
        Note that many database backends do not allow ORDER BY to 
        be rendered on a query called within UNION, EXCEPT, etc. 
        To disable all ORDER BY clauses including those configured 
        on mappers, issue ``query.order_by(None)`` - the resulting 
        :class:`_query.Query` object will not render ORDER BY within 
        its SELECT statement. 
 
        .. seealso:: 
 
            :meth:`_sql.Select.union` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_set_op</span><span class="s4">(</span><span class="s1">expression</span><span class="s4">.</span><span class="s1">union</span><span class="s4">, *</span><span class="s1">q</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">union_all</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">q</span><span class="s4">: </span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Produce a UNION ALL of this Query against one or more queries. 
 
        Works the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See 
        that method for usage examples. 
 
        .. seealso:: 
 
            :meth:`_sql.Select.union_all` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_set_op</span><span class="s4">(</span><span class="s1">expression</span><span class="s4">.</span><span class="s1">union_all</span><span class="s4">, *</span><span class="s1">q</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">intersect</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">q</span><span class="s4">: </span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Produce an INTERSECT of this Query against one or more queries. 
 
        Works the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See 
        that method for usage examples. 
 
        .. seealso:: 
 
            :meth:`_sql.Select.intersect` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_set_op</span><span class="s4">(</span><span class="s1">expression</span><span class="s4">.</span><span class="s1">intersect</span><span class="s4">, *</span><span class="s1">q</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">intersect_all</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">q</span><span class="s4">: </span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Produce an INTERSECT ALL of this Query against one or more queries. 
 
        Works the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See 
        that method for usage examples. 
 
        .. seealso:: 
 
            :meth:`_sql.Select.intersect_all` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_set_op</span><span class="s4">(</span><span class="s1">expression</span><span class="s4">.</span><span class="s1">intersect_all</span><span class="s4">, *</span><span class="s1">q</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">except_</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">q</span><span class="s4">: </span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Produce an EXCEPT of this Query against one or more queries. 
 
        Works the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See 
        that method for usage examples. 
 
        .. seealso:: 
 
            :meth:`_sql.Select.except_` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_set_op</span><span class="s4">(</span><span class="s1">expression</span><span class="s4">.</span><span class="s1">except_</span><span class="s4">, *</span><span class="s1">q</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">except_all</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">q</span><span class="s4">: </span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Produce an EXCEPT ALL of this Query against one or more queries. 
 
        Works the same way as :meth:`~sqlalchemy.orm.query.Query.union`. See 
        that method for usage examples. 
 
        .. seealso:: 
 
            :meth:`_sql.Select.except_all` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_set_op</span><span class="s4">(</span><span class="s1">expression</span><span class="s4">.</span><span class="s1">except_all</span><span class="s4">, *</span><span class="s1">q</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s4">@</span><span class="s1">_assertions</span><span class="s4">(</span><span class="s1">_no_statement_condition</span><span class="s4">, </span><span class="s1">_no_limit_offset</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">join</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">target</span><span class="s4">: </span><span class="s1">_JoinTargetArgument</span><span class="s4">,</span>
        <span class="s1">onclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_OnClauseArgument</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">isouter</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
        <span class="s1">full</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Create a SQL JOIN against this :class:`_query.Query` 
        object's criterion 
        and apply generatively, returning the newly resulting 
        :class:`_query.Query`. 
 
        **Simple Relationship Joins** 
 
        Consider a mapping between two classes ``User`` and ``Address``, 
        with a relationship ``User.addresses`` representing a collection 
        of ``Address`` objects associated with each ``User``.   The most 
        common usage of :meth:`_query.Query.join` 
        is to create a JOIN along this 
        relationship, using the ``User.addresses`` attribute as an indicator 
        for how this should occur:: 
 
            q = session.query(User).join(User.addresses) 
 
        Where above, the call to :meth:`_query.Query.join` along 
        ``User.addresses`` will result in SQL approximately equivalent to:: 
 
            SELECT user.id, user.name 
            FROM user JOIN address ON user.id = address.user_id 
 
        In the above example we refer to ``User.addresses`` as passed to 
        :meth:`_query.Query.join` as the &quot;on clause&quot;, that is, it indicates 
        how the &quot;ON&quot; portion of the JOIN should be constructed. 
 
        To construct a chain of joins, multiple :meth:`_query.Query.join` 
        calls may be used.  The relationship-bound attribute implies both 
        the left and right side of the join at once:: 
 
            q = session.query(User).\ 
                    join(User.orders).\ 
                    join(Order.items).\ 
                    join(Item.keywords) 
 
        .. note:: as seen in the above example, **the order in which each 
           call to the join() method occurs is important**.    Query would not, 
           for example, know how to join correctly if we were to specify 
           ``User``, then ``Item``, then ``Order``, in our chain of joins; in 
           such a case, depending on the arguments passed, it may raise an 
           error that it doesn't know how to join, or it may produce invalid 
           SQL in which case the database will raise an error. In correct 
           practice, the 
           :meth:`_query.Query.join` method is invoked in such a way that lines 
           up with how we would want the JOIN clauses in SQL to be 
           rendered, and each call should represent a clear link from what 
           precedes it. 
 
        **Joins to a Target Entity or Selectable** 
 
        A second form of :meth:`_query.Query.join` allows any mapped entity or 
        core selectable construct as a target.   In this usage, 
        :meth:`_query.Query.join` will attempt to create a JOIN along the 
        natural foreign key relationship between two entities:: 
 
            q = session.query(User).join(Address) 
 
        In the above calling form, :meth:`_query.Query.join` is called upon to 
        create the &quot;on clause&quot; automatically for us.  This calling form will 
        ultimately raise an error if either there are no foreign keys between 
        the two entities, or if there are multiple foreign key linkages between 
        the target entity and the entity or entities already present on the 
        left side such that creating a join requires more information.  Note 
        that when indicating a join to a target without any ON clause, ORM 
        configured relationships are not taken into account. 
 
        **Joins to a Target with an ON Clause** 
 
        The third calling form allows both the target entity as well 
        as the ON clause to be passed explicitly.    A example that includes 
        a SQL expression as the ON clause is as follows:: 
 
            q = session.query(User).join(Address, User.id==Address.user_id) 
 
        The above form may also use a relationship-bound attribute as the 
        ON clause as well:: 
 
            q = session.query(User).join(Address, User.addresses) 
 
        The above syntax can be useful for the case where we wish 
        to join to an alias of a particular target entity.  If we wanted 
        to join to ``Address`` twice, it could be achieved using two 
        aliases set up using the :func:`~sqlalchemy.orm.aliased` function:: 
 
            a1 = aliased(Address) 
            a2 = aliased(Address) 
 
            q = session.query(User).\ 
                    join(a1, User.addresses).\ 
                    join(a2, User.addresses).\ 
                    filter(a1.email_address=='ed@foo.com').\ 
                    filter(a2.email_address=='ed@bar.com') 
 
        The relationship-bound calling form can also specify a target entity 
        using the :meth:`_orm.PropComparator.of_type` method; a query 
        equivalent to the one above would be:: 
 
            a1 = aliased(Address) 
            a2 = aliased(Address) 
 
            q = session.query(User).\ 
                    join(User.addresses.of_type(a1)).\ 
                    join(User.addresses.of_type(a2)).\ 
                    filter(a1.email_address == 'ed@foo.com').\ 
                    filter(a2.email_address == 'ed@bar.com') 
 
        **Augmenting Built-in ON Clauses** 
 
        As a substitute for providing a full custom ON condition for an 
        existing relationship, the :meth:`_orm.PropComparator.and_` function 
        may be applied to a relationship attribute to augment additional 
        criteria into the ON clause; the additional criteria will be combined 
        with the default criteria using AND:: 
 
            q = session.query(User).join( 
                User.addresses.and_(Address.email_address != 'foo@bar.com') 
            ) 
 
        .. versionadded:: 1.4 
 
        **Joining to Tables and Subqueries** 
 
 
        The target of a join may also be any table or SELECT statement, 
        which may be related to a target entity or not.   Use the 
        appropriate ``.subquery()`` method in order to make a subquery 
        out of a query:: 
 
            subq = session.query(Address).\ 
                filter(Address.email_address == 'ed@foo.com').\ 
                subquery() 
 
 
            q = session.query(User).join( 
                subq, User.id == subq.c.user_id 
            ) 
 
        Joining to a subquery in terms of a specific relationship and/or 
        target entity may be achieved by linking the subquery to the 
        entity using :func:`_orm.aliased`:: 
 
            subq = session.query(Address).\ 
                filter(Address.email_address == 'ed@foo.com').\ 
                subquery() 
 
            address_subq = aliased(Address, subq) 
 
            q = session.query(User).join( 
                User.addresses.of_type(address_subq) 
            ) 
 
 
        **Controlling what to Join From** 
 
        In cases where the left side of the current state of 
        :class:`_query.Query` is not in line with what we want to join from, 
        the :meth:`_query.Query.select_from` method may be used:: 
 
            q = session.query(Address).select_from(User).\ 
                            join(User.addresses).\ 
                            filter(User.name == 'ed') 
 
        Which will produce SQL similar to:: 
 
            SELECT address.* FROM user 
                JOIN address ON user.id=address.user_id 
                WHERE user.name = :name_1 
 
        .. seealso:: 
 
            :meth:`_sql.Select.join` - v2 equivalent method. 
 
        :param \*props: Incoming arguments for :meth:`_query.Query.join`, 
         the props collection in modern use should be considered to be a  one 
         or two argument form, either as a single &quot;target&quot; entity or ORM 
         attribute-bound relationship, or as a target entity plus an &quot;on 
         clause&quot; which  may be a SQL expression or ORM attribute-bound 
         relationship. 
 
        :param isouter=False: If True, the join used will be a left outer join, 
         just as if the :meth:`_query.Query.outerjoin` method were called. 
 
        :param full=False: render FULL OUTER JOIN; implies ``isouter``. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">join_target </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">JoinTargetRole</span><span class="s4">,</span>
            <span class="s1">target</span><span class="s4">,</span>
            <span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span><span class="s4">,</span>
            <span class="s1">legacy</span><span class="s4">=</span><span class="s3">True</span><span class="s4">,</span>
        <span class="s4">)</span>
        <span class="s3">if </span><span class="s1">onclause </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">onclause_element </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
                <span class="s1">roles</span><span class="s4">.</span><span class="s1">OnClauseRole</span><span class="s4">, </span><span class="s1">onclause</span><span class="s4">, </span><span class="s1">legacy</span><span class="s4">=</span><span class="s3">True</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">onclause_element </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_setup_joins </span><span class="s4">+= (</span>
            <span class="s4">(</span>
                <span class="s1">join_target</span><span class="s4">,</span>
                <span class="s1">onclause_element</span><span class="s4">,</span>
                <span class="s3">None</span><span class="s4">,</span>
                <span class="s4">{</span>
                    <span class="s5">&quot;isouter&quot;</span><span class="s4">: </span><span class="s1">isouter</span><span class="s4">,</span>
                    <span class="s5">&quot;full&quot;</span><span class="s4">: </span><span class="s1">full</span><span class="s4">,</span>
                <span class="s4">},</span>
            <span class="s4">),</span>
        <span class="s4">)</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">__dict__</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;_last_joined_entity&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">outerjoin</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">target</span><span class="s4">: </span><span class="s1">_JoinTargetArgument</span><span class="s4">,</span>
        <span class="s1">onclause</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">_OnClauseArgument</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
        <span class="s4">*,</span>
        <span class="s1">full</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Create a left outer join against this ``Query`` object's criterion 
        and apply generatively, returning the newly resulting ``Query``. 
 
        Usage is the same as the ``join()`` method. 
 
        .. seealso:: 
 
            :meth:`_sql.Select.outerjoin` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">join</span><span class="s4">(</span><span class="s1">target</span><span class="s4">, </span><span class="s1">onclause</span><span class="s4">=</span><span class="s1">onclause</span><span class="s4">, </span><span class="s1">isouter</span><span class="s4">=</span><span class="s3">True</span><span class="s4">, </span><span class="s1">full</span><span class="s4">=</span><span class="s1">full</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s4">@</span><span class="s1">_assertions</span><span class="s4">(</span><span class="s1">_no_statement_condition</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">reset_joinpoint</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return a new :class:`.Query`, where the &quot;join point&quot; has 
        been reset back to the base FROM entities of the query. 
 
        This method is usually used in conjunction with the 
        ``aliased=True`` feature of the :meth:`~.Query.join` 
        method.  See the example in :meth:`~.Query.join` for how 
        this is used. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_last_joined_entity </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s4">@</span><span class="s1">_assertions</span><span class="s4">(</span><span class="s1">_no_clauseelement_condition</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">select_from</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">from_obj</span><span class="s4">: </span><span class="s1">_FromClauseArgument</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Set the FROM clause of this :class:`.Query` explicitly. 
 
        :meth:`.Query.select_from` is often used in conjunction with 
        :meth:`.Query.join` in order to control which entity is selected 
        from on the &quot;left&quot; side of the join. 
 
        The entity or selectable object here effectively replaces the 
        &quot;left edge&quot; of any calls to :meth:`~.Query.join`, when no 
        joinpoint is otherwise established - usually, the default &quot;join 
        point&quot; is the leftmost entity in the :class:`~.Query` object's 
        list of entities to be selected. 
 
        A typical example:: 
 
            q = session.query(Address).select_from(User).\ 
                join(User.addresses).\ 
                filter(User.name == 'ed') 
 
        Which produces SQL equivalent to:: 
 
            SELECT address.* FROM user 
            JOIN address ON user.id=address.user_id 
            WHERE user.name = :name_1 
 
        :param \*from_obj: collection of one or more entities to apply 
         to the FROM clause.  Entities can be mapped classes, 
         :class:`.AliasedClass` objects, :class:`.Mapper` objects 
         as well as core :class:`.FromClause` elements like subqueries. 
 
        .. seealso:: 
 
            :meth:`~.Query.join` 
 
            :meth:`.Query.select_entity_from` 
 
            :meth:`_sql.Select.select_from` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_set_select_from</span><span class="s4">(</span><span class="s1">from_obj</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__getitem__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">item</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">orm_util</span><span class="s4">.</span><span class="s1">_getitem</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">,</span>
            <span class="s1">item</span><span class="s4">,</span>
        <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s4">@</span><span class="s1">_assertions</span><span class="s4">(</span><span class="s1">_no_statement_condition</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">slice</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">start</span><span class="s4">: </span><span class="s1">int</span><span class="s4">,</span>
        <span class="s1">stop</span><span class="s4">: </span><span class="s1">int</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Computes the &quot;slice&quot; of the :class:`_query.Query` represented by 
        the given indices and returns the resulting :class:`_query.Query`. 
 
        The start and stop indices behave like the argument to Python's 
        built-in :func:`range` function. This method provides an 
        alternative to using ``LIMIT``/``OFFSET`` to get a slice of the 
        query. 
 
        For example, :: 
 
            session.query(User).order_by(User.id).slice(1, 3) 
 
        renders as 
 
        .. sourcecode:: sql 
 
           SELECT users.id AS users_id, 
                  users.name AS users_name 
           FROM users ORDER BY users.id 
           LIMIT ? OFFSET ? 
           (2, 1) 
 
        .. seealso:: 
 
           :meth:`_query.Query.limit` 
 
           :meth:`_query.Query.offset` 
 
           :meth:`_sql.Select.slice` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">self</span><span class="s4">.</span><span class="s1">_limit_clause</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_offset_clause </span><span class="s4">= </span><span class="s1">sql_util</span><span class="s4">.</span><span class="s1">_make_slice</span><span class="s4">(</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_limit_clause</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_offset_clause</span><span class="s4">, </span><span class="s1">start</span><span class="s4">, </span><span class="s1">stop</span>
        <span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s4">@</span><span class="s1">_assertions</span><span class="s4">(</span><span class="s1">_no_statement_condition</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">limit</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">limit</span><span class="s4">: </span><span class="s1">_LimitOffsetType</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Apply a ``LIMIT`` to the query and return the newly resulting 
        ``Query``. 
 
        .. seealso:: 
 
            :meth:`_sql.Select.limit` - v2 equivalent method. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_limit_clause </span><span class="s4">= </span><span class="s1">sql_util</span><span class="s4">.</span><span class="s1">_offset_or_limit_clause</span><span class="s4">(</span><span class="s1">limit</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s4">@</span><span class="s1">_assertions</span><span class="s4">(</span><span class="s1">_no_statement_condition</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">offset</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">offset</span><span class="s4">: </span><span class="s1">_LimitOffsetType</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Apply an ``OFFSET`` to the query and return the newly resulting 
        ``Query``. 
 
        .. seealso:: 
 
            :meth:`_sql.Select.offset` - v2 equivalent method. 
        &quot;&quot;&quot;</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_offset_clause </span><span class="s4">= </span><span class="s1">sql_util</span><span class="s4">.</span><span class="s1">_offset_or_limit_clause</span><span class="s4">(</span><span class="s1">offset</span><span class="s4">)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s4">@</span><span class="s1">_assertions</span><span class="s4">(</span><span class="s1">_no_statement_condition</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">distinct</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, *</span><span class="s1">expr</span><span class="s4">: </span><span class="s1">_ColumnExpressionArgument</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Apply a ``DISTINCT`` to the query and return the newly resulting 
        ``Query``. 
 
 
        .. note:: 
 
            The ORM-level :meth:`.distinct` call includes logic that will 
            automatically add columns from the ORDER BY of the query to the 
            columns clause of the SELECT statement, to satisfy the common need 
            of the database backend that ORDER BY columns be part of the SELECT 
            list when DISTINCT is used.   These columns *are not* added to the 
            list of columns actually fetched by the :class:`_query.Query`, 
            however, 
            so would not affect results. The columns are passed through when 
            using the :attr:`_query.Query.statement` accessor, however. 
 
            .. deprecated:: 2.0  This logic is deprecated and will be removed 
               in SQLAlchemy 2.0.     See :ref:`migration_20_query_distinct` 
               for a description of this use case in 2.0. 
 
        .. seealso:: 
 
            :meth:`_sql.Select.distinct` - v2 equivalent method. 
 
        :param \*expr: optional column expressions.  When present, 
         the PostgreSQL dialect will render a ``DISTINCT ON (&lt;expressions&gt;)`` 
         construct. 
 
         .. deprecated:: 1.4 Using \*expr in other dialects is deprecated 
            and will raise :class:`_exc.CompileError` in a future version. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">expr</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_distinct </span><span class="s4">= </span><span class="s3">True</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_distinct_on </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_distinct_on </span><span class="s4">+ </span><span class="s1">tuple</span><span class="s4">(</span>
                <span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span><span class="s1">roles</span><span class="s4">.</span><span class="s1">ByOfRole</span><span class="s4">, </span><span class="s1">e</span><span class="s4">) </span><span class="s3">for </span><span class="s1">e </span><span class="s3">in </span><span class="s1">expr</span>
            <span class="s4">)</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_distinct </span><span class="s4">= </span><span class="s3">True</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">all</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the results represented by this :class:`_query.Query` 
        as a list. 
 
        This results in an execution of the underlying SQL statement. 
 
        .. warning::  The :class:`_query.Query` object, 
           when asked to return either 
           a sequence or iterator that consists of full ORM-mapped entities, 
           will **deduplicate entries based on primary key**.  See the FAQ for 
           more details. 
 
            .. seealso:: 
 
                :ref:`faq_query_deduplicating` 
 
        .. seealso:: 
 
            :meth:`_engine.Result.all` - v2 comparable method. 
 
            :meth:`_engine.Result.scalars` - v2 comparable method. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">().</span><span class="s1">all</span><span class="s4">()  </span><span class="s0"># type: ignore</span>

    <span class="s4">@</span><span class="s1">_generative</span>
    <span class="s4">@</span><span class="s1">_assertions</span><span class="s4">(</span><span class="s1">_no_clauseelement_condition</span><span class="s4">)</span>
    <span class="s3">def </span><span class="s1">from_statement</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">: </span><span class="s1">ExecutableReturnsRows</span><span class="s4">) </span><span class="s1">-&gt; Self</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Execute the given SELECT statement and return results. 
 
        This method bypasses all internal statement compilation, and the 
        statement is executed without modification. 
 
        The statement is typically either a :func:`_expression.text` 
        or :func:`_expression.select` construct, and should return the set 
        of columns 
        appropriate to the entity class represented by this 
        :class:`_query.Query`. 
 
        .. seealso:: 
 
            :meth:`_sql.Select.from_statement` - v2 comparable method. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">statement </span><span class="s4">= </span><span class="s1">coercions</span><span class="s4">.</span><span class="s1">expect</span><span class="s4">(</span>
            <span class="s1">roles</span><span class="s4">.</span><span class="s1">SelectStatementRole</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">, </span><span class="s1">apply_propagate_attrs</span><span class="s4">=</span><span class="s1">self</span>
        <span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_statement </span><span class="s4">= </span><span class="s1">statement</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">first</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return the first result of this ``Query`` or 
        None if the result doesn't contain any row. 
 
        first() applies a limit of one within the generated SQL, so that 
        only one primary entity row is generated on the server side 
        (note this may consist of multiple result rows if join-loaded 
        collections are present). 
 
        Calling :meth:`_query.Query.first` 
        results in an execution of the underlying 
        query. 
 
        .. seealso:: 
 
            :meth:`_query.Query.one` 
 
            :meth:`_query.Query.one_or_none` 
 
            :meth:`_engine.Result.first` - v2 comparable method. 
 
            :meth:`_engine.Result.scalars` - v2 comparable method. 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># replicates limit(1) behavior</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_statement </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">().</span><span class="s1">first</span><span class="s4">()  </span><span class="s0"># type: ignore</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">limit</span><span class="s4">(</span><span class="s6">1</span><span class="s4">).</span><span class="s1">_iter</span><span class="s4">().</span><span class="s1">first</span><span class="s4">()  </span><span class="s0"># type: ignore</span>

    <span class="s3">def </span><span class="s1">one_or_none</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Optional</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return at most one result or raise an exception. 
 
        Returns ``None`` if the query selects 
        no rows.  Raises ``sqlalchemy.orm.exc.MultipleResultsFound`` 
        if multiple object identities are returned, or if multiple 
        rows are returned for a query that returns only scalar values 
        as opposed to full identity-mapped entities. 
 
        Calling :meth:`_query.Query.one_or_none` 
        results in an execution of the 
        underlying query. 
 
        .. seealso:: 
 
            :meth:`_query.Query.first` 
 
            :meth:`_query.Query.one` 
 
            :meth:`_engine.Result.one_or_none` - v2 comparable method. 
 
            :meth:`_engine.Result.scalar_one_or_none` - v2 comparable method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">().</span><span class="s1">one_or_none</span><span class="s4">()  </span><span class="s0"># type: ignore</span>

    <span class="s3">def </span><span class="s1">one</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; _T</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return exactly one result or raise an exception. 
 
        Raises ``sqlalchemy.orm.exc.NoResultFound`` if the query selects 
        no rows.  Raises ``sqlalchemy.orm.exc.MultipleResultsFound`` 
        if multiple object identities are returned, or if multiple 
        rows are returned for a query that returns only scalar values 
        as opposed to full identity-mapped entities. 
 
        Calling :meth:`.one` results in an execution of the underlying query. 
 
        .. seealso:: 
 
            :meth:`_query.Query.first` 
 
            :meth:`_query.Query.one_or_none` 
 
            :meth:`_engine.Result.one` - v2 comparable method. 
 
            :meth:`_engine.Result.scalar_one` - v2 comparable method. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">().</span><span class="s1">one</span><span class="s4">()  </span><span class="s0"># type: ignore</span>

    <span class="s3">def </span><span class="s1">scalar</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return the first element of the first result or None 
        if no rows present.  If multiple rows are returned, 
        raises MultipleResultsFound. 
 
          &gt;&gt;&gt; session.query(Item).scalar() 
          &lt;Item&gt; 
          &gt;&gt;&gt; session.query(Item.id).scalar() 
          1 
          &gt;&gt;&gt; session.query(Item.id).filter(Item.id &lt; 0).scalar() 
          None 
          &gt;&gt;&gt; session.query(Item.id, Item.name).scalar() 
          1 
          &gt;&gt;&gt; session.query(func.count(Parent.id)).scalar() 
          20 
 
        This results in an execution of the underlying query. 
 
        .. seealso:: 
 
            :meth:`_engine.Result.scalar` - v2 comparable method. 
 
        &quot;&quot;&quot;</span>
        <span class="s0"># TODO: not sure why we can't use result.scalar() here</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">ret </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">one</span><span class="s4">()</span>
            <span class="s3">if not </span><span class="s1">isinstance</span><span class="s4">(</span><span class="s1">ret</span><span class="s4">, </span><span class="s1">collections_abc</span><span class="s4">.</span><span class="s1">Sequence</span><span class="s4">):</span>
                <span class="s3">return </span><span class="s1">ret</span>
            <span class="s3">return </span><span class="s1">ret</span><span class="s4">[</span><span class="s6">0</span><span class="s4">]</span>
        <span class="s3">except </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">NoResultFound</span><span class="s4">:</span>
            <span class="s3">return None</span>

    <span class="s3">def </span><span class="s1">__iter__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Iterator</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]:</span>
        <span class="s1">result </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_iter</span><span class="s4">()</span>
        <span class="s3">try</span><span class="s4">:</span>
            <span class="s3">yield from </span><span class="s1">result  </span><span class="s0"># type: ignore</span>
        <span class="s3">except </span><span class="s1">GeneratorExit</span><span class="s4">:</span>
            <span class="s0"># issue #8710 - direct iteration is not re-usable after</span>
            <span class="s0"># an iterable block is broken, so close the result</span>
            <span class="s1">result</span><span class="s4">.</span><span class="s1">_soft_close</span><span class="s4">()</span>
            <span class="s3">raise</span>

    <span class="s3">def </span><span class="s1">_iter</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">ScalarResult</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">], </span><span class="s1">Result</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]]:</span>
        <span class="s0"># new style execution.</span>
        <span class="s1">params </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_params</span>

        <span class="s1">statement </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_statement_20</span><span class="s4">()</span>
        <span class="s1">result</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">ScalarResult</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">], </span><span class="s1">Result</span><span class="s4">[</span><span class="s1">_T</span><span class="s4">]] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">execute</span><span class="s4">(</span>
            <span class="s1">statement</span><span class="s4">,</span>
            <span class="s1">params</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">={</span><span class="s5">&quot;_sa_orm_load_options&quot;</span><span class="s4">: </span><span class="s1">self</span><span class="s4">.</span><span class="s1">load_options</span><span class="s4">},</span>
        <span class="s4">)</span>

        <span class="s0"># legacy: automatically set scalars, unique</span>
        <span class="s3">if </span><span class="s1">result</span><span class="s4">.</span><span class="s1">_attributes</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;is_single_entity&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">):</span>
            <span class="s1">result </span><span class="s4">= </span><span class="s1">cast</span><span class="s4">(</span><span class="s5">&quot;Result[_T]&quot;</span><span class="s4">, </span><span class="s1">result</span><span class="s4">).</span><span class="s1">scalars</span><span class="s4">()</span>

        <span class="s3">if </span><span class="s4">(</span>
            <span class="s1">result</span><span class="s4">.</span><span class="s1">_attributes</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;filtered&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>
            <span class="s3">and not </span><span class="s1">self</span><span class="s4">.</span><span class="s1">load_options</span><span class="s4">.</span><span class="s1">_yield_per</span>
        <span class="s4">):</span>
            <span class="s1">result </span><span class="s4">= </span><span class="s1">result</span><span class="s4">.</span><span class="s1">unique</span><span class="s4">()</span>

        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">__str__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; str</span><span class="s4">:</span>
        <span class="s1">statement </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_statement_20</span><span class="s4">()</span>

        <span class="s3">try</span><span class="s4">:</span>
            <span class="s1">bind </span><span class="s4">= (</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_get_bind_args</span><span class="s4">(</span><span class="s1">statement</span><span class="s4">, </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">get_bind</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span>
                <span class="s3">else None</span>
            <span class="s4">)</span>
        <span class="s3">except </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">UnboundExecutionError</span><span class="s4">:</span>
            <span class="s1">bind </span><span class="s4">= </span><span class="s3">None</span>

        <span class="s3">return </span><span class="s1">str</span><span class="s4">(</span><span class="s1">statement</span><span class="s4">.</span><span class="s1">compile</span><span class="s4">(</span><span class="s1">bind</span><span class="s4">))</span>

    <span class="s3">def </span><span class="s1">_get_bind_args</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">statement</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, </span><span class="s1">fn</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span><span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">fn</span><span class="s4">(</span><span class="s1">clause</span><span class="s4">=</span><span class="s1">statement</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">column_descriptions</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; List</span><span class="s4">[</span><span class="s1">ORMColumnDescription</span><span class="s4">]:</span>
        <span class="s2">&quot;&quot;&quot;Return metadata about the columns which would be 
        returned by this :class:`_query.Query`. 
 
        Format is a list of dictionaries:: 
 
            user_alias = aliased(User, name='user2') 
            q = sess.query(User, User.id, user_alias) 
 
            # this expression: 
            q.column_descriptions 
 
            # would return: 
            [ 
                { 
                    'name':'User', 
                    'type':User, 
                    'aliased':False, 
                    'expr':User, 
                    'entity': User 
                }, 
                { 
                    'name':'id', 
                    'type':Integer(), 
                    'aliased':False, 
                    'expr':User.id, 
                    'entity': User 
                }, 
                { 
                    'name':'user2', 
                    'type':User, 
                    'aliased':True, 
                    'expr':user_alias, 
                    'entity': user_alias 
                } 
            ] 
 
        .. seealso:: 
 
            This API is available using :term:`2.0 style` queries as well, 
            documented at: 
 
            * :ref:`queryguide_inspection` 
 
            * :attr:`.Select.column_descriptions` 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">_column_descriptions</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">legacy</span><span class="s4">=</span><span class="s3">True</span><span class="s4">)</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">deprecated</span><span class="s4">(</span>
        <span class="s5">&quot;2.0&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;The :meth:`_orm.Query.instances` method is deprecated and will &quot;</span>
        <span class="s5">&quot;be removed in a future release. &quot;</span>
        <span class="s5">&quot;Use the Select.from_statement() method or aliased() construct in &quot;</span>
        <span class="s5">&quot;conjunction with Session.execute() instead.&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">instances</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">result_proxy</span><span class="s4">: </span><span class="s1">CursorResult</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">context</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">QueryContext</span><span class="s4">] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Any</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Return an ORM result given a :class:`_engine.CursorResult` and 
        :class:`.QueryContext`. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">context </span><span class="s3">is None</span><span class="s4">:</span>
            <span class="s1">util</span><span class="s4">.</span><span class="s1">warn_deprecated</span><span class="s4">(</span>
                <span class="s5">&quot;Using the Query.instances() method without a context &quot;</span>
                <span class="s5">&quot;is deprecated and will be disallowed in a future release.  &quot;</span>
                <span class="s5">&quot;Please make use of :meth:`_query.Query.from_statement` &quot;</span>
                <span class="s5">&quot;for linking ORM results to arbitrary select constructs.&quot;</span><span class="s4">,</span>
                <span class="s1">version</span><span class="s4">=</span><span class="s5">&quot;1.4&quot;</span><span class="s4">,</span>
            <span class="s4">)</span>
            <span class="s1">compile_state </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_state</span><span class="s4">(</span><span class="s1">for_statement</span><span class="s4">=</span><span class="s3">False</span><span class="s4">)</span>

            <span class="s1">context </span><span class="s4">= </span><span class="s1">QueryContext</span><span class="s4">(</span>
                <span class="s1">compile_state</span><span class="s4">,</span>
                <span class="s1">compile_state</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">,</span>
                <span class="s1">compile_state</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">_params</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">,</span>
                <span class="s1">self</span><span class="s4">.</span><span class="s1">load_options</span><span class="s4">,</span>
            <span class="s4">)</span>

        <span class="s1">result </span><span class="s4">= </span><span class="s1">loading</span><span class="s4">.</span><span class="s1">instances</span><span class="s4">(</span><span class="s1">result_proxy</span><span class="s4">, </span><span class="s1">context</span><span class="s4">)</span>

        <span class="s0"># legacy: automatically set scalars, unique</span>
        <span class="s3">if </span><span class="s1">result</span><span class="s4">.</span><span class="s1">_attributes</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;is_single_entity&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">):</span>
            <span class="s1">result </span><span class="s4">= </span><span class="s1">result</span><span class="s4">.</span><span class="s1">scalars</span><span class="s4">()  </span><span class="s0"># type: ignore</span>

        <span class="s3">if </span><span class="s1">result</span><span class="s4">.</span><span class="s1">_attributes</span><span class="s4">.</span><span class="s1">get</span><span class="s4">(</span><span class="s5">&quot;filtered&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">):</span>
            <span class="s1">result </span><span class="s4">= </span><span class="s1">result</span><span class="s4">.</span><span class="s1">unique</span><span class="s4">()</span>

        <span class="s0"># TODO: isn't this supposed to be a list?</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">became_legacy_20</span><span class="s4">(</span>
        <span class="s5">&quot;:meth:`_orm.Query.merge_result`&quot;</span><span class="s4">,</span>
        <span class="s1">alternative</span><span class="s4">=</span><span class="s5">&quot;The method is superseded by the &quot;</span>
        <span class="s5">&quot;:func:`_orm.merge_frozen_result` function.&quot;</span><span class="s4">,</span>
        <span class="s1">enable_warnings</span><span class="s4">=</span><span class="s3">False</span><span class="s4">,  </span><span class="s0"># warnings occur via loading.merge_result</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">merge_result</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">iterator</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span>
            <span class="s1">FrozenResult</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Sequence</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]], </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">object</span><span class="s4">]</span>
        <span class="s4">],</span>
        <span class="s1">load</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">True</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; Union</span><span class="s4">[</span><span class="s1">FrozenResult</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">], </span><span class="s1">Iterable</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]]:</span>
        <span class="s2">&quot;&quot;&quot;Merge a result into this :class:`_query.Query` object's Session. 
 
        Given an iterator returned by a :class:`_query.Query` 
        of the same structure 
        as this one, return an identical iterator of results, with all mapped 
        instances merged into the session using :meth:`.Session.merge`. This 
        is an optimized method which will merge all mapped instances, 
        preserving the structure of the result rows and unmapped columns with 
        less method overhead than that of calling :meth:`.Session.merge` 
        explicitly for each value. 
 
        The structure of the results is determined based on the column list of 
        this :class:`_query.Query` - if these do not correspond, 
        unchecked errors 
        will occur. 
 
        The 'load' argument is the same as that of :meth:`.Session.merge`. 
 
        For an example of how :meth:`_query.Query.merge_result` is used, see 
        the source code for the example :ref:`examples_caching`, where 
        :meth:`_query.Query.merge_result` is used to efficiently restore state 
        from a cache back into a target :class:`.Session`. 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">loading</span><span class="s4">.</span><span class="s1">merge_result</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">iterator</span><span class="s4">, </span><span class="s1">load</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">exists</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Exists</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;A convenience method that turns a query into an EXISTS subquery 
        of the form EXISTS (SELECT 1 FROM ... WHERE ...). 
 
        e.g.:: 
 
            q = session.query(User).filter(User.name == 'fred') 
            session.query(q.exists()) 
 
        Producing SQL similar to:: 
 
            SELECT EXISTS ( 
                SELECT 1 FROM users WHERE users.name = :name_1 
            ) AS anon_1 
 
        The EXISTS construct is usually used in the WHERE clause:: 
 
            session.query(User.id).filter(q.exists()).scalar() 
 
        Note that some databases such as SQL Server don't allow an 
        EXISTS expression to be present in the columns clause of a 
        SELECT.    To select a simple boolean value based on the exists 
        as a WHERE, use :func:`.literal`:: 
 
            from sqlalchemy import literal 
 
            session.query(literal(True)).filter(q.exists()).scalar() 
 
        .. seealso:: 
 
            :meth:`_sql.Select.exists` - v2 comparable method. 
 
        &quot;&quot;&quot;</span>

        <span class="s0"># .add_columns() for the case that we are a query().select_from(X),</span>
        <span class="s0"># so that &quot;.statement&quot; can be produced (#2995) but also without</span>
        <span class="s0"># omitting the FROM clause from a query(X) (#2818);</span>
        <span class="s0"># .with_only_columns() after we have a core select() so that</span>
        <span class="s0"># we get just &quot;SELECT 1&quot; without any entities.</span>

        <span class="s1">inner </span><span class="s4">= (</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">enable_eagerloads</span><span class="s4">(</span><span class="s3">False</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">add_columns</span><span class="s4">(</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">literal_column</span><span class="s4">(</span><span class="s5">&quot;1&quot;</span><span class="s4">))</span>
            <span class="s4">.</span><span class="s1">set_label_style</span><span class="s4">(</span><span class="s1">LABEL_STYLE_TABLENAME_PLUS_COL</span><span class="s4">)</span>
            <span class="s4">.</span><span class="s1">_get_select_statement_only</span><span class="s4">()</span>
            <span class="s4">.</span><span class="s1">with_only_columns</span><span class="s4">(</span><span class="s6">1</span><span class="s4">)</span>
        <span class="s4">)</span>

        <span class="s1">ezero </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_entity_from_pre_ent_zero</span><span class="s4">()</span>
        <span class="s3">if </span><span class="s1">ezero </span><span class="s3">is not None</span><span class="s4">:</span>
            <span class="s1">inner </span><span class="s4">= </span><span class="s1">inner</span><span class="s4">.</span><span class="s1">select_from</span><span class="s4">(</span><span class="s1">ezero</span><span class="s4">)</span>

        <span class="s3">return </span><span class="s1">sql</span><span class="s4">.</span><span class="s1">exists</span><span class="s4">(</span><span class="s1">inner</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">count</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Return a count of rows this the SQL formed by this :class:`Query` 
        would return. 
 
        This generates the SQL for this Query as follows:: 
 
            SELECT count(1) AS count_1 FROM ( 
                SELECT &lt;rest of query follows...&gt; 
            ) AS anon_1 
 
        The above SQL returns a single row, which is the aggregate value 
        of the count function; the :meth:`_query.Query.count` 
        method then returns 
        that single integer value. 
 
        .. warning:: 
 
            It is important to note that the value returned by 
            count() is **not the same as the number of ORM objects that this 
            Query would return from a method such as the .all() method**. 
            The :class:`_query.Query` object, 
            when asked to return full entities, 
            will **deduplicate entries based on primary key**, meaning if the 
            same primary key value would appear in the results more than once, 
            only one object of that primary key would be present.  This does 
            not apply to a query that is against individual columns. 
 
            .. seealso:: 
 
                :ref:`faq_query_deduplicating` 
 
        For fine grained control over specific columns to count, to skip the 
        usage of a subquery or otherwise control of the FROM clause, or to use 
        other aggregate functions, use :attr:`~sqlalchemy.sql.expression.func` 
        expressions in conjunction with :meth:`~.Session.query`, i.e.:: 
 
            from sqlalchemy import func 
 
            # count User records, without 
            # using a subquery. 
            session.query(func.count(User.id)) 
 
            # return count of user &quot;id&quot; grouped 
            # by &quot;name&quot; 
            session.query(func.count(User.id)).\ 
                    group_by(User.name) 
 
            from sqlalchemy import distinct 
 
            # count distinct &quot;name&quot; values 
            session.query(func.count(distinct(User.name))) 
 
        .. seealso:: 
 
            :ref:`migration_20_query_usage` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">col </span><span class="s4">= </span><span class="s1">sql</span><span class="s4">.</span><span class="s1">func</span><span class="s4">.</span><span class="s1">count</span><span class="s4">(</span><span class="s1">sql</span><span class="s4">.</span><span class="s1">literal_column</span><span class="s4">(</span><span class="s5">&quot;*&quot;</span><span class="s4">))</span>
        <span class="s3">return </span><span class="s4">(  </span><span class="s0"># type: ignore</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_legacy_from_self</span><span class="s4">(</span><span class="s1">col</span><span class="s4">).</span><span class="s1">enable_eagerloads</span><span class="s4">(</span><span class="s3">False</span><span class="s4">).</span><span class="s1">scalar</span><span class="s4">()</span>
        <span class="s4">)</span>

    <span class="s3">def </span><span class="s1">delete</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">synchronize_session</span><span class="s4">: </span><span class="s1">SynchronizeSessionArgument </span><span class="s4">= </span><span class="s5">&quot;auto&quot;</span>
    <span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Perform a DELETE with an arbitrary WHERE clause. 
 
        Deletes rows matched by this query from the database. 
 
        E.g.:: 
 
            sess.query(User).filter(User.age == 25).\ 
                delete(synchronize_session=False) 
 
            sess.query(User).filter(User.age == 25).\ 
                delete(synchronize_session='evaluate') 
 
        .. warning:: 
 
            See the section :ref:`orm_expression_update_delete` for important 
            caveats and warnings, including limitations when using bulk UPDATE 
            and DELETE with mapper inheritance configurations. 
 
        :param synchronize_session: chooses the strategy to update the 
         attributes on objects in the session.   See the section 
         :ref:`orm_expression_update_delete` for a discussion of these 
         strategies. 
 
        :return: the count of rows matched as returned by the database's 
          &quot;row count&quot; feature. 
 
        .. seealso:: 
 
            :ref:`orm_expression_update_delete` 
 
        &quot;&quot;&quot;</span>

        <span class="s1">bulk_del </span><span class="s4">= </span><span class="s1">BulkDelete</span><span class="s4">(</span><span class="s1">self</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">before_compile_delete</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">before_compile_delete</span><span class="s4">:</span>
                <span class="s1">new_query </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">(</span><span class="s1">bulk_del</span><span class="s4">.</span><span class="s1">query</span><span class="s4">, </span><span class="s1">bulk_del</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">new_query </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s1">bulk_del</span><span class="s4">.</span><span class="s1">query </span><span class="s4">= </span><span class="s1">new_query</span>

                <span class="s1">self </span><span class="s4">= </span><span class="s1">bulk_del</span><span class="s4">.</span><span class="s1">query</span>

        <span class="s1">delete_ </span><span class="s4">= </span><span class="s1">sql</span><span class="s4">.</span><span class="s1">delete</span><span class="s4">(*</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">)  </span><span class="s0"># type: ignore</span>
        <span class="s1">delete_</span><span class="s4">.</span><span class="s1">_where_criteria </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_where_criteria</span>
        <span class="s1">result</span><span class="s4">: </span><span class="s1">CursorResult</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">execute</span><span class="s4">(</span>
            <span class="s1">delete_</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_params</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_execution_options</span><span class="s4">.</span><span class="s1">union</span><span class="s4">(</span>
                <span class="s4">{</span><span class="s5">&quot;synchronize_session&quot;</span><span class="s4">: </span><span class="s1">synchronize_session</span><span class="s4">}</span>
            <span class="s4">),</span>
        <span class="s4">)</span>
        <span class="s1">bulk_del</span><span class="s4">.</span><span class="s1">result </span><span class="s4">= </span><span class="s1">result  </span><span class="s0"># type: ignore</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">after_bulk_delete</span><span class="s4">(</span><span class="s1">bulk_del</span><span class="s4">)</span>
        <span class="s1">result</span><span class="s4">.</span><span class="s1">close</span><span class="s4">()</span>

        <span class="s3">return </span><span class="s1">result</span><span class="s4">.</span><span class="s1">rowcount</span>

    <span class="s3">def </span><span class="s1">update</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">values</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">_DMLColumnArgument</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">synchronize_session</span><span class="s4">: </span><span class="s1">SynchronizeSessionArgument </span><span class="s4">= </span><span class="s5">&quot;auto&quot;</span><span class="s4">,</span>
        <span class="s1">update_args</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]] = </span><span class="s3">None</span><span class="s4">,</span>
    <span class="s4">) </span><span class="s1">-&gt; int</span><span class="s4">:</span>
        <span class="s2">r&quot;&quot;&quot;Perform an UPDATE with an arbitrary WHERE clause. 
 
        Updates rows matched by this query in the database. 
 
        E.g.:: 
 
            sess.query(User).filter(User.age == 25).\ 
                update({User.age: User.age - 10}, synchronize_session=False) 
 
            sess.query(User).filter(User.age == 25).\ 
                update({&quot;age&quot;: User.age - 10}, synchronize_session='evaluate') 
 
        .. warning:: 
 
            See the section :ref:`orm_expression_update_delete` for important 
            caveats and warnings, including limitations when using arbitrary 
            UPDATE and DELETE with mapper inheritance configurations. 
 
        :param values: a dictionary with attributes names, or alternatively 
         mapped attributes or SQL expressions, as keys, and literal 
         values or sql expressions as values.   If :ref:`parameter-ordered 
         mode &lt;tutorial_parameter_ordered_updates&gt;` is desired, the values can 
         be passed as a list of 2-tuples; this requires that the 
         :paramref:`~sqlalchemy.sql.expression.update.preserve_parameter_order` 
         flag is passed to the :paramref:`.Query.update.update_args` dictionary 
         as well. 
 
        :param synchronize_session: chooses the strategy to update the 
         attributes on objects in the session.   See the section 
         :ref:`orm_expression_update_delete` for a discussion of these 
         strategies. 
 
        :param update_args: Optional dictionary, if present will be passed 
         to the underlying :func:`_expression.update` 
         construct as the ``**kw`` for 
         the object.  May be used to pass dialect-specific arguments such 
         as ``mysql_limit``, as well as other special arguments such as 
         :paramref:`~sqlalchemy.sql.expression.update.preserve_parameter_order`. 
 
        :return: the count of rows matched as returned by the database's 
         &quot;row count&quot; feature. 
 
 
        .. seealso:: 
 
            :ref:`orm_expression_update_delete` 
 
        &quot;&quot;&quot;</span>

        <span class="s1">update_args </span><span class="s4">= </span><span class="s1">update_args </span><span class="s3">or </span><span class="s4">{}</span>

        <span class="s1">bulk_ud </span><span class="s4">= </span><span class="s1">BulkUpdate</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">values</span><span class="s4">, </span><span class="s1">update_args</span><span class="s4">)</span>

        <span class="s3">if </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">before_compile_update</span><span class="s4">:</span>
            <span class="s3">for </span><span class="s1">fn </span><span class="s3">in </span><span class="s1">self</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">before_compile_update</span><span class="s4">:</span>
                <span class="s1">new_query </span><span class="s4">= </span><span class="s1">fn</span><span class="s4">(</span><span class="s1">bulk_ud</span><span class="s4">.</span><span class="s1">query</span><span class="s4">, </span><span class="s1">bulk_ud</span><span class="s4">)</span>
                <span class="s3">if </span><span class="s1">new_query </span><span class="s3">is not None</span><span class="s4">:</span>
                    <span class="s1">bulk_ud</span><span class="s4">.</span><span class="s1">query </span><span class="s4">= </span><span class="s1">new_query</span>
            <span class="s1">self </span><span class="s4">= </span><span class="s1">bulk_ud</span><span class="s4">.</span><span class="s1">query</span>

        <span class="s1">upd </span><span class="s4">= </span><span class="s1">sql</span><span class="s4">.</span><span class="s1">update</span><span class="s4">(*</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_raw_columns</span><span class="s4">)  </span><span class="s0"># type: ignore</span>

        <span class="s1">ppo </span><span class="s4">= </span><span class="s1">update_args</span><span class="s4">.</span><span class="s1">pop</span><span class="s4">(</span><span class="s5">&quot;preserve_parameter_order&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">ppo</span><span class="s4">:</span>
            <span class="s1">upd </span><span class="s4">= </span><span class="s1">upd</span><span class="s4">.</span><span class="s1">ordered_values</span><span class="s4">(*</span><span class="s1">values</span><span class="s4">)  </span><span class="s0"># type: ignore</span>
        <span class="s3">else</span><span class="s4">:</span>
            <span class="s1">upd </span><span class="s4">= </span><span class="s1">upd</span><span class="s4">.</span><span class="s1">values</span><span class="s4">(</span><span class="s1">values</span><span class="s4">)</span>
        <span class="s3">if </span><span class="s1">update_args</span><span class="s4">:</span>
            <span class="s1">upd </span><span class="s4">= </span><span class="s1">upd</span><span class="s4">.</span><span class="s1">with_dialect_options</span><span class="s4">(**</span><span class="s1">update_args</span><span class="s4">)</span>

        <span class="s1">upd</span><span class="s4">.</span><span class="s1">_where_criteria </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_where_criteria</span>
        <span class="s1">result</span><span class="s4">: </span><span class="s1">CursorResult</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">] = </span><span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">execute</span><span class="s4">(</span>
            <span class="s1">upd</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_params</span><span class="s4">,</span>
            <span class="s1">execution_options</span><span class="s4">=</span><span class="s1">self</span><span class="s4">.</span><span class="s1">_execution_options</span><span class="s4">.</span><span class="s1">union</span><span class="s4">(</span>
                <span class="s4">{</span><span class="s5">&quot;synchronize_session&quot;</span><span class="s4">: </span><span class="s1">synchronize_session</span><span class="s4">}</span>
            <span class="s4">),</span>
        <span class="s4">)</span>
        <span class="s1">bulk_ud</span><span class="s4">.</span><span class="s1">result </span><span class="s4">= </span><span class="s1">result  </span><span class="s0"># type: ignore</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">.</span><span class="s1">dispatch</span><span class="s4">.</span><span class="s1">after_bulk_update</span><span class="s4">(</span><span class="s1">bulk_ud</span><span class="s4">)</span>
        <span class="s1">result</span><span class="s4">.</span><span class="s1">close</span><span class="s4">()</span>
        <span class="s3">return </span><span class="s1">result</span><span class="s4">.</span><span class="s1">rowcount</span>

    <span class="s3">def </span><span class="s1">_compile_state</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">, </span><span class="s1">for_statement</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">: </span><span class="s1">Any</span>
    <span class="s4">) </span><span class="s1">-&gt; ORMCompileState</span><span class="s4">:</span>
        <span class="s2">&quot;&quot;&quot;Create an out-of-compiler ORMCompileState object. 
 
        The ORMCompileState object is normally created directly as a result 
        of the SQLCompiler.process() method being handed a Select() 
        or FromStatement() object that uses the &quot;orm&quot; plugin.   This method 
        provides a means of creating this ORMCompileState object directly 
        without using the compiler. 
 
        This method is used only for deprecated cases, which include 
        the .from_self() method for a Query that has multiple levels 
        of .from_self() in use, as well as the instances() method.  It is 
        also used within the test suite to generate ORMCompileState objects 
        for test purposes. 
 
        &quot;&quot;&quot;</span>

        <span class="s1">stmt </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_statement_20</span><span class="s4">(</span><span class="s1">for_statement</span><span class="s4">=</span><span class="s1">for_statement</span><span class="s4">, **</span><span class="s1">kw</span><span class="s4">)</span>
        <span class="s3">assert </span><span class="s1">for_statement </span><span class="s4">== </span><span class="s1">stmt</span><span class="s4">.</span><span class="s1">_compile_options</span><span class="s4">.</span><span class="s1">_for_statement</span>

        <span class="s0"># this chooses between ORMFromStatementCompileState and</span>
        <span class="s0"># ORMSelectCompileState.  We could also base this on</span>
        <span class="s0"># query._statement is not None as we have the ORM Query here</span>
        <span class="s0"># however this is the more general path.</span>
        <span class="s1">compile_state_cls </span><span class="s4">= </span><span class="s1">cast</span><span class="s4">(</span>
            <span class="s1">ORMCompileState</span><span class="s4">,</span>
            <span class="s1">ORMCompileState</span><span class="s4">.</span><span class="s1">_get_plugin_class_for_plugin</span><span class="s4">(</span><span class="s1">stmt</span><span class="s4">, </span><span class="s5">&quot;orm&quot;</span><span class="s4">),</span>
        <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">compile_state_cls</span><span class="s4">.</span><span class="s1">create_for_statement</span><span class="s4">(</span><span class="s1">stmt</span><span class="s4">, </span><span class="s3">None</span><span class="s4">)</span>

    <span class="s3">def </span><span class="s1">_compile_context</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">for_statement</span><span class="s4">: </span><span class="s1">bool </span><span class="s4">= </span><span class="s3">False</span><span class="s4">) </span><span class="s1">-&gt; QueryContext</span><span class="s4">:</span>
        <span class="s1">compile_state </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">_compile_state</span><span class="s4">(</span><span class="s1">for_statement</span><span class="s4">=</span><span class="s1">for_statement</span><span class="s4">)</span>
        <span class="s1">context </span><span class="s4">= </span><span class="s1">QueryContext</span><span class="s4">(</span>
            <span class="s1">compile_state</span><span class="s4">,</span>
            <span class="s1">compile_state</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">,</span>
            <span class="s1">compile_state</span><span class="s4">.</span><span class="s1">statement</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">_params</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">session</span><span class="s4">,</span>
            <span class="s1">self</span><span class="s4">.</span><span class="s1">load_options</span><span class="s4">,</span>
        <span class="s4">)</span>

        <span class="s3">return </span><span class="s1">context</span>


<span class="s3">class </span><span class="s1">AliasOption</span><span class="s4">(</span><span class="s1">interfaces</span><span class="s4">.</span><span class="s1">LoaderOption</span><span class="s4">):</span>
    <span class="s1">inherit_cache </span><span class="s4">= </span><span class="s3">False</span>

    <span class="s4">@</span><span class="s1">util</span><span class="s4">.</span><span class="s1">deprecated</span><span class="s4">(</span>
        <span class="s5">&quot;1.4&quot;</span><span class="s4">,</span>
        <span class="s5">&quot;The :class:`.AliasOption` object is not necessary &quot;</span>
        <span class="s5">&quot;for entities to be matched up to a query that is established &quot;</span>
        <span class="s5">&quot;via :meth:`.Query.from_statement` and now does nothing.&quot;</span><span class="s4">,</span>
    <span class="s4">)</span>
    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">alias</span><span class="s4">: </span><span class="s1">Union</span><span class="s4">[</span><span class="s1">Alias</span><span class="s4">, </span><span class="s1">Subquery</span><span class="s4">]):</span>
        <span class="s2">r&quot;&quot;&quot;Return a :class:`.MapperOption` that will indicate to the 
        :class:`_query.Query` 
        that the main table has been aliased. 
 
        &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">process_compile_state</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">compile_state</span><span class="s4">: </span><span class="s1">ORMCompileState</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">BulkUD</span><span class="s4">:</span>
    <span class="s2">&quot;&quot;&quot;State used for the orm.Query version of update() / delete(). 
 
    This object is now specific to Query only. 
 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">self</span><span class="s4">, </span><span class="s1">query</span><span class="s4">: </span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">]):</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">query </span><span class="s4">= </span><span class="s1">query</span><span class="s4">.</span><span class="s1">enable_eagerloads</span><span class="s4">(</span><span class="s3">False</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">_validate_query_state</span><span class="s4">()</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">mapper </span><span class="s4">= </span><span class="s1">self</span><span class="s4">.</span><span class="s1">query</span><span class="s4">.</span><span class="s1">_entity_from_pre_ent_zero</span><span class="s4">()</span>

    <span class="s3">def </span><span class="s1">_validate_query_state</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; </span><span class="s3">None</span><span class="s4">:</span>
        <span class="s3">for </span><span class="s1">attr</span><span class="s4">, </span><span class="s1">methname</span><span class="s4">, </span><span class="s1">notset</span><span class="s4">, </span><span class="s1">op </span><span class="s3">in </span><span class="s4">(</span>
            <span class="s4">(</span><span class="s5">&quot;_limit_clause&quot;</span><span class="s4">, </span><span class="s5">&quot;limit()&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">.</span><span class="s1">is_</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_offset_clause&quot;</span><span class="s4">, </span><span class="s5">&quot;offset()&quot;</span><span class="s4">, </span><span class="s3">None</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">.</span><span class="s1">is_</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_order_by_clauses&quot;</span><span class="s4">, </span><span class="s5">&quot;order_by()&quot;</span><span class="s4">, (), </span><span class="s1">operator</span><span class="s4">.</span><span class="s1">eq</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_group_by_clauses&quot;</span><span class="s4">, </span><span class="s5">&quot;group_by()&quot;</span><span class="s4">, (), </span><span class="s1">operator</span><span class="s4">.</span><span class="s1">eq</span><span class="s4">),</span>
            <span class="s4">(</span><span class="s5">&quot;_distinct&quot;</span><span class="s4">, </span><span class="s5">&quot;distinct()&quot;</span><span class="s4">, </span><span class="s3">False</span><span class="s4">, </span><span class="s1">operator</span><span class="s4">.</span><span class="s1">is_</span><span class="s4">),</span>
            <span class="s4">(</span>
                <span class="s5">&quot;_from_obj&quot;</span><span class="s4">,</span>
                <span class="s5">&quot;join(), outerjoin(), select_from(), or from_self()&quot;</span><span class="s4">,</span>
                <span class="s4">(),</span>
                <span class="s1">operator</span><span class="s4">.</span><span class="s1">eq</span><span class="s4">,</span>
            <span class="s4">),</span>
            <span class="s4">(</span>
                <span class="s5">&quot;_setup_joins&quot;</span><span class="s4">,</span>
                <span class="s5">&quot;join(), outerjoin(), select_from(), or from_self()&quot;</span><span class="s4">,</span>
                <span class="s4">(),</span>
                <span class="s1">operator</span><span class="s4">.</span><span class="s1">eq</span><span class="s4">,</span>
            <span class="s4">),</span>
        <span class="s4">):</span>
            <span class="s3">if not </span><span class="s1">op</span><span class="s4">(</span><span class="s1">getattr</span><span class="s4">(</span><span class="s1">self</span><span class="s4">.</span><span class="s1">query</span><span class="s4">, </span><span class="s1">attr</span><span class="s4">), </span><span class="s1">notset</span><span class="s4">):</span>
                <span class="s3">raise </span><span class="s1">sa_exc</span><span class="s4">.</span><span class="s1">InvalidRequestError</span><span class="s4">(</span>
                    <span class="s5">&quot;Can't call Query.update() or Query.delete() &quot;</span>
                    <span class="s5">&quot;when %s has been called&quot; </span><span class="s4">% (</span><span class="s1">methname</span><span class="s4">,)</span>
                <span class="s4">)</span>

    <span class="s4">@</span><span class="s1">property</span>
    <span class="s3">def </span><span class="s1">session</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Session</span><span class="s4">:</span>
        <span class="s3">return </span><span class="s1">self</span><span class="s4">.</span><span class="s1">query</span><span class="s4">.</span><span class="s1">session</span>


<span class="s3">class </span><span class="s1">BulkUpdate</span><span class="s4">(</span><span class="s1">BulkUD</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;BulkUD which handles UPDATEs.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__</span><span class="s4">(</span>
        <span class="s1">self</span><span class="s4">,</span>
        <span class="s1">query</span><span class="s4">: </span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">values</span><span class="s4">: </span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">_DMLColumnArgument</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">],</span>
        <span class="s1">update_kwargs</span><span class="s4">: </span><span class="s1">Optional</span><span class="s4">[</span><span class="s1">Dict</span><span class="s4">[</span><span class="s1">Any</span><span class="s4">, </span><span class="s1">Any</span><span class="s4">]],</span>
    <span class="s4">):</span>
        <span class="s1">super</span><span class="s4">().</span><span class="s1">__init__</span><span class="s4">(</span><span class="s1">query</span><span class="s4">)</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">values </span><span class="s4">= </span><span class="s1">values</span>
        <span class="s1">self</span><span class="s4">.</span><span class="s1">update_kwargs </span><span class="s4">= </span><span class="s1">update_kwargs</span>


<span class="s3">class </span><span class="s1">BulkDelete</span><span class="s4">(</span><span class="s1">BulkUD</span><span class="s4">):</span>
    <span class="s2">&quot;&quot;&quot;BulkUD which handles DELETEs.&quot;&quot;&quot;</span>


<span class="s3">class </span><span class="s1">RowReturningQuery</span><span class="s4">(</span><span class="s1">Query</span><span class="s4">[</span><span class="s1">Row</span><span class="s4">[</span><span class="s1">_TP</span><span class="s4">]]):</span>
    <span class="s3">if </span><span class="s1">TYPE_CHECKING</span><span class="s4">:</span>

        <span class="s3">def </span><span class="s1">tuples</span><span class="s4">(</span><span class="s1">self</span><span class="s4">) </span><span class="s1">-&gt; Query</span><span class="s4">[</span><span class="s1">_TP</span><span class="s4">]:  </span><span class="s0"># type: ignore</span>
            <span class="s4">...</span>
</pre>
</body>
</html>